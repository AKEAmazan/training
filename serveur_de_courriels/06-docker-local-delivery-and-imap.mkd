<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 

* [ Introduction](#Intro)
* [ Définition des images ](#setup_images)
* [ Création de l'image SMTP (postfix)](#setup_postfix)
       * [ Installation des packages dans l'image](#setup_postfix_install_pkg)
       * [ Mise en place des fichiers de configuration](#setup_postfix_setup_conf)
       * [ Validation de l'image](#setup_postfix_setup_validation)
* [ Définition de l'utilisation du conteneur postfix](#workflow_conteneur_smtp)
* [ Configuration postfix avec LTMP ](#Postfix_with_lmtp)
* [ Création de l'image IMAP / LMTP (dovecot)](#setup_dovecot)
       * [ Installation des packages dans l'image](#setup_dovecot_install_pkg)
       * [ Mise en place des fichiers de configuration avec la méthode (docker diff :D)](#setup_dovecot_setup_conf)
           * [ Validation de la configuration imap ](#setup_dovecot_setup_imap_conf)
           * [ Validation de la configuration lmtp](#setup_dovecot_setup_lmtp_conf)
           * [ Mise en place de la configuration maildir](#setup_dovecot_setup_maildir_conf)
           * [ Extraction de la configuration mise en place](#setup_dovecot_setup_extraction_conf)
           * [ Définition des fichiers de configuration dans le Dockerfile](#setup_dovecot_setup_dovecot_conf)
* [ Mise en symbiose des images :D](#integration)
       * [ Visualisation du résultat du volumes](#visualisation_volumes)
       * [ Redirection de port](#visualisation_port_redirect)
       * [ Teste de la configuration](#teste_contener)
       * [ Analyse du problème lmtp](#analyse_prob_lmtp)
* [ Recule et analyse de la situation](#analyse_prob_interconnexion)
* [ Correction de la configuration postfix et dovecot](#correction_setup)
       * [ Correction de la configuration postfix ](#correction_setup_postfix)
       * [ Correction de la configuration dovecot](#correction_setup_dovecot)
       * [ Changement du docker-compose](#correction_dockercompose)
       * [ Validation de la configuration](#correction_status)
       * [ Partage de la liste des adresses courriels ](#correction_share_file)
* [ Intégration et cohabitation des conteneurs](#integration_conteneur)
       * [ Génération automatique du fichier de courriels (postmap)](#integration_conteneur_postmap)
           * [ Modification de l'image postfix pour inclure incron](#integration_incron)
       * [ Gestion de l'ajout d'un utilisateur à l'exécution](#integration_create-user)


# <a name="Intro" /> Introduction

Nous avons donc vue la mise en place du système de réception de courriel localement ainsi que la possibilité pour les utilisateurs de récupérer leur courriel grâce au système __pop3__ et __imap__. Nous avions fait l'exercice avec un [pet container](http://rhelblog.redhat.com/2016/06/08/in-defense-of-the-pet-container-part-1-prelude-the-only-constant-is-complexity/) en d'autre mot avec un conteneur docker comme si c'était une __VM__. C'est mal , c'est bien je vous laisse lire le blog de RedHat sur le sujet, je suis un puriste sur l'utilisation du logiciel libre après je ne suis pas rigide sur les méthodes. Donc pour moi un pet conteneur c'est pas la fin du monde. 
Par contre il reste que c'est mieux d'avoir des vraies conteneurs qui sont indépendant , bien structuré que l'on peut modifier manipulé de manière indépendante ! Comme nous sommes dans le cadre de la formation nous allons faire l'exercice. 
Mettons tous de suite quelque chose au claire, ma configuration actuelle est un __pet conteneur__ , dû à des contrainte de temps de migration de serveur je n'avais pas eu le temps de faire l'exercice que l'on fait ici !!!
En d'autre mot pas de stress :D .

La grande particularité de la configuration qui suit est que nous allons pour la première fois depuis notre utilisation dans la formation connecter 2 conteneurs ensemble . 

* __postfix__ : réception et envoie de courriel
* __dovecot__ : Récupération des courriels.

# <a name="setup_images" /> Définition des images 

Pour débuter du bon pieds nous allons définir les critères de configuration afin de ne pas tourné en rond lors de la mise en place de postfix , voici les critère à répondre . 

* **réception** : Permettre la réception de courriel pour 1 ou plusieurs domaines
* **envoie** : Permettre l'envoie de courriel sans authentification pour un ou plusieurs réseaux nommé (quand nous mettrons la configuration avec __Mysql__ nous ajouterons l'authentification)
* **MailDir** : Utilisation du système de stockage __maildir__ afin de limité les risques de corruption du fichier unique de courriel définie avec le format __mbox__
* **Validation des adresses à la source** : Nous voulons conservé la validation des adresses de courriels au niveau de postfix afin de ne pas avoir une charge élevé de courriels .
* **imap** : Permettre la réception de courriel via le protocole __imap__ , je vais mettre de coté le __pop3__ pour le moment.

Ça semble bon :D , maintenant passons au variable que nous désirons avoir configurable :

* **domaines** : Avoir une variable configurable pour que l'image soit utilisable pour n'importe quelle domaine
* **mynetwork** : Avoir une variable configuration pour la définition des réseaux qui peuvent transmettre des courriels.
* **relayhost** : Si le déploiement est fait dans un réseau restrictif permettre l'envoie pour via un __relayhost__.
* **authentification en claire** : Paramètre permettant l'authentification en claire sans chiffrement , bon vraiment pas obligatoire mais sinon j'ai rien pour dovecot :P

Comme la formation est sous Ubuntu , nous allons prendre la dernière __LTS__ pour le besoin donc Ubuntu:16.04

# <a name="setup_postfix" /> Création de l'image SMTP (postfix)

Nous allons reprendre bêtement les étapes vue dans la formation pour faire la création du __Dockerfile__ :

1. Installation des packages postfix
2. Mise en place d'un fichier de configuration en __template__ [Jinja2](http://jinja.pocoo.org/docs/2.9/)
3. Script de démarrage de postfix

Nous avons déjà débuter cette configuration lors de la mise en place du conteneur pour le __relayhost__ bien entendu on va s'en inspirer on l'a déjà étudier :D. J'ai tendance à présenter un produit fini quand je présente docker, malheureusement vous n'avez pas la chance de voir le processus de création incluant les erreur :D . Nous allons donc faire la démarche ensemble afin de voir l'avantage de l'utilisation de docker avec l'utilisation des couches (__layer__) en cache . 

Débutons je crée la structure :

        $ ls -R srvMailWithImap/
        srvMailWithImap/:
        imap  smtp

        srvMailWithImap/imap:

        srvMailWithImap/smtp:
        bin  Dockerfile  run.sh

        srvMailWithImap/smtp/bin:
        dfg.sh

Comme vous pouvez le voir , dans le répertoire __srvMailWithImap/__ il y a 2 répertoires 1 pour le service __smtp__ et l'autre pour le service __imap__ . 
Dans le répertoire __smtp__ j'ai repris une partie de la configuration du serveur __srvMailRelay__ , soit le script __dfg.sh__ ainsi que le script de démarrage. Nous le modifierons peut-être par la suite, mais pour le moment ceci nous donne un point de départ, et nous savons qu'il fonctionne !!

Voici le contenu du fichier **Dockerfile**

        $ cat Dockerfile
        # Using debian
        # Start Exemple:
        # ou can add -p 25:25 for LAN access
        FROM ubuntu:16.04
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Packages: update
        RUN apt-get update -qq && \
            apt-get install -qq -y --no-install-recommends postfix \
                    python-pip supervisor rsyslog && \
            pip install j2cli

        # Configure: supervisor
        ADD bin/dfg.sh /usr/local/bin/
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/

        # Runner
        ADD run.sh /root/run.sh
        RUN chmod +x /root/run.sh

        # Declare
        EXPOSE 25

        CMD ["/root/run.sh"]

Bien simple :

* Nous débutons avec l'image **Ubuntu:16.04** comme nous avons utilisé cette distribution depuis le début.
* Installation des packages pour postfix et __supervisor__ ainsi que le système __rsyslog__ pour les logs.
* Nous installons aussi __j2cli__ , toujours dans l'optique d'utiliser le système __jinja2__ comme __template__ pour les fichiers de configuration.
* Installation des fichiers de configuration pour __supervisor__ , j'ai simplement repris ceux déjà présenter lors de la présentation de la __dockerisation__ du serveur de relais.

L'ensemble des fichiers sont disponible sur [github](https://github.com/x3rus/training/tree/master/serveur_de_courriels/dockers/srvMailWithImap/smtp).

## <a name="setup_postfix_install_pkg" /> Installation des packages dans l'image

Passons à la génération de l'image , bien entendu la configuration n'est pas terminé !! 

        $ docker build -t srvsmtp .
        Sending build context to Docker daemon 6.144 kB
        Step 1 : FROM ubuntu:16.04
         ---> c73a085dc378
        Step 2 : MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>
         ---> Running in d42a4e80f101
         ---> 9421a73877a6
       [... OUTPUT COUPÉ ...]

Cette compilation est un peu plus longue, car ceci comprend l'installation des applications.

Super , j'en attendait pas autant :) , on a déjà une erreur :D , la voici :

       [... OUTPUT COUPÉ ...]
        Running hooks in /etc/ca-certificates/update.d...
        done.
        Collecting j2cli
          Downloading j2cli-0.3.1_0-py2-none-any.whl
        Collecting jinja2>=2.7.2 (from j2cli)
          Downloading Jinja2-2.9.5-py2.py3-none-any.whl (340kB)
        Collecting MarkupSafe>=0.23 (from jinja2>=2.7.2->j2cli)
          Downloading MarkupSafe-0.23.tar.gz
        Complete output from command python setup.py egg_info:
          Traceback (most recent call last):
          File "<string>", line 1, in <module>
          ImportError: No module named setuptools
          ----------------------------------------
          Command "python setup.py egg_info" failed with error code 1 in /tmp/pip-build-Gs2DNu/MarkupSafe/
          You are using pip version 8.1.1, however version 9.0.1 is available.
          You should consider upgrading via the 'pip install --upgrade pip' command.
         The command '/bin/sh -c apt-get update -qq &&     apt-get install -qq -y --no-install-recommends postfix         python-pip supervisor rsyslog &&     pip install j2cli' returned a non-zero code: 1



Vous me direz , mais pourquoi ça fonctionnait très bien avec le serveur de relais , effectivement mais nous étions avec une Debian __jessie__ , maintenant nous sommes avec Ubuntu.

Comment analyser le problème , voici comment je procède :

        $ docker run -it ubuntu:16.04 bash
        root@6c3da44d101c:/# apt-get update && apt-get install python-pip
	The following additional packages will be installed:
	  binutils build-essential bzip2 ca-certificates cpp cpp-5 dpkg-dev fakeroot file g++ g++-5 gcc gcc-5 gcc-5-base ifupdown iproute2 isc-dhcp-client
	  isc-dhcp-common libalgorithm-diff-perl libalgorithm-diff-xs-perl libalgorithm-merge-perl libasan2 libatm1 libatomic1 libc-dev-bin libc6 libc6-dev libcc1-0
	  libcilkrts5 libdns-export162 libdpkg-perl libexpat1 libexpat1-dev libfakeroot libffi6 libfile-fcntllock-perl libgcc-5-dev libgdbm3 libgmp10 libgomp1
	  libisc-export160 libisl15 libitm1 liblsan0 libmagic1 libmnl0 libmpc3 libmpfr4 libmpx0 libperl5.22 libpython-all-dev libpython-dev libpython-stdlib
	  libpython2.7 libpython2.7-dev libpython2.7-minimal libpython2.7-stdlib libquadmath0 libsqlite3-0 libssl1.0.0 libstdc++-5-dev libstdc++6 libtsan0 libubsan0
	  libxtables11 linux-libc-dev make manpages manpages-dev mime-support netbase openssl patch perl perl-modules-5.22 python python-all python-all-dev
	  python-dev python-minimal python-pip-whl python-pkg-resources python-setuptools python-wheel python2.7 python2.7-dev python2.7-minimal rename xz-utils
	Suggested packages:
	  binutils-doc bzip2-doc cpp-doc gcc-5-locales debian-keyring g++-multilib g++-5-multilib gcc-5-doc libstdc++6-5-dbg gcc-multilib autoconf automake libtool
	  flex bison gdb gcc-doc gcc-5-multilib libgcc1-dbg libgomp1-dbg libitm1-dbg libatomic1-dbg libasan2-dbg liblsan0-dbg libtsan0-dbg libubsan0-dbg
	  libcilkrts5-dbg libmpx0-dbg libquadmath0-dbg ppp rdnssd iproute2-doc resolvconf avahi-autoipd isc-dhcp-client-ddns apparmor glibc-doc libstdc++-5-doc
	  make-doc man-browser ed diffutils-doc perl-doc libterm-readline-gnu-perl | libterm-readline-perl-perl python-doc python-tk python-setuptools-doc
	  python2.7-doc binfmt-support
	The following NEW packages will be installed:
	  binutils build-essential bzip2 ca-certificates cpp cpp-5 dpkg-dev fakeroot file g++ g++-5 gcc gcc-5 ifupdown iproute2 isc-dhcp-client isc-dhcp-common
	  libalgorithm-diff-perl libalgorithm-diff-xs-perl libalgorithm-merge-perl libasan2 libatm1 libatomic1 libc-dev-bin libc6-dev libcc1-0 libcilkrts5
	  libdns-export162 libdpkg-perl libexpat1 libexpat1-dev libfakeroot libffi6 libfile-fcntllock-perl libgcc-5-dev libgdbm3 libgmp10 libgomp1 libisc-export160
	  libisl15 libitm1 liblsan0 libmagic1 libmnl0 libmpc3 libmpfr4 libmpx0 libperl5.22 libpython-all-dev libpython-dev libpython-stdlib libpython2.7
	  libpython2.7-dev libpython2.7-minimal libpython2.7-stdlib libquadmath0 libsqlite3-0 libssl1.0.0 libstdc++-5-dev libtsan0 libubsan0 libxtables11
	  linux-libc-dev make manpages manpages-dev mime-support netbase openssl patch perl perl-modules-5.22 python python-all python-all-dev python-dev
	  python-minimal python-pip python-pip-whl python-pkg-resources python-setuptools python-wheel python2.7 python2.7-dev python2.7-minimal rename xz-utils
	The following packages will be upgraded:
	  gcc-5-base libc6 libstdc++6
	3 upgraded, 87 newly installed, 0 to remove and 25 not upgraded.
	Need to get 88.4 MB of archives.
	After this operation, 268 MB of additional disk space will be used.
	Do you want to continue? [Y/n] y
	 
        [... Isshhh c beaucoup de packages requis :P ...]

Je démarre un Ubuntu éphémère uniquement pour valider la procédure , ceci me permettra de réaliser l'analyse du problème en mode interactif. 

Recherche du package __j2cli__ 

        root@6c3da44d101c:/# pip search j2cli
        j2cli3 (0.0.7.post0)  - Command-line interface to Jinja2 for templating in shell scripts.
        j2cli (0.3.1-0)       - Command-line interface to Jinja2 for templating in shell scripts.

__Humm__ ça semble bon :-/ on va tenter de l'installer alors :

        root@6c3da44d101c:/# pip install j2cli
        Collecting j2cli
          Downloading j2cli-0.3.1_0-py2-none-any.whl
        Collecting jinja2>=2.7.2 (from j2cli)
          Downloading Jinja2-2.9.5-py2.py3-none-any.whl (340kB)
          100% |################################| 348kB 1.1MB/s
        Collecting MarkupSafe>=0.23 (from jinja2>=2.7.2->j2cli)
        Downloading MarkupSafe-0.23.tar.gz
        Building wheels for collected packages: MarkupSafe
        Running setup.py bdist_wheel for MarkupSafe ... done
        Stored in directory: /root/.cache/pip/wheels/a3/fa/dc/0198eed9ad95489b8a4f45d14dd5d2aee3f8984e46862c5748
        Successfully built MarkupSafe
        Installing collected packages: MarkupSafe, jinja2, j2cli
        Successfully installed MarkupSafe-0.23 j2cli-0.3.1-0 jinja2-2.9.5
        You are using pip version 8.1.1, however version 9.0.1 is available.
        You should consider upgrading via the 'pip install --upgrade pip' command.

Donc :

        $ docker build -t srvsmtp .

Aucun problème ... On va refaire un teste alors avec le __Dockerfile__ :

        Command "python setup.py egg_info" failed with error code 1 in /tmp/pip-build-cpjQyz/MarkupSafe/
        You are using pip version 8.1.1, however version 9.0.1 is available.
        You should consider upgrading via the 'pip install --upgrade pip' command.
        The command '/bin/sh -c apt-get update -qq &&     apt-get install -qq -y --no-install-recommends postfix         python-pip supervisor rsyslog &&     pip install j2cli' returned a non-zero code: 1

Pourquoi ? Si nous regardons une des différences entre la configuration dans le __Dockerfile__ et mon teste est que lors de l'installation dans le __Dockerfile__ il y a l'instruction **--no-install-recommends**. Résultat il manque des packages requis pour l'utilisation de **pip**. 

Bien entendu 2 options s'offre à nous :

* Supprimer le paramètre **--no-install-recommends** dans le __Dockerfile__ , résultat une image plus grosse , est-ce vraiment critique ?!?! À vous de voir.
* Ajuster les packages lors de l'installation afin de conserver l'option d'installation des packages requis uniquement.

Bon , comme la suppression du paramètre est assez simple , je vais prendre l'option, car l'important n'est pas la solution mais le processus pour y arrivé, sinon vous ne seriez pas là :D. 

Donc je quitte mon conteneur de teste , car pollué par trop de packages et en redémarre un nouveau et reprend :

        root@6c3da44d101c:/# exit
        ٩(◠◡◠)۶ $ docker run -it ubuntu:16.04 bash
        root@8f4caf46401e:/#  apt-get update && apt-get --no-install-recommends install python-pip
        The following additional packages will be installed:
          ca-certificates libexpat1 libffi6 libpython-stdlib libpython2.7-minimal libpython2.7-stdlib libsqlite3-0 libssl1.0.0 mime-support openssl python
          python-minimal python-pip-whl python2.7 python2.7-minimal
        Suggested packages:
          python-doc python-tk python2.7-doc binutils binfmt-support
        Recommended packages:
          file build-essential python-all-dev python-setuptools python-wheel
        The following NEW packages will be installed:
          ca-certificates libexpat1 libffi6 libpython-stdlib libpython2.7-minimal libpython2.7-stdlib libsqlite3-0 libssl1.0.0 mime-support openssl python
          python-minimal python-pip python-pip-whl python2.7 python2.7-minimal
        0 upgraded, 16 newly installed, 0 to remove and 28 not upgraded.
        Need to get 7450 kB of archives.
        After this operation, 24.9 MB of additional disk space will be used.

Pas mal moins de packages, bon maintenant nous allons être dans le détail pour le problème spécifique . Regardons le message d'erreur que nous avons avec le conteneur :

        Collecting MarkupSafe>=0.23 (from jinja2>=2.7.2->j2cli)
          Downloading MarkupSafe-0.23.tar.gz
        Complete output from command python setup.py egg_info:
          Traceback (most recent call last):
          File "<string>", line 1, in <module>
          ImportError: No module named setuptools

Si nous regardons , un des packages recommencés il y a **python-setuptools** , ceci correspond au message d'erreur que nous avons :D , installons le pour voir et testons à nouveau .


        root@8f4caf46401e:/# apt-get --no-install-recommends install python-setuptools
        Collecting j2cli
          Downloading j2cli-0.3.1_0-py2-none-any.whl
        Collecting jinja2>=2.7.2 (from j2cli)
          Downloading Jinja2-2.9.5-py2.py3-none-any.whl (340kB)
          100% |################################| 348kB 1.1MB/s
        Collecting MarkupSafe>=0.23 (from jinja2>=2.7.2->j2cli)
          Downloading MarkupSafe-0.23.tar.gz
          Building wheels for collected packages: MarkupSafe
          Running setup.py bdist_wheel for MarkupSafe ... error
          Complete output from command /usr/bin/python -u -c "import setuptools, tokenize;__file__='/tmp/pip-build-NleDVW/MarkupSafe/setup.py';exec(compile(getattr(tokenize, 'open', open)(__file__).read().replace('\r\n', '\n'), __file__, 'exec'))" bdist_wheel -d /tmp/tmp2aCAjppip-wheel- --python-tag cp27:
          usage: -c [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
          or: -c --help [cmd1 cmd2 ...]
          or: -c --help-commands
          or: -c cmd --help
          error: invalid command 'bdist_wheel'
          ----------------------------------------
          Failed building wheel for MarkupSafe
          Running setup.py clean for MarkupSafe
          Failed to build MarkupSafe
          Installing collected packages: MarkupSafe, jinja2, j2cli
          Running setup.py install for MarkupSafe ... done
          Successfully installed MarkupSafe-0.23 j2cli-0.3.1-0 jinja2-2.9.5

**COOL** encore une erreur mais PAS la même , si nous regardons encore le message il y a le mot __wheel__ de présent , il est aussi dans un des packages recommandés pour l'installation ajoutons le :D .

        root@8f4caf46401e:/# apt-get --no-install-recommends install python-wheel                                                                                     
        root@8f4caf46401e:/# pip install j2cli
        Requirement already satisfied (use --upgrade to upgrade): j2cli in /usr/local/lib/python2.7/dist-packages
        Requirement already satisfied (use --upgrade to upgrade): jinja2>=2.7.2 in /usr/local/lib/python2.7/dist-packages (from j2cli)
        Requirement already satisfied (use --upgrade to upgrade): MarkupSafe>=0.23 in /usr/local/lib/python2.7/dist-packages (from jinja2>=2.7.2->j2cli)
        You are using pip version 8.1.1, however version 9.0.1 is available.
        You should consider upgrading via the 'pip install --upgrade pip' command.
        root@8f4caf46401e:/# echo $?
        0

**Yeahhh** du premier coup :P, nous allons donc ajuster le fichier __Dockerfile__ , voici donc la nouvelle ligne avec la liste des packages :


        # Packages: update
        RUN apt-get update -qq && \
            apt-get install -qq -y --no-install-recommends postfix \
                    python-pip supervisor rsyslog python-wheel python-setuptools  && \
                    pip install j2cli


On reconstruit l'image :

        $ docker build -t srvsmtp .                                                                                                                          
        Sending build context to Docker daemon 6.656 kB
        Step 1 : FROM ubuntu:16.04
         ---> c73a085dc378
         Step 2 : MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>
         [ ... OUTPUT COUPÉ ...]

        Removing intermediate container ba87a471cb7a
        Step 5 : ADD bin/dfg.sh /usr/local/bin/
         ---> b842eee6ca8a
         Removing intermediate container 4631078aaad4
        Step 6 : ADD conf/supervisor-all.conf /etc/supervisor/conf.d/
         lstat conf/supervisor-all.conf: no such file or directory

Je suis sûr que vous pensez que je l'ai fait volontairement, mais même pas je vous jure ... En temps normale je le cache ça :P . Bon on va capitalisé sur le problème j'ai opté pour vous montrer tous, donc ça sera tous , le bon et le moins bon .

## <a name="setup_postfix_setup_conf" /> Mise en place des fichiers de configuration

Donc suite à l'erreur de mon oublie du fichier de __supervisor__ je vais le mettre dans le répertoire conf , voici le contenu , c'est le même que pour le __relayhost__ je ne prendrai pas le temps d'écrire.

        [supervisord]
        logfile = /var/log/supervisord.log
        logfile_backups = 0

        [program:rsyslogd]
        command = /usr/sbin/rsyslogd -n

        [program:postfix]
        command = /usr/local/bin/dfg.sh /var/spool/postfix/pid/master.pid /etc/init.d/postfix start
        startsecs = 3

Donc on reprend :D : 

        $ docker build -t srvsmtp .
        [... OUTPUT COUPÉ ...]
        Step 3 : ENV DEBIAN_FRONTEND noninteractive
         ---> Using cache
         ---> 7bb41adacabf
        Step 4 : RUN apt-get update -qq &&     apt-get install -qq -y --no-install-recommends postfix         python-pip supervisor rsyslog python-wheel python-setuptools  &&     pip install j2cli
         ---> Using cache
         ---> db7a6b374677
        Step 5 : ADD bin/dfg.sh /usr/local/bin/
         ---> Using cache
         ---> b842eee6ca8a
        [... OUTPUT COUPÉ ...]

Ce qui est super est que le temps pris pour l'installation n'est pas repris maintenant car __docker__ va utiliser le cache des couches (__layers__) déjà compilé. 

État de la situation nous avons un conteneur qui à l'ensemble des packages d'installer ainsi que la configuration minimal pour le démarrage du conteneur , il nous reste :

1. Mettre en place la configuration pour postfix , en __template__
2. Modifier le script **run.sh** afin qu'il traite notre fichier de configuration en __template__ et le dispose dans le bon répertoire
3. Ajuster les valeurs par défaut de notre image si besoin est !

Voici notre fichier de configuration en __template__  (**conf/postfix-main.j2**) : 

        smtpd_banner = $myhostname ESMTP $mail_name

        alias_database = hash:/etc/aliases
        alias_maps = hash:/etc/aliases

        # Si vous le désirez nous pourrions avoir ce paramètre en option
        home_mailbox = Maildir/

        smtpd_relay_restrictions = permit_mynetworks  defer_unauth_destination
        myhostname = $myorigin
        myorigin = {{ SMTP_HOSTNAME }}

        mydestination = {{ ACCEPT_DOMAIN }}
        mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 {{ PERMIT_NETWORK }}
        inet_interfaces = all
        inet_protocols = ipv4

        {% if (EXT_RELAY_HOST != "DIRECT") %}relayhost = {{ EXT_RELAYHOST }} {% endif %}

Nous allons donc l'ajouter dans le __Dockerfile__

        [...OUTPUT COUPÉ ...]
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/

        # Setup postfix conf
        ADD conf/postfix-main.j2 /root/

        # Runner
        ADD run.sh /root/run.sh
        [...OUTPUT COUPÉ...]

Comme vous pouvez le constater j'ai mis la configuration **après** la définition des packages, ceci principalement pour ne pas à avoir à les réinstaller et profiter du caches de __docker__.

Le fichier sera donc dans le répertoire **/root** , nous devons ajuster le fichier **run.sh** pour le traitement du fichier , voici le nouveau contenu :

        #! /usr/bin/env bash
        set -e # exit on error

        # Variables
        export EXT_RELAY_HOST=${EXT_RELAY_HOST:-"DIRECT"}
        export SMTP_HOSTNAME=${SMTP_HOSTNAME:-"relay.example.com"}
        export PERMIT_NETWORK=${PERMIT_NETWORK:-"192.168.0.0/16"}
        export ACCEPT_DOMAIN=${ACCEPT_DOMAIN:-"localhost $SMTP_HOSTNAME"}
                              
        echo $SMTP_HOSTNAME > /etc/mailname
             
        # Templates
        j2 /root/postfix-main.j2 > /etc/postfix/main.cf

        # Launch
        rm -f /var/spool/postfix/pid/*.pid
        exec /usr/bin/supervisord -n

Principale changement :

* Les variables  et les valeurs par défaut
* Le patch pour le fichier postfix de __template__

On reconstruit l'image :D :

        $ docker build -t srvsmtp . 
        [... OUTPUT COUPÉ ...]
         ---> b842eee6ca8a
         Step 6 : ADD conf/supervisor-all.conf /etc/supervisor/conf.d/
          ---> Using cache
          ---> 98fd86c1b2a2
         Step 7 : ADD conf/postfix-main.j2 /root/
          ---> e6bbe80dbe93
        [... OUTPUT COUPÉ ...]


Comme vous pouvez  le constater le système à utiliser le cache jusqu'à la première modification . **Woot** donc la compilation est un succès on passe à la phase de teste !!

## <a name="setup_postfix_setup_validation" /> Validation de l'image

Bon idéalement on pourrait faire un système de unit teste pour confirmer que tous fonctionne bien mais on est pas encore en mode "production" , on s'amuse plus qu'autre chose :D.

Donc nous allons démarrer un conteneur et valider manuellement , par la suite nous réaliserons un **docker-compose.yml** pour faciliter l'utilisation. J'ai définie des variables :

* __SMTP\_HOSTNAME=mailtraining.x3rus.com__
* __PERMIT\_NETWORK=172.17.0.0/16__
* __ACCEPT\_DOMAIN="mailtraining.x3rus.com toto.x3rus.com"__ 

        $ docker run -h mailtraining.x3rus.com -e SMTP_HOSTNAME=mailtraining.x3rus.com -e PERMIT_NETWORK=172.17.0.0/16 -e ACCEPT_DOMAIN="mailtraining.x3rus.com toto.x3rus.com" srvsmtp
        /usr/lib/python2.7/dist-packages/supervisor/options.py:297: UserWarning: Supervisord is running as root and it is searching for its configuration file in default locations (including its current working directory); you probably want to specify a "-c" argument specifying an absolute path to a configuration file for improved security.
          'Supervisord is running as root and it is searching '
          2017-01-31 13:10:13,071 CRIT Supervisor running as root (no user in config file)
          2017-01-31 13:10:13,071 WARN Included extra file "/etc/supervisor/conf.d/supervisor-all.conf" during parsing
          2017-01-31 13:10:13,090 INFO RPC interface 'supervisor' initialized
          2017-01-31 13:10:13,090 CRIT Server 'unix_http_server' running without any HTTP authentication checking
          2017-01-31 13:10:13,090 INFO supervisord started with pid 1
          2017-01-31 13:10:14,097 INFO spawned: 'postfix' with pid 11
          2017-01-31 13:10:14,100 INFO spawned: 'rsyslogd' with pid 12
          2017-01-31 13:10:15,456 INFO success: rsyslogd entered RUNNING state, process has stayed up for > than 1 seconds (startsecs)
          2017-01-31 13:10:17,459 INFO success: postfix entered RUNNING state, process has stayed up for > than 3 seconds (startsecs)

Prenons un autre terminal et validons l'ensemble :

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS               NAMES
        21b0aa433d27        srvsmtp             "/root/run.sh"      About a minute ago   Up About a minute   25/tcp              grave_jones
        $ docker exec -it grave_jones bash

        root@mailtraining:/# cat /etc/postfix/main.cf
        smtpd_banner = $myhostname ESMTP $mail_name

        alias_database = hash:/etc/aliases
        alias_maps = hash:/etc/aliases

        # Si vous le désirez nous pourrions avoir ce paramètre en option
        home_mailbox = Maildir/

        smtpd_relay_restrictions = permit_mynetworks  defer_unauth_destination
        myhostname = $myorigin
        myorigin = mailtraining.x3rus.com

        mydestination = mailtraining.x3rus.com toto.x3rus.com
        mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 172.17.0.0/16
        inet_interfaces = all
        inet_protocols = ipv4

        root@mailtraining:/# tail /var/log/mail.log
        Jan 31 13:10:14 mailtraining postfix[87]: Postfix is running with backwards-compatible default settings
        Jan 31 13:10:14 mailtraining postfix[87]: See http://www.postfix.org/COMPATIBILITY_README.html for details
        Jan 31 13:10:14 mailtraining postfix[87]: To disable backwards compatibility use "postconf compatibility_level=2" and "postfix reload"
        Jan 31 13:10:14 mailtraining postfix/master[132]: daemon started -- version 3.1.0, configuration /etc/postfix

Ça semble pas mal :D , on valide en transmettant un petit courriel à l'utilisateur __root__ !!
Je récupère l'IP du conteneur : 

        $ docker inspect grave_jones | grep IPAddress
            "SecondaryIPAddresses": null,
            "IPAddress": "172.17.0.2",
                "IPAddress": "172.17.0.2",

Un petit __telnet__ rapide :

        $ telnet 172.17.0.2 25
        Trying 172.17.0.2...
        Connected to 172.17.0.2.
        Escape character is '^]'.
        220 mailtraining.x3rus.com ESMTP Postfix
        ehlo toto
        250-mailtraining.x3rus.com
        250-PIPELINING
        250-SIZE 10240000
        250-VRFY
        250-ETRN
        250-ENHANCEDSTATUSCODES
        250-8BITMIME
        250 DSN
        mail from: toto@x3rus.com
        250 2.1.0 Ok
        rcpt to: root@mailtraining.x3rus.com
        250 2.1.5 Ok
        data
        354 End data with <CR><LF>.<CR><LF>
        un courriel
        .
        250 2.0.0 Ok: queued as 9A2B460758E
        quit
        221 2.0.0 Bye
        Connection closed by foreign host.

Visualisons les logs et confirmons que le répertoire **Maildir** fut créé .

        $ docker exec grave_jones tail /var/log/mail.log
        Jan 31 13:10:14 mailtraining postfix[87]: See http://www.postfix.org/COMPATIBILITY_README.html for details
        Jan 31 13:10:14 mailtraining postfix[87]: To disable backwards compatibility use "postconf compatibility_level=2" and "postfix reload"
        Jan 31 13:10:14 mailtraining postfix/master[132]: daemon started -- version 3.1.0, configuration /etc/postfix
        Jan 31 13:16:15 mailtraining postfix/smtpd[1589]: connect from unknown[172.17.0.1]
        Jan 31 13:16:36 mailtraining postfix/smtpd[1589]: 9A2B460758E: client=unknown[172.17.0.1]
        Jan 31 13:16:40 mailtraining postfix/cleanup[1676]: 9A2B460758E: message-id=<>
        Jan 31 13:16:40 mailtraining postfix/qmgr[135]: 9A2B460758E: from=<toto@x3rus.com>, size=198, nrcpt=1 (queue active)
        Jan 31 13:16:40 mailtraining postfix/local[1693]: 9A2B460758E: to=<root@mailtraining.x3rus.com>, relay=local, delay=18, delays=18/0.01/0/0.01, dsn=2.0.0, status=sent (delivered to maildir)
        Jan 31 13:16:40 mailtraining postfix/qmgr[135]: 9A2B460758E: removed
        Jan 31 13:16:42 mailtraining postfix/smtpd[1589]: disconnect from unknown[172.17.0.1] ehlo=1 mail=1 rcpt=1 data=1 quit=1 commands=5

        $ docker exec grave_jones ls -R /root/Maildir
        /root/Maildir:
        cur
        new
        tmp

        /root/Maildir/cur:

        /root/Maildir/new:
        1485868600.Vfe01Ie0699bM516582.mailtraining.x3rus.com

        /root/Maildir/tmp:

**SUPER** , l'image fonctionne bien pour la réception des courriels __yeahh__ félicitation !!

Bon avant de débuter la définition du __docker-compose__ prenons un peu de recule sur l'utilisation de l'image .

# <a name="workflow_conteneur_smtp" /> Définition de l'utilisation du conteneur postfix

Le gros défis de **docker** réside ici , faire l'image n'est pas très difficile , par contre nous nous retrouvons maintenant avec un conteneur qui peu être éphémère .Telle que mentionné plus tôt actuellement mon serveur de courriel est un **pet conteneur** il n'y a pas de honte , mais essayons de nous améliorer c'est l'objectif , sinon on ne progresse pas. 
Dans cette objectif nous allons essayer de s'assurer que le conteneur __smtp__ puisse être changé à tous moment.

État de l'image et de son utilisation comme conteneur initialisé :

* Le système accepte les courriels pour le / les domaines fournit en paramètre 
* Le système démarre :P 
* Le système stocke le(s) courriel(s) dans le répertoire personnel de l'utilisateur 
* Le système n'a qu'un seul utilisateur disponible : **root*** et les autres utilisateurs systèmes :-(
* La définition des alias sont statique dans le conteneur (comme les utilisateurs)
* Les courriels sont dans le conteneur :-/ (__issshh__ :P )

Bon regardons les "problèmes" , pour la question des courriels qui sont dans le conteneur , quelle est la solution ? 

__Yep__ la création d'un volume qui réalisera l'association du répertoire **/home** dans le conteneur avec un répertoire sur le __docker host__. COOL problème réglé.


La définition des utilisateurs maintenant , ici ça se complique un peu , en fait faut prendre la bonne approche, mais avant rappelons nous pourquoi nous avons besoins d'avoir la liste des utilisateurs  :

* **Validation des adresses courriels** : Comme nous avions pu le voir postfix est en mesure de valider que l'adresse courriel existe avant d'accepter le courriel. Par défaut il utilise la liste des utilisateurs système.
* **Livraison dans le répertoire personnel de l'utilisateur** : Lors de la livraison par postfix , le système va créer les fichiers avec le __UID__ et __GID__ de l'utilisateur que ce soit en __mbox__ ou __maildr__. Bien entendu en __maildir___ en plus il y a la livraison dans le répertoire personnel de l'utilisateur.
* **PAS Authentification** : Il n'y aura pas d'authentification dans ce conteneur , car l'authentification de récupération de courriel sera réalisé dans le conteneur __imap__.

Donc voici quelques options 


1. Passez en **paramètre une liste d'utilisateur** pour réaliser la création lors de l'initialisation du conteneur. Pour ce faire nous devrions modifier le script **run.sh** afin de faire la création des utilisateurs ainsi que le répertoire personnel. Point à prendre en considération :
    * Les variables d'environnement ne sont interpréter QUE et UNIQUEMENT lors de l'initialisation initiale du conteneur (nominatif) en d'autre mot , si la liste des utilisateurs est : Robert, Peter et Bonny . Que vous désirez rajouter Bob , vous ne pouvez pas simplement redémarrer le conteneur avec la nouvelle valeur à la variable, il vous faudra détruire le conteneur et en créer un nouveau . Bien entendu même processus lors de la suppression d'un utilisateur !
    * **Contre** : votre premier reflex est probablement , __woww__ c'est vraiment pas une bonne options, commençons par vous conforter dans votre idée :P
        * La suppression du conteneur est "risqué" si ce dernier est mal configurer et surtout si vous réalisez des modifications directement dans le conteneur. Par exemple une personne ajoute manuellement un utilisateur dans le conteneur , lors de la recréation il sera perdu !
        * S'il y a eu une modification dans l'image de références, lors de la recréation il est possible que le service ne fonctionne plus du tous ! 
        * Il peut être difficile sans système autour de déléguer à un __help desk__ l'ajout d'un utilisateur, car il y a l'implication de redémarrage de la production.
        * Mais surtout ceci nous oblige à changer nos habitudes de fonctionnement.
    * **Pour** : Bon maintenant que vous êtes bien conforté dans l'idée que c'est une mauvaise idée, voyons le positif de cette solution.
        * Comme nous sommes obligé de recréer le conteneur, ceci sera une occasion de nous forcer à mettre à jour le conteneur. J'aimerai faire une parenthèse sur le cycle de mise à jour. Mettre en lumière une réalité avec __Docker__ . Regardons le schéma suivant :
        
            ![docker-update_cycle.png](./imgs/docker-update_cycle.png)
        
            Lors de la création de l'image du conteneur les versions sont figé dans le temps, résultat s'il y a une faille de sécurité découvert nous la trainerons dans le temps au lieu de la fixer ! Le fait que nous devons détruire le conteneur nous obligera à réaliser une mise à jour des packages. Ceci est particulièrement important pour les services exposés sur Internet.
        * L'autre point positif de cette opération est que nous avons un système éphémère, qui est régulièrement généré résultat nous avons un niveau de confiance dans le système car régulièrement testé lors de l'ajout d'un utilisateur. S'il y a un problème on le recréer , on pourrait même y voir un système qui augmente le nombre de serveur postfix s'il y a une monté en charge des courriels et qui modifie les DNS afin d'ajouter la définition MX pour la réception . Le système est donc autonome dans ça définition.
2. Avoir un fichier local des utilisateurs qui est à l'extérieur du conteneur !
    * Regardons d'un œil froid, où est définie les utilisateurs ? Dans le fichier **/etc/passwd** , le fichier est présent par défaut sur le système mais pouvons nous le surdéfinir. En fait pas de problème , nous avons le système de volume dans docker qui nous permet d'assigner un répertoire ou un fichier de l'hôte docker dans le conteneur !! Nous n'avons pas besoin du fichier **/etc/shadow** car l'utilisateur n'établis pas de connexion sur ce conteneur.
    * **Contre** : Bon je présume que vous êtes pour mais je peux pas changé le pour / contre d'une section à l'autre trop tard :P
        * La problématique avec cette solution est la définition du fichier **/etc/passwd** qui est sur 1 hôte docker , donc s'il y a un problème avec l'hôte votre conteneur en est dépendant. Vous n'êtes pas en mesure de redémarrer le conteneur sur un autre hôtes de manière transparente. Bien entendu il y a la question des courriels reçu __anyway__ qui seront non disponible. Mais attention , le conteneur postfix ne stock pas obligatoirement le courriel ce dernier reçoit et livre les courriels , il peut aussi agir comme __buffer__ si le service dovecot n'est pas disponible.
        * L'ajout d'un utilisateur se fera sur la machine hôte , il faudra donc éventuellement conserver le fichier dans un contrôleur de révision (git, svn) pour voir les changements et conserver une copie à l'extérieur.
        * Si nous éditons le fichier manuellement , il faudra faire attention de ne pas avoir les même UID , voir les mêmes nom avec un répertoire personnel différent.
    * **Pour** : L'utilisation d'un fichier **/etc/passwd** local , sans être obligé de recréer le conteneur nous rassure nous avons presque le même comportement qu'une VM.
        * Change peu nos habitudes donc c'est réconfortant :P
        * Le fichier **/etc/passwd** pourrait être utilisé par un autre conteneur par exemple __dovecot__ pour la liste des utilisateurs ;-)
        * Pas besoin de porter une action sur le conteneur lors de l'ajout d'un utilisateur.
3. Utilisation d'un système de gestion de configuration telle que **puppet** ou **ansible** .
    * Une autre possibilité serait d'avoir un système de gestion de configuration telle que __puppet__ ou __ansible__ externe au conteneur qui communiquerai avec un serveur contenant la définition des utilisateurs qui doivent être présent dans le conteneur. Lors de l'initialisation du conteneur une première synchronisation de la configuration avec le serveur serait réalisé récupérant la liste des utilisateurs . Par la suite un processus (__agent__) synchroniserai la configuration de manière régulière. Selon la solution utilisé, la configuration pourrait être poussée par le serveur de configuration.
    * **Contre** : Le problème de cette solution est qu'elle suit moins le principe de __docker__ et d'une utilisation indépendante de l'infrastructure
        * Le principe de l'utilisation des conteneurs est la possibilité d'être utilisé sur un portable, dans un __datacenter__, dans le __cloud__, ... Ceci indépendamment de l'infrastructure en place. La création d'une dépendance avec une infrastructure externe **serveur de configuration** va à l'encontre du principe. 
        * Généralement les solutions de gestion de configuration utilise le nom de la machine pour l'identifier (__hostname__) , ceci risque d'être un problème si nous désirons avoir un déploiement dynamique en cas de monté en charge de la réception de courriel. En d'autre mot il risque d'être difficile de dynamiquement faire le déploiement dynamiquement mais surtout automatiquement sans action humaine.
        * Si nous continuons avec le principe de docker , si vous désirez réellement mettre en place cette solution le processus __puppet__ ou __ansible__ devrez être exécuté sur l'hôte docker et non dans le conteneur afin de ne pas pollué le conteneur avec une application non essentiel .
    * **Pour** : Uniformité de la configuration et conservation à l'externe
        * Bien entendu , la solution nous permet d'avoir une référence de la configuration en dehors du conteneur nous permettant de le recréer avec la même définition . Nous limitons le risque de perte d'information possible comparativement en aillant un fichier local sur le docker hôte.
        * Si vous avez un parc significatif utilisant déjà une solution de gestion de configuration l'intégration est facile et ne demande pas de monté en compétence .
        * Uniformité de la configuration entre les conteneurs, si les conteneurs utilisent le même __playbook__ (__ansible__) ou le même module (__puppet__) le conteneur __smtp__ et __imap__ auront la même liste des utilisateurs.
4. Utilisation d'une source externe de définition des utilisateurs **LDAP**, **NIS**, **SQL**.
    * Bon l'utilisation d'une source externe telle que __mysql__ sera couverte par la source, est-ce que l'on va la __dockerisé__ , honnêtement je le sais pas encore :-) . J'aimerai souligner un propos mentionné plus tôt , l'indépendance des conteneurs , il faut idéalement gardé le principe que le système sera utilisé sur un __laptop__ dans le train pour travailler ! L'utilisation en soit de **LDAP** , **SQL** n'est pas un problème de fond car nous allons l'avoir pour augmenté les fonctionnalités possible des courriels ( **contacts** , **calendrier**, ... ) . Donc si cette approche est préconisé il faudrait livré un conteneur __SQL__ ou __LDAP__ avec le conteneur __smtp__ et __imap__. Ceci étant rappeler reprenons le **Contre/Pour** 
    * **Contre** : 
        * Dans le cadre du service postfix, étant donnée qu'il ne réalise que de la validation de courriel et la récupération des __UID__ il y a peu de plus value d'avoir un système __LDAP__ en particulier. Les données changes si ce service est déjà mis en place pour l'augmentation de fonctionnalité pour l'utilisateur.
        * Si la configuration __LDAP__ se base sur un serveur d'infrastructure interne uniquement , ceci ne suit pas le principe de __docker__ permettant le déploiement n'importe où en s'affranchissant de l'infrastructure .
        * De mon point de vue si vous avez déjà une base de donnée __SQL__ et que vous ajoutez un serveur __LDAP__ pour la gestion des utilisateurs ceci ajoute un système qui peut avoir des problèmes. La gestion de la prise de backup , afin d'être en mesure de remettre en fonction en cas de problème du docker hôte.
    * **Pour** : oui oui vous pouvez dire que je suis un peu trop rigide sur le principe de docker , mais mon objectif et de générer une réflexion toute les solution sont possible l'important est de faire un choix éclairé. Puis surtout être en mesure de constater son erreur si on a fait le mauvais choix ça arrive :D.
        * Si vous déjà l'ensemble de vos utilisateur dans un __ldap__ (exemple AD), ceci vous facilite grandement la vie et oui c'est vraie, dans ce cas peut-être faire une copie synchronisé afin d'avoir un conteneur indépendant pour le gars dans le train :P.
        * Mise à jour "instantané" des utilisateurs grâce à la solution AD
        * Avoir des utilisateurs locaux et une sources externe **optionel** afin d'avoir l'autonomie du conteneur et la pluralité des utilisateurs corporatif. (je suis mitigé , car je ne vois pas de solution dans une production __cloud__ mais bon ça reste une possibilité)

Bon l'ensemble des suggestions mentionnés ci-dessus est général peut importe le système , l'idée est d'essayer de trouve une solution optimal voici en gros les critères que je désires :

* Ne pas avoir de gestion des utilisateurs manuel sur chaque conteneur , ajout ou suppression .
* Permettre le déploiement des conteneurs "simplement" peut importe l'environnement (portable, __datacenter__, ...).
* Je veux avoir une limitation des adresses courriels dans le systèmes postfix .

Reprenons le diagramme simplifié de l'architecture postfix :

![POSTFIX_Envoi_Externe.png](./imgs/POSTFIX_Envoi_Externe.png) 

J'aimerai porter votre attention sur les autres possibiliter soit :

* ltmp
* virtual
* pipe

En d'autre mot il y d'autre méthode pour transmettre les courriels vers un autre système , en fait principalement le protocol [lmtp](https://fr.wikipedia.org/wiki/Local_Mail_Transfer_Protocol) soit **Local Mail Transfer Protocol** . ET ça tombe bien car **dovecot** supporte ce protocole [dovecot et ltmp](http://wiki2.dovecot.org/HowTo/PostfixDovecotLMTP) , elle est pas belle la vie :P.

Avec cette solution nous aurons , les utilisateurs uniquement définie dans le conteneur __dovecot__ , __postfix__ sera en mesure de faire une validation via le protocole __LMTP__ telle que spécifier dans la documentation  [dovecot et ltmp](http://wiki2.dovecot.org/HowTo/PostfixDovecotLMTP). Comme nous aurons qu'une source d'utilisateur et pas de définition dans un serveur d'infrastructure de type __LDAP__ nous pourrons le déployé peu importe l'environnement. 

**COOL** , bon le petit malin qui se dit __ouin__ mais avec cette solution tu n'as rien réglé car comment on va définir les utilisateurs dans le conteneur __dovecot__ , effectivement il faudra prendre tous de même une des options plus haut. Bien entendu quand nous serons rendu avec un système complet avec une base de données **requise** pour plus de fonctionnalité nous n'aurons plus le choix. 
Mais 1 problème à la fois :D.

# <a name="Postfix_with_lmtp" /> Configuration postfix avec LTMP 

Telle que mentionné plus tôt nous allons utiliser postfix uniquement comme **MTA** (**Mail Transport Agent**) et laisser la gestion de la livraison **MDA** (**Mail Delivery Agent**) à dovecot via le protocole __lmtp__. Le gros avantage d'utiliser __lmtp__ est que nous seront donc en mesure de changer dovecot par une autre solution, il faudra simplement que cette solution supporte le protocole ouvert __lmtp__.

Si nous regardons la documentation [dovecot et ltmp](http://wiki2.dovecot.org/HowTo/PostfixDovecotLMTP) vous constaterez que le système utilise un __socket__ Unix pour la communication. Quand nous avons une configuration d'une machine réalisant l'ensemble de l'opération y a pas de problème, mais dans notre cas nous utiliseront le port __tcp__ . Une vraie communication réseau nous offrant plus de possibilité surtout avec les conteneurs. Pour voir l'ensemble des configurations disponible voir la documentation [postfix lmtp](http://linuxcommand.org/man_pages/lmtp8.html). 

Comme nous pouvons le voir dans le diagramme du traitement des courriels par postfix : 

![POSTFIX_Reception_UNIX.png](./imgs/POSTFIX_Reception_UNIX.png)

Par défaut postfix utilise le service **local** pour livrer les courriels nous allons modifier cette configuration, en changeant la valeur de [mailbox_transport](http://www.postfix.org/postconf.5.html#mailbox_transport). Voici ce que nous allons définir :

        mailbox_transport = lmtp:dovecot-lmtp:24

Juste par clarification :

* **lmtp** : le protocole 
* **dovecot-lmtp** : le __hostname__ du serveur de destination , si nous étions dans une logique avec des machines virtuel j'aurais définie un __hostname__ valide , comme nous sommes avec docker ceci sera réalisé avec un __link__ de conteneur nous y reviendrons.
* **24** : Le port , bon la selon wikipedia ils disent qu'il n'y a pas de port standard, mais selon la documentation de __lmtp__ de postfix il mentionne que le port par défaut est 24 ... Donc si je suis pour choisir n'importe quoi autant en prendre un presque standard :D. 

Bon la pour ceux qui se disent,  aille __woww__ __pépito__  puis la validation des courriels tu en fais quoi , la liste des adresses et alias . Bon point mais pas de panique :D voici la solution que nous allons mettre en place :

        Dynamic address verification with LMTP

        With Dovecot 2.0 you can also use LMTP and the Postfix setting "reject_unverified_recipient" for dynamic address verification. It's really nice because Postfix doesn't need to query an external datasource (MySQL, LDAP...). Postfix maintain a local database with existing/non existing addresses (you can configure how long positive/negative results should be cached).

        To use LMTP and dynamic address verification you must first get Dovecot working. Then you can configure Postfix to use LMTP and set "reject_unverified_recipient" in the smtpd_recipient_restrictions.

        On every incoming email Postfix will probe if the recipient address exists. You will see similar entries in your logfile:

                Recipient address rejected: undeliverable address: host tux.example.com[private/dovecot-lmtp] said: 550 5.1.1 < tzknvtr@example.com > User doesn't exist: tzknvtr@example.com (in reply to RCPT TO command); from=< cnrilrgfclra@spammer.org > to=< tzknvtr@example.com >

        If the recipient address exists (status=deliverable) Postfix accepts the mail. 

On y reviens ce sera une amélioration , avant de mettre cette limitation on va confirmer que tous fonctionne , sinon c'est gênant pour diagnostique le problème :D.

Voici donc le résultat de notre configuration postfix en __template__ :

        $ cat conf/postfix-main.j2
        smtpd_banner = $myhostname ESMTP $mail_name

        alias_database = hash:/etc/aliases
        alias_maps = hash:/etc/aliases

        # Si vous le désirez nous pourrions avoir ce paramètre en option
        home_mailbox = Maildir/

        smtpd_relay_restrictions = permit_mynetworks  defer_unauth_destination
        myhostname = $myorigin
        myorigin = {{ SMTP_HOSTNAME }}

        mydestination = {{ ACCEPT_DOMAIN }}
        mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 {{ PERMIT_NETWORK }}
        inet_interfaces = all
        inet_protocols = ipv4

        # Configuration pour l'envoie vers lmtp (aka dovecot)
        mailbox_transport = lmtp:dovecot-lmtp:24

        {% if (EXT_RELAY_HOST != "DIRECT") %}relayhost = {{ EXT_RELAYHOST }} {% endif %}


Oublié pas de reconstruire votre image :

        $ docker build -t srvsmtp .

Le problème à ce stade est que la validation de la configuration est "difficile", car nous avons besoin du conteneur dovecot pour valider l'ensemble , je pense donc que c'est le bon moment pour créer l'image du second conteneur.

# <a name="setup_dovecot" /> Création de l'image IMAP / LMTP (dovecot)

Juste pour être sûr que l'on s'entend sur le besoin du conteneur :

* **imap** : Service __imap__ pour que les utilisateurs consultent leurs courriels
* **lmtp** : Service __lmtp__ pour que le transfert des courriels entre postfix et dovecot
* **maildir** : Nous désirons que les fichiers de courriels soit individuel par communication 

Nous allons reprendre bêtement les étapes vue dans la formation pour faire la création du __Dockerfile__ :

1. Installation des packages pour dovecot : imap et lmtp
2. Mise en place d'un fichier de configuration en __template__ [Jinja2](http://jinja.pocoo.org/docs/2.9/)
3. Script de démarrage de dovecot

Pour rappel la structure :

        $ ls -R srvMailWithImap/
        srvMailWithImap/:
        imap  smtp

        srvMailWithImap/imap/:
        bin  conf  Dockerfile  run.sh

        srvMailWithImap/imap/bin:
        dfg.sh

        srvMailWithImap/imap/conf:
        supervisor-all.conf

        srvMailWithImap/smtp:
        bin  Dockerfile  run.sh

        srvMailWithImap/smtp/bin:
        dfg.sh

Nous allons nous attaquer à la partie __imap__ , avec le recule j'aurais dû aussi mettre le mot __lmtp__, mais je savais pas au début que nous allions avoir ce service :P ( oui oui la formation est vraiment rédigé et réfléchie au fur et à mesure :D **free style** ).

Faut ce lancer donc un premier jet du fichier __Dockerfile__ on le corrigera  au fur et à mesure :D. :

        # Using debian
        # Start Exemple:
        # ou can add -p 25:25 for LAN access
        FROM ubuntu:16.04
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Packages: update
        RUN apt-get update -qq && \
            apt-get install -qq -y --no-install-recommends dovecot-imap dovecot-lmtp \
                    python-pip supervisor rsyslog python-wheel python-setuptools  && \
                    pip install j2cli

        # Configure: supervisor
        ADD bin/dfg.sh /usr/local/bin/
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/

        # Runner
        ADD run.sh /root/run.sh
        RUN chmod +x /root/run.sh

        # Declare
        EXPOSE 143 993 24

        CMD ["/root/run.sh"]

* Nous débutons avec l'image **Ubuntu:16.04** comme nous avons utilisé cette distribution depuis le début.
* Installation des packages pour dovecot et __supervisor__ ainsi que le système __rsyslog__ pour les logs.
* Nous installons aussi __j2cli__ , toujours dans l'optique d'utiliser le système __jinja2__ comme __template__ pour les fichiers de configuration.
* Installation des fichiers de configuration pour __supervisor__ , j'ai simplement repris ceux déjà présenter lors de la présentation de la __dockerisation__ du serveur de relais.

L'ensemble des fichiers sont disponible sur [github](https://github.com/x3rus/training/tree/master/serveur_de_courriels/dockers/srvMailWithImap/smtp).

J'ai fait quelque modification du fichier __supervisor-all.conf__ ET __run.sh__ afin que ceci soit adapté à la configuration de dovecot , pour visualiser les changement un petit __diff__ ou __vimdiff__ entre celui de postfix et dovecot vous fournira l'ensemble des données 

        $ vimdiff smtp/conf/supervisor-all.conf  imap/conf/supervisor-all.conf 

On se lance dans la compilation :D de l'image . 

## <a name="setup_dovecot_install_pkg" /> Installation des packages dans l'image

Bon j'ai encore le même problème de nom de package ... Donc je vais refaire l'opération , comme avec postfix en démarrant un conteneur Ubuntu 16:04  pour faire l'analyse et trouver le bon nom de package

        Step 4 : RUN apt-get update -qq &&     apt-get install -qq -y --no-install-recommends dovecot-imap dovecot-lmtp         python-pip supervisor rsyslog python-wheel python-setuptools  &&     pip install j2cli
         ---> Running in 3e58129c72bc
         E: Unable to locate package dovecot-imap
         E: Unable to locate package dovecot-lmtp

Résultat fallait ajouter un D à la fin :P  :

         apt-get install -qq -y --no-install-recommends dovecot-imapd dovecot-lmtpd \

Bon je montre le processus pourquoi ?  Juste pour vous démontrer que c'est pas parce que ça fait 15 ans que t'es sous GNU/Linux que ça marche du premier coup :P en fait vraiment pas , mes 15 ans d'expérience me donne juste plus d'outils pour trouver le correctif rapidement. :P

Suite à la modification la compilation a bien fonctionné :

        $ docker build -t srvimap .
        [ ... OUTPUT COUPÉ ... ]
        Step 10 : CMD /root/run.sh
         ---> Running in 735c2152fd8c
         ---> 6547ceb2a3f1
        Removing intermediate container 735c2152fd8c
        Successfully built 6547ceb2a3f1

## <a name="setup_dovecot_setup_conf" /> Mise en place des fichiers de configuration avec la méthode (docker diff :D)

Telle que mentionné au début de la formation, vous avez l'air motivé pour l'utilisation de **docker**, donc on creuse plus loin et surtout on voit des méthodes de travail disponible. Je suis tous de même nouveau dans docker , bon en même temps ça fait pas 10 ans que ça existe, je ne sais pas la position des puristes sur ce qui suit , mais moi j'aime bien . 

Bon lors de la configuration de postfix c'était 1 fichier de configuration et nous étions , en tout cas moi :P , très confortable avec postfix . Dans le cadre de dovecot nous avons 2 services à mettre en place et la structure des fichiers de configurations est très divisé. Nous allons voir maintenant un autre technique pour faire de l'analyse de mise en place pour nous aider pour le conteneur final.

Donc nous avons l'image de base avec les packages et le démarrage de dovecot , on va initialiser le conteneur , pour le moment nous n'avons pas de variables ceci viendra par la suite :

        $ docker images | head                                                                                                                               
        REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
        srvimap                       latest              6547ceb2a3f1        23 hours ago        217.2 MB

        $ docker run srvimap
        /usr/lib/python2.7/dist-packages/supervisor/options.py:297: UserWarning: Supervisord is running as root and it is searching for its configuration file in default locations (including its current working directory); you probably want to specify a "-c" argument specifying an absolute path to a configuration file for improved security.
          'Supervisord is running as root and it is searching '
        2017-02-08 13:13:01,165 CRIT Supervisor running as root (no user in config file)
        2017-02-08 13:13:01,165 WARN Included extra file "/etc/supervisor/conf.d/supervisor-all.conf" during parsing
        2017-02-08 13:13:01,180 INFO RPC interface 'supervisor' initialized
        2017-02-08 13:13:01,181 CRIT Server 'unix_http_server' running without any HTTP authentication checking
        2017-02-08 13:13:01,181 INFO supervisord started with pid 1
        2017-02-08 13:13:02,188 INFO spawned: 'dovecot' with pid 10
        2017-02-08 13:13:02,199 INFO spawned: 'rsyslogd' with pid 11
        2017-02-08 13:13:03,261 INFO success: rsyslogd entered RUNNING state, process has stayed up for > than 1 seconds (startsecs)
        2017-02-08 13:13:05,263 INFO success: dovecot entered RUNNING state, process has stayed up for > than 3 seconds (startsecs)

Comme vous pouvez le constater je n'ai pas nommé le conteneur pour le moment je cherche uniquement à avoir un environnement volatile pour faire des testes.

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS               NAMES
        9c93ab3c3243        srvimap             "/root/run.sh"      About a minute ago   Up About a minute   25/tcp              sick_brahmagupta

Bon on voit déjà une erreur :P , le Port **25/tcp** , je vais corriger mon **serveur_de_courriels/dockers/srvMailWithImap/imap/Dockerfile** :

        # Declare
        EXPOSE 143 24

On reconstruira l'image plus tard pas critique à ce stade , maintenant je vais établir une connexion dans le conteneur volatile :

        $ docker exec -it sick_brahmagupta bash
        root@9c93ab3c3243:/#

Comme je vais travailler dans le conteneur je vais installer **vim** dans le conteneur volatile , je ne vais **pas** l'ajouter dans le __Dockerfile__ , donc lors de la suppression du conteneur ce ne sera pas présent.


### <a name="setup_dovecot_setup_imap_conf" /> Validation de la configuration imap 

Visualisation du fichier de configuration :

         root@9c93ab3c3243:/etc/dovecot/# cat dovecot.conf | grep -v "^#" | grep -v ^$
         !include_try /usr/share/dovecot/protocols.d/*.protocol
         dict {
           #quota = mysql:/etc/dovecot/dovecot-dict-sql.conf.ext
           #expire = sqlite:/etc/dovecot/dovecot-dict-sql.conf.ext
         }
         !include conf.d/*.conf
         !include_try local.conf

Si nous regardons dans le répertoire **/usr/share/dovecot/protocols.d/**, nous voyons bien le fichier pour __imap__ : 

        root@9c93ab3c3243:/etc/dovecot# ls /usr/share/dovecot/protocols.d/*.protocol
        /usr/share/dovecot/protocols.d/imapd.protocol  /usr/share/dovecot/protocols.d/lmtpd.protocol

Et le contenu spécifie bien l'activation du protocole __imap__

        root@9c93ab3c3243:/etc/dovecot# cat /usr/share/dovecot/protocols.d/imapd.protocol
        protocols = $protocols imap

        root@9c93ab3c3243:/etc/dovecot/conf.d# cat /etc/dovecot/conf.d/20-imap.conf  | grep -v ^# | grep -v ^$
        protocol imap {
          # Space separated list of plugins to load (default is global mail_plugins).
          #mail_plugins = $mail_plugins
          # Maximum number of IMAP connections allowed for a user from each IP address.
          # NOTE: The username is compared case-sensitively.
          #mail_max_userip_connections = 10
        }

Tous semble bon on peut valider avec la commande **ss** ou **netstat** , mais faut installer un package :P 

        root@9c93ab3c3243:/etc/dovecot# apt-get install iproute2
        root@9c93ab3c3243:/etc/dovecot# ss -lntp
        State      Recv-Q Send-Q                                  Local Address:Port                                                 Peer Address:Port
        LISTEN     0      100                                                 *:143                                                             *:*
        users:(("dovecot",pid=22,fd=34))
        LISTEN     0      100                                                :::143                                                            :::*
        users:(("dovecot",pid=22,fd=35))

Le __imap__ semble, convenable du moins pour ce que l'on a vue :D.

### <a name="setup_dovecot_setup_lmtp_conf" /> Validation de la configuration lmtp

Validons la configuration comme pour __imap__

         root@9c93ab3c3243:/etc/dovecot/# cat dovecot.conf | grep -v "^#" | grep -v ^$
         !include_try /usr/share/dovecot/protocols.d/*.protocol
         dict {
           #quota = mysql:/etc/dovecot/dovecot-dict-sql.conf.ext
           #expire = sqlite:/etc/dovecot/dovecot-dict-sql.conf.ext
         }
         !include conf.d/*.conf
         !include_try local.conf

Si nous regardons dans le répertoire **/usr/share/dovecot/protocols.d/**, nous voyons bien le fichier pour __ltmp__: 

        root@9c93ab3c3243:/etc/dovecot# ls /usr/share/dovecot/protocols.d/*.protocol
        /usr/share/dovecot/protocols.d/imapd.protocol  /usr/share/dovecot/protocols.d/lmtpd.protocol

Et le contenu spécifie bien l'activation du protocole __lmtp__

        root@9c93ab3c3243:/etc/dovecot# cat /usr/share/dovecot/protocols.d/lmtpd.protocol
        protocols = $protocols lmtp

        root@9c93ab3c3243:/etc/dovecot/conf.d# cat 20-lmtp.conf  | grep -v ^# | grep -v ^$
        protocol lmtp {
          # Space separated list of plugins to load (default is global mail_plugins).
          #mail_plugins = $mail_plugins
        }

Bon comme on a pas vu le détail de la configuration dans passé dans le doute il y a une définition donc ça doit être ok :P ... 

Tous semble bon on peut valider avec la commande **ss** ou **netstat** , mais faut installer un package :P 

        root@9c93ab3c3243:/etc/dovecot# ss -lntp
        State      Recv-Q Send-Q                                  Local Address:Port                                                 Peer Address:Port
        LISTEN     0      100                                                 *:143                                                             *:*
        users:(("dovecot",pid=22,fd=34))
        LISTEN     0      100                                                :::143                                                            :::*
        users:(("dovecot",pid=22,fd=35))

**OUPSSss** : le port 24 n'est **PAS** ouvert , ça va être compliquer pour le passage via le réseau des communications entre le postfix et dovecot, reprenons le site de configuration comme point de référence : [http://wiki.dovecot.org/LMTP](http://wiki.dovecot.org/LMTP).

Donc nous allons la définition du service de __lmtp__ :

        root@9c93ab3c3243:/etc/dovecot# grep "service lmtp" -R *
        conf.d/10-master.conf:service lmtp {

Bon __ok ok__, je me rappeler plus du nom du fichier :P , mais **grep** a une bien meilleur mémoire :P .

Voici la configuration présente :

        service lmtp {
          unix_listener lmtp {
              #mode = 0666
            }

            # Create inet listener only if you can't use the above UNIX socket
            #inet_listener lmtp {
            # Avoid making LMTP visible for the entire internet
            #address =
            #port = 
            #}
        }

Ceci indique de ne pas utiliser le protocole réseau mais un __socket__ sur la machine qui permet de simulé via un fichier la communication réseau, bien entendu 90% du temps quand les services sont sur la même machine s'est très bien !! L'avantage est qu'il n'y a pas de port d'ouvert sur le réseau , alors que ce n'est pas pertinent. Pour notre cas par contre nous devons changer cette configuration.

        service lmtp {
          unix_listener lmtp {
              #mode = 0666
          }

          inet_listener lmtp {
            address = 0.0.0.0
            port = 24
          }

          # Create inet listener only if you can't use the above UNIX socket
          #inet_listener lmtp {
          # Avoid making LMTP visible for the entire internet
          #address =
          #port = 
          #}
        }

Je redémarre le service et valide avec **ss** 

        root@9c93ab3c3243:/etc/dovecot# /etc/init.d/dovecot restart
        root@9c93ab3c3243:/etc/dovecot# ss -lntp                   
        State      Recv-Q Send-Q                                  Local Address:Port                                                 Peer Address:Port
        LISTEN     0      100                                                 *:143                                                             *:*                   users:(("dovecot",pid=7509,fd=35))
        LISTEN     0      100                                                 *:24                                                              *:*                   users:(("dovecot",pid=7509,fd=25))
        LISTEN     0      100                                                :::143                                                            :::*                   users:(("dovecot",pid=7509,fd=36))

Bon ça semble bon , on validera quand postfix va transmettre ses courriel :D 

### <a name="setup_dovecot_setup_maildir_conf" /> Mise en place de la configuration maildir

Dans les requis nous avions aussi la mise en place du système __Maildir__ au lieu de __mailbox__ c'est partie ...

Pour rappel nous devons modifier l'entrée **mail\_location** :

        $ grep mail_location /etc/dovecot/conf.d/*
        mail_location = mbox:~/mail:INBOX=/var/mail/%u

La nouvelle valeur :

        mail_location = maildir:~/Maildir

On peut __reloader__ la configuration et on peut valider les logs qu'il n'y a pas un processus qui pleure du à un problème de configuration :

        root@9c93ab3c3243:/etc/dovecot# /etc/init.d/dovecot reload
         * Reloading IMAP/POP3 mail server dovecot
         ...done.
        root@9c93ab3c3243:/var/log# tail mail.log
        Feb  8 13:13:02 9c93ab3c3243 dovecot: master: Dovecot v2.2.22 (fe789d2) starting up for imap, lmtp
        Feb  8 13:13:02 9c93ab3c3243 dovecot: ssl-params: Generating SSL parameters
        Feb  8 13:13:04 9c93ab3c3243 dovecot: ssl-params: SSL parameters regeneration completed
        Feb  8 13:43:09 9c93ab3c3243 dovecot: master: Warning: Killed with signal 15 (by pid=7504 uid=0 code=kill)
        Feb  8 13:43:10 9c93ab3c3243 dovecot: master: Dovecot v2.2.22 (fe789d2) starting up for imap, lmtp
        Feb  8 13:49:47 9c93ab3c3243 dovecot: master: Warning: Killed with signal 15 (by pid=0 uid=0 code=kill)
        Feb  8 13:49:47 9c93ab3c3243 dovecot: anvil: Warning: Killed with signal 15 (by pid=0 uid=0 code=kill)
        Feb  8 13:49:47 9c93ab3c3243 dovecot: log: Warning: Killed with signal 15 (by pid=0 uid=0 code=kill)
        Feb  9 13:10:03 9c93ab3c3243 dovecot: master: Dovecot v2.2.22 (fe789d2) starting up for imap, lmtp
        Feb  9 13:14:00 9c93ab3c3243 dovecot: master: Warning: SIGHUP received - reloading configuration

### <a name="setup_dovecot_setup_extraction_conf" /> Extraction de la configuration mise en place

Bon maintenant vous êtes peut-être septiques , vous vous dites ouin mais la il vient de nous faire un __pet container__ , moi je voulais avoir quelques chose de propre dans le __Dockerfile__ on peut pas reproduire la configure . 

Généralement à ce moment je réponds : **Minutes papillons, ça arrive** :D. 

L'objectif de l'ensemble de la configuration dans un conteneur est de valider que nous sommes en mesure de faire la configuration , l'utilisation des layer de docker c'est vraiment génial. Cependant lors de la période d'exploration c'est assez casse couille de devoir refaire : le changement de configuration, le __build__ ,  le redémarrage du conteneur puis la validation . 

Maintenant que nous avons configurer le conteneur qu'il n'a pas d'erreur nous allons reprendre les fichiers que nous avons modifier ramener pour faire la création du __Dockerfile__. Bien entendu nous pouvons faire référence à notre mémoire pour lister les fichiers, mais soyons honnête selon le nombre de fichier nous allons en oublier , MOI le premier. 

Nous avons une super fonctionnalité dans docker qui est : **docker diff**  , ceci nous permet de lister les fichiers qui furent modifié entre l'image de référence et le conteneur en activité.

        $ docker diff sick_brahmagupta | wc -l                                                                                                                
        2979

**Woww**, __ouin__ on a installé des logiciels ça explose tous de suite le nombre de fichier modifier :P ... Comme j'ai pas envie de lire l'ensemble et que je sais que nous avons modifier uniquement des fichiers dans __/etc/dovecot__ nous allons faire un __grep__ sur ce répertoire.

Voilà Magie :

        $ docker diff sick_brahmagupta | grep '/etc/dovecot'
        C /etc/dovecot
        C /etc/dovecot/conf.d
        C /etc/dovecot/conf.d/10-master.conf
        C /etc/dovecot/conf.d/10-mail.conf

Bien entendu en changeant le grep pour uniquement __/etc__ vous aurez une plus grande couverture. Donc nous voyons que nous avons finalement touchez que 2 fichiers de configuration . 

Je vais maintenant copier ces fichiers dans le répertoire de conf dans le répertoire du __Dockerfile__ afin  de pouvoir les copier lors de la génération de l'image srvimap. Bon j'ai 2 fichiers on va pas s'énerver mais j'aimerai vous présenter une méthode de copie , particulièrement pertinente si vous avions 20 ou 50 fichiers.

        $ docker diff sick_brahmagupta | grep '/etc/dovecot' | grep \.conf$ | cut -d " " -f 2
        /etc/dovecot/conf.d/10-mail.conf
        /etc/dovecot/conf.d/10-master.conf

Avec quelques __grep__ et un __cut__ je filtre le résultat , bon les fanatiques de __awk__ :P je vous laisse le plaisir de convertir :P.
J'assigne le résultat à une variable :

        $ LST_FILE=$(docker diff sick_brahmagupta | grep '/etc/dovecot' | grep \.conf$ | cut -d " " -f 2)

Une petite validation pré exécution :D

        $ for x in $LST_FILE; do echo $x; done
        /etc/dovecot/conf.d/10-master.conf
        /etc/dovecot/conf.d/10-mail.conf

Et on fait la même chose avec __docker copy__ :

        $ for x in $LST_FILE; do docker cp sick_brahmagupta:$x . ; done
        $ ls
        10-mail.conf  10-master.conf  supervisor-all.conf

C'est comme de la magie :D

### <a name="setup_dovecot_setup_dovecot_conf" /> Définition des fichiers de configuration dans le Dockerfile

Maintenant que nous avons les fichiers de configuration pour **dovecot** , dans le répertoire conf , nous allons pouvoir ajuster le __Dockerfile__.

        ADD conf/10-*.conf /etc/dovecot/conf.d/

Voici le résultat "final" jusqu'au prochain problème :P 

        $ cat Dockerfile
        # Using debian
        # Start Exemple:
        # ou can add -p 25:25 for LAN access
        FROM ubuntu:16.04
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Packages: update
        RUN apt-get update -qq && \
            apt-get install -qq -y --no-install-recommends dovecot-imapd dovecot-lmtpd \
                    python-pip supervisor rsyslog python-wheel python-setuptools  && \
                    pip install j2cli

        # Configure: supervisor
        ADD bin/dfg.sh /usr/local/bin/
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/

        # Add dovecot configuration
        ADD conf/10-*.conf /etc/dovecot/conf.d/

        # Runner
        ADD run.sh /root/run.sh
        RUN chmod +x /root/run.sh

        # Declare
        EXPOSE 143 24

        CMD ["/root/run.sh"]

On reconstruit l'image :

        $ docker build -t srvimap .
        Sending build context to Docker daemon 28.16 kB
        Step 1 : FROM ubuntu:16.04
         ---> c73a085dc378
        [ ...  OUTPUT ... ]
        Removing intermediate container 4f496692783f
        Successfully built f57aa93b57e1

# <a name="integration" /> Mise en symbiose des images :D

Donc nous sommes au point ou nous avons 2 conteneurs qui ont des services réseau qui ont une configuration théoriquement (on l'a pas encore testé) compatible , il est temps de les combiner. Allez chercher , la colle et les ciseaux !! 

Telle que mentionné je vous invite **FORTEMENT** à utiliser **docker-compose** , ça aide énormément !! Donc nous allons l'utiliser ici :D.

        version: '2'
        services:
            smtp-coco:
                image: srvsmtp
                restart: unless-stopped
                container_name : 'coco-smtp-t'
                hostname: mail.coco.com
                environment:
                    - SMTP_HOSTNAME=mail.coco.com
                    - ACCEPT_DOMAIN=coco.com
                    - TIMEZONE=America/Montreal
                    - TERM=xterm
                links:
                    - imap-coco:dovecot-lmtp
                ports:
                    - 25:25
                volumes:
                    - /tmp/docker/coco-smtp-t/var_spool/mails:/var/spool/postfix
            imap-coco :
                image: srvimap
                container_name : 'coco-imap-t'
                hostname: mail.coco.com
                environment:
                    - TIMEZONE=America/Montreal
                    - TERM=xterm
                ports:
                    - 143:143
                volumes:
                    - /tmp/docker/coco-imap-t//home:/home


Nous avions déjà vu la configuration d'un __docker-compose__ lors de la présentation de conteneur pour le relais de courriel , si vous avez besoin de vous rafraichir la mémoire je vous invite à voir la documentation. Je vais me concentrer sur les nouveautés :

* **environment** (**TIMEZONE=America/Montreal**) : contrairement à la dernière fois je définie le __timezone__ à l'initialisation du conteneur , me permettant de déplacé mon image dans le MONDE :D. 
* **links** (**imap-coco:dovecot-lmtp**) : Nous réalisons le lien entre le conteneur **smtp** et le conteneur **imap** si vous vous rappeler dans la configuration postfix la définition du lien **lmtp** fut réaliser en donnant le nom __dovecot-lmtp__. Avec l'instruction **link** nous indiquons que le service **imap-coco** est associé au nom __dovecot-lmtp__. Nous le verrons à l'utilisation mais le conteneur aura une entré dans le fichier **/etc/hosts** associant le conteneur __coco-imap-t*__ avec ce nom :D. La magie de docker, ceci permet de gérer le problème d'IP dynamique.
* **ports** : Définition des ports qui seront accessible depuis l'externe, comme vous pouvez le constater le port 24 (__lmtp__) n'est pas mentionné, car ce n'est pas un port publique mais inter docker. Entre les conteneur il n'y aura pas de problème de communication peut importe le port.


## <a name="visualisation_volumes" /> Visualisation du résultat du volumes

Prenons quelques minutes avant de valider nos conteneur pour voir le résultat de la définition du volumes , suite à l'initialisation du conteneur ce dernier à associé le répertoire :

* **/tmp/docker/coco-smtp-t/var_spool/mails** sur le docker __host__ dans le conteneur sous le répertoire **/var/spool/postfix**
* **/tmp/docker/coco-imap-t/var_spool/home** sur le docker __host__ dans le conteneur sous le répertoire **/home**

Si nous réalisons visualisons uniquement les répertoire voici le résultat :

        /tmp/docker/
        /tmp/docker/coco-smtp-t
        /tmp/docker/coco-smtp-t/var_spool
        /tmp/docker/coco-smtp-t/var_spool/mails
        /tmp/docker/coco-smtp-t/var_spool/mails/trace
        /tmp/docker/coco-smtp-t/var_spool/mails/saved
        /tmp/docker/coco-smtp-t/var_spool/mails/pid
        /tmp/docker/coco-smtp-t/var_spool/mails/public
        /tmp/docker/coco-smtp-t/var_spool/mails/maildrop
        /tmp/docker/coco-smtp-t/var_spool/mails/private
        /tmp/docker/coco-smtp-t/var_spool/mails/incoming
        /tmp/docker/coco-smtp-t/var_spool/mails/hold
        /tmp/docker/coco-smtp-t/var_spool/mails/flush
        /tmp/docker/coco-smtp-t/var_spool/mails/deferred
        /tmp/docker/coco-smtp-t/var_spool/mails/defer
        /tmp/docker/coco-smtp-t/var_spool/mails/corrupt
        /tmp/docker/coco-smtp-t/var_spool/mails/bounce
        /tmp/docker/coco-smtp-t/var_spool/mails/active
        /tmp/docker/coco-smtp-t/var_spool/mails/lib
        /tmp/docker/coco-smtp-t/var_spool/mails/lib/x86_64-linux-gnu
        /tmp/docker/coco-smtp-t/var_spool/mails/usr
        /tmp/docker/coco-smtp-t/var_spool/mails/usr/lib
        /tmp/docker/coco-smtp-t/var_spool/mails/usr/lib/zoneinfo
        /tmp/docker/coco-smtp-t/var_spool/mails/dev
        /tmp/docker/coco-smtp-t/var_spool/mails/etc
        /tmp/docker/coco-smtp-t/var_spool/mails/etc/ssl
        /tmp/docker/coco-smtp-t/var_spool/mails/etc/ssl/certs
        /tmp/docker/coco-imap-t
        /tmp/docker/coco-imap-t/home


## <a name="visualisation_port_redirect" /> Redirection de port

J'aurais pas pris le temps, mais j'ai eu un comportement étrange et comme souvent les petits problèmes étrange sont les plus long à diagnostiquer. Je ne sais pas si lors de la présentation le problème sera aussi présent. 

J'ai initialisé les conteneurs avec l'instruction **docker-compose** :

        $ docker-compose up
        Creating coco-imap-t
        Creating coco-smtp-t
        Attaching to coco-imap-t, coco-smtp-t
        coco-imap-t  | /usr/lib/python2.7/dist-packages/supervisor/options.py:297: UserWarning: Supervisord is running as root and it is searching for its configuration file in default locations (including its current working directory); you probably want to specify a "-c" argument specifying an absolute path to a configuration file for improved security.
        coco-imap-t  |   'Supervisord is running as root and it is searching '
        coco-imap-t  | 2017-02-10 13:37:00,582 CRIT Supervisor running as root (no user in config file)

Pas de problème mais quand je liste les ports je devrais en avoir 2 conformément au __docker-compose__ :

        $ ss -lntp
        State      Recv-Q Send-Q                                  Local Address:Port                                                 Peer Address:Port
        LISTEN     0      128                                                :::143                                                            :::*
        LISTEN     0      128                                                :::32771                                                          :::*

* 143 : OK pas problème c'est bon.
* 32771 : heu .. __what__ !!

Réalisation d'un **docker ps** :

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                             NAMES
        d81f664c8613        srvsmtp             "/root/run.sh"      49 seconds ago      Up 48 seconds       25/tcp, 0.0.0.0:32771->1525/tcp   coco-smtp-t
        fc3f3a80fffb        srvimap             "/root/run.sh"      50 seconds ago      Up 49 seconds       24/tcp, 0.0.0.0:143->143/tcp      coco-imap-t

J'ai changé la définition du __docker-compose__ pour n'avoir que le port 25 d'associer :

                ports:
                    - 25

Suppression des conteneurs et ré initialisation :

        coco-imap-t  | 2017-02-10 13:30:27,901 INFO success: dovecot entered RUNNING state, process has stayed up for > than 3 seconds (startsecs)
        coco-smtp-t  | 2017-02-10 13:30:29,662 INFO success: postfix entered RUNNING state, process has stayed up for > than 3 seconds (startsecs)
        ^[^[[A^CGracefully stopping... (press Ctrl+C again to force)
        Stopping coco-smtp-t ... done
        Stopping coco-imap-t ... done
        $ docker-compose rm
        Going to remove coco-smtp-t, coco-imap-t
        Are you sure? [yN] y
        Removing coco-smtp-t ... done
        Removing coco-imap-t ... done

Redémarrage des conteneurs :

        $ docker-compose up
        Creating coco-imap-t
        Creating coco-smtp-t

Résultat encore très étonnant : 

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                          NAMES
        701d9449fb94        srvsmtp             "/root/run.sh"      3 seconds ago       Up 2 seconds        0.0.0.0:32772->25/tcp          coco-smtp-t
        2761155e3d08        srvimap             "/root/run.sh"      4 seconds ago       Up 3 seconds        24/tcp, 0.0.0.0:143->143/tcp   coco-imap-t

Après recherche je suis tombé sur ce problème signalé sur __github__ : https://github.com/docker/compose/issues/1906

Résultat simplement mettre des " autour du port ... Je fait mention du problème, car c'est le genre de détail qui peut prendre une demi journée a résoudre , voir plus quand on est pas confortable et que l'on doute de ça configuration !

Donc voici le résultat :

        ports:
            - '25:25'
                            -
On réinitialise les conteneurs.

        $ docker-compose up
        Creating coco-imap-t
        Creating coco-smtp-t
        Attaching to coco-imap-t, coco-smtp-t

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                  PORTS                          NAMES
        8dde07090918        srvsmtp             "/root/run.sh"      1 seconds ago       Up Less than a second   0.0.0.0:25->25/tcp             coco-smtp-t
        f8f28a4c2dae        srvimap             "/root/run.sh"      2 seconds ago       Up Less than a second   24/tcp, 0.0.0.0:143->143/tcp   coco-imap-t

Voilà tout est bon maintenant :D

## <a name="teste_contener" /> Teste de la configuration

Bon on y croit :P à font on se dit que ça va fonctionner du premier coup :P , l'espoir fait vivre que l'on dit :D.

        $ docker inspect coco-smtp-t | grep IPA
                "SecondaryIPAddresses": null,
                "IPAddress": "",
                "IPAMConfig": null,
                       "IPAddress": "172.21.0.3",

Envoie du courriel au seul utilisateur existant donc __root__ :

        $ telnet 172.21.0.3 25
        Trying 172.21.0.3...
        Connected to 172.21.0.3.
        Escape character is '^]'.
        220 mail.coco.com ESMTP Postfix
        ehlo toto
        250-mail.coco.com
        250-PIPELINING
        250-SIZE 10240000
        250-VRFY
        250-ETRN
        250-ENHANCEDSTATUSCODES
        250-8BITMIME
        250 DSN
        mail from:toto@ejhfk.com
        250 2.1.0 Ok
        rcpt to: root@coco.com
        250 2.1.5 Ok
        data
        354 End data with <CR><LF>.<CR><LF>
        un courriel
        .
        250 2.0.0 Ok: queued as 1A9048F41
        quit
        221 2.0.0 Bye
        Connection closed by foreign host.

Pour le moment c'est bon , regardons les logs de postfix :

        $ docker exec coco-smtp-t tail -20 /var/log/mail.log
        Feb 10 21:52:28 mail postfix/smtpd[788]: connect from unknown[172.21.0.1]
        Feb 10 21:52:53 mail postfix/smtpd[788]: 1A9048F41: client=unknown[172.21.0.1]
        Feb 10 21:52:57 mail postfix/cleanup[930]: 1A9048F41: message-id=<>
        Feb 10 21:52:57 mail postfix/qmgr[127]: 1A9048F41: from=<toto@ejhfk.com>, size=173, nrcpt=1 (queue active)
        Feb 10 21:52:57 mail postfix/lmtp[948]: 1A9048F41: to=<root@coco.com>, relay=dovecot-lmtp[172.21.0.2]:24, delay=12, delays=12/0.01/0.02/0.05, dsn=5.1.1, status=bounced (host dovecot-lmtp[172.21.0.2] said: 550 5.1.1 <root@coco.com> User doesn't exist: root@coco.com (in reply to RCPT TO command))
        Feb 10 21:52:57 mail postfix/cleanup[930]: 4342C92C4: message-id=<20170210215257.4342C92C4@mail.coco.com>
        Feb 10 21:52:57 mail postfix/bounce[949]: 1A9048F41: sender non-delivery notification: 4342C92C4
        Feb 10 21:52:57 mail postfix/qmgr[127]: 4342C92C4: from=<>, size=2050, nrcpt=1 (queue active)
        Feb 10 21:52:57 mail postfix/qmgr[127]: 1A9048F41: removed
        Feb 10 21:52:58 mail postfix/smtpd[788]: disconnect from unknown[172.21.0.1] ehlo=1 mail=1 rcpt=1 data=1 quit=1 commands=5
        Feb 10 21:53:17 mail postfix/smtp[950]: 4342C92C4: to=<toto@ejhfk.com>, relay=none, delay=20, delays=0/0.01/20/0, dsn=4.4.3, status=deferred (Host or domain name not found. Name service error for name=ejhfk.com type=MX: Host not found, try again)

Bon ça n'a pas tous à fait fonctionné :D , mais on va se consoler un peu pour commencer , qu'est-ce qui marche et marche pas :

* Fonctionne :
    * Le système d'acceptation de courriel fonctionne !! Le courriel fut accepté pour le domaine __coco.com__ pour un utilisateur existant !
    * Le système postfix à communiquer avec l'IP **dovecot-lmtp[172.21.0.2]** pour faire le transfère du courriel !
    * Le système **lmtp** à même répondu que l'adresse courriel n'était PAS valide ... 
* Fonctionne pas :
    * La livraison des courriels par __dovecot__
    * La validation de la liste des utilisateurs !

Donc si on prend un pas de recule le constat est assez positif :D , nous avons 2 conteneurs qui se parlent sans problème :D (**Think positif**)

## <a name="analyse_prob_lmtp" /> Analyse du problème lmtp

Nous devons à présent voir pourquoi __dovecot__ n'a pas pris le courriel , bon toujours dans un soucis de transparence ça fait des années que j'ai pas utilisé __lmtp__ donc c'est de ma faute :D . Chanceux pareil :D.

Voyons les logs :

        $ docker exec coco-imap-t tail -20 /var/log/mail.log
        Feb 10 21:49:28 mail dovecot: master: Dovecot v2.2.22 (fe789d2) starting up for imap, lmtp
        Feb 10 21:49:28 mail dovecot: ssl-params: Generating SSL parameters
        Feb 10 21:49:31 mail dovecot: ssl-params: SSL parameters regeneration completed
        Feb 10 21:52:57 mail dovecot: lmtp(851): Connect from 172.21.0.3
        Feb 10 21:52:57 mail dovecot: lmtp(851): Disconnect from 172.21.0.3: Successful quit

__Woww__ :D , magnifique , très verbeux :D.

Donc là j'ai __googlé__ :P car google sait tous :D. (http://www.dovecot.org/list/dovecot/2016-February/103298.html)[http://www.dovecot.org/list/dovecot/2016-February/103298.html] . 

        The solution was
        auth_username_format = %Ln

        in /etc/dovecot/conf.d/10-auth.conf

        I saw it on another thread. Thanks Pascal

La validation réalisé par dovecot prend le nom de domaine pour réaliser la validation , ceci est parfait car normalement on utilise ce système pour gérer plusieurs domaine donc ceci est convenable. Dans notre cas c'est un peu particulier comme nous ne réalisons pas une configuration de masse mais pour s'amuser ... 
N'est  pas que l'on s'amuse bien :D !!

Je passe donc en mode exploration de la solution ... 
Je vais copier le fichier, le modifier et le repousser dans le conteneur , par la suite , je vais allé dans le conteneur pour redémarrer le service .

        $ docker cp coco-imap-t:/etc/dovecot/conf.d/10-auth.conf /tmp/
        $ vim 10-auth.conf

        Je change :

        auth_username_format = %Lu
        pour 
        auth_username_format = %Ln

J'en ai profiter aussi pour changer l'authentification en mode __plain text__ (__disable\_plaintext\_auth = no__).

Je repousse la configuration :

         $ docker cp 10-auth.conf coco-imap-t:/etc/dovecot/conf.d/10-auth.conf

Je redémarre le service dovecot :

         $ docker exec -it coco-imap-t /etc/init.d/dovecot restart

On peut refaire le test :D 

* logs smtp :

       Feb 10 22:16:27 mail postfix/qmgr[125]: 65A3A12CA1: from=<toto@chekf.com>, size=188, nrcpt=1 (queue active)
       Feb 10 22:16:28 mail postfix/lmtp[547]: 65A3A12CA1: to=<root@coco.com>, relay=dovecot-lmtp[172.21.0.3]:24, delay=11, delays=11/0.01/0.01/0.05, dsn=4.3.0, status=deferred (host dovecot-lmtp[172.21.0.3] said: 451 4.3.0 <root@coco.com> Invalid user settings. Refer to server log for more information. (in reply to RCPT TO command))

* logs __imap__ :

        Feb 10 22:10:02 mail dovecot: master: Dovecot v2.2.22 (fe789d2) starting up for imap, lmtp
        Feb 10 22:16:28 mail dovecot: lmtp(401): Connect from 172.21.0.2
        Feb 10 22:16:28 mail dovecot: lmtp(root@coco.com): Error: Invalid settings in userdb: userdb returned 0 as uid
        Feb 10 22:16:28 mail dovecot: lmtp(401): Disconnect from 172.21.0.2: Successful quit


Création d'un utilisateur dans le conteneur __imap__ pour faire un teste autre qu'avec l'utilisateur __root__ qui  cause problème

        root@mail:/etc/dovecot/conf.d# adduser toto
        Adding user `toto' ...
        Adding new group `toto' (1000) ...
        Adding new user `toto' (1000) with group `toto' ...
        Creating home directory `/home/toto' ...
        Copying files from `/etc/skel' ...
        Enter new UNIX password:
        Retype new UNIX password:
        passwd: password updated successfully
        Changing the user information for toto
        Enter the new value, or press ENTER for the default
        Full Name []:
        Room Number []:
        Work Phone []:
        Home Phone []:
        Other []:
        Is the information correct? [Y/n] y


Crotte ça marche pas plus :P

        $ telnet 172.21.0.2 25
        Trying 172.21.0.2...
        Connected to 172.21.0.2.
        Escape character is '^]'.
        220 mail.coco.com ESMTP Postfix
        ehlo toto
        250-mail.coco.com
        250-PIPELINING
        250-SIZE 10240000
        250-VRFY
        250-ETRN
        250-ENHANCEDSTATUSCODES
        250-8BITMIME
        250 DSN
        mail from:toto@jrjfe.com
        250 2.1.0 Ok
        rcpt to:toto@coco.com
        550 5.1.1 <toto@coco.com>: Recipient address rejected: User unknown in local recipient table

Bon pour le moment je veux valider l'interconnexion de mes conteneurs donc je vais désactivé la configuration de validation des adresses sur le serveur postfix. 

J'utilise la commande **postconf** pour faire un changement rapide .. validation 

        root@mail:/# postconf | grep local_recipient_maps 
        local_recipient_maps = proxy:unix:passwd.byname $alias_maps
        root@mail:/# postconf local_recipient_maps=
        root@mail:/# postconf | grep local_recipient_maps
        local_recipient_maps =

**magie** ça passe :P

        $ telnet 172.21.0.2 25
        Trying 172.21.0.2...
        Connected to 172.21.0.2.
        Escape character is '^]'.
        220 mail.coco.com ESMTP Postfix
        ehlo toto
        250-mail.coco.com
        250-PIPELINING
        250-SIZE 10240000
        250-VRFY
        250-ETRN
        250-ENHANCEDSTATUSCODES
        250-8BITMIME
        250 DSN
        mail from: toto@jerkjf.com
        250 2.1.0 Ok
        rcpt to: toto@coco.com
        250 2.1.5 Ok
        data
        354 End data with <CR><LF>.<CR><LF>
        un test sans filtrage courriel     
        .
        250 2.0.0 Ok: queued as DE2C615FB1
        quit
        221 2.0.0 Bye
        Connection closed by foreign host.

Et maintenant dans les logs de dovecot 

        Feb 10 22:24:42 mail dovecot: lmtp(2414): Disconnect from 172.21.0.2: Successful quit
        Feb 10 22:27:23 mail dovecot: lmtp(3060): Connect from 172.21.0.2
        Feb 10 22:27:23 mail dovecot: lmtp(toto): EqsFNks+nlj0CwAABKaThQ: msgid=unspecified: saved mail to INBOX
        Feb 10 22:27:23 mail dovecot: lmtp(3060): Disconnect from 172.21.0.2: Successful quit

Validation du courriel sur le docker host :

        $ ls -R  /tmp/docker/coco-imap-t/home/toto/
        /tmp/docker/coco-imap-t/home/toto/:
        Maildir

        /tmp/docker/coco-imap-t/home/toto/Maildir:
        cur  dovecot.index.cache  dovecot.index.log  dovecot-uidlist  dovecot-uidvalidity  dovecot-uidvalidity.589e3e4b  new  tmp

        /tmp/docker/coco-imap-t/home/toto/Maildir/cur:

        /tmp/docker/coco-imap-t/home/toto/Maildir/new:
        '1486765643.M950101P3060.mail.coco.com,S=409,W=419'

        /tmp/docker/coco-imap-t/home/toto/Maildir/tmp:

L'interconnexion entre les conteneurs fonctionne mais ce n'est vraiment pas optimal nous avons du faire des ajustements de configuration "live" sur le système . Prenons un temps de recule et analysons le problème.

# <a name="analyse_prob_interconnexion" /> Recule et analyse de la situation

Analysons la situation :

* **Validation adresses** : Postfix réalise la validation des adresses courriels lors de la réception du courriel pour le domaine ! Voici les options possibles 
    * **désactivation** : Nous pourrions supprimer cette validation , pas vraiment agréable mais nous l'avons validé ça marche.
    * **lister les adresses** : Nous pourrions aussi mettre en place un script qui crée une liste des adresses courriels.
    * **configuration lmtp** : Pousser la réflexion pour avoir une validation avec **lmtp** pour avoir la validation avec le nom de domaine, le problème est que nous avons modifier la configuration pour que la validation de l'usager n'inclut pas l'adresse courriel.
* **Gestion des utilisateurs** : Actuellement pour les besoins de la validation de l'interconnexion des conteneurs j'ai créé manuellement l'utilisateur dans le conteneur __imap__. J'ai déjà mentionné des méthodes possible de mise en place quand nous avons parlé de postfix , je vais en sortir proposer une.
    * **Définition par variable** : Je vais opté pour la mise en place d'utilisateur dans dovecot via le système de variables lors de l'initialisation, cependant nous allons aussi permettre la création "rapide" d'utilisateur afin de répondre à une demande immédiate. Bien entendu nous utiliserons un script pour le faire plus simplement.

En conclusion nous avons l'impression que l'on est loin de la solution, mais on a 2 points majeur bloquant, ce n'est pas si mal :D. On est loin de la catastrophe comme on pourrait le penser au début . Il est important de prendre le recule pour saisir l'ampleur de la situation.

# <a name="correction_setup" /> Correction de la configuration postfix et dovecot

C'est repartie , j'espère que le processus n'est pas trop long pour vous ... 

## <a name="correction_setup_postfix" /> Correction de la configuration postfix 

Nous allons modifier notre fichier de configuration postfix afin d'avoir un argument additionnel pour le fichier de validation des adresses courriels. Par défaut nous avons 

        local_recipient_maps = proxy:unix:passwd.byname $alias_maps

Nous allons mettre définir un fichier en plus , de type __hash__ car j'ai pas voulu me prendre la tête encore :P. Voici donc le nouveau fichier de configuration **srvMailWithImap/smtp/conf/postfix-main.j2** : 

        smtpd_banner = $myhostname ESMTP $mail_name

        alias_database = hash:/etc/aliases
        alias_maps = hash:/etc/aliases

        # Si vous le désirez nous pourrions avoir ce paramètre en option
        home_mailbox = Maildir/

        smtpd_relay_restrictions = permit_mynetworks  defer_unauth_destination
        myhostname = $myorigin
        myorigin = {{ SMTP_HOSTNAME }}

        mydestination = {{ ACCEPT_DOMAIN }}
        mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 {{ PERMIT_NETWORK }}
        inet_interfaces = all
        inet_protocols = ipv4

        # Configuration pour l'envoie vers lmtp (aka dovecot)
        mailbox_transport = lmtp:dovecot-lmtp:24

        local_recipient_maps = proxy:unix:passwd.byname $alias_maps /etc/postfix/mails-{{ ACCEPT_DOMAIN }}.lst

        {% if (EXT_RELAY_HOST != "DIRECT") %}relayhost = {{ EXT_RELAYHOST }} {% endif %}

J'ai donc ajouter le fichier **/etc/postfix/mails-{{ ACCEPT_DOMAIN }}.lst** à la variable **local\_reciepient\_maps**

On reconstruit l'image !!

Parfait nous aurons une autre modification à réaliser par la suite, mais j'y reviendrais :D. Passons à la configuration de dovecot .

## <a name="correction_setup_dovecot" /> Correction de la configuration dovecot

Nous avions fait 2 modification :

1. La validation du nom de l'utilisateur
2. La désactivation de la restriction du passage en claire du mot de passe , ça tombe bien les 2 paramètres sont dans le fichier **10-auth**


        $ cd srvMailWithImap/imap/conf
        $ docker cp coco-imap-t:/etc/dovecot/conf.d/10-auth.conf .


Le fichier __Dockerfile__ contient la ligne suivante :

        # Add dovecot configuration
        ADD conf/10-*.conf /etc/dovecot/conf.d/

Donc il sera prit en considération lors de la reconstruction de l'image.

Nous devons aussi mettre en place la configuration de la liste des usagers, bon je le répète, ces conteneurs sont pour des fin de présentation !! En d'autre mot non viable pour une utilisation de production. Car nous allons définir des mot de passe au utilisateur, qu'ils ne pourront pas changer autrement que de se connecter sur le conteneur. L'autre méthode serait de mettre une page web et un script en arrière , mais ce serait ridicule autant utiliser une base de donnée pour stocker les informations . Ça nous aurait aussi simplifié la vie pour postfix, mais bon trop tard j'ai trop écrit pour revenir en arrière :P.

Nous allons donc modifier le script de démarrage pour qu'il crée les utilisateurs lors de l'initialisation du conteneur, voici donc le nouveau fichier **run.sh** :

        #! /usr/bin/env bash
        set -e # exit on error

        # Variables
        export LST_USERS=${LST_USERS:"NONE"}

        export LST_MAILS=${LST_MAILS:"/etc/dovecot/mails.lst"}

        # Création des utilisateurs 
        if [ "$LST_USERS" == "NONE" ] ; then
            echo "You must define variable LST_USER to create at leat one user !!"
                exit 2
            fi   

            # Creation des utilisateur 
            for user in $LST_USER ; do
                    useradd $user
                    mkdir /home/$user
                    chown $user /home/$user
                    # set password motpasse 
                    echo "${user}:motpasse" | chpasswd
                    # Création de la liste des adresses courriels valides 
                    echo "$user@$ACCEPT_DOMAIN OK" >> $LST_MAILS
            done


         # Launch
         rm -f /var/run/dovecot/*.pid
         exec /usr/bin/supervisord -n


On reconstruit l'image !!


## <a name="correction_dockercompose" /> Changement du docker-compose

Suite à l'ajout de la variable pour les utilisateurs et l'utilisation du nom de domaine nous allons modifier le fichier __docker-compose.yaml__ afin d'avoir une définition convenable lors de l'initialisation du conteneur .

        version: '2'
        services:
            smtp-coco:
                image: srvsmtp
                restart: unless-stopped
                container_name : 'coco-smtp-t'
                hostname: mail.coco.com
                environment:
                    - SMTP_HOSTNAME=mail.coco.com
                    - ACCEPT_DOMAIN=coco.com
                    - TIMEZONE=America/Montreal
                    - TERM=xterm
                links:
                    - imap-coco:dovecot-lmtp
                ports:
                    - '25:25'
                volumes:
                    - /tmp/docker/coco-smtp-t/var_spool/mails:/var/spool/postfix
            imap-coco :
                image: srvimap
                container_name : 'coco-imap-t'
                hostname: mail.coco.com
                environment:
                    - ACCEPT_DOMAIN=coco.com
                    - LST_USER="robert bob peter benny lee"
                    - TIMEZONE=America/Montreal
                    - TERM=xterm
                ports:
                    - 143:143
                volumes:
                    - /tmp/docker/coco-imap-t/home:/home

Ça semble bon :D on redémarre le tout :D.

Je supprimer les anciens conteneur pour être certain :

        $ docker-compose rm
        Going to remove coco-imap-t
        Are you sure? [yN] y
        Removing coco-imap-t ... done

Je supprime les volumes afin de ne pas avoir d'ancienne configuration causant un problème, qui sera plus difficile à identifier.

        $ sudo rm -rf /tmp/docker/

On redémarre :D

        $ docker-compose up
        Creating coco-imap-t
        Creating coco-smtp-t
        Attaching to coco-imap-t, coco-smtp-t
        coco-imap-t  | /root/run.sh: line 24: $LST_MAILS: ambiguous redirect
        coco-imap-t exited with code 1
        coco-smtp-t  | /usr/lib/python2.7/dist-packages/supervisor/options.py:297: UserWarning: Supervisord is running as root and it is searching for its configuration file in default locations (including its current working directory); you probably want to specify a "-c" argument specifying an absolute path to a configuration file for improved security.
        coco-smtp-t  |   'Supervisord is running as root and it is searching '
        coco-smtp-t  | 2017-02-14 13:19:21,041 CRIT Supervisor running as root (no user in config file)
        coco-smtp-t  | 2017-02-14 13:19:21,041 WARN Included extra file "/etc/supervisor/conf.d/supervisor-all.conf" during parsing
        coco-smtp-t  | 2017-02-14 13:19:21,050 INFO RPC interface 'supervisor' initialized
        coco-smtp-t  | 2017-02-14 13:19:21,050 CRIT Server 'unix_http_server' running without any HTTP authentication checking
        coco-smtp-t  | 2017-02-14 13:19:21,051 INFO supervisord started with pid 1
        coco-smtp-t  | 2017-02-14 13:19:22,054 INFO spawned: 'postfix' with pid 11
        coco-smtp-t  | 2017-02-14 13:19:22,057 INFO spawned: 'rsyslogd' with pid 12
        coco-smtp-t  | 2017-02-14 13:19:23,358 INFO success: rsyslogd entered RUNNING state, process has stayed up for > than 1 seconds (startsecs)
        coco-smtp-t  | 2017-02-14 13:19:25,360 INFO success: postfix entered RUNNING state, process has stayed up for > than 3 seconds (startsecs)


        $ docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                NAMES
        0085f6c10929        srvsmtp             "/root/run.sh"      21 seconds ago      Up 19 seconds       0.0.0.0:25->25/tcp   coco-smtp-t

Si nous lisons le résultat nous voyons que le conteneur **coco-imap-t** n'a pas pu être initialisé car le script **run.sh** à eu un problème , ceci est dû a un problème de redirection nous allons analyser.

Alors là œil de lynx pour trouver le problème :P ... 

Ligne original du fichier **imap/run.sh**

        export LST_MAILS=${LST_MAILS:"/etc/dovecot/mails.lst"}

Ligne convenable  :

        export LST_MAILS=${LST_MAILS:-"/etc/dovecot/mails.lst"}

Oublié pas de reconstruire l'image !!

        $ docker build -t srvimap .

On recommence :

        $ docker-compose up                                                                                                                                  
        Recreating coco-imap-t
        Recreating coco-smtp-t
        Attaching to coco-imap-t, coco-smtp-t
        coco-imap-t  | mkdir: cannot create directory '/home/robert': File exists
        coco-smtp-t  | /usr/lib/python2.7/dist-packages/supervisor/options.py:297: UserWarning: Supervisord is running as root and it is searching for its configuration file in default locations (including its current working directory); you probably want to specify a "-c" argument specifying an absolute path to a configuration file for improved security.
        coco-smtp-t  |   'Supervisord is running as root and it is searching '
        coco-imap-t exited with code 1
        coco-smtp-t  | 2017-02-14 13:24:02,295 CRIT Supervisor running as root (no user in config file)
        coco-smtp-t  | 2017-02-14 13:24:02,295 WARN Included extra file "/etc/supervisor/conf.d/supervisor-all.conf" during parsing
        coco-smtp-t  | 2017-02-14 13:24:02,303 INFO RPC interface 'supervisor' initialized
        coco-smtp-t  | 2017-02-14 13:24:02,303 CRIT Server 'unix_http_server' running without any HTTP authentication checking
        coco-smtp-t  | 2017-02-14 13:24:02,303 INFO supervisord started with pid 1
        coco-smtp-t  | 2017-02-14 13:24:03,307 INFO spawned: 'postfix' with pid 11
        coco-smtp-t  | 2017-02-14 13:24:03,309 INFO spawned: 'rsyslogd' with pid 12
        coco-smtp-t  | 2017-02-14 13:24:04,330 INFO success: rsyslogd entered RUNNING state, process has stayed up for > than 1 seconds (startsecs)
        coco-smtp-t  | 2017-02-14 13:24:06,835 INFO success: postfix entered RUNNING state, process has stayed up for > than 3 seconds (startsecs)

Bon faut encore modifier le script **run.sh** , vous voyez je suis pas meilleur que vous , j'avance aussi à petit pas tranquillement , parfois une bière à la main avec le sourire et du plaisir de voir le progrès :D.

Donc voici la nouvelle version de la boucle **for** pour la création des utilisateurs pour le conteneur __imap__:

        # Creation des utilisateur 
        for user in $LST_USER ; do
            if ! getent passwd $user ; then
                useradd $user
                mkdir /home/$user
                chown $user /home/$user
                # set password motpasse 
                echo "${user}:motpasse" | chpasswd
                # Création de la liste des adresses courriels valides 
                echo "$user@$ACCEPT_DOMAIN OK" >> $LST_MAILS
            fi
        done

Bon ça va finir par fonctionner ou pas :P !! Courage le bon coté c'est que ça fini toujours par fonctionner on sait juste PAS quand :D et parfois où :P.

On reconstruit l'image ,  on détruit les conteneurs et on recommence :

        $ docker build -t srvimap .
        $ cd ..
        $ docker-compose rm 
        $ sudo rm -rf /tmp/docker

**OK let's GO !!** 

        $ docker-compose up
        Creating coco-imap-t
        Creating coco-smtp-t
        Attaching to coco-imap-t, coco-smtp-t
        coco-imap-t  | /usr/lib/python2.7/dist-packages/supervisor/options.py:297: UserWarning: Supervisord is running as root and it is searching for its configuration file in default locations (including its current working directory); you probably want to specify a "-c" argument specifying an absolute path to a configuration file for improved security.
        coco-imap-t  |   'Supervisord is running as root and it is searching '
        coco-imap-t  | 2017-02-14 13:35:39,247 CRIT Supervisor running as root (no user in config file)
        coco-imap-t  | 2017-02-14 13:35:39,247 WARN Included extra file "/etc/supervisor/conf.d/supervisor-all.conf" during parsing
        coco-imap-t  | 2017-02-14 13:35:39,256 INFO RPC interface 'supervisor' initialized
        coco-imap-t  | 2017-02-14 13:35:39,256 CRIT Server 'unix_http_server' running without any HTTP authentication checking
        coco-imap-t  | 2017-02-14 13:35:39,259 INFO supervisord started with pid 1
        coco-smtp-t  | /usr/lib/python2.7/dist-packages/supervisor/options.py:297: UserWarning: Supervisord is running as root and it is searching for its configuration file in default locations (including its current working directory); you probably want to specify a "-c" argument specifying an absolute path to a configuration file for improved security.
        coco-smtp-t  |   'Supervisord is running as root and it is searching '
        coco-smtp-t  | 2017-02-14 13:35:39,385 CRIT Supervisor running as root (no user in config file)
        coco-smtp-t  | 2017-02-14 13:35:39,385 WARN Included extra file "/etc/supervisor/conf.d/supervisor-all.conf" during parsing
        coco-smtp-t  | 2017-02-14 13:35:39,394 INFO RPC interface 'supervisor' initialized
        coco-smtp-t  | 2017-02-14 13:35:39,394 CRIT Server 'unix_http_server' running without any HTTP authentication checking


        $ docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                          NAMES
        32a621a290b1        srvsmtp             "/root/run.sh"      47 seconds ago      Up 45 seconds       0.0.0.0:25->25/tcp             coco-smtp-t
        b06f68de4806        srvimap             "/root/run.sh"      47 seconds ago      Up 47 seconds       24/tcp, 0.0.0.0:143->143/tcp   coco-imap-t


**Yeahhh !!! Du premier coup !**

## <a name="correction_status" /> Validation de la configuration

* Liste des utilisateurs créer dans le conteneur **dovecot** :

        $ docker exec -it coco-imap-t tail /etc/passwd
        systemd-bus-proxy:x:103:105:systemd Bus Proxy,,,:/run/systemd:/bin/false
        _apt:x:104:65534::/nonexistent:/bin/false
        syslog:x:105:106::/home/syslog:/bin/false
        dovecot:x:106:108:Dovecot mail server,,,:/usr/lib/dovecot:/bin/false
        dovenull:x:107:109:Dovecot login user,,,:/nonexistent:/bin/false
        robert:x:1000:1000::/home/robert:
        bob:x:1001:1001::/home/bob:
        peter:x:1002:1002::/home/peter:
        benny:x:1003:1003::/home/benny:
        lee:x:1004:1004::/home/lee:
* Liste des adresses de courriels dans le conteneur **dovecot** :

        $ docker exec -it coco-imap-t cat /etc/dovecot/mails.lst
        robert@coco.com OK
        bob@coco.com OK
        peter@coco.com OK
        benny@coco.com OK
        lee@coco.com OK

* Liste des adresses courriels sur le serveur **smtp** :

        $ docker exec -it coco-smtp-t cat /etc/postfix/mails-coco.com.lst
        cat: /etc/postfix/mails-coco.com.lst: No such file or directory

HA __ouin__ ... C'est pas encore ça !! Notre problème est que la liste des utilisateurs est définie dans le conteneur __dovecot__ mais dois aussi être présent sur le conteneur __smtp__. Je le répète la solution est d'avoir une source externe __BD__ ou autre car ma solution ne "__scale__" pas , mais ça reste un bonne exemple.

## <a name="correction_share_file" /> Partage de la liste des adresses courriels 

Nous allons modifier la configuration afin de permettre le partage d'un fichier entre les 2 conteneurs ! 
On détruit tous et on recommence :

        $ sudo rm -rf /tmp/docker/
        docker-compose rm                                                                                                                                  
        Going to remove coco-smtp-t, coco-imap-t
        Are you sure? [yN] y
        Removing coco-smtp-t ... done
        Removing coco-imap-t ... done

Je vais modifier le fichier **docker-compose.yml** afin d'associer le fichier le fichier **/etc/dovecot/mails.lst** à l'extérieur du conteneur et le définir aussi dans le conteneur **smtp**.

        version: '2'
        services:
            smtp-coco:
                image: srvsmtp
                restart: unless-stopped
                container_name : 'coco-smtp-t'
                hostname: mail.coco.com
                environment:
                    - SMTP_HOSTNAME=mail.coco.com
                    - ACCEPT_DOMAIN=coco.com
                    - TIMEZONE=America/Montreal
                    - TERM=xterm
                links:
                    - imap-coco:dovecot-lmtp
                ports:
                    - '25:25'
                volumes:
                    - /tmp/docker/coco-smtp-t/var_spool/mails:/var/spool/postfix
                    - /tmp/docker/coco-t/etc/mails.lst:/etc/postfix/mails-coco.com.lst
            imap-coco :
                image: srvimap
                container_name : 'coco-imap-t'
                hostname: mail.coco.com
                environment:
                    - ACCEPT_DOMAIN=coco.com
                    - LST_USER=robert bob peter benny lee
                    - TIMEZONE=America/Montreal
                    - TERM=xterm
                ports:
                    - 143:143
                volumes:
                    - /tmp/docker/coco-imap-t/home:/home
                    - /tmp/docker/coco-t/etc/mails.lst:/etc/dovecot/mails.lst

Détail mais je préfère le nommé vous pouvez constater que les chemins de mes volumes contienne le nom de mes conteneurs , si j'ai un fichier qui doit être partagé je le met dans un répertoire distinct qui est commun. Ai-je raison ou tord honnêtement je le sais pas encore ;-), j'ai pris cette orientation pour avoir une structure l'avenir répondra à la question :D. 

On redémarre le tous ! 

        $ docker-compose up
        Creating coco-imap-t
        Creating coco-smtp-t
        Attaching to coco-imap-t, coco-smtp-t
        coco-imap-t  | /root/run.sh: line 25: /etc/dovecot/mails.lst: Is a directory
        coco-imap-t exited with code 1
        coco-smtp-t  | /usr/lib/python2.7/dist-packages/supervisor/options.py:297: UserWarning: Supervisord is running as root and it is searching for its configuration file in default locations (including its current working directory); you probably want to specify a "-c" argument specifying an absolute path to a configuration file for improved security.

**BOOM** encore une erreur , on en fini plus :P . Regardons l'erreur **/root/run.sh: line 25: /etc/dovecot/mails.lst: Is a directory** .

Il mentionne que lors de l'exécution du script **run.sh** le fichier **/etc/dovecot/mails.lst** est un répertoire. Quand nous définissons des **volumes** dans le fichier **docker-compose** si le premier paramètre n'existe pas ce dernier va réaliser la création. Comme 99% du temps ceci est pour des associations de répertoire il crée un répertoire par défaut, malheureusement dans notre cas ce n'est pas le besoin :D.

**Solution:** 

Je refais un __clean up__ de la configuration :

        $ docker-compose rm
        Going to remove coco-smtp-t, coco-imap-t
        Are you sure? [yN] y
        Removing coco-smtp-t ... done
        Removing coco-imap-t ... done
        $ sudo rm -rf /tmp/docker

On est de retour à une configuration vierge, je vais créer le répertoire manuellement et réalisé un **touch** pour définir un fichier vierge :

        $ mkdir -p /tmp/docker/coco-t/etc/
        $ sudo touch /tmp/docker/coco-t/etc/mails.lst

C'est repartie :D .

        $ docker-compose up 
        Creating coco-imap-t
        Creating coco-smtp-t
        Attaching to coco-imap-t, coco-smtp-t
        coco-imap-t  | /usr/lib/python2.7/dist-packages/supervisor/options.py:297: UserWarning: Supervisord is running as root and it is searching for its configuration file in default locations (including its current working directory); you probably want to specify a "-c" argument specifying an absolute path to a configuration file for improved security.
        coco-imap-t  |   'Supervisord is running as root and it is searching '

**Yeahh** encore une fois du premier coup :P .

**Validation** :

        $ docker exec -it coco-imap-t cat /etc/dovecot/mails.lst
        robert@coco.com OK
        bob@coco.com OK
        peter@coco.com OK
        benny@coco.com OK
        lee@coco.com OK

        $ docker exec -it coco-smtp-t cat /etc/postfix/mails-coco.com.lst
        robert@coco.com OK
        bob@coco.com OK
        peter@coco.com OK
        benny@coco.com OK
        lee@coco.com OK

Donc nos 2 conteneurs on bien le même fichier avec les informations des utilisateurs :D.
On fait un teste ?? **sortez pas tous de suite le champagne :P , on arrête pas d'avancer, mais on est pas arrivé :P** 

        $ telnet 172.21.0.3 25
        Trying 172.21.0.3...
        Connected to 172.21.0.3.
        Escape character is '^]'.
         
        [ ... PAS DE RETOUR ON EST COINCÉ ... ] 

Regardons les logs du serveurs de courriel :

        $ docker exec -it coco-smtp-t tail /var/log/mail.log
        Feb 14 22:27:21 mail postfix[87]: Postfix is running with backwards-compatible default settings
        Feb 14 22:27:21 mail postfix[87]: See http://www.postfix.org/COMPATIBILITY_README.html for details
        Feb 14 22:27:21 mail postfix[87]: To disable backwards compatibility use "postconf compatibility_level=2" and "postfix reload"
        Feb 14 22:27:21 mail postfix/master[178]: daemon started -- version 3.1.0, configuration /etc/postfix
        Feb 14 22:30:32 mail postfix/smtpd[938]: fatal: open dictionary: expecting "type:name" form instead of "/etc/postfix/mails-coco.com.lst"
        Feb 14 22:30:33 mail postfix/master[178]: warning: process /usr/lib/postfix/sbin/smtpd pid 938 exit status 1
        Feb 14 22:30:33 mail postfix/master[178]: warning: /usr/lib/postfix/sbin/smtpd: bad command startup -- throttling

Effectivement le fichier **/etc/postfix/mails-coco.com.lst** est bien présent mais on a pas exécuté la commande **postmap** dessus , résultat ça plante.

Bien entendu nous pourrions l'ajouter à la fin du __run.sh__ du conteneur **smtp**, mais on ne sait pas vraiment si le conteneur **imap** sera initialisé en premier ou le serveur **smtp**. De plus s'il y a une modification, ce serait bien que le fichier se génère aussi. 


# <a name="integration_conteneur" /> Intégration et cohabitation des conteneurs

## <a name="integration_conteneur_postmap" /> Génération automatique du fichier de courriels (postmap)

Bon je dois vous avouer, là je me fais vachement plaisir !! Ça fait super longtemps que je veux utiliser ce truc, mais j'avais jamais eu l'occasion :D .
Ce qui suit n'est PAS propre à docker, vous pouvez l'utiliser sur des machines classique sans problème , après faut avoir l'occasion.

Une option qui est possible pour que le fichier ce génère est d'avoir un __crontab__ qui s'exécutera toutes les minutes voir 5 minutes pour générer le fichier. Malheureusement n'ayant pas l'application **postmap** sur le conteneur **imap** je ne peux pas le générer à la fin du script **run.sh** du conteneur **imap**. 
Mais ça me fait chier, d'avoir un __cron__ qui est exécuter pour RIEN toutes les minutes juste pour valider si peut-être éventuellement le fichier a changé, sachant que ce dernier risque de ne pas changer souvent !

Bon comme j'ai toujours des petites merveille dans mon sac de produit open source :D, j'ai cette article : [http://linuxfr.org/news/exploiter-inotify-c-est-simple](http://linuxfr.org/news/exploiter-inotify-c-est-simple) , si vous regardez la date de parution : **24/11/14** j'ai attendu pour l'utiliser, mais aujourd'hui ENFIN je l'utilise !! Pour ça je vous dis merci :D.

Bon ça fait quoi ça ?? En gros **incron** va intercepter les messages du __kernel__ (ça tombe bien les systèmes partage le même __kernel__ ) et portera une action SI et uniquement s'il y a modification du fichier :D.

Bien entendu, je me suis pas lancé dans la modification du fichier __Dockerfile__ directement :P. J'ai fait un teste manuellement préalablement .

        $ docker exec -it coco-smtp-t bash
        root@mail:~# apt-get install incron
        root@mail:~# /etc/init.d/incron start
        root@mail:~# echo "/etc/postfix/mails-coco.com.lst IN_MODIFY postmap /etc/postfix/mails-coco.com.lst" > /root/incron-postfix
        root@mail:~# echo "root" > /etc/incron.allow
        root@mail:~# incrontab /root/incron-postfix
        root@mail:~# ls -ltr /etc/postfix/
        root@mail:/# ls -ltr /etc/postfix/
        total 96
        drwxr-xr-x 2 root root     6 Apr 13  2016 sasl
        -rwxr-xr-x 1 root root  9344 Apr 13  2016 postfix-script
        -rw-r--r-- 1 root root 21233 Apr 13  2016 postfix-files
        -rwxr-xr-x 1 root root 29446 Apr 13  2016 post-install
        -rw-r--r-- 1 root root  6068 Jan 30 21:57 master.cf
        -rw-r--r-- 1 root root   108 Jan 30 21:57 dynamicmaps.cf
        -rw-r--r-- 1 root root   658 Feb 14 20:41 main.cf
        -rw-r--r-- 1 root root   376 Feb 14 22:33 mails-coco.com.lst
        root@mail:/# logout


Validation du bon fonctionnement

        $ sudo vim /tmp/docker/coco-t/etc/mails.lst
        ajout de :
        toto@coco.com

        $ docker exec -it coco-smtp-t ls -ltr /etc/postfix/
        [ ... OUTPUT COUPÉ ... ]
        -rw-r--r-- 1 root root   376 Feb 14 22:40 mails-coco.com.lst
        -rw-r--r-- 1 root root   376 Feb 14 22:40 mails-coco.com.lst.db

On modifie le __Dockerfile__ avec :

* Ajout de l'application **incron** 
* Modification de __supervisor__ pour démarrer aussi le service **incron**
* Activation du fichier de configuration pour __incron__

### <a name="integration_incron" /> Modification de l'image postfix pour inclure incron

On arrête pas le plaisir :D !!!

Bon petit truc de tour de passe passe :P , je suis dans le train avec ma connexion internet "limité", je vais donc profiter des couches dockers pour ne PAS réinstallé toutes les applications. En phase de teste je vais créer une couche uniquement pour __incron__ , bien entendu dans la configuration finale je l'inclurais dans la couche d'installation de package.  Voici le résultat :

        # Using debian
        # Start Exemple:
        # ou can add -p 25:25 for LAN access
        FROM ubuntu:16.04
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Packages: update
        RUN apt-get update -qq && \
            apt-get install -qq -y --no-install-recommends postfix \
                    python-pip supervisor rsyslog python-wheel python-setuptools  && \
                    pip install j2cli

        # TODO mettre l'installation dans le layer précédent 
        RUN apt-get install --no-install-recommends incron

        # Configure: supervisor
        ADD bin/dfg.sh /usr/local/bin/
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/

        [ ... OUTPUT COUPÉ ... ]


Nous allons modifier la configuration du __supervisor__ . Si nous nous inspirons de l'exécution de __rsyslogd__ définie dans le fichier **conf/supervisor-all.conf** :

        [... OUTPUT COUPÉ ...]
        [program:rsyslogd]
        command = /usr/sbin/rsyslogd -n

        [... OUTPUT COUPÉ ...]

C'est quoi l'option **-n** , je le sais pas plus que vous , bon maintenant oui, car j'ai déjà validé , mais je le savais pas avant d'écrire ces lignes :P. Voici comment j'ai démystifié l'option :

        $ docker exec -it coco-smtp-t bash
        root@mail:/# /usr/sbin/rsyslogd -h    
        usage: rsyslogd [options]
        use "man rsyslogd" for details. To run rsyslog interactively, use "rsyslogd -n"to run it in debug mode use "rsyslogd -dn"
        For further information see http://www.rsyslog.com/doc
        root@mail:/# man rsyslogd
        bash: man: command not found

Bon finalement, comme la commande **man** est pas installé j'ai du allé sur le net :P : [https://linux.die.net/man/8/rsyslogd](https://linux.die.net/man/8/rsyslogd) :

        -n
        Avoid auto-backgrounding. This is needed especially if the rsyslogd is started and controlled by init(8). 

Donc ça permet au processus de rester en avant plan (__forground__). Cool donc on va essayer de faire la même chose pour __incron__ :D , je vais analyser le fichier d'initialisation de __incron__ :

        root@mail:/# cat /etc/init.d/incron | grep -v "#" | more
        PATH=/sbin:/bin:/usr/sbin:/usr/bin
        INCROND=/usr/sbin/incrond
        NAME=incron
        DESC="File system events scheduler"
        INCROND_PID=/var/run/incrond.pid
        INCROND_CONF=/etc/incron.conf

        if [ ! -x "$INCROND" ]; then
            exit 0
        fi

        . /lib/lsb/init-functions

        case "$1" in
            start)
                log_daemon_msg "Starting $DESC"
                log_progress_msg "$NAME"
                start_daemon -p "$INCROND_PID" "$INCROND" -f "$INCROND_CONF"
                log_end_msg $?
            ;;
       [... OUTPUT COUPÉ ...]

Donc le système démarre **start_daemon** en utilisant la commande **"$INCROND"** définie par la variable : **INCROND=/usr/sbin/incrond**.
Regardons les options disponible , en espérant que l'aide soit disponible .

        root@mail:/# /usr/sbin/incrond --help
        incrond - inotify cron daemon
        (c) Lukas Jelinek, 2006, 2007, 2008

        usage: incrond [<options>]

        <operation> may be one of the following:
        These options may be used:
          -?, --about                  gives short information about program
          -h, --help                   prints this help text
          -n, --foreground             runs on foreground (no daemonizing)
          -k, --kill                   terminates running instance of incrond
          -f <FILE>, --config=<FILE>   overrides default configuration file  (requires root privileges)
          -V, --version                prints program version

          For reporting bugs please use http://bts.aiken.cz

**Yeahh** , merci **Lukas Jelinek** :D, bon finalement c'est la même option :P. __héhéhé__ :D on pouvait pas vraiment le deviner , donc on modifier le fichier __conf/supervisor-all.conf__ :

        [... OUTPUT COUPÉ ...]
        [program:rsyslogd]
        command = /usr/sbin/rsyslogd -n

        [program:incrond]
        command = /usr/sbin/incrond -n
        [... OUTPUT COUPÉ ...]


Dernière étape modifier le fichier **run.sh** pour que notre configuration soit prise en charge  :

        #! /usr/bin/env bash
        set -e # exit on error

        # Variables
        export EXT_RELAY_HOST=${EXT_RELAY_HOST:-"DIRECT"}
        export SMTP_HOSTNAME=${SMTP_HOSTNAME:-"relay.example.com"}
        export PERMIT_NETWORK=${PERMIT_NETWORK:-"192.168.0.0/16"}
        export ACCEPT_DOMAIN=${ACCEPT_DOMAIN:-"localhost $SMTP_HOSTNAME"}

        echo $SMTP_HOSTNAME > /etc/mailname

        # Templates
        j2 /root/postfix-main.j2 > /etc/postfix/main.cf

        # Incron 
        echo "/etc/postfix/mails-$ACCEPT_DOMAIN.lst IN_MODIFY postmap /etc/postfix/mails-$ACCEPT_DOMAIN.lst" > /root/incron-postfix
        /usr/bin/incrontab /root/incron-postfix

        # Launch
        rm -f /var/spool/postfix/pid/*.pid
        exec /usr/bin/supervisord -n

On reconstruit l'image :

        $ docker build -t srvsmtp .
        [... OUTPUT COUPÉ ...]
        Step 4 : RUN apt-get update -qq &&     apt-get install -qq -y --no-install-recommends postfix         python-pip supervisor rsyslog python-wheel python-setup$
        ools  &&     pip install j2cli
         ---> Using cache
         ---> db7a6b374677
        Step 5 : RUN apt-get install --no-install-recommends incron
         ---> Running in 82d43b1fd0a4
         Reading package lists...
         Building dependency tree...
         Reading state information...
         The following NEW packages will be installed:
             incron
        [... OUTPUT COUPÉ ...]

Mon objectif de réutilisation de couche à très bien fonctionné :P , nous voyons que l'étape 4 , le cache fut utilisé :D.

C'est le temps de tester tous  ça ! 

1. Nettoyage : 
        
        $ docker-compose stop && docker-compose rm
        Stopping coco-smtp-t ... done
        Stopping coco-imap-t ... done
        Going to remove coco-smtp-t, coco-imap-t
        Are you sure? [yN] y
        Removing coco-smtp-t ... done
        Removing coco-imap-t ... done
        $ sudo rm -rf  /tmp/docker/coco-smtp-t/ /tmp/docker/coco-imap-t/

2. On redémarrage .

        $ docker-compose up
        [... OUTPUT COUPÉ ...]
        coco-smtp-t  | user 'root' is not allowed to use incron
        coco-imap-t  | 2017-02-15 13:12:42,000 INFO spawned: 'dovecot' with pid 65
        coco-imap-t  | 2017-02-15 13:12:42,001 INFO spawned: 'rsyslogd' with pid 66
        coco-smtp-t exited with code 1
        coco-smtp-t  | user 'root' is not allowed to use incron
        coco-smtp-t  | user 'root' is not allowed to use incron
        [... OUTPUT COUPÉ ...]

:D , je vous ai dis que l'on aurait du plaisir :D , bon j'ai oublié faut aussi définir dans __/etc/incron.allow__ les utilisateurs permit :P. C'est la matin , j'ai juste 4 café dans le corps soyez indulgent :D. On corrige le __run.sh__ :

        [... OUTPUT COUPÉ ...]
        # Incron 
        echo "/etc/postfix/mails-$ACCEPT_DOMAIN.lst IN_MODIFY postmap /etc/postfix/mails-$ACCEPT_DOMAIN.lst" > /root/incron-postfix
        echo "root" >> /etc/incron.allow
        /usr/bin/incrontab /root/incron-postfix
        [... OUTPUT COUPÉ ...]

Reconstruire l'image , et nettoyage

        $ docker-compose stop && docker-compose rm
        Stopping coco-smtp-t ... done
        Stopping coco-imap-t ... done
        Going to remove coco-smtp-t, coco-imap-t
        Are you sure? [yN] y
        Removing coco-smtp-t ... done
        Removing coco-imap-t ... done
        $ sudo rm -rf  /tmp/docker/coco-smtp-t/ /tmp/docker/coco-imap-t/

Validation que le fichier pour volume est bien présent :

        $ ls -l /tmp/docker/coco-t/etc/mails.lst
        -rw-r--r-- 1 root root 0 Feb 15 16:47 /tmp/docker/coco-t/etc/mails.lst

C'est repartie :

        $ docker-compose up
        Creating coco-imap-t
        Creating coco-smtp-t
        Attaching to coco-imap-t, coco-smtp-t
        coco-imap-t  | /usr/lib/python2.7/dist-packages/supervisor/options.py:297: UserWarning: Supervisord is running as root and it is searching for its configuration file in default locations (including its current working directory); you probably want to specify a "-c" argument specifying an absolute path to a configuration file for improved security.
        coco-imap-t  |   'Supervisord is running as root and it is searching '
        coco-imap-t  | 2017-02-15 13:17:38,706 CRIT Supervisor running as root (no user in config file)
        coco-imap-t  | 2017-02-15 13:17:38,706 WARN Included extra file "/etc/supervisor/conf.d/supervisor-all.conf" during parsing
        coco-imap-t  | 2017-02-15 13:17:38,715 INFO RPC interface 'supervisor' initialized
        coco-imap-t  | 2017-02-15 13:17:38,715 CRIT Server 'unix_http_server' running without any HTTP authentication checking
        coco-imap-t  | 2017-02-15 13:17:38,716 INFO supervisord started with pid 1
        coco-smtp-t  | copying table from file '/root/incron-postfix'
        coco-smtp-t  | /usr/lib/python2.7/dist-packages/supervisor/options.py:297: UserWarning: Supervisord is running as root and it is searching for its configuration file in default locations (including its current working directory); you probably want to specify a "-c" argument specifying an absolute path to a configuration file for improved security.
        coco-smtp-t  |   'Supervisord is running as root and it is searching '
        coco-smtp-t  | 2017-02-15 13:17:38,838 CRIT Supervisor running as root (no user in config file)
        coco-smtp-t  | 2017-02-15 13:17:38,838 WARN Included extra file "/etc/supervisor/conf.d/supervisor-all.conf" during parsing
        coco-smtp-t  | 2017-02-15 13:17:38,847 INFO RPC interface 'supervisor' initialized
        coco-smtp-t  | 2017-02-15 13:17:38,847 CRIT Server 'unix_http_server' running without any HTTP authentication checking
        coco-smtp-t  | 2017-02-15 13:17:38,847 INFO supervisord started with pid 1
        coco-imap-t  | 2017-02-15 13:17:39,719 INFO spawned: 'dovecot' with pid 65
        coco-imap-t  | 2017-02-15 13:17:39,722 INFO spawned: 'rsyslogd' with pid 66
        coco-smtp-t  | 2017-02-15 13:17:39,849 INFO spawned: 'incrond' with pid 12
        coco-smtp-t  | 2017-02-15 13:17:39,851 INFO spawned: 'postfix' with pid 13
        coco-smtp-t  | 2017-02-15 13:17:39,854 INFO spawned: 'rsyslogd' with pid 14

**YEahh**, bon est-ce que ça marche vraiment ?? Maintenant :P , listons les fichiers dans le répertoire **/etc/postfix/** du conteneur **smtp** :

        $ docker exec -it coco-smtp-t ls -ltr /etc/postfix
        total 88
        drwxr-xr-x 2 root root     6 Apr 13  2016 sasl
        -rwxr-xr-x 1 root root  9344 Apr 13  2016 postfix-script
        -rw-r--r-- 1 root root 21233 Apr 13  2016 postfix-files
        -rwxr-xr-x 1 root root 29446 Apr 13  2016 post-install
        -rw-r--r-- 1 root root  6068 Jan 30 21:57 master.cf
        -rw-r--r-- 1 root root   108 Jan 30 21:57 dynamicmaps.cf
        -rw-r--r-- 1 root root    87 Feb 15 21:52 mails-coco.com.lst
        -rw-r--r-- 1 root root   658 Feb 15 21:52 main.cf

La je sens une pointe de découragement !! Il ne faut pas , voyez vraiment comme l'occasion de visualiser des problèmes avec des solutions quand vous aurez les même problème, vous ne vous rappellerez pas de la solution. Il faut être honnête, par contre vous vous direz , ha oui !! Thomas en avais parlé ... Puis vous consulterez ce document :D .

Pourquoi ça marche ?? Regardons les premières lignes lors de l'exécution du **docker-compose** 

        $ docker-compose up
        Creating coco-imap-t
        Creating coco-smtp-t
        Attaching to coco-imap-t, coco-smtp-t

Car le conteneur **coco-imap-t** qui génère le fichier est créer en premier !! Mon premier réflexe fut de définir la séquence dans le __docker-compose__ via l'option [depends-on](https://docs.docker.com/compose/compose-file/#depends-on)

J'avais donc modifier la définition du service **coco-imap-t** dans le __docker-compose__ 

            imap-coco :
                image: srvimap
                container_name : 'coco-imap-t'
                hostname: mail.coco.com
                environment:
                    - ACCEPT_DOMAIN=coco.com
                    - LST_USER=robert bob peter benny lee
                    - TIMEZONE=America/Montreal
                    - TERM=xterm
                depends_on:
                    - smtp-coco
                ports:
                    - 143:143
                volumes:
                    - /tmp/docker/coco-imap-t/home:/home
                    - /tmp/docker/coco-t/etc/mails.lst:/etc/dovecot/mails.lst

Le système [depends-on](https://docs.docker.com/compose/compose-file/#depends-on) permet de définir une séquence entre les conteneurs ! Quand j'ai voulu démarrer mon conteneur ... __isshh__ !!

        $ docker-compose up
        ERROR: Circular dependency between imap-coco and smtp-coco

Le problème est que dans la définition du conteneur **smtp-coco** , j'ai aussi l'instruction **links** qui indique un lien entre les conteneurs et qui attends l'initialisation du premier conteneur pour démarrer le suivant . Pas de chance :P .

Cependant ceci veut dire quoi ?? Que le conteneur **imap-coco** sera toujours initialisé en premier avant le conteneur **smtp** nous allons donc modifier le script **run.sh** afin de réaliser le **postmap** à la fin de son initialisation :D.

C'est repartie !! 

        $ docker-compose stop && docker-compose rm
        Going to remove coco-smtp-t, coco-imap-t
        Are you sure? [yN] y
        Removing coco-smtp-t ... done
        Removing coco-imap-t ... done

        $ sudo rm -rf  /tmp/docker/coco-smtp-t/ /tmp/docker/coco-imap-t/

        $ sudo rm /tmp/docker/coco-t/etc/mails.lst
        $ sudo touch /tmp/docker/coco-t/etc/mails.lst

Modification du script **smtp/run.sh**

        [... OUTPUT COUPÉ ...]
        # Incron 
        echo "/etc/postfix/mails-$ACCEPT_DOMAIN.lst IN_MODIFY postmap /etc/postfix/mails-$ACCEPT_DOMAIN.lst" > /root/incron-postfix
        echo "root" >> /etc/incron.allow
        /usr/bin/incrontab /root/incron-postfix

        postmap /etc/postfix/mails-$ACCEPT_DOMAIN.lst

        # Launch

        [... OUTPUT COUPÉ ...]

On reconstruit :

        $ docker build -t srvsmtp .

Une petite dernière ?? Ou pas :D


        $ docker-compose up
        Creating coco-imap-t
        Creating coco-smtp-t
        Attaching to coco-imap-t, coco-smtp-t
        coco-imap-t  | /usr/lib/python2.7/dist-packages/supervisor/options.py:297: UserWarning: Supervisord is running as root and it is searching for its configuration file in default locations (including its current working directory); you probably want to specify a "-c" argument specifying an absolute path to a configuration file for improved security.

Validation :

        $ docker exec -it coco-smtp-t ls -ltr /etc/postfix                                                                                                    
        total 100
        drwxr-xr-x 2 root root     6 Apr 13  2016 sasl
        -rwxr-xr-x 1 root root  9344 Apr 13  2016 postfix-script
        -rw-r--r-- 1 root root 21233 Apr 13  2016 postfix-files
        -rwxr-xr-x 1 root root 29446 Apr 13  2016 post-install
        -rw-r--r-- 1 root root  6068 Jan 30 21:57 master.cf
        -rw-r--r-- 1 root root   108 Jan 30 21:57 dynamicmaps.cf
        -rw-r--r-- 1 root root    87 Feb 15 22:07 mails-coco.com.lst
        -rw-r--r-- 1 root root   658 Feb 15 22:07 main.cf
        -rw-r--r-- 1 root root 12288 Feb 15 22:07 mails-coco.com.lst.db

C'est tellement plaisant quand si veut faire quelque chose puis du premier coup ça fonctionne :D !!! ( oui faut en rire un peu , mais on a tous compris des raison :D ) 

__LOL__ !!! OK heu ... Je n'avais pas vu mais il y a une erreur dans ma configuration ... lol , la génération à bien passé, cependant quand je fait le __telnet__ ça passe pas plus :P 

        $ telnet 172.21.0.3 25
        Trying 172.21.0.3...
        Connected to 172.21.0.3.
        Escape character is '^]'.

        [ ... HANG ... ]

        $ docker exec -it coco-smtp-t tail /var/log/mail.log                                                                                                 
        Feb 15 22:07:07 mail postfix[90]: Postfix is running with backwards-compatible default settings
        Feb 15 22:07:07 mail postfix[90]: See http://www.postfix.org/COMPATIBILITY_README.html for details
        Feb 15 22:07:07 mail postfix[90]: To disable backwards compatibility use "postconf compatibility_level=2" and "postfix reload"
        Feb 15 22:07:07 mail postfix/master[181]: daemon started -- version 3.1.0, configuration /etc/postfix
        Feb 15 22:08:54 mail postfix/smtpd[611]: fatal: open dictionary: expecting "type:name" form instead of "/etc/postfix/mails-coco.com.lst"

En fait ma ligne de définition ne contient pas le type de __Lookup table__ ... :P  ( Vraiment pas voulu j'espère que je vous décourage pas :P ) .

        $ cat smtp/conf/postfix-main.j2 | grep local
        local_recipient_maps = proxy:unix:passwd.byname $alias_maps /etc/postfix/mails-{{ ACCEPT_DOMAIN }}.lst

Ce doit être 

        local_recipient_maps = proxy:unix:passwd.byname $alias_maps hash:/etc/postfix/mails-{{ ACCEPT_DOMAIN }}.lst

Bon ben ... On recommence ...J'ai reconstruis l'image et fait le nettoyage , vous en faite pas vous serez meilleur que moi :P !! 

        $ docker-compose up
        Creating coco-imap-t
        Creating coco-smtp-t
        Attaching to coco-imap-t, coco-smtp-t

On valide encore !!!

        $ telnet 172.21.0.3 25
        Trying 172.21.0.3...
        Connected to 172.21.0.3.
        Escape character is '^]'.
        220 mail.coco.com ESMTP Postfix
        ehlo toto
        250-mail.coco.com
        250-PIPELINING
        250-SIZE 10240000
        250-VRFY
        250-ETRN
        250-ENHANCEDSTATUSCODES
        250-8BITMIME
        250 DSN
        mail from:toto@fjkjf.com
        250 2.1.0 Ok
        rcpt to:bob@coco.com
        250 2.1.5 Ok
        data
        354 End data with <CR><LF>.<CR><LF>
        un courriel de validatoin
        .
        250 2.0.0 Ok: queued as 8619212361
        quit
        221 2.0.0 Bye
        Connection closed by foreign host.


        $ docker exec -it coco-smtp-t tail /var/log/mail.log                                                                                                 
        Feb 15 22:15:32 mail postfix[90]: See http://www.postfix.org/COMPATIBILITY_README.html for details
        Feb 15 22:15:32 mail postfix[90]: To disable backwards compatibility use "postconf compatibility_level=2" and "postfix reload"
        Feb 15 22:15:32 mail postfix/master[181]: daemon started -- version 3.1.0, configuration /etc/postfix
        Feb 15 22:16:02 mail postfix/smtpd[297]: connect from unknown[172.21.0.1]
        Feb 15 22:16:16 mail postfix/smtpd[297]: 8619212361: client=unknown[172.21.0.1]
        Feb 15 22:16:21 mail postfix/cleanup[355]: 8619212361: message-id=<>
        Feb 15 22:16:21 mail postfix/qmgr[184]: 8619212361: from=<toto@fjkjf.com>, size=187, nrcpt=1 (queue active)
        Feb 15 22:16:21 mail postfix/lmtp[379]: 8619212361: to=<bob@coco.com>, relay=dovecot-lmtp[172.21.0.2]:24, delay=11, delays=11/0.01/0.02/0.04, dsn=2.0.0, status=sent (250 2.0.0 <bob@coco.com> VHlVLjXTpFgYAQAABKaThQ Saved)
        Feb 15 22:16:21 mail postfix/qmgr[184]: 8619212361: removed
        Feb 15 22:16:23 mail postfix/smtpd[297]: disconnect from unknown[172.21.0.1] ehlo=1 mail=1 rcpt=1 data=1 quit=1 commands=5


        $ sudo cat /tmp/docker/coco-imap-t/home/bob/Maildir/new/'1487196981.M820895P280.mail.coco.com,S=400,W=410'
        Return-Path: <toto@fjkjf.com>
        Delivered-To: bob@coco.com
        Received: from mail.coco.com ([172.21.0.3])
                by mail.coco.com (Dovecot) with LMTP id VHlVLjXTpFgYAQAABKaThQ
                for <bob@coco.com>; Wed, 15 Feb 2017 22:16:21 +0000
        Received: from toto (unknown [172.21.0.1])
                by mail.coco.com (Postfix) with ESMTP id 8619212361
                for <bob@coco.com>; Wed, 15 Feb 2017 22:16:10 +0000 (UTC)

        un courriel de validatoin

**YEAHHH** bon pas du premier coup , mais au deuxième ?!?! :P 

Et l'accès IMAP :

        $ telnet 172.21.0.2 143
        Trying 172.21.0.2...
        Connected to 172.21.0.2.
        Escape character is '^]'.
        * OK [CAPABILITY IMAP4rev1 LITERAL+ SASL-IR LOGIN-REFERRALS ID ENABLE IDLE AUTH=PLAIN] Dovecot ready.
        * a login bob motpasse
        * a OK [CAPABILITY IMAP4rev1 LITERAL+ SASL-IR LOGIN-REFERRALS ID ENABLE IDLE SORT SORT=DISPLAY THREAD=REFERENCES THREAD=REFS THREAD=ORDEREDSUBJECT MULTIAPPEND URL-PARTIAL CATENATE UNSELECT CHILDREN NAMESPACE UIDPLUS LIST-EXTENDED I18NLEVEL=1 CONDSTORE QRESYNC ESEARCH ESORT SEARCHRES WITHIN CONTEXT=SEARCH LIST-STATUS
        * BINARY MOVE SPECIAL-USE] Logged in
        * a002 select inbox
        * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
        * OK [PERMANENTFLAGS (\Answered \Flagged \Deleted \Seen \Draft \*)] Flags permitted.
        * 1 EXISTS
        * 1 RECENT
        * OK [UNSEEN 1] First unseen.
        * OK [UIDVALIDITY 1487197434] UIDs valid
        * OK [UIDNEXT 2] Predicted next UID
        * OK [HIGHESTMODSEQ 1] Highest
        * a002 OK [READ-WRITE] Select completed (0.000 + 0.000 secs).
        * a003 fetch 1 full
        * * 1 FETCH (FLAGS (\Recent) INTERNALDATE "15-Feb-2017 22:23:54 +0000" RFC822.SIZE 410 ENVELOPE (NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL) BODY ("text" "plain" ("charset" "us-ascii") NIL NIL "7bit" 27 1))
        * a003 OK Fetch completed (0.001 + 0.000 secs).
        * a004 fetch 1 BODY
        * * 1 FETCH (BODY ("text" "plain" ("charset" "us-ascii") NIL NIL "7bit" 27 1))
        * a004 OK Fetch completed (0.001 + 0.000 secs).
        * z logout
        * * BYE Logging out
        * z OK Logout completed.
        * Connection closed by foreign host.

C'est magnifique :D !!

Si on a le temps nous pourrions aussi faire le teste avec __thunderbird__ pour ne pas pollué mon environnement avec un conteneur :

[https://hub.docker.com/r/yantis/thunderbird/](https://hub.docker.com/r/yantis/thunderbird/)

## <a name="integration_create-user" /> Gestion de l'ajout d'un utilisateur à l'exécution

Reprenons notre discutions sur l'ajout d'un utilisateur, actuellement nous avons pris l'option ( nous étant moi :P, de manière totalitaire ;-) ) d'utiliser une variable d'environnement définie lors de l'initialisation du conteneur. 
Nous sommes au 21 ième siècle, la clé de l'informatique de nos jours est la flexibilité certainement pas la mise en place de contrainte ou de limitation nous empêchant de réagir vite !

Nous utilisons docker pour avoir un déploiement plus fluide , un système que l'on déploie fiable et pré empaqueté , fiable ! Pas un système dont le changement de configuration est pas possible une fois déployé. 

Donc comment pouvons nous ajouter un utilisateur ? 

1. Réaliser l'opération de **useradd** dans le conteneur en production , effectivement ça fonctionne nous l'avons fait !
2. Détruire, modifier la variable d'environnement et  recréer le conteneur , ça aussi c'est bon , avec les contraintes qui s'en suivent.

Je reprendrais pas toutes la discutions sur le sujet , vous pouvez reprendre le chapitre : [ Définition de l'utilisation du conteneur postfix](#workflow_conteneur_smtp) qui inclut l'ensemble de la discutions !

Nous allons voir donc maintenant voir comment nous pourrions mettre en place une solution flexible et fiable. Bon encore une fois je le répète ceci à pour but de vous présenter une solution éducative. Pour être en production il faut ajouter plusieurs validation dans la solution ... Cependant ceci à l'avantage de vous fournir un début de solution, toujours le problème de la page blanche !

Je vais créer un script qui va réaliser la création de l'utilisateur, Le script va créer l'utilisateur dans le conteneur, ce script sera exécuté sur le docker __host__.

        $ cat imap/bin/cuser.sh
        #!/bin/bash
        #
        #########################################################################################
        set -e # exit on error

        user=$1
        pass=$2

        export LST_MAILS=${LST_MAILS:-"/etc/dovecot/mails.lst"}

        if ! getent passwd $user ; then
            useradd $user
            mkdir /home/$user
            chown $user /home/$user
            # set password motpasse
            echo "${user}:$pass" | chpasswd

            # Création de la liste des adresses courriels valides
            echo "$user@$ACCEPT_DOMAIN OK" >> $LST_MAILS
        fi

Changement de permission :

        $ chmod a+x imap/bin/cuser.sh

Ajout du fichier dans le __Dockerfile__ :

        [... OUTPUT COUPÉ ...]
        # Configure: supervisor
        ADD bin/dfg.sh /usr/local/bin/
        ADD bin/cuser.sh /usr/local/bin/
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/
        [... OUTPUT COUPÉ ...]

Et oui, on reconstruit :D, on détruits le conteneur en place et on recommence.

Pour valider 

        $ docker exec coco-imap-t ls -ltr /usr/local/bin
        total 12
        -rwxr-xr-x 1 root root 818 Feb  7 13:21 dfg.sh
        -rwxr-xr-x 1 root root 206 Feb  7 13:34 j2
        -rwxr-xr-x 1 root root 444 Feb 16 13:33 cuser.sh

On essaye le tous depuis le docker __host__ :

        $ docker exec -it coco-imap-t /usr/local/bin/cuser.sh xerus2 titi
        $ cat /tmp/docker/coco-t/etc/mails.lst                                                                                                               
        robert@coco.com OK
        bob@coco.com OK
        peter@coco.com OK
        benny@coco.com OK
        lee@coco.com OK
        xerus2@coco.com OK

**Yeahh** vraiment du premier coup :P.

Bon on écrit un petit script sur le docker __host__ pour recouvrir l'ensemble des opérations :

        $ mkdir srvMailWithImap/scripts/
        $ vim srvMailWithImap/scripts/creation_user.sh


      #!/bin/bash
      #
      # Description : Création d'utilisateur pour le service de courriel
      #
      # Autheur : Thomas Boutry <Thomas.boutry@x3rus.com>
      # Licence : GPL v3
      #
      #########################################################################

      IMAPCONTENEUR=coco-imap-t

      f_usage () {
          # Show help message
          echo "  usage : $0 -u nom_utilisateur "
          echo " "
          echo " Description : Création d'un utilisateur pour imap .... "
      }

      ####################
      # script arguments #
      while getopts u:p:h FLAG; do
          case $FLAG in
              u)  # Recuperation du nom de l'utilisateur
                  NOM_UTILISATEUR=$OPTARG
                  ;;
              p)  # Recuperation le mot de passe de l'utilisateur
                  PASSWORD_UTILISATEUR=$OPTARG
                  ;;
              h)  #how help message
                  f_usage
                  exit 1
                  ;;
              \?) #unrecognized option - show help
                  echo "ERROR: option used not reconized , please read usage "
                  f_usage
                  exit 1
                  ;;
          esac # end case opts
      done # End while getopts

      # Création de l'utilisateur dans le docker

      docker exec -it $IMAPCONTENEUR /usr/local/bin/cuser.sh $NOM_UTILISATEUR $PASSWORD_UTILISATEUR

Quelle est le problème avec cette solution ? 
Notre définition d'utilisateur n'est pas conforme avec notre __docker-compose__ en d'autre mot si nous perdons notre conteneur (__pet conteneur__), nous perdons la définitions des utilisateurs !! :( Nous n'avons pas une source externe contenant la configuration de référence !

Solution ? 
Mettre à jour le __docker-compose__ :D , réalisons la modification dans le script, mais avant ça une petite information.
Lors de l'utilisation de __docker exec__ vous avez le code de retour du programme qui fut exécuté exemple.

        $ docker exec -it coco-imap-t ls -l /etc/dovecot/mails.lst
        -rw-r--r-- 1 root root 125 Feb 17 00:03 /etc/dovecot/mails.lst
        $ echo $?
        0

        $ docker exec -it coco-imap-t ls -l /etc/dovecot/mails.lst-bad
        ls: cannot access '/etc/dovecot/mails.lst-bad': No such file or directory
        $ echo $?
        2

En d'autre mot si votre script retourne le bon code de retour vous êtes en mesure de traiter adéquatement le résultat dans le conteneur.

Voici donc la nouvelle version du script :

        #!/bin/bash
        #
        # Description : Création d'utilisateur pour le service de courriel
        #
        # Autheur : Thomas Boutry <Thomas.boutry@x3rus.com>
        # Licence : GPL v3
        #
        #########################################################################

        IMAPCONTENEUR=coco-imap-t
        DCKcompose=~/git/formations/serveur_de_courriels/dockers/srvMailWithImap/docker-compose.yml

        f_usage () {
            # Show help message
            echo "  usage : $0 -u nom_utilisateur "
            echo " "
            echo " Description : Création d'un utilisateur pour imap .... "
        }
        
        ####################
        # script arguments #

        while getopts u:p:h FLAG; do
            case $FLAG in
                u)  # Recuperation du nom de l'utilisateur
                    NOM_UTILISATEUR=$OPTARG
                    ;;
                p)  # Recuperation le mot de passe de l'utilisateur
                    PASSWORD_UTILISATEUR=$OPTARG
                    ;;
                h)  #how help message
                    f_usage
                    exit 1
                    ;;
                \?) #unrecognized option - show help
                    echo "ERROR: option used not reconized , please read usage "
                    f_usage
                    exit 1
                    ;;
            esac # end case opts
        done # End while getopts

        # Création de l'utilisateur dans le docker

        docker exec -it $IMAPCONTENEUR /usr/local/bin/cuser.sh $NOM_UTILISATEUR $PASSWORD_UTILISATEUR

        if [ $? == 0 ] ; then
            # Si la création de l'utilisateur fut un succes met à jour le docker-compose
            sed -i -e "s/\(\s*- LST_USER=.*\)/\1 $NOM_UTILISATEUR/g" $DCKcompose

            # Idealement ajouter un git commit / push ou un svn commit pour conserver l'information hors du docker host
        fi

Et voilà nous avons maintenant une configuration cohérente même si nous réalisons des ajouts dans le conteneur :D.

