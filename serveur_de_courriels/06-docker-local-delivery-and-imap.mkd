<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 

# <a name="Intro" /> Introduction

Nous avons donc vue la mise en place du système de réception de courriel localement ainsi que la possibilité pour les utilisateurs de récupérer leur courriel grâce au système __pop3__ et __imap__. Nous avions fait l'exercice avec un [pet container](http://rhelblog.redhat.com/2016/06/08/in-defense-of-the-pet-container-part-1-prelude-the-only-constant-is-complexity/) en d'autre mot avec un conteneur docker comme si c'était une __VM__. C'est mal , c'est bien je vous laisse lire le blog de RedHat sur le sujet, je suis un puriste sur l'utilisation du logiciel libre après je ne suis pas rigide sur les méthodes. Donc pour moi un pet conteneur c'est pas la fin du monde. 
Par contre il reste que c'est mieux d'avoir des vraies conteneurs qui sont indépendant , bien structuré que l'on peut modifier manipulé de manière indépendante ! Comme nous sommes dans le cadre de la formation nous allons faire l'exercice. 
Mettons tous de suite quelque chose au claire, ma configuration actuelle est un __pet conteneur__ , dû à des contrainte de temps de migration de serveur je n'avais pas eu le temps de faire l'exercice que l'on fait ici !!!
En d'autre mot pas de stress :D .

La grande particularité de la configuration qui suit est que nous allons pour la première fois depuis notre utilisation dans la formation connecter 2 conteneurs ensemble . 

* __postfix__ : réception et envoie de courriel
* __dovecot__ : Récupération des courriels.

# <a name="setup_images" /> Définition des images 

Pour débuter du bon pieds nous allons définir les critères de configuration afin de ne pas tourné en rond lors de la mise en place de postfix , voici les critère à répondre . 

* **réception** : Permettre la réception de courriel pour 1 ou plusieurs domaines
* **envoie** : Permettre l'envoie de courriel sans authentification pour un ou plusieurs réseaux nommé (quand nous mettrons la configuration avec __Mysql__ nous ajouterons l'authentification)
* **MailDir** : Utilisation du système de stockage __maildir__ afin de limité les risques de corruption du fichier unique de courriel définie avec le format __mbox__
* **Validation des adresses à la source** : Nous voulons conservé la validation des adresses de courriels au niveau de postfix afin de ne pas avoir une charge élevé de courriels .
* **imap** : Permettre la réception de courriel via le protocole __imap__ , je vais mettre de coté le __pop3__ pour le moment.

Ça semble bon :D , maintenant passons au variable que nous désirons avoir configurable :

* **domaines** : Avoir une variable configurable pour que l'image soit utilisable pour n'importe quelle domaine
* **mynetwork** : Avoir une variable configuration pour la définition des réseaux qui peuvent transmettre des courriels.
* **relayhost** : Si le déploiement est fait dans un réseau restrictif permettre l'envoie pour via un __relayhost__.
* **authentification en claire** : Paramètre permettant l'authentification en claire sans chiffrement , bon vraiment pas obligatoire mais sinon j'ai rien pour dovecot :P

Comme la formation est sous Ubuntu , nous allons prendre la dernière __LTS__ pour le besoin donc Ubuntu:16.04

# <a name="setup_postfix" /> Création de l'image SMTP (postfix)

Nous allons reprendre bêtement les étapes vue dans la formation pour faire la création du __Dockerfile__ :

1. Installation des packages postfix
2. Mise en place d'un fichier de configuration en __template__ [Jinja2](http://jinja.pocoo.org/docs/2.9/)
3. Script de démarrage de postfix

Nous avons déjà débuter cette configuration lors de la mise en place du conteneur pour le __relayhost__ bien entendu on va s'en inspirer on l'a déjà étudier :D. J'ai tendance à présenter un produit fini quand je présente docker, malheureusement vous n'avez pas la chance de voir le processus de création incluant les erreur :D . Nous allons donc faire la démarche ensemble afin de voir l'avantage de l'utilisation de docker avec l'utilisation des couches (__layer__) en cache . 

Débutons je crée la structure :

        $ ls -R srvMailWithImap/
        srvMailWithImap/:
        imap  smtp

        srvMailWithImap/imap:

        srvMailWithImap/smtp:
        bin  Dockerfile  run.sh

        srvMailWithImap/smtp/bin:
        dfg.sh

Comme vous pouvez le voir , dans le répertoire __srvMailWithImap/__ il y a 2 répertoires 1 pour le service __smtp__ et l'autre pour le service __imap__ . 
Dans le répertoire __smtp__ j'ai repris une partie de la configuration du serveur __srvMailRelay__ , soit le script __dfg.sh__ ainsi que le script de démarrage. Nous le modifierons peut-être par la suite, mais pour le moment ceci nous donne un point de départ, et nous savons qu'il fonctionne !!

Voici le contenu du fichier **Dockerfile**

        $ cat Dockerfile
        # Using debian
        # Start Exemple:
        # ou can add -p 25:25 for LAN access
        FROM ubuntu:16.04
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Packages: update
        RUN apt-get update -qq && \
            apt-get install -qq -y --no-install-recommends postfix \
                    python-pip supervisor rsyslog && \
            pip install j2cli

        # Configure: supervisor
        ADD bin/dfg.sh /usr/local/bin/
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/

        # Runner
        ADD run.sh /root/run.sh
        RUN chmod +x /root/run.sh

        # Declare
        EXPOSE 25

        CMD ["/root/run.sh"]

Bien simple :

* Nous débutons avec l'image **Ubuntu:16.04** comme nous avons utilisé cette distribution depuis le début.
* Installation des packages pour postfix et __supervisor__ ainsi que le système __rsyslog__ pour les logs.
* Nous installons aussi __j2cli__ , toujours dans l'optique d'utiliser le système __jinja2__ comme __template__ pour les fichiers de configuration.
* Installation des fichiers de configuration pour __supervisor__ , j'ai simplement repris ceux déjà présenter lors de la présentation de la __dockerisation__ du serveur de relais.

L'ensemble des fichiers sont disponible sur [github](https://github.com/x3rus/training/tree/master/serveur_de_courriels/dockers/srvMailWithImap/smtp).

## <a name="setup_postfix_install_pkg" /> Installation des packages dans l'image

Passons à la génération de l'image , bien entendu la configuration n'est pas terminé !! 

        $ docker build -t srvsmtp .
        Sending build context to Docker daemon 6.144 kB
        Step 1 : FROM ubuntu:16.04
         ---> c73a085dc378
        Step 2 : MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>
         ---> Running in d42a4e80f101
         ---> 9421a73877a6
       [... OUTPUT COUPÉ ...]

Cette compilation est un peu plus longue, car ceci comprend l'installation des applications.

Super , j'en attendait pas autant :) , on a déjà une erreur :D , la voici :

       [... OUTPUT COUPÉ ...]
        Running hooks in /etc/ca-certificates/update.d...
        done.
        Collecting j2cli
          Downloading j2cli-0.3.1_0-py2-none-any.whl
        Collecting jinja2>=2.7.2 (from j2cli)
          Downloading Jinja2-2.9.5-py2.py3-none-any.whl (340kB)
        Collecting MarkupSafe>=0.23 (from jinja2>=2.7.2->j2cli)
          Downloading MarkupSafe-0.23.tar.gz
        Complete output from command python setup.py egg_info:
          Traceback (most recent call last):
          File "<string>", line 1, in <module>
          ImportError: No module named setuptools
          ----------------------------------------
          Command "python setup.py egg_info" failed with error code 1 in /tmp/pip-build-Gs2DNu/MarkupSafe/
          You are using pip version 8.1.1, however version 9.0.1 is available.
          You should consider upgrading via the 'pip install --upgrade pip' command.
         The command '/bin/sh -c apt-get update -qq &&     apt-get install -qq -y --no-install-recommends postfix         python-pip supervisor rsyslog &&     pip install j2cli' returned a non-zero code: 1



Vous me direz , mais pourquoi ça fonctionnait très bien avec le serveur de relais , effectivement mais nous étions avec une Debian __jessie__ , maintenant nous sommes avec Ubuntu.

Comment analyser le problème , voici comment je procède :

        $ docker run -it ubuntu:16.04 bash
        root@6c3da44d101c:/# apt-get update && apt-get install python-pip
	The following additional packages will be installed:
	  binutils build-essential bzip2 ca-certificates cpp cpp-5 dpkg-dev fakeroot file g++ g++-5 gcc gcc-5 gcc-5-base ifupdown iproute2 isc-dhcp-client
	  isc-dhcp-common libalgorithm-diff-perl libalgorithm-diff-xs-perl libalgorithm-merge-perl libasan2 libatm1 libatomic1 libc-dev-bin libc6 libc6-dev libcc1-0
	  libcilkrts5 libdns-export162 libdpkg-perl libexpat1 libexpat1-dev libfakeroot libffi6 libfile-fcntllock-perl libgcc-5-dev libgdbm3 libgmp10 libgomp1
	  libisc-export160 libisl15 libitm1 liblsan0 libmagic1 libmnl0 libmpc3 libmpfr4 libmpx0 libperl5.22 libpython-all-dev libpython-dev libpython-stdlib
	  libpython2.7 libpython2.7-dev libpython2.7-minimal libpython2.7-stdlib libquadmath0 libsqlite3-0 libssl1.0.0 libstdc++-5-dev libstdc++6 libtsan0 libubsan0
	  libxtables11 linux-libc-dev make manpages manpages-dev mime-support netbase openssl patch perl perl-modules-5.22 python python-all python-all-dev
	  python-dev python-minimal python-pip-whl python-pkg-resources python-setuptools python-wheel python2.7 python2.7-dev python2.7-minimal rename xz-utils
	Suggested packages:
	  binutils-doc bzip2-doc cpp-doc gcc-5-locales debian-keyring g++-multilib g++-5-multilib gcc-5-doc libstdc++6-5-dbg gcc-multilib autoconf automake libtool
	  flex bison gdb gcc-doc gcc-5-multilib libgcc1-dbg libgomp1-dbg libitm1-dbg libatomic1-dbg libasan2-dbg liblsan0-dbg libtsan0-dbg libubsan0-dbg
	  libcilkrts5-dbg libmpx0-dbg libquadmath0-dbg ppp rdnssd iproute2-doc resolvconf avahi-autoipd isc-dhcp-client-ddns apparmor glibc-doc libstdc++-5-doc
	  make-doc man-browser ed diffutils-doc perl-doc libterm-readline-gnu-perl | libterm-readline-perl-perl python-doc python-tk python-setuptools-doc
	  python2.7-doc binfmt-support
	The following NEW packages will be installed:
	  binutils build-essential bzip2 ca-certificates cpp cpp-5 dpkg-dev fakeroot file g++ g++-5 gcc gcc-5 ifupdown iproute2 isc-dhcp-client isc-dhcp-common
	  libalgorithm-diff-perl libalgorithm-diff-xs-perl libalgorithm-merge-perl libasan2 libatm1 libatomic1 libc-dev-bin libc6-dev libcc1-0 libcilkrts5
	  libdns-export162 libdpkg-perl libexpat1 libexpat1-dev libfakeroot libffi6 libfile-fcntllock-perl libgcc-5-dev libgdbm3 libgmp10 libgomp1 libisc-export160
	  libisl15 libitm1 liblsan0 libmagic1 libmnl0 libmpc3 libmpfr4 libmpx0 libperl5.22 libpython-all-dev libpython-dev libpython-stdlib libpython2.7
	  libpython2.7-dev libpython2.7-minimal libpython2.7-stdlib libquadmath0 libsqlite3-0 libssl1.0.0 libstdc++-5-dev libtsan0 libubsan0 libxtables11
	  linux-libc-dev make manpages manpages-dev mime-support netbase openssl patch perl perl-modules-5.22 python python-all python-all-dev python-dev
	  python-minimal python-pip python-pip-whl python-pkg-resources python-setuptools python-wheel python2.7 python2.7-dev python2.7-minimal rename xz-utils
	The following packages will be upgraded:
	  gcc-5-base libc6 libstdc++6
	3 upgraded, 87 newly installed, 0 to remove and 25 not upgraded.
	Need to get 88.4 MB of archives.
	After this operation, 268 MB of additional disk space will be used.
	Do you want to continue? [Y/n] y
	 
        [... Isshhh c beaucoup de packages requis :P ...]

Je démarre un Ubuntu éphémère uniquement pour valider la procédure , ceci me permettra de réaliser l'analyse du problème en mode interactif. 

Recherche du package __j2cli__ 

        root@6c3da44d101c:/# pip search j2cli
        j2cli3 (0.0.7.post0)  - Command-line interface to Jinja2 for templating in shell scripts.
        j2cli (0.3.1-0)       - Command-line interface to Jinja2 for templating in shell scripts.

__Humm__ ça semble bon :-/ on va tenter de l'installer alors :

        root@6c3da44d101c:/# pip install j2cli
        Collecting j2cli
          Downloading j2cli-0.3.1_0-py2-none-any.whl
        Collecting jinja2>=2.7.2 (from j2cli)
          Downloading Jinja2-2.9.5-py2.py3-none-any.whl (340kB)
          100% |################################| 348kB 1.1MB/s
        Collecting MarkupSafe>=0.23 (from jinja2>=2.7.2->j2cli)
        Downloading MarkupSafe-0.23.tar.gz
        Building wheels for collected packages: MarkupSafe
        Running setup.py bdist_wheel for MarkupSafe ... done
        Stored in directory: /root/.cache/pip/wheels/a3/fa/dc/0198eed9ad95489b8a4f45d14dd5d2aee3f8984e46862c5748
        Successfully built MarkupSafe
        Installing collected packages: MarkupSafe, jinja2, j2cli
        Successfully installed MarkupSafe-0.23 j2cli-0.3.1-0 jinja2-2.9.5
        You are using pip version 8.1.1, however version 9.0.1 is available.
        You should consider upgrading via the 'pip install --upgrade pip' command.

Donc :

        $ docker build -t srvsmtp .

Aucun problème ... On va refaire un teste alors avec le __Dockerfile__ :

        Command "python setup.py egg_info" failed with error code 1 in /tmp/pip-build-cpjQyz/MarkupSafe/
        You are using pip version 8.1.1, however version 9.0.1 is available.
        You should consider upgrading via the 'pip install --upgrade pip' command.
        The command '/bin/sh -c apt-get update -qq &&     apt-get install -qq -y --no-install-recommends postfix         python-pip supervisor rsyslog &&     pip install j2cli' returned a non-zero code: 1

Pourquoi ? Si nous regardons une des différences entre la configuration dans le __Dockerfile__ et mon teste est que lors de l'installation dans le __Dockerfile__ il y a l'instruction **--no-install-recommends**. Résultat il manque des packages requis pour l'utilisation de **pip**. 

Bien entendu 2 options s'offre à nous :

* Supprimer le paramètre **--no-install-recommends** dans le __Dockerfile__ , résultat une image plus grosse , est-ce vraiment critique ?!?! À vous de voir.
* Ajuster les packages lors de l'installation afin de conserver l'option d'installation des packages requis uniquement.

Bon , comme la suppression du paramètre est assez simple , je vais prendre l'option, car l'important n'est pas la solution mais le processus pour y arrivé, sinon vous ne seriez pas là :D. 

Donc je quitte mon conteneur de teste , car pollué par trop de packages et en redémarre un nouveau et reprend :

        root@6c3da44d101c:/# exit
        ٩(◠◡◠)۶ $ docker run -it ubuntu:16.04 bash
        root@8f4caf46401e:/#  apt-get update && apt-get --no-install-recommends install python-pip
        The following additional packages will be installed:
          ca-certificates libexpat1 libffi6 libpython-stdlib libpython2.7-minimal libpython2.7-stdlib libsqlite3-0 libssl1.0.0 mime-support openssl python
          python-minimal python-pip-whl python2.7 python2.7-minimal
        Suggested packages:
          python-doc python-tk python2.7-doc binutils binfmt-support
        Recommended packages:
          file build-essential python-all-dev python-setuptools python-wheel
        The following NEW packages will be installed:
          ca-certificates libexpat1 libffi6 libpython-stdlib libpython2.7-minimal libpython2.7-stdlib libsqlite3-0 libssl1.0.0 mime-support openssl python
          python-minimal python-pip python-pip-whl python2.7 python2.7-minimal
        0 upgraded, 16 newly installed, 0 to remove and 28 not upgraded.
        Need to get 7450 kB of archives.
        After this operation, 24.9 MB of additional disk space will be used.

Pas mal moins de packages, bon maintenant nous allons être dans le détail pour le problème spécifique . Regardons le message d'erreur que nous avons avec le conteneur :

        Collecting MarkupSafe>=0.23 (from jinja2>=2.7.2->j2cli)
          Downloading MarkupSafe-0.23.tar.gz
        Complete output from command python setup.py egg_info:
          Traceback (most recent call last):
          File "<string>", line 1, in <module>
          ImportError: No module named setuptools

Si nous regardons , un des packages recommencés il y a **python-setuptools** , ceci correspond au message d'erreur que nous avons :D , installons le pour voir et testons à nouveau .


        root@8f4caf46401e:/# apt-get --no-install-recommends install python-setuptools
        Collecting j2cli
          Downloading j2cli-0.3.1_0-py2-none-any.whl
        Collecting jinja2>=2.7.2 (from j2cli)
          Downloading Jinja2-2.9.5-py2.py3-none-any.whl (340kB)
          100% |################################| 348kB 1.1MB/s
        Collecting MarkupSafe>=0.23 (from jinja2>=2.7.2->j2cli)
          Downloading MarkupSafe-0.23.tar.gz
          Building wheels for collected packages: MarkupSafe
          Running setup.py bdist_wheel for MarkupSafe ... error
          Complete output from command /usr/bin/python -u -c "import setuptools, tokenize;__file__='/tmp/pip-build-NleDVW/MarkupSafe/setup.py';exec(compile(getattr(tokenize, 'open', open)(__file__).read().replace('\r\n', '\n'), __file__, 'exec'))" bdist_wheel -d /tmp/tmp2aCAjppip-wheel- --python-tag cp27:
          usage: -c [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
          or: -c --help [cmd1 cmd2 ...]
          or: -c --help-commands
          or: -c cmd --help
          error: invalid command 'bdist_wheel'
          ----------------------------------------
          Failed building wheel for MarkupSafe
          Running setup.py clean for MarkupSafe
          Failed to build MarkupSafe
          Installing collected packages: MarkupSafe, jinja2, j2cli
          Running setup.py install for MarkupSafe ... done
          Successfully installed MarkupSafe-0.23 j2cli-0.3.1-0 jinja2-2.9.5

**COOL** encore une erreur mais PAS la même , si nous regardons encore le message il y a le mot __wheel__ de présent , il est aussi dans un des packages recommandés pour l'installation ajoutons le :D .

        root@8f4caf46401e:/# apt-get --no-install-recommends install python-wheel                                                                                     
        root@8f4caf46401e:/# pip install j2cli
        Requirement already satisfied (use --upgrade to upgrade): j2cli in /usr/local/lib/python2.7/dist-packages
        Requirement already satisfied (use --upgrade to upgrade): jinja2>=2.7.2 in /usr/local/lib/python2.7/dist-packages (from j2cli)
        Requirement already satisfied (use --upgrade to upgrade): MarkupSafe>=0.23 in /usr/local/lib/python2.7/dist-packages (from jinja2>=2.7.2->j2cli)
        You are using pip version 8.1.1, however version 9.0.1 is available.
        You should consider upgrading via the 'pip install --upgrade pip' command.
        root@8f4caf46401e:/# echo $?
        0

**Yeahhh** du premier coup :P, nous allons donc ajuster le fichier __Dockerfile__ , voici donc la nouvelle ligne avec la liste des packages :


        # Packages: update
        RUN apt-get update -qq && \
            apt-get install -qq -y --no-install-recommends postfix \
                    python-pip supervisor rsyslog python-wheel python-setuptools  && \
                    pip install j2cli


On reconstruit l'image :

        $ docker build -t srvsmtp .                                                                                                                          
        Sending build context to Docker daemon 6.656 kB
        Step 1 : FROM ubuntu:16.04
         ---> c73a085dc378
         Step 2 : MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>
         [ ... OUTPUT COUPÉ ...]

        Removing intermediate container ba87a471cb7a
        Step 5 : ADD bin/dfg.sh /usr/local/bin/
         ---> b842eee6ca8a
         Removing intermediate container 4631078aaad4
        Step 6 : ADD conf/supervisor-all.conf /etc/supervisor/conf.d/
         lstat conf/supervisor-all.conf: no such file or directory

Je suis sûr que vous pensez que je l'ai fait volontairement, mais même pas je vous jure ... En temps normale je le cache ça :P . Bon on va capitalisé sur le problème j'ai opté pour vous montrer tous, donc ça sera tous , le bon et le moins bon .

## <a name="setup_postfix_setup_conf" /> Mise en place des fichiers de configuration

Donc suite à l'erreur de mon oublie du fichier de __supervisor__ je vais le mettre dans le répertoire conf , voici le contenu , c'est le même que pour le __relayhost__ je ne prendrai pas le temps d'écrire.

        [supervisord]
        logfile = /var/log/supervisord.log
        logfile_backups = 0

        [program:rsyslogd]
        command = /usr/sbin/rsyslogd -n

        [program:postfix]
        command = /usr/local/bin/dfg.sh /var/spool/postfix/pid/master.pid /etc/init.d/postfix start
        startsecs = 3

Donc on reprend :D : 

        $ docker build -t srvsmtp .
        [... OUTPUT COUPÉ ...]
        Step 3 : ENV DEBIAN_FRONTEND noninteractive
         ---> Using cache
         ---> 7bb41adacabf
        Step 4 : RUN apt-get update -qq &&     apt-get install -qq -y --no-install-recommends postfix         python-pip supervisor rsyslog python-wheel python-setuptools  &&     pip install j2cli
         ---> Using cache
         ---> db7a6b374677
        Step 5 : ADD bin/dfg.sh /usr/local/bin/
         ---> Using cache
         ---> b842eee6ca8a
        [... OUTPUT COUPÉ ...]

Ce qui est super est que le temps pris pour l'installation n'est pas repris maintenant car __docker__ va utiliser le cache des couches (__layers__) déjà compilé. 

État de la situation nous avons un conteneur qui à l'ensemble des packages d'installer ainsi que la configuration minimal pour le démarrage du conteneur , il nous reste :

1. Mettre en place la configuration pour postfix , en __template__
2. Modifier le script **run.sh** afin qu'il traite notre fichier de configuration en __template__ et le dispose dans le bon répertoire
3. Ajuster les valeurs par défaut de notre image si besoin est !

Voici notre fichier de configuration en __template__  (**conf/postfix-main.j2**) : 

        smtpd_banner = $myhostname ESMTP $mail_name

        alias_database = hash:/etc/aliases
        alias_maps = hash:/etc/aliases

        # Si vous le désirez nous pourrions avoir ce paramètre en option
        home_mailbox = Maildir/

        smtpd_relay_restrictions = permit_mynetworks  defer_unauth_destination
        myhostname = $myorigin
        myorigin = {{ SMTP_HOSTNAME }}

        mydestination = {{ ACCEPT_DOMAIN }}
        mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 {{ PERMIT_NETWORK }}
        inet_interfaces = all
        inet_protocols = ipv4

        {% if (EXT_RELAY_HOST != "DIRECT") %}relayhost = {{ EXT_RELAYHOST }} {% endif %}

Nous allons donc l'ajouter dans le __Dockerfile__

        [...OUTPUT COUPÉ ...]
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/

        # Setup postfix conf
        ADD conf/postfix-main.j2 /root/

        # Runner
        ADD run.sh /root/run.sh
        [...OUTPUT COUPÉ...]

Comme vous pouvez le constater j'ai mis la configuration **après** la définition des packages, ceci principalement pour ne pas à avoir à les réinstaller et profiter du caches de __docker__.

Le fichier sera donc dans le répertoire **/root** , nous devons ajuster le fichier **run.sh** pour le traitement du fichier , voici le nouveau contenu :

        #! /usr/bin/env bash
        set -e # exit on error

        # Variables
        export EXT_RELAY_HOST=${EXT_RELAY_HOST:-"DIRECT"}
        export SMTP_HOSTNAME=${SMTP_HOSTNAME:-"relay.example.com"}
        export PERMIT_NETWORK=${PERMIT_NETWORK:-"192.168.0.0/16"}
        export ACCEPT_DOMAIN=${ACCEPT_DOMAIN:-"localhost $SMTP_HOSTNAME"}
                              
        echo $SMTP_HOSTNAME > /etc/mailname
             
        # Templates
        j2 /root/postfix-main.j2 > /etc/postfix/main.cf

        # Launch
        rm -f /var/spool/postfix/pid/*.pid
        exec /usr/bin/supervisord -n

Principale changement :

* Les variables  et les valeurs par défaut
* Le patch pour le fichier postfix de __template__

On reconstruit l'image :D :

        $ docker build -t srvsmtp . 
        [... OUTPUT COUPÉ ...]
         ---> b842eee6ca8a
         Step 6 : ADD conf/supervisor-all.conf /etc/supervisor/conf.d/
          ---> Using cache
          ---> 98fd86c1b2a2
         Step 7 : ADD conf/postfix-main.j2 /root/
          ---> e6bbe80dbe93
        [... OUTPUT COUPÉ ...]


Comme vous pouvez  le constater le système à utiliser le cache jusqu'à la première modification . **Woot** donc la compilation est un succès on passe à la phase de teste !!

## <a name="setup_postfix_setup_validation" /> Validation de l'image

Bon idéalement on pourrait faire un système de unit teste pour confirmer que tous fonctionne bien mais on est pas encore en mode "production" , on s'amuse plus qu'autre chose :D.

Donc nous allons démarrer un conteneur et valider manuellement , par la suite nous réaliserons un **docker-compose.yml** pour faciliter l'utilisation. J'ai définie des variables :

* __SMTP\_HOSTNAME=mailtraining.x3rus.com__
* __PERMIT\_NETWORK=172.17.0.0/16__
* __ACCEPT\_DOMAIN="mailtraining.x3rus.com toto.x3rus.com"__ 

        $ docker run -h mailtraining.x3rus.com -e SMTP_HOSTNAME=mailtraining.x3rus.com -e PERMIT_NETWORK=172.17.0.0/16 -e ACCEPT_DOMAIN="mailtraining.x3rus.com toto.x3rus.com" srvsmtp
        /usr/lib/python2.7/dist-packages/supervisor/options.py:297: UserWarning: Supervisord is running as root and it is searching for its configuration file in default locations (including its current working directory); you probably want to specify a "-c" argument specifying an absolute path to a configuration file for improved security.
          'Supervisord is running as root and it is searching '
          2017-01-31 13:10:13,071 CRIT Supervisor running as root (no user in config file)
          2017-01-31 13:10:13,071 WARN Included extra file "/etc/supervisor/conf.d/supervisor-all.conf" during parsing
          2017-01-31 13:10:13,090 INFO RPC interface 'supervisor' initialized
          2017-01-31 13:10:13,090 CRIT Server 'unix_http_server' running without any HTTP authentication checking
          2017-01-31 13:10:13,090 INFO supervisord started with pid 1
          2017-01-31 13:10:14,097 INFO spawned: 'postfix' with pid 11
          2017-01-31 13:10:14,100 INFO spawned: 'rsyslogd' with pid 12
          2017-01-31 13:10:15,456 INFO success: rsyslogd entered RUNNING state, process has stayed up for > than 1 seconds (startsecs)
          2017-01-31 13:10:17,459 INFO success: postfix entered RUNNING state, process has stayed up for > than 3 seconds (startsecs)

Prenons un autre terminal et validons l'ensemble :

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS               NAMES
        21b0aa433d27        srvsmtp             "/root/run.sh"      About a minute ago   Up About a minute   25/tcp              grave_jones
        $ docker exec -it grave_jones bash

        root@mailtraining:/# cat /etc/postfix/main.cf
        smtpd_banner = $myhostname ESMTP $mail_name

        alias_database = hash:/etc/aliases
        alias_maps = hash:/etc/aliases

        # Si vous le désirez nous pourrions avoir ce paramètre en option
        home_mailbox = Maildir/

        smtpd_relay_restrictions = permit_mynetworks  defer_unauth_destination
        myhostname = $myorigin
        myorigin = mailtraining.x3rus.com

        mydestination = mailtraining.x3rus.com toto.x3rus.com
        mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 172.17.0.0/16
        inet_interfaces = all
        inet_protocols = ipv4

        root@mailtraining:/# tail /var/log/mail.log
        Jan 31 13:10:14 mailtraining postfix[87]: Postfix is running with backwards-compatible default settings
        Jan 31 13:10:14 mailtraining postfix[87]: See http://www.postfix.org/COMPATIBILITY_README.html for details
        Jan 31 13:10:14 mailtraining postfix[87]: To disable backwards compatibility use "postconf compatibility_level=2" and "postfix reload"
        Jan 31 13:10:14 mailtraining postfix/master[132]: daemon started -- version 3.1.0, configuration /etc/postfix

Ça semble pas mal :D , on valide en transmettant un petit courriel à l'utilisateur __root__ !!
Je récupère l'IP du conteneur : 

        $ docker inspect grave_jones | grep IPAddress
            "SecondaryIPAddresses": null,
            "IPAddress": "172.17.0.2",
                "IPAddress": "172.17.0.2",

Un petit __telnet__ rapide :

        $ telnet 172.17.0.2 25
        Trying 172.17.0.2...
        Connected to 172.17.0.2.
        Escape character is '^]'.
        220 mailtraining.x3rus.com ESMTP Postfix
        ehlo toto
        250-mailtraining.x3rus.com
        250-PIPELINING
        250-SIZE 10240000
        250-VRFY
        250-ETRN
        250-ENHANCEDSTATUSCODES
        250-8BITMIME
        250 DSN
        mail from: toto@x3rus.com
        250 2.1.0 Ok
        rcpt to: root@mailtraining.x3rus.com
        250 2.1.5 Ok
        data
        354 End data with <CR><LF>.<CR><LF>
        un courriel
        .
        250 2.0.0 Ok: queued as 9A2B460758E
        quit
        221 2.0.0 Bye
        Connection closed by foreign host.

Visualisons les logs et confirmons que le répertoire **Maildir** fut créé .

        $ docker exec grave_jones tail /var/log/mail.log
        Jan 31 13:10:14 mailtraining postfix[87]: See http://www.postfix.org/COMPATIBILITY_README.html for details
        Jan 31 13:10:14 mailtraining postfix[87]: To disable backwards compatibility use "postconf compatibility_level=2" and "postfix reload"
        Jan 31 13:10:14 mailtraining postfix/master[132]: daemon started -- version 3.1.0, configuration /etc/postfix
        Jan 31 13:16:15 mailtraining postfix/smtpd[1589]: connect from unknown[172.17.0.1]
        Jan 31 13:16:36 mailtraining postfix/smtpd[1589]: 9A2B460758E: client=unknown[172.17.0.1]
        Jan 31 13:16:40 mailtraining postfix/cleanup[1676]: 9A2B460758E: message-id=<>
        Jan 31 13:16:40 mailtraining postfix/qmgr[135]: 9A2B460758E: from=<toto@x3rus.com>, size=198, nrcpt=1 (queue active)
        Jan 31 13:16:40 mailtraining postfix/local[1693]: 9A2B460758E: to=<root@mailtraining.x3rus.com>, relay=local, delay=18, delays=18/0.01/0/0.01, dsn=2.0.0, status=sent (delivered to maildir)
        Jan 31 13:16:40 mailtraining postfix/qmgr[135]: 9A2B460758E: removed
        Jan 31 13:16:42 mailtraining postfix/smtpd[1589]: disconnect from unknown[172.17.0.1] ehlo=1 mail=1 rcpt=1 data=1 quit=1 commands=5

        $ docker exec grave_jones ls -R /root/Maildir
        /root/Maildir:
        cur
        new
        tmp

        /root/Maildir/cur:

        /root/Maildir/new:
        1485868600.Vfe01Ie0699bM516582.mailtraining.x3rus.com

        /root/Maildir/tmp:

**SUPER** , l'image fonctionne bien pour la réception des courriels __yeahh__ félicitation !!

Bon avant de débuter la définition du __docker-compose__ prenons un peu de recule sur l'utilisation de l'image .

# <a name="workflow_conteneur_smtp" /> Définition de l'utilisation du conteneur postfix

Le gros défis de **docker** réside ici , faire l'image n'est pas très difficile , par contre nous nous retrouvons maintenant avec un conteneur qui peu être éphémère .Telle que mentionné plus tôt actuellement mon serveur de courriel est un **pet conteneur** il n'y a pas de honte , mais essayons de nous améliorer c'est l'objectif , sinon on ne progresse pas. 
Dans cette objectif nous allons essayer de s'assurer que le conteneur __smtp__ puisse être changé à tous moment.

État de l'image et de son utilisation comme conteneur initialisé :

* Le système accepte les courriels pour le / les domaines fournit en paramètre 
* Le système démarre :P 
* Le système stocke le(s) courriel(s) dans le répertoire personnel de l'utilisateur 
* Le système n'a qu'un seul utilisateur disponible : **root*** et les autres utilisateurs systèmes :-(
* La définition des alias sont statique dans le conteneur (comme les utilisateurs)
* Les courriels sont dans le conteneur :-/ (__issshh__ :P )

Bon regardons les "problèmes" , pour la question des courriels qui sont dans le conteneur , quelle est la solution ? 

__Yep__ la création d'un volume qui réalisera l'association du répertoire **/home** dans le conteneur avec un répertoire sur le __docker host__. COOL problème réglé.


La définition des utilisateurs maintenant , ici ça se complique un peu , en fait faut prendre la bonne approche, mais avant rappelons nous pourquoi nous avons besoins d'avoir la liste des utilisateurs  :

* **Validation des adresses courriels** : Comme nous avions pu le voir postfix est en mesure de valider que l'adresse courriel existe avant d'accepter le courriel. Par défaut il utilise la liste des utilisateurs système.
* **Livraison dans le répertoire personnel de l'utilisateur** : Lors de la livraison par postfix , le système va créer les fichiers avec le __UID__ et __GID__ de l'utilisateur que ce soit en __mbox__ ou __maildr__. Bien entendu en __maildir___ en plus il y a la livraison dans le répertoire personnel de l'utilisateur.
* **PAS Authentification** : Il n'y aura pas d'authentification dans ce conteneur , car l'authentification de récupération de courriel sera réalisé dans le conteneur __imap__.

Donc voici quelques options 


1. Passez en **paramètre une liste d'utilisateur** pour réaliser la création lors de l'initialisation du conteneur. Pour ce faire nous devrions modifier le script **run.sh** afin de faire la création des utilisateurs ainsi que le répertoire personnel. Point à prendre en considération :
    * Les variables d'environnement ne sont interpréter QUE et UNIQUEMENT lors de l'initialisation initiale du conteneur (nominatif) en d'autre mot , si la liste des utilisateurs est : Robert, Peter et Bonny . Que vous désirez rajouter Bob , vous ne pouvez pas simplement redémarrer le conteneur avec la nouvelle valeur à la variable, il vous faudra détruire le conteneur et en créer un nouveau . Bien entendu même processus lors de la suppression d'un utilisateur !
    * **Contre** : votre premier reflex est probablement , __woww__ c'est vraiment pas une bonne options, commençons par vous conforter dans votre idée :P
        * La suppression du conteneur est "risqué" si ce dernier est mal configurer et surtout si vous réalisez des modifications directement dans le conteneur. Par exemple une personne ajoute manuellement un utilisateur dans le conteneur , lors de la recréation il sera perdu !
        * S'il y a eu une modification dans l'image de références, lors de la recréation il est possible que le service ne fonctionne plus du tous ! 
        * Il peut être difficile sans système autour de déléguer à un __help desk__ l'ajout d'un utilisateur, car il y a l'implication de redémarrage de la production.
        * Mais surtout ceci nous oblige à changer nos habitudes de fonctionnement.
    * **Pour** : Bon maintenant que vous êtes bien conforté dans l'idée que c'est une mauvaise idée, voyons le positif de cette solution.
        * Comme nous sommes obligé de recréer le conteneur, ceci sera une occasion de nous forcer à mettre à jour le conteneur. J'aimerai faire une parenthèse sur le cycle de mise à jour. Mettre en lumière une réalité avec __Docker__ . Regardons le schéma suivant :
        
            ![docker-update_cycle.png](./imgs/docker-update_cycle.png)
        
            Lors de la création de l'image du conteneur les versions sont figé dans le temps, résultat s'il y a une faille de sécurité découvert nous la trainerons dans le temps au lieu de la fixer ! Le fait que nous devons détruire le conteneur nous obligera à réaliser une mise à jour des packages. Ceci est particulièrement important pour les services exposés sur Internet.
        * L'autre point positif de cette opération est que nous avons un système éphémère, qui est régulièrement généré résultat nous avons un niveau de confiance dans le système car régulièrement testé lors de l'ajout d'un utilisateur. S'il y a un problème on le recréer , on pourrait même y voir un système qui augmente le nombre de serveur postfix s'il y a une monté en charge des courriels et qui modifie les DNS afin d'ajouter la définition MX pour la réception . Le système est donc autonome dans ça définition.
2. Avoir un fichier local des utilisateurs qui est à l'extérieur du conteneur !
    * Regardons d'un œil froid, où est définie les utilisateurs ? Dans le fichier **/etc/passwd** , le fichier est présent par défaut sur le système mais pouvons nous le surdéfinir. En fait pas de problème , nous avons le système de volume dans docker qui nous permet d'assigner un répertoire ou un fichier de l'hôte docker dans le conteneur !! Nous n'avons pas besoin du fichier **/etc/shadow** car l'utilisateur n'établis pas de connexion sur ce conteneur.
    * **Contre** : Bon je présume que vous êtes pour mais je peux pas changé le pour / contre d'une section à l'autre trop tard :P
        * La problématique avec cette solution est la définition du fichier **/etc/passwd** qui est sur 1 hôte docker , donc s'il y a un problème avec l'hôte votre conteneur en est dépendant. Vous n'êtes pas en mesure de redémarrer le conteneur sur un autre hôtes de manière transparente. Bien entendu il y a la question des courriels reçu __anyway__ qui seront non disponible. Mais attention , le conteneur postfix ne stock pas obligatoirement le courriel ce dernier reçoit et livre les courriels , il peut aussi agir comme __buffer__ si le service dovecot n'est pas disponible.
        * L'ajout d'un utilisateur se fera sur la machine hôte , il faudra donc éventuellement conserver le fichier dans un contrôleur de révision (git, svn) pour voir les changements et conserver une copie à l'extérieur.
        * Si nous éditons le fichier manuellement , il faudra faire attention de ne pas avoir les même UID , voir les mêmes nom avec un répertoire personnel différent.
    * **Pour** : L'utilisation d'un fichier **/etc/passwd** local , sans être obligé de recréer le conteneur nous rassure nous avons presque le même comportement qu'une VM.
        * Change peu nos habitudes donc c'est réconfortant :P
        * Le fichier **/etc/passwd** pourrait être utilisé par un autre conteneur par exemple __dovecot__ pour la liste des utilisateurs ;-)
        * Pas besoin de porter une action sur le conteneur lors de l'ajout d'un utilisateur.
3. Utilisation d'un système de gestion de configuration telle que **puppet** ou **ansible** .
    * Une autre possibilité serait d'avoir un système de gestion de configuration telle que __puppet__ ou __ansible__ externe au conteneur qui communiquerai avec un serveur contenant la définition des utilisateurs qui doivent être présent dans le conteneur. Lors de l'initialisation du conteneur une première synchronisation de la configuration avec le serveur serait réalisé récupérant la liste des utilisateurs . Par la suite un processus (__agent__) synchroniserai la configuration de manière régulière. Selon la solution utilisé, la configuration pourrait être poussée par le serveur de configuration.
    * **Contre** : Le problème de cette solution est qu'elle suit moins le principe de __docker__ et d'une utilisation indépendante de l'infrastructure
        * Le principe de l'utilisation des conteneurs est la possibilité d'être utilisé sur un portable, dans un __datacenter__, dans le __cloud__, ... Ceci indépendamment de l'infrastructure en place. La création d'une dépendance avec une infrastructure externe **serveur de configuration** va à l'encontre du principe. 
        * Généralement les solutions de gestion de configuration utilise le nom de la machine pour l'identifier (__hostname__) , ceci risque d'être un problème si nous désirons avoir un déploiement dynamique en cas de monté en charge de la réception de courriel. En d'autre mot il risque d'être difficile de dynamiquement faire le déploiement dynamiquement mais surtout automatiquement sans action humaine.
        * Si nous continuons avec le principe de docker , si vous désirez réellement mettre en place cette solution le processus __puppet__ ou __ansible__ devrez être exécuté sur l'hôte docker et non dans le conteneur afin de ne pas pollué le conteneur avec une application non essentiel .
    * **Pour** : Uniformité de la configuration et conservation à l'externe
        * Bien entendu , la solution nous permet d'avoir une référence de la configuration en dehors du conteneur nous permettant de le recréer avec la même définition . Nous limitons le risque de perte d'information possible comparativement en aillant un fichier local sur le docker hôte.
        * Si vous avez un parc significatif utilisant déjà une solution de gestion de configuration l'intégration est facile et ne demande pas de monté en compétence .
        * Uniformité de la configuration entre les conteneurs, si les conteneurs utilisent le même __playbook__ (__ansible__) ou le même module (__puppet__) le conteneur __smtp__ et __imap__ auront la même liste des utilisateurs.
4. Utilisation d'une source externe de définition des utilisateurs **LDAP**, **NIS**, **SQL**.
    * Bon l'utilisation d'une source externe telle que __mysql__ sera couverte par la source, est-ce que l'on va la __dockerisé__ , honnêtement je le sais pas encore :-) . J'aimerai souligner un propos mentionné plus tôt , l'indépendance des conteneurs , il faut idéalement gardé le principe que le système sera utilisé sur un __laptop__ dans le train pour travailler ! L'utilisation en soit de **LDAP** , **SQL** n'est pas un problème de fond car nous allons l'avoir pour augmenté les fonctionnalités possible des courriels ( **contacts** , **calendrier**, ... ) . Donc si cette approche est préconisé il faudrait livré un conteneur __SQL__ ou __LDAP__ avec le conteneur __smtp__ et __imap__. Ceci étant rappeler reprenons le **Contre/Pour** 
    * **Contre** : 
        * Dans le cadre du service postfix, étant donnée qu'il ne réalise que de la validation de courriel et la récupération des __UID__ il y a peu de plus value d'avoir un système __LDAP__ en particulier. Les données changes si ce service est déjà mis en place pour l'augmentation de fonctionnalité pour l'utilisateur.
        * Si la configuration __LDAP__ se base sur un serveur d'infrastructure interne uniquement , ceci ne suit pas le principe de __docker__ permettant le déploiement n'importe où en s'affranchissant de l'infrastructure .
        * De mon point de vue si vous avez déjà une base de donnée __SQL__ et que vous ajoutez un serveur __LDAP__ pour la gestion des utilisateurs ceci ajoute un système qui peut avoir des problèmes. La gestion de la prise de backup , afin d'être en mesure de remettre en fonction en cas de problème du docker hôte.
    * **Pour** : oui oui vous pouvez dire que je suis un peu trop rigide sur le principe de docker , mais mon objectif et de générer une réflexion toute les solution sont possible l'important est de faire un choix éclairé. Puis surtout être en mesure de constater son erreur si on a fait le mauvais choix ça arrive :D.
        * Si vous déjà l'ensemble de vos utilisateur dans un __ldap__ (exemple AD), ceci vous facilite grandement la vie et oui c'est vraie, dans ce cas peut-être faire une copie synchronisé afin d'avoir un conteneur indépendant pour le gars dans le train :P.
        * Mise à jour "instantané" des utilisateurs grâce à la solution AD
        * Avoir des utilisateurs locaux et une sources externe **optionel** afin d'avoir l'autonomie du conteneur et la pluralité des utilisateurs corporatif. (je suis mitigé , car je ne vois pas de solution dans une production __cloud__ mais bon ça reste une possibilité)

Bon l'ensemble des suggestions mentionnés ci-dessus est général peut importe le système , l'idée est d'essayer de trouve une solution optimal voici en gros les critères que je désires :

* Ne pas avoir de gestion des utilisateurs manuel sur chaque conteneur , ajout ou suppression .
* Permettre le déploiement des conteneurs "simplement" peut importe l'environnement (portable, __datacenter__, ...).
* Je veux avoir une limitation des adresses courriels dans le systèmes postfix .

Reprenons le diagramme simplifié de l'architecture postfix :

![POSTFIX_Envoi_Externe.png](./imgs/POSTFIX_Envoi_Externe.png) 

J'aimerai porter votre attention sur les autres possibiliter soit :

* ltmp
* virtual
* pipe

En d'autre mot il y d'autre méthode pour transmettre les courriels vers un autre système , en fait principalement le protocol [lmtp](https://fr.wikipedia.org/wiki/Local_Mail_Transfer_Protocol) soit **Local Mail Transfer Protocol** . ET ça tombe bien car **dovecot** supporte ce protocole [dovecot et ltmp](http://wiki2.dovecot.org/HowTo/PostfixDovecotLMTP) , elle est pas belle la vie :P.

Avec cette solution nous aurons , les utilisateurs uniquement définie dans le conteneur __dovecot__ , __postfix__ sera en mesure de faire une validation via le protocole __LMTP__ telle que spécifier dans la documentation  [dovecot et ltmp](http://wiki2.dovecot.org/HowTo/PostfixDovecotLMTP). Comme nous aurons qu'une source d'utilisateur et pas de définition dans un serveur d'infrastructure de type __LDAP__ nous pourrons le déployé peu importe l'environnement. 

**COOL** , bon le petit malin qui se dit __ouin__ mais avec cette solution tu n'as rien réglé car comment on va définir les utilisateurs dans le conteneur __dovecot__ , effectivement il faudra prendre tous de même une des options plus haut. Bien entendu quand nous serons rendu avec un système complet avec une base de données **requise** pour plus de fonctionnalité nous n'aurons plus le choix. 
Mais 1 problème à la fois :D.

# <a name="Postfix_with_lmtp" /> Configuration postfix avec LTMP 

Telle que mentionné plus tôt nous allons utiliser postfix uniquement comme **MTA** (**Mail Transport Agent**) et laisser la gestion de la livraison **MDA** (**Mail Delivery Agent**) à dovecot via le protocole __lmtp__. Le gros avantage d'utiliser __lmtp__ est que nous seront donc en mesure de changer dovecot par une autre solution, il faudra simplement que cette solution supporte le protocole ouvert __lmtp__.

Si nous regardons la documentation [dovecot et ltmp](http://wiki2.dovecot.org/HowTo/PostfixDovecotLMTP) vous constaterez que le système utilise un __socket__ Unix pour la communication. Quand nous avons une configuration d'une machine réalisant l'ensemble de l'opération y a pas de problème, mais dans notre cas nous utiliseront le port __tcp__ . Une vraie communication réseau nous offrant plus de possibilité surtout avec les conteneurs. Pour voir l'ensemble des configurations disponible voir la documentation [postfix lmtp](http://linuxcommand.org/man_pages/lmtp8.html). 

Comme nous pouvons le voir dans le diagramme du traitement des courriels par postfix : 

![POSTFIX_Reception_UNIX.png](./imgs/POSTFIX_Reception_UNIX.png)

Par défaut postfix utilise le service **local** pour livrer les courriels nous allons modifier cette configuration, en changeant la valeur de [mailbox_transport](http://www.postfix.org/postconf.5.html#mailbox_transport). Voici ce que nous allons définir :

        mailbox_transport = lmtp:dovecot-lmtp:24

Juste par clarification :

* **lmtp** : le protocole 
* **dovecot-lmtp** : le __hostname__ du serveur de destination , si nous étions dans une logique avec des machines virtuel j'aurais définie un __hostname__ valide , comme nous sommes avec docker ceci sera réalisé avec un __link__ de conteneur nous y reviendrons.
* **24** : Le port , bon la selon wikipedia ils disent qu'il n'y a pas de port standard, mais selon la documentation de __lmtp__ de postfix il mentionne que le port par défaut est 24 ... Donc si je suis pour choisir n'importe quoi autant en prendre un presque standard :D. 

Bon la pour ceux qui se disent,  aille __woww__ __pépito__  puis la validation des courriels tu en fais quoi , la liste des adresses et alias . Bon point mais pas de panique :D voici la solution que nous allons mettre en place :

        Dynamic address verification with LMTP

        With Dovecot 2.0 you can also use LMTP and the Postfix setting "reject_unverified_recipient" for dynamic address verification. It's really nice because Postfix doesn't need to query an external datasource (MySQL, LDAP...). Postfix maintain a local database with existing/non existing addresses (you can configure how long positive/negative results should be cached).

        To use LMTP and dynamic address verification you must first get Dovecot working. Then you can configure Postfix to use LMTP and set "reject_unverified_recipient" in the smtpd_recipient_restrictions.

        On every incoming email Postfix will probe if the recipient address exists. You will see similar entries in your logfile:

                Recipient address rejected: undeliverable address: host tux.example.com[private/dovecot-lmtp] said: 550 5.1.1 < tzknvtr@example.com > User doesn't exist: tzknvtr@example.com (in reply to RCPT TO command); from=< cnrilrgfclra@spammer.org > to=< tzknvtr@example.com >

        If the recipient address exists (status=deliverable) Postfix accepts the mail. 

On y reviens ce sera une amélioration , avant de mettre cette limitation on va confirmer que tous fonctionne , sinon c'est gênant pour diagnostique le problème :D.

Voici donc le résultat de notre configuration postfix en __template__ :

        $ cat conf/postfix-main.j2
        smtpd_banner = $myhostname ESMTP $mail_name

        alias_database = hash:/etc/aliases
        alias_maps = hash:/etc/aliases

        # Si vous le désirez nous pourrions avoir ce paramètre en option
        home_mailbox = Maildir/

        smtpd_relay_restrictions = permit_mynetworks  defer_unauth_destination
        myhostname = $myorigin
        myorigin = {{ SMTP_HOSTNAME }}

        mydestination = {{ ACCEPT_DOMAIN }}
        mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 {{ PERMIT_NETWORK }}
        inet_interfaces = all
        inet_protocols = ipv4

        # Configuration pour l'envoie vers lmtp (aka dovecot)
        mailbox_transport = lmtp:dovecot-lmtp:24

        {% if (EXT_RELAY_HOST != "DIRECT") %}relayhost = {{ EXT_RELAYHOST }} {% endif %}


Oublié pas de reconstruire votre image :

        $ docker build -t srvsmtp .

Le problème à ce stade est que la validation de la configuration est "difficile", car nous avons besoin du conteneur dovecot pour valider l'ensemble , je pense donc que c'est le bon moment pour créer l'image du second conteneur.

# <a name="setup_dovecot" /> Création de l'image IMAP / LMTP (dovecot)

Juste pour être sûr que l'on s'entend sur le besoin du conteneur :

* **imap** : Service __imap__ pour que les utilisateurs consultent leurs courriels
* **lmtp** : Service __lmtp__ pour que le transfert des courriels entre postfix et dovecot
* **maildir** : Nous désirons que les fichiers de courriels soit individuel par communication 

Nous allons reprendre bêtement les étapes vue dans la formation pour faire la création du __Dockerfile__ :

1. Installation des packages pour dovecot : imap et lmtp
2. Mise en place d'un fichier de configuration en __template__ [Jinja2](http://jinja.pocoo.org/docs/2.9/)
3. Script de démarrage de dovecot

Pour rappel la structure :

        $ ls -R srvMailWithImap/
        srvMailWithImap/:
        imap  smtp

        srvMailWithImap/imap/:
        bin  conf  Dockerfile  run.sh

        srvMailWithImap/imap/bin:
        dfg.sh

        srvMailWithImap/imap/conf:
        supervisor-all.conf

        srvMailWithImap/smtp:
        bin  Dockerfile  run.sh

        srvMailWithImap/smtp/bin:
        dfg.sh

Nous allons nous attaquer à la partie __imap__ , avec le recule j'aurais dû aussi mettre le mot __lmtp__, mais je savais pas au début que nous allions avoir ce service :P ( oui oui la formation est vraiment rédigé et réfléchie au fur et à mesure :D **free style** ).

Faut ce lancer donc un premier jet du fichier __Dockerfile__ on le corrigera  au fur et à mesure :D. :

        # Using debian
        # Start Exemple:
        # ou can add -p 25:25 for LAN access
        FROM ubuntu:16.04
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Packages: update
        RUN apt-get update -qq && \
            apt-get install -qq -y --no-install-recommends dovecot-imap dovecot-lmtp \
                    python-pip supervisor rsyslog python-wheel python-setuptools  && \
                    pip install j2cli

        # Configure: supervisor
        ADD bin/dfg.sh /usr/local/bin/
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/

        # Runner
        ADD run.sh /root/run.sh
        RUN chmod +x /root/run.sh

        # Declare
        EXPOSE 143 993 24

        CMD ["/root/run.sh"]

* Nous débutons avec l'image **Ubuntu:16.04** comme nous avons utilisé cette distribution depuis le début.
* Installation des packages pour dovecot et __supervisor__ ainsi que le système __rsyslog__ pour les logs.
* Nous installons aussi __j2cli__ , toujours dans l'optique d'utiliser le système __jinja2__ comme __template__ pour les fichiers de configuration.
* Installation des fichiers de configuration pour __supervisor__ , j'ai simplement repris ceux déjà présenter lors de la présentation de la __dockerisation__ du serveur de relais.

L'ensemble des fichiers sont disponible sur [github](https://github.com/x3rus/training/tree/master/serveur_de_courriels/dockers/srvMailWithImap/smtp).

J'ai fait quelque modification du fichier __supervisor-all.conf__ ET __run.sh__ afin que ceci soit adapté à la configuration de dovecot , pour visualiser les changement un petit __diff__ ou __vimdiff__ entre celui de postfix et dovecot vous fournira l'ensemble des données 

        $ vimdiff smtp/conf/supervisor-all.conf  imap/conf/supervisor-all.conf 

On se lance dans la compilation :D de l'image . 

## <a name="setup_dovecot_install_pkg" /> Installation des packages dans l'image

Bon j'ai encore le même problème de nom de package ... Donc je vais refaire l'opération , comme avec postfix en démarrant un conteneur Ubuntu 16:04  pour faire l'analyse et trouver le bon nom de package

        Step 4 : RUN apt-get update -qq &&     apt-get install -qq -y --no-install-recommends dovecot-imap dovecot-lmtp         python-pip supervisor rsyslog python-wheel python-setuptools  &&     pip install j2cli
         ---> Running in 3e58129c72bc
         E: Unable to locate package dovecot-imap
         E: Unable to locate package dovecot-lmtp

Résultat fallait ajouter un D à la fin :P  :

         apt-get install -qq -y --no-install-recommends dovecot-imapd dovecot-lmtpd \

Bon je montre le processus pourquoi ?  Juste pour vous démontrer que c'est pas parce que ça fait 15 ans que t'es sous GNU/Linux que ça marche du premier coup :P en fait vraiment pas , mes 15 ans d'expérience me donne juste plus d'outils pour trouver le correctif rapidement. :P

Suite à la modification la compilation a bien fonctionné :

        $ docker build -t srvimap .
        [ ... OUTPUT COUPÉ ... ]
        Step 10 : CMD /root/run.sh
         ---> Running in 735c2152fd8c
         ---> 6547ceb2a3f1
        Removing intermediate container 735c2152fd8c
        Successfully built 6547ceb2a3f1

## <a name="setup_dovecot_setup_conf" /> Mise en place des fichiers de configuration avec la méthode (docker diff :D)

Telle que mentionné au début de la formation, vous avez l'air motivé pour l'utilisation de **docker**, donc on creuse plus loin et surtout on voit des méthodes de travail disponible. Je suis tous de même nouveau dans docker , bon en même temps ça fait pas 10 ans que ça existe, je ne sais pas la position des puristes sur ce qui suit , mais moi j'aime bien . 

Bon lors de la configuration de postfix c'était 1 fichier de configuration et nous étions , en tout cas moi :P , très confortable avec postfix . Dans le cadre de dovecot nous avons 2 services à mettre en place et la structure des fichiers de configurations est très divisé. Nous allons voir maintenant un autre technique pour faire de l'analyse de mise en place pour nous aider pour le conteneur final.

Donc nous avons l'image de base avec les packages et le démarrage de dovecot , on va initialiser le conteneur , pour le moment nous n'avons pas de variables ceci viendra par la suite :

        $ docker images | head                                                                                                                               
        REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
        srvimap                       latest              6547ceb2a3f1        23 hours ago        217.2 MB

        $ docker run srvimap
        /usr/lib/python2.7/dist-packages/supervisor/options.py:297: UserWarning: Supervisord is running as root and it is searching for its configuration file in default locations (including its current working directory); you probably want to specify a "-c" argument specifying an absolute path to a configuration file for improved security.
          'Supervisord is running as root and it is searching '
        2017-02-08 13:13:01,165 CRIT Supervisor running as root (no user in config file)
        2017-02-08 13:13:01,165 WARN Included extra file "/etc/supervisor/conf.d/supervisor-all.conf" during parsing
        2017-02-08 13:13:01,180 INFO RPC interface 'supervisor' initialized
        2017-02-08 13:13:01,181 CRIT Server 'unix_http_server' running without any HTTP authentication checking
        2017-02-08 13:13:01,181 INFO supervisord started with pid 1
        2017-02-08 13:13:02,188 INFO spawned: 'dovecot' with pid 10
        2017-02-08 13:13:02,199 INFO spawned: 'rsyslogd' with pid 11
        2017-02-08 13:13:03,261 INFO success: rsyslogd entered RUNNING state, process has stayed up for > than 1 seconds (startsecs)
        2017-02-08 13:13:05,263 INFO success: dovecot entered RUNNING state, process has stayed up for > than 3 seconds (startsecs)

Comme vous pouvez le constater je n'ai pas nommé le conteneur pour le moment je cherche uniquement à avoir un environnement volatile pour faire des testes.

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS               NAMES
        9c93ab3c3243        srvimap             "/root/run.sh"      About a minute ago   Up About a minute   25/tcp              sick_brahmagupta

Bon on voit déjà une erreur :P , le Port **25/tcp** , je vais corriger mon **serveur_de_courriels/dockers/srvMailWithImap/imap/Dockerfile** :

        # Declare
        EXPOSE 143 24

On reconstruira l'image plus tard pas critique à ce stade , maintenant je vais établir une connexion dans le conteneur volatile :

        $ docker exec -it sick_brahmagupta bash
        root@9c93ab3c3243:/#

Comme je vais travailler dans le conteneur je vais installer **vim** dans le conteneur volatile , je ne vais **pas** l'ajouter dans le __Dockerfile__ , donc lors de la suppression du conteneur ce ne sera pas présent.


### <a name="setup_dovecot_setup_imap_conf" /> Validation de la configuration imap 

Visualisation du fichier de configuration :

         root@9c93ab3c3243:/etc/dovecot/# cat dovecot.conf | grep -v "^#" | grep -v ^$
         !include_try /usr/share/dovecot/protocols.d/*.protocol
         dict {
           #quota = mysql:/etc/dovecot/dovecot-dict-sql.conf.ext
           #expire = sqlite:/etc/dovecot/dovecot-dict-sql.conf.ext
         }
         !include conf.d/*.conf
         !include_try local.conf

Si nous regardons dans le répertoire **/usr/share/dovecot/protocols.d/**, nous voyons bien le fichier pour __imap__ : 

        root@9c93ab3c3243:/etc/dovecot# ls /usr/share/dovecot/protocols.d/*.protocol
        /usr/share/dovecot/protocols.d/imapd.protocol  /usr/share/dovecot/protocols.d/lmtpd.protocol

Et le contenu spécifie bien l'activation du protocole __imap__

        root@9c93ab3c3243:/etc/dovecot# cat /usr/share/dovecot/protocols.d/imapd.protocol
        protocols = $protocols imap

        root@9c93ab3c3243:/etc/dovecot/conf.d# cat /etc/dovecot/conf.d/20-imap.conf  | grep -v ^# | grep -v ^$
        protocol imap {
          # Space separated list of plugins to load (default is global mail_plugins).
          #mail_plugins = $mail_plugins
          # Maximum number of IMAP connections allowed for a user from each IP address.
          # NOTE: The username is compared case-sensitively.
          #mail_max_userip_connections = 10
        }

Tous semble bon on peut valider avec la commande **ss** ou **netstat** , mais faut installer un package :P 

        root@9c93ab3c3243:/etc/dovecot# apt-get install iproute2
        root@9c93ab3c3243:/etc/dovecot# ss -lntp
        State      Recv-Q Send-Q                                  Local Address:Port                                                 Peer Address:Port
        LISTEN     0      100                                                 *:143                                                             *:*
        users:(("dovecot",pid=22,fd=34))
        LISTEN     0      100                                                :::143                                                            :::*
        users:(("dovecot",pid=22,fd=35))

Le __imap__ semble, convenable du moins pour ce que l'on a vue :D.

### <a name="setup_dovecot_setup_lmtp_conf" /> Validation de la configuration lmtp

Validons la configuration comme pour __imap__

         root@9c93ab3c3243:/etc/dovecot/# cat dovecot.conf | grep -v "^#" | grep -v ^$
         !include_try /usr/share/dovecot/protocols.d/*.protocol
         dict {
           #quota = mysql:/etc/dovecot/dovecot-dict-sql.conf.ext
           #expire = sqlite:/etc/dovecot/dovecot-dict-sql.conf.ext
         }
         !include conf.d/*.conf
         !include_try local.conf

Si nous regardons dans le répertoire **/usr/share/dovecot/protocols.d/**, nous voyons bien le fichier pour __ltmp__: 

        root@9c93ab3c3243:/etc/dovecot# ls /usr/share/dovecot/protocols.d/*.protocol
        /usr/share/dovecot/protocols.d/imapd.protocol  /usr/share/dovecot/protocols.d/lmtpd.protocol

Et le contenu spécifie bien l'activation du protocole __lmtp__

        root@9c93ab3c3243:/etc/dovecot# cat /usr/share/dovecot/protocols.d/lmtpd.protocol
        protocols = $protocols lmtp

        root@9c93ab3c3243:/etc/dovecot/conf.d# cat 20-lmtp.conf  | grep -v ^# | grep -v ^$
        protocol lmtp {
          # Space separated list of plugins to load (default is global mail_plugins).
          #mail_plugins = $mail_plugins
        }

Bon comme on a pas vu le détail de la configuration dans passé dans le doute il y a une définition donc ça doit être ok :P ... 

Tous semble bon on peut valider avec la commande **ss** ou **netstat** , mais faut installer un package :P 

        root@9c93ab3c3243:/etc/dovecot# ss -lntp
        State      Recv-Q Send-Q                                  Local Address:Port                                                 Peer Address:Port
        LISTEN     0      100                                                 *:143                                                             *:*
        users:(("dovecot",pid=22,fd=34))
        LISTEN     0      100                                                :::143                                                            :::*
        users:(("dovecot",pid=22,fd=35))

**OUPSSss** : le port 24 n'est **PAS** ouvert , ça va être compliquer pour le passage via le réseau des communications entre le postfix et dovecot, reprenons le site de configuration comme point de référence : [http://wiki.dovecot.org/LMTP](http://wiki.dovecot.org/LMTP).

Donc nous allons la définition du service de __lmtp__ :

        root@9c93ab3c3243:/etc/dovecot# grep "service lmtp" -R *
        conf.d/10-master.conf:service lmtp {

Bon __ok ok__, je me rappeler plus du nom du fichier :P , mais **grep** a une bien meilleur mémoire :P .

Voici la configuration présente :

        service lmtp {
          unix_listener lmtp {
              #mode = 0666
            }

            # Create inet listener only if you can't use the above UNIX socket
            #inet_listener lmtp {
            # Avoid making LMTP visible for the entire internet
            #address =
            #port = 
            #}
        }

Ceci indique de ne pas utiliser le protocole réseau mais un __socket__ sur la machine qui permet de simulé via un fichier la communication réseau, bien entendu 90% du temps quand les services sont sur la même machine s'est très bien !! L'avantage est qu'il n'y a pas de port d'ouvert sur le réseau , alors que ce n'est pas pertinent. Pour notre cas par contre nous devons changer cette configuration.

        service lmtp {
          unix_listener lmtp {
              #mode = 0666
          }

          inet_listener lmtp {
            address = 0.0.0.0
            port = 24
          }

          # Create inet listener only if you can't use the above UNIX socket
          #inet_listener lmtp {
          # Avoid making LMTP visible for the entire internet
          #address =
          #port = 
          #}
        }

Je redémarre le service et valide avec **ss** 

        root@9c93ab3c3243:/etc/dovecot# /etc/init.d/dovecot restart
        root@9c93ab3c3243:/etc/dovecot# ss -lntp                   
        State      Recv-Q Send-Q                                  Local Address:Port                                                 Peer Address:Port
        LISTEN     0      100                                                 *:143                                                             *:*                   users:(("dovecot",pid=7509,fd=35))
        LISTEN     0      100                                                 *:24                                                              *:*                   users:(("dovecot",pid=7509,fd=25))
        LISTEN     0      100                                                :::143                                                            :::*                   users:(("dovecot",pid=7509,fd=36))

Bon ça semble bon , on validera quand postfix va transmettre ses courriel :D 

### <a name="setup_dovecot_setup_maildir_conf" /> Mise en place de la configuration maildir

Dans les requis nous avions aussi la mise en place du système __Maildir__ au lieu de __mailbox__ c'est partie ...

Pour rappel nous devons modifier l'entrée **mail\_location** :

        $ grep mail_location /etc/dovecot/conf.d/*
        mail_location = mbox:~/mail:INBOX=/var/mail/%u

La nouvelle valeur :

        mail_location = maildir:~/Maildir

On peut __reloader__ la configuration et on peut valider les logs qu'il n'y a pas un processus qui pleure du à un problème de configuration :

        root@9c93ab3c3243:/etc/dovecot# /etc/init.d/dovecot reload
         * Reloading IMAP/POP3 mail server dovecot
         ...done.
        root@9c93ab3c3243:/var/log# tail mail.log
        Feb  8 13:13:02 9c93ab3c3243 dovecot: master: Dovecot v2.2.22 (fe789d2) starting up for imap, lmtp
        Feb  8 13:13:02 9c93ab3c3243 dovecot: ssl-params: Generating SSL parameters
        Feb  8 13:13:04 9c93ab3c3243 dovecot: ssl-params: SSL parameters regeneration completed
        Feb  8 13:43:09 9c93ab3c3243 dovecot: master: Warning: Killed with signal 15 (by pid=7504 uid=0 code=kill)
        Feb  8 13:43:10 9c93ab3c3243 dovecot: master: Dovecot v2.2.22 (fe789d2) starting up for imap, lmtp
        Feb  8 13:49:47 9c93ab3c3243 dovecot: master: Warning: Killed with signal 15 (by pid=0 uid=0 code=kill)
        Feb  8 13:49:47 9c93ab3c3243 dovecot: anvil: Warning: Killed with signal 15 (by pid=0 uid=0 code=kill)
        Feb  8 13:49:47 9c93ab3c3243 dovecot: log: Warning: Killed with signal 15 (by pid=0 uid=0 code=kill)
        Feb  9 13:10:03 9c93ab3c3243 dovecot: master: Dovecot v2.2.22 (fe789d2) starting up for imap, lmtp
        Feb  9 13:14:00 9c93ab3c3243 dovecot: master: Warning: SIGHUP received - reloading configuration

### <a name="setup_dovecot_setup_extraction_conf" /> Extraction de la configuration mise en place

Bon maintenant vous êtes peut-être septiques , vous vous dites ouin mais la il vient de nous faire un __pet container__ , moi je voulais avoir quelques chose de propre dans le __Dockerfile__ on peut pas reproduire la configure . 

Généralement à ce moment je réponds : **Minutes papillons, ça arrive** :D. 

L'objectif de l'ensemble de la configuration dans un conteneur est de valider que nous sommes en mesure de faire la configuration , l'utilisation des layer de docker c'est vraiment génial. Cependant lors de la période d'exploration c'est assez casse couille de devoir refaire : le changement de configuration, le __build__ ,  le redémarrage du conteneur puis la validation . 

Maintenant que nous avons configurer le conteneur qu'il n'a pas d'erreur nous allons reprendre les fichiers que nous avons modifier ramener pour faire la création du __Dockerfile__. Bien entendu nous pouvons faire référence à notre mémoire pour lister les fichiers, mais soyons honnête selon le nombre de fichier nous allons en oublier , MOI le premier. 

Nous avons une super fonctionnalité dans docker qui est : **docker diff**  , ceci nous permet de lister les fichiers qui furent modifié entre l'image de référence et le conteneur en activité.

        $ docker diff sick_brahmagupta | wc -l                                                                                                                
        2979

**Woww**, __ouin__ on a installé des logiciels ça explose tous de suite le nombre de fichier modifier :P ... Comme j'ai pas envie de lire l'ensemble et que je sais que nous avons modifier uniquement des fichiers dans __/etc/dovecot__ nous allons faire un __grep__ sur ce répertoire.

Voilà Magie :

        $ docker diff sick_brahmagupta | grep '/etc/dovecot'
        C /etc/dovecot
        C /etc/dovecot/conf.d
        C /etc/dovecot/conf.d/10-master.conf
        C /etc/dovecot/conf.d/10-mail.conf

Bien entendu en changeant le grep pour uniquement __/etc__ vous aurez une plus grande couverture. Donc nous voyons que nous avons finalement touchez que 2 fichiers de configuration . 

Je vais maintenant copier ces fichiers dans le répertoire de conf dans le répertoire du __Dockerfile__ afin  de pouvoir les copier lors de la génération de l'image srvimap. Bon j'ai 2 fichiers on va pas s'énerver mais j'aimerai vous présenter une méthode de copie , particulièrement pertinente si vous avions 20 ou 50 fichiers.

        $ docker diff sick_brahmagupta | grep '/etc/dovecot' | grep \.conf$ | cut -d " " -f 2
        /etc/dovecot/conf.d/10-mail.conf
        /etc/dovecot/conf.d/10-master.conf

Avec quelques __grep__ et un __cut__ je filtre le résultat , bon les fanatiques de __awk__ :P je vous laisse le plaisir de convertir :P.
J'assigne le résultat à une variable :

        $ LST_FILE=$(docker diff sick_brahmagupta | grep '/etc/dovecot' | grep \.conf$ | cut -d " " -f 2)

Une petite validation pré exécution :D

        $ for x in $LST_FILE; do echo $x; done
        /etc/dovecot/conf.d/10-master.conf
        /etc/dovecot/conf.d/10-mail.conf

Et on fait la même chose avec __docker copy__ :

        $ for x in $LST_FILE; do docker cp sick_brahmagupta:$x . ; done
        $ ls
        10-mail.conf  10-master.conf  supervisor-all.conf

C'est comme de la magie :D

### <a name="setup_dovecot_setup_dovecot_conf" /> Définition des fichiers de configuration dans le Dockerfile

Maintenant que nous avons les fichiers de configuration pour **dovecot** , dans le répertoire conf , nous allons pouvoir ajuster le __Dockerfile__.

        ADD conf/10-*.conf /etc/dovecot/conf.d/

Voici le résultat "final" jusqu'au prochain problème :P 

        $ cat Dockerfile
        # Using debian
        # Start Exemple:
        # ou can add -p 25:25 for LAN access
        FROM ubuntu:16.04
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Packages: update
        RUN apt-get update -qq && \
            apt-get install -qq -y --no-install-recommends dovecot-imapd dovecot-lmtpd \
                    python-pip supervisor rsyslog python-wheel python-setuptools  && \
                    pip install j2cli

        # Configure: supervisor
        ADD bin/dfg.sh /usr/local/bin/
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/

        # Add dovecot configuration
        ADD conf/10-*.conf /etc/dovecot/conf.d/

        # Runner
        ADD run.sh /root/run.sh
        RUN chmod +x /root/run.sh

        # Declare
        EXPOSE 143 24

        CMD ["/root/run.sh"]

On reconstruit l'image :

        $ docker build -t srvimap .
        Sending build context to Docker daemon 28.16 kB
        Step 1 : FROM ubuntu:16.04
         ---> c73a085dc378
        [ ...  OUTPUT ... ]
        Removing intermediate container 4f496692783f
        Successfully built f57aa93b57e1

# <a name="integration" /> Mise en symbiose des images :D

Donc nous sommes au point ou nous avons 2 conteneurs qui ont des services réseau qui ont une configuration théoriquement (on l'a pas encore testé) compatible , il est temps de les combiner. Allez chercher , la colle et les ciseaux !! 

Telle que mentionné je vous invite **FORTEMENT** à utiliser **docker-compose** , ça aide énormément !! Donc nous allons l'utiliser ici :D.

        version: '2'
        services:
            smtp-coco:
                image: srvsmtp
                restart: unless-stopped
                container_name : 'coco-smtp-t'
                hostname: mail.coco.com
                environment:
                    - SMTP_HOSTNAME=mail.coco.com
                    - ACCEPT_DOMAIN=coco.com
                    - TIMEZONE=America/Montreal
                    - TERM=xterm
                links:
                    - imap-coco:dovecot-lmtp
                ports:
                    - 25:25
                volumes:
                    - /tmp/docker/coco-smtp-t/var_spool/mails:/var/spool/postfix
            imap-coco :
                image: srvimap
                container_name : 'coco-imap-t'
                hostname: mail.coco.com
                environment:
                    - TIMEZONE=America/Montreal
                    - TERM=xterm
                ports:
                    - 143:143
                volumes:
                    - /tmp/docker/coco-imap-t//home:/home


Nous avions déjà vu la configuration d'un __docker-compose__ lors de la présentation de conteneur pour le relais de courriel , si vous avez besoin de vous rafraichir la mémoire je vous invite à voir la documentation. Je vais me concentrer sur les nouveautés :

* **environment** (**TIMEZONE=America/Montreal**) : contrairement à la dernière fois je définie le __timezone__ à l'initialisation du conteneur , me permettant de déplacé mon image dans le MONDE :D. 
* **links** (**imap-coco:dovecot-lmtp**) : Nous réalisons le lien entre le conteneur **smtp** et le conteneur **imap** si vous vous rappeler dans la configuration postfix la définition du lien **lmtp** fut réaliser en donnant le nom __dovecot-lmtp__. Avec l'instruction **link** nous indiquons que le service **imap-coco** est associé au nom __dovecot-lmtp__. Nous le verrons à l'utilisation mais le conteneur aura une entré dans le fichier **/etc/hosts** associant le conteneur __coco-imap-t*__ avec ce nom :D. La magie de docker, ceci permet de gérer le problème d'IP dynamique.
* **ports** : Définition des ports qui seront accessible depuis l'externe, comme vous pouvez le constater le port 24 (__lmtp__) n'est pas mentionné, car ce n'est pas un port publique mais inter docker. Entre les conteneur il n'y aura pas de problème de communication peut importe le port.


## <a name="visualisation_volumes" /> Visualisation du résultat du volumes

Prenons quelques minutes avant de valider nos conteneur pour voir le résultat de la définition du volumes , suite à l'initialisation du conteneur ce dernier à associé le répertoire :

* **/tmp/docker/coco-smtp-t/var_spool/mails** sur le docker __host__ dans le conteneur sous le répertoire **/var/spool/postfix**
* **/tmp/docker/coco-imap-t/var_spool/home** sur le docker __host__ dans le conteneur sous le répertoire **/home**

Si nous réalisons visualisons uniquement les répertoire voici le résultat :

        /tmp/docker/
        /tmp/docker/coco-smtp-t
        /tmp/docker/coco-smtp-t/var_spool
        /tmp/docker/coco-smtp-t/var_spool/mails
        /tmp/docker/coco-smtp-t/var_spool/mails/trace
        /tmp/docker/coco-smtp-t/var_spool/mails/saved
        /tmp/docker/coco-smtp-t/var_spool/mails/pid
        /tmp/docker/coco-smtp-t/var_spool/mails/public
        /tmp/docker/coco-smtp-t/var_spool/mails/maildrop
        /tmp/docker/coco-smtp-t/var_spool/mails/private
        /tmp/docker/coco-smtp-t/var_spool/mails/incoming
        /tmp/docker/coco-smtp-t/var_spool/mails/hold
        /tmp/docker/coco-smtp-t/var_spool/mails/flush
        /tmp/docker/coco-smtp-t/var_spool/mails/deferred
        /tmp/docker/coco-smtp-t/var_spool/mails/defer
        /tmp/docker/coco-smtp-t/var_spool/mails/corrupt
        /tmp/docker/coco-smtp-t/var_spool/mails/bounce
        /tmp/docker/coco-smtp-t/var_spool/mails/active
        /tmp/docker/coco-smtp-t/var_spool/mails/lib
        /tmp/docker/coco-smtp-t/var_spool/mails/lib/x86_64-linux-gnu
        /tmp/docker/coco-smtp-t/var_spool/mails/usr
        /tmp/docker/coco-smtp-t/var_spool/mails/usr/lib
        /tmp/docker/coco-smtp-t/var_spool/mails/usr/lib/zoneinfo
        /tmp/docker/coco-smtp-t/var_spool/mails/dev
        /tmp/docker/coco-smtp-t/var_spool/mails/etc
        /tmp/docker/coco-smtp-t/var_spool/mails/etc/ssl
        /tmp/docker/coco-smtp-t/var_spool/mails/etc/ssl/certs
        /tmp/docker/coco-imap-t
        /tmp/docker/coco-imap-t/home


## <a name="visualisation_port_redirect" /> Redirection de port

J'aurais pas pris le temps, mais j'ai eu un comportement étrange et comme souvent les petits problèmes étrange sont les plus long à diagnostiquer. Je ne sais pas si lors de la présentation le problème sera aussi présent. 

J'ai initialisé les conteneurs avec l'instruction **docker-compose** :

        $ docker-compose up
        Creating coco-imap-t
        Creating coco-smtp-t
        Attaching to coco-imap-t, coco-smtp-t
        coco-imap-t  | /usr/lib/python2.7/dist-packages/supervisor/options.py:297: UserWarning: Supervisord is running as root and it is searching for its configuration file in default locations (including its current working directory); you probably want to specify a "-c" argument specifying an absolute path to a configuration file for improved security.
        coco-imap-t  |   'Supervisord is running as root and it is searching '
        coco-imap-t  | 2017-02-10 13:37:00,582 CRIT Supervisor running as root (no user in config file)

Pas de problème mais quand je liste les ports je devrais en avoir 2 conformément au __docker-compose__ :

        $ ss -lntp
        State      Recv-Q Send-Q                                  Local Address:Port                                                 Peer Address:Port
        LISTEN     0      128                                                :::143                                                            :::*
        LISTEN     0      128                                                :::32771                                                          :::*

* 143 : OK pas problème c'est bon.
* 32771 : heu .. __what__ !!

Réalisation d'un **docker ps** :

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                             NAMES
        d81f664c8613        srvsmtp             "/root/run.sh"      49 seconds ago      Up 48 seconds       25/tcp, 0.0.0.0:32771->1525/tcp   coco-smtp-t
        fc3f3a80fffb        srvimap             "/root/run.sh"      50 seconds ago      Up 49 seconds       24/tcp, 0.0.0.0:143->143/tcp      coco-imap-t

J'ai changé la définition du __docker-compose__ pour n'avoir que le port 25 d'associer :

                ports:
                    - 25

Suppression des conteneurs et ré initialisation :

        coco-imap-t  | 2017-02-10 13:30:27,901 INFO success: dovecot entered RUNNING state, process has stayed up for > than 3 seconds (startsecs)
        coco-smtp-t  | 2017-02-10 13:30:29,662 INFO success: postfix entered RUNNING state, process has stayed up for > than 3 seconds (startsecs)
        ^[^[[A^CGracefully stopping... (press Ctrl+C again to force)
        Stopping coco-smtp-t ... done
        Stopping coco-imap-t ... done
        $ docker-compose rm
        Going to remove coco-smtp-t, coco-imap-t
        Are you sure? [yN] y
        Removing coco-smtp-t ... done
        Removing coco-imap-t ... done

Redémarrage des conteneurs :

        $ docker-compose up
        Creating coco-imap-t
        Creating coco-smtp-t

Résultat encore très étonnant : 

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                          NAMES
        701d9449fb94        srvsmtp             "/root/run.sh"      3 seconds ago       Up 2 seconds        0.0.0.0:32772->25/tcp          coco-smtp-t
        2761155e3d08        srvimap             "/root/run.sh"      4 seconds ago       Up 3 seconds        24/tcp, 0.0.0.0:143->143/tcp   coco-imap-t

Après recherche je suis tombé sur ce problème signalé sur __github__ : https://github.com/docker/compose/issues/1906

Résultat simplement mettre des " autour du port ... Je fait mention du problème, car c'est le genre de détail qui peut prendre une demi journée a résoudre , voir plus quand on est pas confortable et que l'on doute de ça configuration !

Donc voici le résultat :

        ports:
            - '25:25'
                            -
On réinitialise les conteneurs.

        $ docker-compose up
        Creating coco-imap-t
        Creating coco-smtp-t
        Attaching to coco-imap-t, coco-smtp-t

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                  PORTS                          NAMES
        8dde07090918        srvsmtp             "/root/run.sh"      1 seconds ago       Up Less than a second   0.0.0.0:25->25/tcp             coco-smtp-t
        f8f28a4c2dae        srvimap             "/root/run.sh"      2 seconds ago       Up Less than a second   24/tcp, 0.0.0.0:143->143/tcp   coco-imap-t

Voilà tout est bon maintenant :D

## <a name="teste_contener" /> Teste de la configuration

Bon on y croit :P à font on se dit que ça va fonctionner du premier coup :P , l'espoir fait vivre que l'on dit :D.

        $ docker inspect coco-smtp-t | grep IPA
                "SecondaryIPAddresses": null,
                "IPAddress": "",
                "IPAMConfig": null,
                       "IPAddress": "172.21.0.3",

Envoie du courriel au seul utilisateur existant donc __root__ :

        $ telnet 172.21.0.3 25
        Trying 172.21.0.3...
        Connected to 172.21.0.3.
        Escape character is '^]'.
        220 mail.coco.com ESMTP Postfix
        ehlo toto
        250-mail.coco.com
        250-PIPELINING
        250-SIZE 10240000
        250-VRFY
        250-ETRN
        250-ENHANCEDSTATUSCODES
        250-8BITMIME
        250 DSN
        mail from:toto@ejhfk.com
        250 2.1.0 Ok
        rcpt to: root@coco.com
        250 2.1.5 Ok
        data
        354 End data with <CR><LF>.<CR><LF>
        un courriel
        .
        250 2.0.0 Ok: queued as 1A9048F41
        quit
        221 2.0.0 Bye
        Connection closed by foreign host.

Pour le moment c'est bon , regardons les logs de postfix :

        $ docker exec coco-smtp-t tail -20 /var/log/mail.log
        Feb 10 21:52:28 mail postfix/smtpd[788]: connect from unknown[172.21.0.1]
        Feb 10 21:52:53 mail postfix/smtpd[788]: 1A9048F41: client=unknown[172.21.0.1]
        Feb 10 21:52:57 mail postfix/cleanup[930]: 1A9048F41: message-id=<>
        Feb 10 21:52:57 mail postfix/qmgr[127]: 1A9048F41: from=<toto@ejhfk.com>, size=173, nrcpt=1 (queue active)
        Feb 10 21:52:57 mail postfix/lmtp[948]: 1A9048F41: to=<root@coco.com>, relay=dovecot-lmtp[172.21.0.2]:24, delay=12, delays=12/0.01/0.02/0.05, dsn=5.1.1, status=bounced (host dovecot-lmtp[172.21.0.2] said: 550 5.1.1 <root@coco.com> User doesn't exist: root@coco.com (in reply to RCPT TO command))
        Feb 10 21:52:57 mail postfix/cleanup[930]: 4342C92C4: message-id=<20170210215257.4342C92C4@mail.coco.com>
        Feb 10 21:52:57 mail postfix/bounce[949]: 1A9048F41: sender non-delivery notification: 4342C92C4
        Feb 10 21:52:57 mail postfix/qmgr[127]: 4342C92C4: from=<>, size=2050, nrcpt=1 (queue active)
        Feb 10 21:52:57 mail postfix/qmgr[127]: 1A9048F41: removed
        Feb 10 21:52:58 mail postfix/smtpd[788]: disconnect from unknown[172.21.0.1] ehlo=1 mail=1 rcpt=1 data=1 quit=1 commands=5
        Feb 10 21:53:17 mail postfix/smtp[950]: 4342C92C4: to=<toto@ejhfk.com>, relay=none, delay=20, delays=0/0.01/20/0, dsn=4.4.3, status=deferred (Host or domain name not found. Name service error for name=ejhfk.com type=MX: Host not found, try again)

Bon ça n'a pas tous à fait fonctionné :D , mais on va se consoler un peu pour commencer , qu'est-ce qui marche et marche pas :

* Fonctionne :
    * Le système d'acceptation de courriel fonctionne !! Le courriel fut accepté pour le domaine __coco.com__ pour un utilisateur existant !
    * Le système postfix à communiquer avec l'IP **dovecot-lmtp[172.21.0.2]** pour faire le transfère du courriel !
    * Le système **lmtp** à même répondu que l'adresse courriel n'était PAS valide ... 
* Fonctionne pas :
    * La livraison des courriels par __dovecot__
    * La validation de la liste des utilisateurs !

Donc si on prend un pas de recule le constat est assez positif :D , nous avons 2 conteneurs qui se parlent sans problème :D (**Think positif**)

## <a name="analyse_prob_lmtp" /> Analyse du problème lmtp

Nous devons à présent voir pourquoi __dovecot__ n'a pas pris le courriel , bon toujours dans un soucis de transparence ça fait des années que j'ai pas utilisé __lmtp__ donc c'est de ma faute :D . Chanceux pareil :D.

Voyons les logs :

        $ docker exec coco-imap-t tail -20 /var/log/mail.log
        Feb 10 21:49:28 mail dovecot: master: Dovecot v2.2.22 (fe789d2) starting up for imap, lmtp
        Feb 10 21:49:28 mail dovecot: ssl-params: Generating SSL parameters
        Feb 10 21:49:31 mail dovecot: ssl-params: SSL parameters regeneration completed
        Feb 10 21:52:57 mail dovecot: lmtp(851): Connect from 172.21.0.3
        Feb 10 21:52:57 mail dovecot: lmtp(851): Disconnect from 172.21.0.3: Successful quit

__Woww__ :D , magnifique , très verbeux :D.

Donc là j'ai __googlé__ :P car google sait tous :D. (http://www.dovecot.org/list/dovecot/2016-February/103298.html)[http://www.dovecot.org/list/dovecot/2016-February/103298.html] . 

        The solution was
        auth_username_format = %Ln

        in /etc/dovecot/conf.d/10-auth.conf

        I saw it on another thread. Thanks Pascal

La validation réalisé par dovecot prend le nom de domaine pour réaliser la validation , ceci est parfait car normalement on utilise ce système pour gérer plusieurs domaine donc ceci est convenable. Dans notre cas c'est un peu particulier comme nous ne réalisons pas une configuration de masse mais pour s'amuser ... 
N'est  pas que l'on s'amuse bien :D !!

Je passe donc en mode exploration de la solution ... 
Je vais copier le fichier, le modifier et le repousser dans le conteneur , par la suite , je vais allé dans le conteneur pour redémarrer le service .

        $ docker cp coco-imap-t:/etc/dovecot/conf.d/10-auth.conf /tmp/
        $ vim 10-auth.conf

        Je change :

        auth_username_format = %Lu
        pour 
        auth_username_format = %Ln

J'en ai profiter aussi pour changer l'authentification en mode __plain text__ (__disable\_plaintext\_auth = yes__).

Je repousse la configuration :

         $ docker cp 10-auth.conf coco-imap-t:/etc/dovecot/conf.d/10-auth.conf

Je redémarre le service dovecot :

         $ docker exec -it coco-imap-t /etc/init.d/dovecot restart

On peut refaire le test :D 

* logs smtp :

       Feb 10 22:16:27 mail postfix/qmgr[125]: 65A3A12CA1: from=<toto@chekf.com>, size=188, nrcpt=1 (queue active)
       Feb 10 22:16:28 mail postfix/lmtp[547]: 65A3A12CA1: to=<root@coco.com>, relay=dovecot-lmtp[172.21.0.3]:24, delay=11, delays=11/0.01/0.01/0.05, dsn=4.3.0, status=deferred (host dovecot-lmtp[172.21.0.3] said: 451 4.3.0 <root@coco.com> Invalid user settings. Refer to server log for more information. (in reply to RCPT TO command))

* logs __imap__ :

        Feb 10 22:10:02 mail dovecot: master: Dovecot v2.2.22 (fe789d2) starting up for imap, lmtp
        Feb 10 22:16:28 mail dovecot: lmtp(401): Connect from 172.21.0.2
        Feb 10 22:16:28 mail dovecot: lmtp(root@coco.com): Error: Invalid settings in userdb: userdb returned 0 as uid
        Feb 10 22:16:28 mail dovecot: lmtp(401): Disconnect from 172.21.0.2: Successful quit


Création d'un utilisateur dans le conteneur __imap__ pour faire un teste autre qu'avec l'utilisateur __root__ qui  cause problème

        root@mail:/etc/dovecot/conf.d# adduser toto
        Adding user `toto' ...
        Adding new group `toto' (1000) ...
        Adding new user `toto' (1000) with group `toto' ...
        Creating home directory `/home/toto' ...
        Copying files from `/etc/skel' ...
        Enter new UNIX password:
        Retype new UNIX password:
        passwd: password updated successfully
        Changing the user information for toto
        Enter the new value, or press ENTER for the default
        Full Name []:
        Room Number []:
        Work Phone []:
        Home Phone []:
        Other []:
        Is the information correct? [Y/n] y


Crotte ça marche pas plus :P

        $ telnet 172.21.0.2 25
        Trying 172.21.0.2...
        Connected to 172.21.0.2.
        Escape character is '^]'.
        220 mail.coco.com ESMTP Postfix
        ehlo toto
        250-mail.coco.com
        250-PIPELINING
        250-SIZE 10240000
        250-VRFY
        250-ETRN
        250-ENHANCEDSTATUSCODES
        250-8BITMIME
        250 DSN
        mail from:toto@jrjfe.com
        250 2.1.0 Ok
        rcpt to:toto@coco.com
        550 5.1.1 <toto@coco.com>: Recipient address rejected: User unknown in local recipient table

Bon pour le moment je veux valider l'interconnexion de mes conteneurs donc je vais désactivé la configuration de validation des adresses sur le serveur postfix. 

J'utilise la commande **postconf** pour faire un changement rapide .. validation 

        root@mail:/# postconf | grep local_recipient_maps 
        local_recipient_maps = proxy:unix:passwd.byname $alias_maps
        root@mail:/# postconf local_recipient_maps=
        root@mail:/# postconf | grep local_recipient_maps
        local_recipient_maps =

**magie** ça passe :P

        $ telnet 172.21.0.2 25
        Trying 172.21.0.2...
        Connected to 172.21.0.2.
        Escape character is '^]'.
        220 mail.coco.com ESMTP Postfix
        ehlo toto
        250-mail.coco.com
        250-PIPELINING
        250-SIZE 10240000
        250-VRFY
        250-ETRN
        250-ENHANCEDSTATUSCODES
        250-8BITMIME
        250 DSN
        mail from: toto@jerkjf.com
        250 2.1.0 Ok
        rcpt to: toto@coco.com
        250 2.1.5 Ok
        data
        354 End data with <CR><LF>.<CR><LF>
        un test sans filtrage courriel     
        .
        250 2.0.0 Ok: queued as DE2C615FB1
        quit
        221 2.0.0 Bye
        Connection closed by foreign host.

Et maintenant dans les logs de dovecot 

        Feb 10 22:24:42 mail dovecot: lmtp(2414): Disconnect from 172.21.0.2: Successful quit
        Feb 10 22:27:23 mail dovecot: lmtp(3060): Connect from 172.21.0.2
        Feb 10 22:27:23 mail dovecot: lmtp(toto): EqsFNks+nlj0CwAABKaThQ: msgid=unspecified: saved mail to INBOX
        Feb 10 22:27:23 mail dovecot: lmtp(3060): Disconnect from 172.21.0.2: Successful quit

Validation du courriel sur le docker host :

        $ ls -R  /tmp/docker/coco-imap-t/home/toto/
        /tmp/docker/coco-imap-t/home/toto/:
        Maildir

        /tmp/docker/coco-imap-t/home/toto/Maildir:
        cur  dovecot.index.cache  dovecot.index.log  dovecot-uidlist  dovecot-uidvalidity  dovecot-uidvalidity.589e3e4b  new  tmp

        /tmp/docker/coco-imap-t/home/toto/Maildir/cur:

        /tmp/docker/coco-imap-t/home/toto/Maildir/new:
        '1486765643.M950101P3060.mail.coco.com,S=409,W=419'

        /tmp/docker/coco-imap-t/home/toto/Maildir/tmp:

L'interconnexion entre les conteneurs fonctionne mais ce n'est vraiment pas optimal nous avons du faire des ajustements de configuration "live" sur le système . Prenons un temps de recule et analysons le problème.

# <a name="analyse_prob_interconnexion" /> Recule et analyse de la situation

Analysons la situation :

* **Validation adresses** : Postfix réalise la validation des adresses courriels lors de la réception du courriel pour le domaine ! Voici les options possibles 
    * **désactivation** : Nous pourrions supprimer cette validation , pas vraiment agréable mais nous l'avons validé ça marche.
    * **lister les adresses** : Nous pourrions aussi mettre en place un script qui crée une liste des adresses courriels.
    * **configuration lmtp** : Pousser la réflexion pour avoir une validation avec **lmtp** pour avoir la validation avec le nom de domaine, le problème est que nous avons modifier la configuration pour que la validation de l'usager n'inclut pas l'adresse courriel.
* **Gestion des utilisateurs** : Actuellement pour les besoins de la validation de l'interconnexion des conteneurs j'ai créé manuellement l'utilisateur dans le conteneur __imap__. J'ai déjà mentionné des méthodes possible de mise en place quand nous avons parlé de postfix , je vais en sortir proposer une.
    * **Définition par variable** : Je vais opté pour la mise en place d'utilisateur dans dovecot via le système de variables lors de l'initialisation, cependant nous allons aussi permettre la création "rapide" d'utilisateur afin de répondre à une demande immédiate. Bien entendu nous utiliserons un script pour le faire plus simplement.

En conclusion nous avons l'impression que l'on est loin de la solution, mais on a 2 points majeur bloquant, ce n'est pas si mal :D. On est loin de la catastrophe comme on pourrait le penser au début . Il est important de prendre le recule pour saisir l'ampleur de la situation.

# <a name="correction_setup" /> Correction de la configuration postfix et dovecot

C'est repartie , j'espère que le processus n'est pas trop long pour vous ... 

## <a name="correction_setup_postfix" /> Correction de la configuration postfix 

Nous allons modifier notre fichier de configuration postfix afin d'avoir un argument additionnel pour le fichier de validation des adresses courriels. Par défaut nous avons 

        local_recipient_maps = proxy:unix:passwd.byname $alias_maps

Nous allons mettre définir un fichier en plus , de type __hash__ car j'ai pas voulu me prendre la tête encore :P. Voici donc le nouveau fichier de configuration **srvMailWithImap/smtp/conf/postfix-main.j2** : 

        smtpd_banner = $myhostname ESMTP $mail_name

        alias_database = hash:/etc/aliases
        alias_maps = hash:/etc/aliases

        # Si vous le désirez nous pourrions avoir ce paramètre en option
        home_mailbox = Maildir/

        smtpd_relay_restrictions = permit_mynetworks  defer_unauth_destination
        myhostname = $myorigin
        myorigin = {{ SMTP_HOSTNAME }}

        mydestination = {{ ACCEPT_DOMAIN }}
        mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 {{ PERMIT_NETWORK }}
        inet_interfaces = all
        inet_protocols = ipv4

        # Configuration pour l'envoie vers lmtp (aka dovecot)
        mailbox_transport = lmtp:dovecot-lmtp:24

        local_recipient_maps = proxy:unix:passwd.byname $alias_maps /etc/postfix/mails-{{ ACCEPT_DOMAIN }}.lst

        {% if (EXT_RELAY_HOST != "DIRECT") %}relayhost = {{ EXT_RELAYHOST }} {% endif %}

J'ai donc ajouter le fichier **/etc/postfix/mails-{{ ACCEPT_DOMAIN }}.lst** à la variable **local\_reciepient\_maps**

On reconstruit l'image !!

Parfait nous aurons une autre modification à réaliser par la suite, mais j'y reviendrais :D. Passons à la configuration de dovecot .

## <a name="correction_setup_dovecot" /> Correction de la configuration dovecot

Nous avions fait 2 modification :

1. La validation du nom de l'utilisateur
2. La désactivation de la restriction du passage en claire du mot de passe , ça tombe bien les 2 paramètres sont dans le fichier **10-auth**


        $ cd srvMailWithImap/imap/conf
        $ docker cp coco-imap-t:/etc/dovecot/conf.d/10-auth.conf .


Le fichier __Dockerfile__ contient la ligne suivante :

        # Add dovecot configuration
        ADD conf/10-*.conf /etc/dovecot/conf.d/

Donc il sera prit en considération lors de la reconstruction de l'image.

Nous devons aussi mettre en place la configuration de la liste des usagers, bon je le répète, ces conteneurs sont pour des fin de présentation !! En d'autre mot non viable pour une utilisation de production. Car nous allons définir des mot de passe au utilisateur, qu'ils ne pourront pas changer autrement que de se connecter sur le conteneur. L'autre méthode serait de mettre une page web et un script en arrière , mais ce serait ridicule autant utiliser une base de donnée pour stocker les informations . Ça nous aurait aussi simplifié la vie pour postfix, mais bon trop tard j'ai trop écrit pour revenir en arrière :P.

Nous allons donc modifier le script de démarrage pour qu'il crée les utilisateurs lors de l'initialisation du conteneur, voici donc le nouveau fichier **run.sh** :

        #! /usr/bin/env bash
        set -e # exit on error

        # Variables
        export LST_USERS=${LST_USERS:"NONE"}

        export LST_MAILS=${LST_MAILS:"/etc/dovecot/mails-$ACCEPT_DOMAIN.lst"}

        # Création des utilisateurs 
        if [ "$LST_USERS" == "NONE" ] ; then
            echo "You must define variable LST_USER to create at leat one user !!"
                exit 2
            fi   

            # Creation des utilisateur 
            for user in $LST_USER ; do
                adduser $user
                # set password motpasse 
                echo "${user}:motpasse" | chpasswd 

                # Création de la liste des adresses courriels valides 
                echo "$user@$ACCEPT_DOMAIN OK" >> $LST_MAILS
            done


         # Launch
         rm -f /var/run/dovecot/*.pid
         exec /usr/bin/supervisord -n


On reconstruit l'image !!

ICI ICI ICI
    changement du docker-compose 
ICI ICI ICI


# note pour apres :

REF: http://linuxfr.org/news/exploiter-inotify-c-est-simple

        apt-get install incron


# les logs 
http://hokstadconsulting.com/docker/postfix , utilisation de -v /dev/log:/dev/log
