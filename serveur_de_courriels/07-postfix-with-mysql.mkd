<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 

# <a name="Intro" /> Introduction

Telle que mentionné plusieurs fois lors des sessions précédente l'utilisation d'utilisateur local ne permet pas une gestion massive d'utilisateur, ceci nous limite beaucoup en particulier pour :

* La délégation de la création des comptes
* La modification des mot de passe
* La gestion des adresses similaire pour plusieurs domaine (ex: __info@coco.com et info@blabla.com__)
* La sécurisation de l'environnement, car chaque personne à un compte localement sur la machine
* ....

Un solution préconiser est l'utilisation d'une base de donnée pour le stockage des informations client. 
Voici ce que nous allons couvrir :

* Mise en place de postfix avec des comptes virtuels
* Intégration de postfix avec une base de données
* Mise en place d'une interface de gestion des comptes
* Intégration avec le serveur dovecot __imap__
* Un _webmail__ ? On verra selon le temps :-/

On va réaliser l'opération dans des conteneurs directement, maintenant que l'on y arrive chaque fois du premier coup :P  !

Voici un schéma des communications entre les conteneurs / application :

![flux_communication_smtp-bd-imap-http.png](./imgs/flux_communication_smtp-bd-imap-http.png)

Comme vous pouvez le constater la base de donnée est centrale dans le système , de les données sont uniquement fournit par le conteneur **imap** !

# <a name="setup_img" /> Configuration des images 

Telle que mentionné pour gagné du temps on va tous de suite le faire avec des conteneurs, si vous désirez le mettre en place uniquement sur une machines il suffira de reprendre l'ensemble des commandes des conteneurs et faire l'opération sur **LA** machine.

## <a name="setup_db" /> Configuration de la base de donnée

Comme l'ensemble du système repose sur la base de donnée, nous allons débuter par ce conteneur et construire autour . L'avantage aussi de débuter par ce conteneur et que l'image est déjà disponible . [https://hub.docker.com](https//hub.docker.com) offre un conteneur officiel de [Mysql](https://hub.docker.com/_/mysql/).

Si nous regardons le descriptif nous avons ceci :

        MYSQL_USER, MYSQL_PASSWORD
        These variables are optional, used in conjunction to create a new user and to set that user's password. This user will be granted superuser permissions (see above) for the database specified by the MYSQL_DATABASE variable. Both variables are required for a user to be created.

En d'autre mot en passant les variables d'environnement le système va automatiquement faire la création de l'utilisateur / mot de passe et de la BD .

On essaye :D , on sait jamais peut-être que le site ment :P.

        $ docker run -e MYSQL_USER=umail -e MYSQL_PASSWORD=ZePassword -e MYSQL_DATABASE=vmail -e MYSQL_RANDOM_ROOT_PASSWORD=yes  mysql:5.5
        Initializing database
        170217 22:18:49 [Note] /usr/local/mysql/bin/mysqld (mysqld 5.5.52) starting as process 60 ...
        170217 22:18:50 [Note] /usr/local/mysql/bin/mysqld (mysqld 5.5.52) starting as process 66 ...

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
        f95afd51c1e2        mysql:5.5           "docker-entrypoint.sh"   28 seconds ago      Up 27 seconds       3306/tcp            pensive_bohr

        $ docker exec -it pensive_bohr mysql -u umail -p
        Enter password:
        mysql> show databases;
        +--------------------+
        | Database           |
        +--------------------+
        | information_schema |
        | vmail              |
        +--------------------+
        2 rows in set (0.00 sec)

        mysql> use vmail;
        Database changed
        mysql> show tables;
        Empty set (0.00 sec)

        mysql> Bye

Là on peut dire du premier coup :P !!!

Bon on fait le __docker-compose__ tous de suite !!

        version: '2'
        services:
            db-coco:
                image: mysql:5.5
                restart: unless-stopped
                container_name : 'coco-db-t'
                hostname: db.coco.com
                environment:
                    - MYSQL_USER=umail
                    - MYSQL_PASSWORD=ZePassword
                    - MYSQL_DATABASE=vmail
                    - MYSQL_RANDOM_ROOT_PASSWORD=yes
                    - TZ=America/Montreal
                    - TERM=xterm
                volumes:
                    - /srv/docker/coco-db-t/var_lib_mysql:/var/lib/mysql

Comme vous pouvez le constater j'ai exporter le répertoire __/var/lib/mysql__ sur le docker host pour conserver les données hors du conteneur.
On le valide :

        $ docker-compose up
        Creating network "srvmailwithimapwithbd_default" with the default driver
        Creating coco-db-t
        Attaching to coco-db-t
        coco-db-t  | Initializing database

Encore du premier coup , on y prend goût :D, pas de panique ça ne durera pas :D.

## <a name="setup_http" /> Configuration du service Web pour la gestion de la base de donnée

Maintenant que l'on a une base de donnée vierge nous allons la remplir avec le système [postfixadmin](http://postfixadmin.sourceforge.net/), ce système permet de contrôler et définir des domaines , adresses courriels, utilisateur , ... Là pas de bol pas de conteneur officiel, on va devoir s'amuser :D. 
Par contre nous avons un conteneur officiel pour [php](https://hub.docker.com/_/php/) , au lieu de démarrer avec un Ubuntu et installer apache et **php** nous allons démarrer avec le conteneur officiel ! Faut bien faire changement un peu de temps en temps :D, histoire d'avoir de nouveau problème :D.

Si vous regardez la page il y a plusieurs type de conteneur disponible :

        5.6.30-cli, 5.6-cli, 5-cli, 5.6.30, 5.6, 5 (5.6/Dockerfile)
        5.6.30-alpine, 5.6-alpine, 5-alpine (5.6/alpine/Dockerfile)
        5.6.30-apache, 5.6-apache, 5-apache (5.6/apache/Dockerfile)
        5.6.30-fpm, 5.6-fpm, 5-fpm (5.6/fpm/Dockerfile)

* **cli** :  pour utiliser __php__ en commande line
* **alpine** : Utilise une version minimal de Linux
* **apache** : Avec le serveur web apache

La version alpine est un conteneur plus minimal , alpine est une distribution moins gourmand en espace disque , alors que la version "non" alpine est un conteneur dérivé de debian (si je ne me trompe pas). On va commencer par la version "normale" et on analysera si on peut passer au mode alpine par la suite.

Avant de se lancer dans __Dockerfile__ définissons les grandes lignes que ceci devra conteneur , nous allons vouloir installer [postfixadmin](http://postfixadmin.sourceforge.net/) , donc prenons la documentation . [https://github.com/albanpeignier/postfixadmin/blob/master/INSTALL.TXT](https://github.com/albanpeignier/postfixadmin/blob/master/INSTALL.TXT) 

Nous avons donc besoin :

* apache (bien entendu)
* __PHP__ 4.1 ou plus (5.X recommandé )
* Module __php__ pour établir une connexion __Mysql__

Je vais d'abord valider l'image __php:5-apache__ Je la récupère donc depuis [hub.docker.com](http://hub.docker.com).

        $ docker pull php:5-apache
        5-apache: Pulling from library/php

Si nous regardons la page du conteneur __php__ nous pourrons constater qu'il y a le lien vers le __dockerFile__ du package : [php:5-apache](https://github.com/docker-library/php/blob/e573f8f7fda5d7378bae9c6a936a298b850c4076/5.6/apache/Dockerfile), nous voyons clairement que la référence est un __debian:jessie__.

Vous pouvez le démarrer pour vous faire la main dessus, car être confortable est très important , bon moi j'ai envie de le faire "live", je vais débuter avec un __dockerfile__ :P après le succès de __MySQL__ j'ai crois :P.

Voici le __dockerfile__ : 

        # Thomas Boutry
        FROM php:5-apache
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Php Modules a activer
        RUN docker-php-ext-install mbstring \
            && docker-php-ext-install mcrypt \
            && docker-php-ext-install mysql \
            && docker-php-ext-install mysqli \
            && docker-php-ext-install pdo_mysql


La particularité ici , entre une machine "classique" et le conteneur __php__ , l'instruction d'installation des modules aurais été comme suit pour une installe classique  :

        RUN apt-get update \
            && apt-get install php-mcrypt php-mysql php-mysqli 

Mais le système de docker officiel offre une autre possibilité , que j'ai envie d'essayer :D , donc j'ai pris la philosophie du conteneur ! 

On construit l'image :

        $ docker build -t postfixadmin .
        [ ... OUTPUT COUPÉ ...]
        checking if nawk is broken... no
        checking for mcrypt support... yes, shared
        configure: error: mcrypt.h not found. Please reinstall libmcrypt.
        The command '/bin/sh -c docker-php-ext-install mbstring     && docker-php-ext-install mcrypt     && docker-php-ext-install mysql     && docker-php-ext-install mysqli     && docker-php-ext-install pdo_mysql' returned a non-zero code: 1


Nous pouvons voir que lors de la création du conteneur , le système compile les modules à ajouter il a donc besoin des packages sources pour réaliser l'opération je vais faire l'ajout. 


        # Thomas Boutry
        FROM php:5-apache
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Php Modules a activer 
        RUN apt-get update && apt-get install -y  --no-install-recommends libmcrypt-dev \
            && docker-php-ext-install mbstring \
            && docker-php-ext-install mcrypt \
            && docker-php-ext-install mysql \
            && docker-php-ext-install mysqli \
            && docker-php-ext-install pdo_mysql


        $ docker build -t postfixadmin .
        [ ... OUTPUT COUPÉ ... ]
        rm -f libphp.la       modules/* libs/*
         ---> 5e8e831c6a96
         Removing intermediate container 6d35d7aee6b8
         Successfully built 5e8e831c6a96


Super nous avons donc notre conteneur avec l'ensemble d'installer ... Du moins on le pense (honnêtement je le sais pas moi même à ce stade :D , on découvre ensemble !! ).

Je vais démarrer le conteneur et mettre en place un fichier __phpinfo__ afin de confirmer ce qui est bien présent :D .

        $ docker run  postfixadmin
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message
        [Mon Feb 20 13:37:20.574334 2017] [mpm_prefork:notice] [pid 1] AH00163: Apache/2.4.10 (Debian) PHP/5.6.30 configured -- resuming normal operations
        [Mon Feb 20 13:37:20.574363 2017] [core:notice] [pid 1] AH00094: Command line: 'apache2 -D FOREGROUND'

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
        095673118d88        postfixadmin        "docker-php-entrypoin"   15 seconds ago      Up 13 seconds       80/tcp              focused_hawking

        $ docker exec -it focused_hawking bash
        root@095673118d88:/var/www/html# pwd
        /var/www/html

Comme je n'ai pas **vi** sur la machine je vais simplement faire la création avec __echo__ 

        root@095673118d88:/var/www/html# echo "<?php  phpinfo(); ?>" >> index.php

Visualisation du résultat :

![php_docker-view-phpinfo.png](./imgs/php_docker-view-phpinfo.png)

Bien entendu vous pouvez visualiser le conteneur de la configuration apache dans **/etc/apache2**, je vous laisse le plaisir !

Parfait après validation nous pouvons dire que ceci semble convenable, nous allons maintenant ajouter la configuration de __postfixadmin__. Je télécharge l'application depuis internet [https://sourceforge.net/projects/postfixadmin/files/postfixadmin/postfixadmin-2.3.8/](https://sourceforge.net/projects/postfixadmin/files/postfixadmin/postfixadmin-2.3.8/).

J'ai placé l'application dans le répertoire __docroot__

        $ ls http/
        Dockerfile  docroot

        $ ls http/docroot/
        postfixadmin-2.3.8

        $ ls -1 http/docroot/postfixadmin-2.3.8/ | head -5
        ADDITIONS
        admin
        backup.php
        broadcast-message.php
        CHANGELOG.TXT

Modification du __Dockerfile__ en conséquence. 

        COPY docroot/postfixadmin-2.3.8/ /var/www/html/

Nous allons aussi profiter du moment pour modifier le fichier __docker-compose.yml__ :


        version: '2'
        services:
            db-coco:
                image: mysql:5.5
                restart: unless-stopped
                container_name : 'coco-db-t'
                hostname: db.coco.com
                environment:
                    - MYSQL_USER=umail
                    - MYSQL_PASSWORD=ZePassword
                    - MYSQL_DATABASE=vmail
                    - MYSQL_RANDOM_ROOT_PASSWORD=yes
                    - TZ=America/Montreal
                    - TERM=xterm
                volumes:
                    - /srv/docker/coco-db-t/var_lib_mysql:/var/lib/mysql
            http-coco:
                image: postfixadmin
                build: ./http/
                restart: unless-stopped
                container_name : 'coco-http-t'
                hostname: mail.coco.com
                links:
                    - db-coco:mysql-db
                environment:
                    - MYSQL_USER=umail
                    - MYSQL_PASSWORD=ZePassword
                    - MYSQL_DATABASE=vmail
                    - TZ=America/Montreal
                    - TERM=xterm

L'ensemble est pas mal déjà maîtrisé , petit détail qui fut ajouté la ligne suivante :

        build: ./http/

Ceci me permet de réaliser des constructions d'image directement avec la commande __docker-compose__ au lieu de changer de répertoire et de faire __docker build -t ....__ :D. Ça commençais  à m'ennuyer de changer de répertoire tous le temps. Résultat  :

        $ docker-compose build http-coco
        Building http-coco
        Step 1 : FROM php:5-apache
         ---> 9013e58a01eb
         Step 2 : MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>
          ---> Using cache
           ---> 1ab4c14a8cbd
        [ ... OUTPUT COUPÉ ... ]


Nous réalisons un teste avec les 2 conteneurs :

        $ docker-compose up
        Starting coco-db-t
        Creating coco-http-t
        Attaching to coco-db-t, coco-http-t
        coco-db-t    | 170221  8:18:38 [Note] mysqld (mysqld 5.5.52) starting as process 1 ...
        coco-db-t    | 170221  8:18:38 [Note] Plugin 'FEDERATED' is disabled.
        coco-db-t    | 170221  8:18:38 InnoDB: The InnoDB memory heap is disabled
        coco-db-t    | 170221  8:18:38 InnoDB: Mutexes and rw_locks use GCC atomic builtins
        coco-db-t    | 170221  8:18:38 InnoDB: Compressed tables use zlib 1.2.3
        coco-db-t    | 170221  8:18:38 InnoDB: Using Linux native AIO

![default_page_postfixadm.png](./imgs/default_page_postfixadm.png)


Pas trop mal :D. Nous pouvons réaliser le **setup** : [http://172.22.0.3/setup.php](http://172.22.0.3/setup.php) Bien entendu votre IP peut être tous autre.

[erreur_setup_postfixadm-01.png](./imgs/erreur_setup_postfixadm-01.png)

**yeahh** des problèmes on finira pas trop tôt la formation ;-).

Bon clairement il manque la configuration du fichier ! Nous allons donc regarder ce dit fichier. Le fichier est dans le répertoire **http/docroot/postfixadmin-2.3.8/config.inc.php**.

Premièrement je vais réaliser une copie du fichier , le nouveau fichier sera de type **jinja2**

        $ mkdir http/conf/
        $ cp http/docroot/postfixadmin-2.3.8/config.inc.php http/conf/config.inc.php.j2


Voici les changements réalisés :


        $ diff http/conf/config.inc.php.j2 http/docroot/postfixadmin-2.3.8/config.inc.php  
        26c26
        < $CONF['configured'] = true;
        ---
        > $CONF['configured'] = false;
        31c31
        < $CONF['setup_password'] = '{{ SETUP_PASS }}';
        ---
        > $CONF['setup_password'] = 'changeme';
        49,53c49,53
        < $CONF['database_type'] = '{{ DB_TYPE }}';
        < $CONF['database_host'] = 'db';
        < $CONF['database_user'] = '{{ MYSQL_USER }}';
        < $CONF['database_password'] = '{{ MYSQL_PASSWORD }}';
        < $CONF['database_name'] = '{{ MYSQL_DATABASE }}';
        ---
        > $CONF['database_type'] = 'mysql';
        > $CONF['database_host'] = 'localhost';
        > $CONF['database_user'] = 'postfix';
        > $CONF['database_password'] = 'postfixadmin';
        > $CONF['database_name'] = 'postfix';
        82c82
        < $CONF['admin_email'] = 'postmaster@{{ MAIL_DOMAIN }}';
        ---
        > $CONF['admin_email'] = 'postmaster@change-this-to-your.domain.tld';
        133,136c133,136
        <     'abuse' => 'abuse@{{ MAIL_DOMAIN }}',
        <     'hostmaster' => 'hostmaster@{{ MAIL_DOMAIN }}',
        <     'postmaster' => 'postmaster@{{ MAIL_DOMAIN }}',
        <     'webmaster' => 'webmaster@{{ MAIL_DOMAIN }}'
        ---
        >     'abuse' => 'abuse@change-this-to-your.domain.tld',
        >     'hostmaster' => 'hostmaster@change-this-to-your.domain.tld',
        >     'postmaster' => 'postmaster@change-this-to-your.domain.tld',
        >     'webmaster' => 'webmaster@change-this-to-your.domain.tld'

J'ai donc modifier les paramètres de définitions de la base de donnée ainsi que la définition du domaine __change-this-to-your.domain.tld__ pour la variable __MAIL\_DOMAIN__ . **ATTENTION** je ne prétend pas que l'ensemble de la configuration est complète je vous invite à refaire une validation !!!

C'est cool tous ça mais on a pas installé le système de conversion __jinja2__ :P faut modifier le __Dockerfile__ :

        # Php Modules a activer
        RUN apt-get update && apt-get install -y  --no-install-recommends libmcrypt-dev python-pip python-wheel python-setuptools \
        && docker-php-ext-install mbstring \
        && docker-php-ext-install mcrypt \
        && docker-php-ext-install mysql \
        && docker-php-ext-install mysqli \
        && docker-php-ext-install pdo_mysql \
        && pip install j2cli

On reconstruit :

        $ docker-compose build http-coco 
        [... OUTPUT COUPÉ ...]
        Removing intermediate container 3a605fd30e74
        Step 5 : COPY docroot/postfixadmin-2.3.8/ /var/www/html/
         ---> 252f7f7de579
         Removing intermediate container b63121cb60e1
         Successfully built 252f7f7de579

__Oupss__ ça a marché du premier coup :P , à avoir su j'aurais tous de suite modifier le fichier __Dockerfile__ pour qu'il copie le fichier de configuration :P .

Donc ajout du fichier de configuration en __template__ dans le __Dockerfile__: 

        # Copie la configuration en format Jinja2
        COPY conf/config.inc.php.j2 /root/

Nous allons aussi modifier le __docker-compose__ afin d'avoir la définition des variables , comme il y a eu 24 heures entre l'écriture du fichier de __template__ et la définition du __docker-compose__ je vais faire l'extraction des variables , car j'ai une petite mémoire :P.

        $ cat http/conf/config.inc.php.j2 | grep {{ | sed "s/.*{{ \([A-Z_]*\) }}'/\1/g"  | tr -d "," | tr -d ";" | sort | uniq
        $CONF['database_name'] = '{{ MYSQL_DATABASE }}'
        DB_TYPE
        MAIL_DOMAIN
        MYSQL_PASSWORD
        MYSQL_USER
        SETUP_PASS


Bon presque, mais on va pas perdre plus de temps :D, l'important ici c'est pas le **sed** :D.
Voici donc nos nouvelles variables pour le __docker-compose__ :

                environment:
                    - MYSQL_USER=umail
                    - MYSQL_PASSWORD=ZePassword
                    - MYSQL_DATABASE=vmail
                    - TZ=America/Montreal
                    - TERM=xterm
                    - DB_TYPE=mysql
                    - MAIL_DOMAIN=coco.com
                    - SETUP_PASS=superPasse



### <a name="setup_http_script" /> Script de démarrage 

Comme vous pouvez le constater actuellement notre __Dockerfile__ ne contient PAS de script d'exécution :

            # Thomas Boutry
            FROM php:5-apache
            MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

            # Ignore APT warnings about not having a TTY
            ENV DEBIAN_FRONTEND noninteractive

            # Php Modules a activer
            RUN apt-get update && apt-get install -y  --no-install-recommends libmcrypt-dev python-pip python-wheel python-setuptools \
                && docker-php-ext-install mbstring \
                && docker-php-ext-install mcrypt \
                && docker-php-ext-install mysql \
                && docker-php-ext-install mysqli \
                && docker-php-ext-install pdo_mysql \
                && pip install j2cli

            # Copie l'application postfix adm
            COPY docroot/postfixadmin-2.3.8/ /var/www/html/

            # Copie la configuration en format Jinja2
            COPY conf/config.inc.php.j2 /root/

Pourtant le service __apache__ fonctionne quand on démarre le conteneur nous l'avons vu lors de la visualisation du fichier __phpinfo__. Ceci est inclut dans l'image de base **php:5-apache** :

        $ docker history php:5-apache                                                                                                                        
        IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
        9013e58a01eb        3 weeks ago         /bin/sh -c #(nop)  CMD ["apache2-foreground"]   0 B
        <missing>           3 weeks ago         /bin/sh -c #(nop)  EXPOSE 80/tcp                0 B
        <missing>           3 weeks ago         /bin/sh -c #(nop)  WORKDIR /var/www/html        0 B
        <missing>           3 weeks ago         /bin/sh -c #(nop) COPY file:24613ecbb1ce6a09f   1.346 kB
        <missing>           4 weeks ago         /bin/sh -c #(nop)  ENTRYPOINT ["docker-php-en   0 B
        <missing>           4 weeks ago         /bin/sh -c #(nop) COPY multi:2b7e23dbf0e975ef   5.33 kB
        <missing>           4 weeks ago         /bin/sh -c set -xe  && buildDeps="   $PHP_EXT   33.21 MB
        <missing>           4 weeks ago         /bin/sh -c #(nop) COPY file:207c686e3fed4f71f   587 B
        <missing>           4 weeks ago         /bin/sh -c set -xe;   fetchDeps='   wget  ';    12.98 MB

Vous pouvez le constater il y a la ligne :

* **CMD ["apache2-foreground"]**
* **ENTRYPOINT ["docker-php-en**

Nous avons besoin nous aussi d'avoir un script qui soit exécuter lors de l'initialisation du conteneur afin de faire la substitution des variables !! 

Cette situation m'a permis d'analyser la question de l'héritage des entrés **CMD** et **ENTRYPOINT** , car il y a 2 instructions possible pour exécuter une script lors de l'initialisation du conteneur. Mon objectif fut de définir une instruction pour le __run__ mais que par la suite il appel le script d'initialisation du parent !

Cependant ceci ne semble pas possible, voici l'interaction entre **CMD** et **ENTRYPOINT** :

[https://docs.docker.com/engine/reference/builder/#/entrypoint](https://docs.docker.com/engine/reference/builder/#/entrypoint)


![cmd_vs_entrypoint.png](./imgs/cmd_vs_entrypoint.png)

Nous allons donc surdéfinir l'instruction **CMD** et appeler le script **apache2-foreground** par la suite !
Donc définition du script **run.sh** :

        $ cat http/run.sh
        #! /usr/bin/env bash
        set -e # exit on error

        # Variables
        export MYSQL_USER=${MYSQL_USER:-"myuser"}
        export MYSQL_PASSWORD=${MYSQL_PASSWORD:-"superpass"}
        export MYSQL_DATABASE=${MYSQL_DATABASE:-"mails"}
        export DB_TYPE=${DB_TYPE:-"mysql"}
        export MAIL_DOMAIN=${MAIL_DOMAIN:-"example.com"}
        export SETUP_PASS=${SETUP_PASS:-"fkrhreiu"}

        # Templates
        j2 /root/config.inc.php.j2 > /var/www/html/config.inc.php

        # Rappel de la commande CMD du script original
        apache2-foreground

Modification du __Dockerfile__ :

        [... OUTPUT COUPÉ ...]
        # Copie la configuration en format Jinja2
        COPY conf/config.inc.php.j2 /root/

        # script pour la substitution
        ADD run.sh /

        CMD ["/run.sh"]

On reconstruit l'image et on valide :

        $ docker-compose build http-coco
        $ docker-compose up http-coco
        $ docker exec coco-http-t cat /var/www/html/config.inc.php | grep -i coco                                                                             
        $CONF['admin_email'] = 'postmaster@coco.com';
        'abuse' => 'abuse@coco.com',
        'hostmaster' => 'hostmaster@coco.com',
        'postmaster' => 'postmaster@coco.com',
        'webmaster' => 'webmaster@coco.com'

Ça semble bon :D

### <a name="setup_http_app_postfixadm" /> Validation de l'application postfixadmin

J'ai arrêté le conteneur __http__ pour démarrer l'ensemble __http__ ET __bd__ 

        $ docker-compose up
        [... OUTPUT COUPÉ ...]
        coco-db-t    | 170223  8:06:13 [Note] Event Scheduler: Loaded 0 events
        coco-db-t    | 170223  8:06:13 [Note] mysqld: ready for connections.
        coco-db-t    | Version: '5.5.52'  socket: '/tmp/mysql.sock'  port: 3306  MySQL Community Server (GPL)
        coco-http-t  | [Thu Feb 23 08:13:25.903190 2017] [mpm_prefork:notice] [pid 8] AH00163: Apache/2.4.10 (Debian) PHP/5.6.30 configured -- resuming normal operations
        coco-http-t  | [Thu Feb 23 08:13:25.903242 2017] [core:notice] [pid 8] AH00094: Command line: 'apache2 -D FOREGROUND'


Extraction de l'IP du serveur __http__ :

        $ docker inspect coco-http-t | grep IPAddre
                    "SecondaryIPAddresses": null,
                        "IPAddress": "",
                        "IPAddress": "172.22.0.2",

Si vous allez à la page [http://172.22.0.2](http://172.22.0.2) , vous aurez la page d'authentification :

![postfixadm-home.png](./imgs/postfixadm-home.png)

Si nous reprenons les instructions d'installation de __postfixadmin__ [INSTALL.TXT](https://github.com/albanpeignier/postfixadmin/blob/master/INSTALL.TXT) vous pourrez voir à l'étape 4 que nous devons aller à l'URL [http://172.22.0.2/setup.php](http://172.22.0.2/setup.php) pour compléter l'installation.

On va le faire ! Donc je vais à la page [http://172.22.0.2/setup.php](http://172.22.0.2/setup.php) 

Voici le résultat 

![postfixadm-setup1.png](./imgs/postfixadm-setup1.png)
![postfixadm-setup2.png](./imgs/postfixadm-setup2.png)

Regardons l'état de la Base de donnée :


        $ docker exec -it coco-db-t mysql -u umail -p
        Enter password:
        Welcome to the MySQL monitor.  Commands end with ; or \g.
        [ ... OUTPUT COUPÉ ...]
        mysql> use vmail;

        mysql> show tables;
        +-----------------------+
        | Tables_in_vmail       |
        +-----------------------+
        | admin                 |
        | alias                 |
        | alias_domain          |
        | config                |
        | domain                |
        | domain_admins         |
        | fetchmail             |
        | log                   |
        | mailbox               |
        | quota                 |
        | quota2                |
        | vacation              |
        | vacation_notification |
        +-----------------------+
        13 rows in set (0.00 sec)

        mysql> select * from admin;
        Empty set (0.00 sec)

        mysql> select * from config;
        +----+---------+-------+
        | id | name    | value |
        +----+---------+-------+
        |  1 | version | 740   |
        +----+---------+-------+
        1 row in set (0.00 sec)



Ajoutons l'administrateur ! 

* __Setup password : password__
* __Admin: xerus@coco.com__
* __Password: blabla__
* __Password (again): blabla__

Une fois l'opération réaliser voici le résultat :

![postfixadm-setup3.png](./imgs/postfixadm-setup3.png)


Si nous regardons dans la BD maintenant :

        mysql> select * from admin;
        Empty set (0.00 sec)

RIEN !!! **ishh** , 

Il y a l'information suivante sur la page web: 

        If you want to use the password you entered as setup password, edit config.inc.php and set
        
        $CONF['setup_password'] = 'e483919d4e684d4bff3669f0a50f6c57:805a8aa8ff92297d7e83c74a5cd1a7f9827ecfdb';

Une fois que j'ai modifier le fichier __coco-http-t:/var/www/html/config.inc.php__ pour définir la variable convenable ceci à très bien fonctionné :-/.
J'ai refait l'opération et j'ai eu l'information suivante :

![postfixadm-setup4.png](./imgs/postfixadm-setup4.png)

Si je valide dans la base de donnée :

        mysql> select * from admin;
        +----------------+------------------------------------+---------------------+---------------------+--------+
        | username       | password                           | created             | modified            | active |
        +----------------+------------------------------------+---------------------+---------------------+--------+
        | xerus@coco.com | $1$f02bfd0b$g.W7zDWmgCve8tBsKo5Fn. | 2017-02-23 08:33:27 | 2017-02-23 08:33:27 |      1 |
        +----------------+------------------------------------+---------------------+---------------------+--------+
        1 row in set (0.00 sec)

Et via l'interface j'arrive bien à m'authentifier :

![postfixadm-main-admin.png](./imgs/postfixadm-main-admin.png)

Bon maintenant LA question , mais comment faire pour que ce soit automatique ?!?! Ce n'est pas quelque chose de compliqué, cependant nous aimerions pouvoir déployer des conteneurs avec le système de __postfixadmin__ __pré-configurer__ en définissant l'administrateur par défaut en variable. N'est-ce pas ?
Bien entendu je démontre ici pour __postfixadmin__ mais c'est une configuration très classique.
