<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 

# <a name="Intro" /> Introduction

Telle que mentionné plusieurs fois lors des sessions précédente l'utilisation d'utilisateur local ne permet pas une gestion massive d'utilisateur, ceci nous limite beaucoup en particulier pour :

* La délégation de la création des comptes
* La modification des mot de passe
* La gestion des adresses similaire pour plusieurs domaine (ex: __info@coco.com et info@blabla.com__)
* La sécurisation de l'environnement, car chaque personne à un compte localement sur la machine
* ....

Un solution préconiser est l'utilisation d'une base de donnée pour le stockage des informations client. 
Voici ce que nous allons couvrir :

* Mise en place de postfix avec des comptes virtuels
* Intégration de postfix avec une base de données
* Mise en place d'une interface de gestion des comptes
* Intégration avec le serveur dovecot __imap__
* Un __webmail__ ? On verra selon le temps :-/

On va réaliser l'opération dans des conteneurs directement, maintenant que l'on y arrive chaque fois du premier coup :P  !

Voici un schéma des communications entre les conteneurs / application :

![flux_communication_smtp-bd-imap-http.png](./imgs/flux_communication_smtp-bd-imap-http.png)

Comme vous pouvez le constater la base de donnée est centrale dans le système , de les données sont uniquement fournit par le conteneur **imap** !

# <a name="setup_img" /> Configuration des images 

Telle que mentionné pour gagné du temps on va tous de suite le faire avec des conteneurs, si vous désirez le mettre en place uniquement sur une machines il suffira de reprendre l'ensemble des commandes des conteneurs et faire l'opération sur **LA** machine.

## <a name="setup_db" /> Configuration de la base de donnée

Comme l'ensemble du système repose sur la base de donnée, nous allons débuter par ce conteneur et construire autour . L'avantage aussi de débuter par ce conteneur et que l'image est déjà disponible . [https://hub.docker.com](https//hub.docker.com) offre un conteneur officiel de [Mysql](https://hub.docker.com/_/mysql/).

Si nous regardons le descriptif nous avons ceci :

        MYSQL_USER, MYSQL_PASSWORD
        These variables are optional, used in conjunction to create a new user and to set that user's password. This user will be granted superuser permissions (see above) for the database specified by the MYSQL_DATABASE variable. Both variables are required for a user to be created.

En d'autre mot en passant les variables d'environnement le système va automatiquement faire la création de l'utilisateur / mot de passe et de la BD .

On essaye :D , on sait jamais peut-être que le site ment :P.

        $ docker run -e MYSQL_USER=umail -e MYSQL_PASSWORD=ZePassword -e MYSQL_DATABASE=vmail -e MYSQL_RANDOM_ROOT_PASSWORD=yes  mysql:5.5
        Initializing database
        170217 22:18:49 [Note] /usr/local/mysql/bin/mysqld (mysqld 5.5.52) starting as process 60 ...
        170217 22:18:50 [Note] /usr/local/mysql/bin/mysqld (mysqld 5.5.52) starting as process 66 ...

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
        f95afd51c1e2        mysql:5.5           "docker-entrypoint.sh"   28 seconds ago      Up 27 seconds       3306/tcp            pensive_bohr

        $ docker exec -it pensive_bohr mysql -u umail -p
        Enter password:
        mysql> show databases;
        +--------------------+
        | Database           |
        +--------------------+
        | information_schema |
        | vmail              |
        +--------------------+
        2 rows in set (0.00 sec)

        mysql> use vmail;
        Database changed
        mysql> show tables;
        Empty set (0.00 sec)

        mysql> Bye

Là on peut dire du premier coup :P !!!

Bon on fait le __docker-compose__ tous de suite !!

        version: '2'
        services:
            db-coco:
                image: mysql:5.5
                restart: unless-stopped
                container_name : 'coco-db-t'
                hostname: db.coco.com
                environment:
                    - MYSQL_USER=umail
                    - MYSQL_PASSWORD=ZePassword
                    - MYSQL_DATABASE=vmail
                    - MYSQL_RANDOM_ROOT_PASSWORD=yes
                    - TZ=America/Montreal
                    - TERM=xterm
                volumes:
                    - /srv/docker/coco-db-t/var_lib_mysql:/var/lib/mysql

Comme vous pouvez le constater j'ai exporter le répertoire __/var/lib/mysql__ sur le docker host pour conserver les données hors du conteneur.
On le valide :

        $ docker-compose up
        Creating network "srvmailwithimapwithbd_default" with the default driver
        Creating coco-db-t
        Attaching to coco-db-t
        coco-db-t  | Initializing database

Encore du premier coup , on y prend goût :D, pas de panique ça ne durera pas :D.

## <a name="setup_http" /> Configuration du service Web pour la gestion de la base de donnée

Maintenant que l'on a une base de donnée vierge nous allons la remplir avec le système [postfixadmin](http://postfixadmin.sourceforge.net/), ce système permet de contrôler et définir des domaines , adresses courriels, utilisateur , ... Là pas de bol pas de conteneur officiel, on va devoir s'amuser :D. 
Par contre nous avons un conteneur officiel pour [php](https://hub.docker.com/_/php/) , au lieu de démarrer avec un Ubuntu et installer apache et **php** nous allons démarrer avec le conteneur officiel ! Faut bien faire changement un peu de temps en temps :D, histoire d'avoir de nouveau problème :D.

Si vous regardez la page il y a plusieurs type de conteneur disponible :

        5.6.30-cli, 5.6-cli, 5-cli, 5.6.30, 5.6, 5 (5.6/Dockerfile)
        5.6.30-alpine, 5.6-alpine, 5-alpine (5.6/alpine/Dockerfile)
        5.6.30-apache, 5.6-apache, 5-apache (5.6/apache/Dockerfile)
        5.6.30-fpm, 5.6-fpm, 5-fpm (5.6/fpm/Dockerfile)

* **cli** :  pour utiliser __php__ en commande line
* **alpine** : Utilise une version minimal de Linux
* **apache** : Avec le serveur web apache

La version alpine est un conteneur plus minimal , alpine est une distribution moins gourmand en espace disque , alors que la version "non" alpine est un conteneur dérivé de debian (si je ne me trompe pas). On va commencer par la version "normale" et on analysera si on peut passer au mode alpine par la suite.

Avant de se lancer dans __Dockerfile__ définissons les grandes lignes que ceci devra conteneur , nous allons vouloir installer [postfixadmin](http://postfixadmin.sourceforge.net/) , donc prenons la documentation . [https://github.com/albanpeignier/postfixadmin/blob/master/INSTALL.TXT](https://github.com/albanpeignier/postfixadmin/blob/master/INSTALL.TXT) 

Nous avons donc besoin :

* apache (bien entendu)
* __PHP__ 4.1 ou plus (5.X recommandé )
* Module __php__ pour établir une connexion __Mysql__

Je vais d'abord valider l'image __php:5-apache__ Je la récupère donc depuis [hub.docker.com](http://hub.docker.com).

        $ docker pull php:5-apache
        5-apache: Pulling from library/php

Si nous regardons la page du conteneur __php__ nous pourrons constater qu'il y a le lien vers le __dockerFile__ du package : [php:5-apache](https://github.com/docker-library/php/blob/e573f8f7fda5d7378bae9c6a936a298b850c4076/5.6/apache/Dockerfile), nous voyons clairement que la référence est un __debian:jessie__.

Vous pouvez le démarrer pour vous faire la main dessus, car être confortable est très important , bon moi j'ai envie de le faire "live", je vais débuter avec un __dockerfile__ :P après le succès de __MySQL__ j'ai crois :P.

Voici le __dockerfile__ : 

        # Thomas Boutry
        FROM php:5-apache
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Php Modules a activer
        RUN docker-php-ext-install mbstring \
            && docker-php-ext-install mcrypt \
            && docker-php-ext-install mysql \
            && docker-php-ext-install mysqli \
            && docker-php-ext-install pdo_mysql


La particularité ici , entre une machine "classique" et le conteneur __php__ , l'instruction d'installation des modules aurais été comme suit pour une installe classique  :

        RUN apt-get update \
            && apt-get install php-mcrypt php-mysql php-mysqli 

Mais le système de docker officiel offre une autre possibilité , que j'ai envie d'essayer :D , donc j'ai pris la philosophie du conteneur ! 

On construit l'image :

        $ docker build -t postfixadmin .
        [ ... OUTPUT COUPÉ ...]
        checking if nawk is broken... no
        checking for mcrypt support... yes, shared
        configure: error: mcrypt.h not found. Please reinstall libmcrypt.
        The command '/bin/sh -c docker-php-ext-install mbstring     && docker-php-ext-install mcrypt     && docker-php-ext-install mysql     && docker-php-ext-install mysqli     && docker-php-ext-install pdo_mysql' returned a non-zero code: 1


Nous pouvons voir que lors de la création du conteneur , le système compile les modules à ajouter il a donc besoin des packages sources pour réaliser l'opération je vais faire l'ajout. 


        # Thomas Boutry
        FROM php:5-apache
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Php Modules a activer 
        RUN apt-get update && apt-get install -y  --no-install-recommends libmcrypt-dev \
            && docker-php-ext-install mbstring \
            && docker-php-ext-install mcrypt \
            && docker-php-ext-install mysql \
            && docker-php-ext-install mysqli \
            && docker-php-ext-install pdo_mysql


        $ docker build -t postfixadmin .
        [ ... OUTPUT COUPÉ ... ]
        rm -f libphp.la       modules/* libs/*
         ---> 5e8e831c6a96
         Removing intermediate container 6d35d7aee6b8
         Successfully built 5e8e831c6a96


Super nous avons donc notre conteneur avec l'ensemble d'installer ... Du moins on le pense (honnêtement je le sais pas moi même à ce stade :D , on découvre ensemble !! ).

Je vais démarrer le conteneur et mettre en place un fichier __phpinfo__ afin de confirmer ce qui est bien présent :D .

        $ docker run  postfixadmin
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message
        [Mon Feb 20 13:37:20.574334 2017] [mpm_prefork:notice] [pid 1] AH00163: Apache/2.4.10 (Debian) PHP/5.6.30 configured -- resuming normal operations
        [Mon Feb 20 13:37:20.574363 2017] [core:notice] [pid 1] AH00094: Command line: 'apache2 -D FOREGROUND'

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
        095673118d88        postfixadmin        "docker-php-entrypoin"   15 seconds ago      Up 13 seconds       80/tcp              focused_hawking

        $ docker exec -it focused_hawking bash
        root@095673118d88:/var/www/html# pwd
        /var/www/html

Comme je n'ai pas **vi** sur la machine je vais simplement faire la création avec __echo__ 

        root@095673118d88:/var/www/html# echo "<?php  phpinfo(); ?>" >> index.php

Visualisation du résultat :

![php_docker-view-phpinfo.png](./imgs/php_docker-view-phpinfo.png)

Bien entendu vous pouvez visualiser le conteneur de la configuration apache dans **/etc/apache2**, je vous laisse le plaisir !

Parfait après validation nous pouvons dire que ceci semble convenable, nous allons maintenant ajouter la configuration de __postfixadmin__. Je télécharge l'application depuis internet [https://sourceforge.net/projects/postfixadmin/files/postfixadmin/postfixadmin-2.3.8/](https://sourceforge.net/projects/postfixadmin/files/postfixadmin/postfixadmin-2.3.8/).

J'ai placé l'application dans le répertoire __docroot__

        $ ls http/
        Dockerfile  docroot

        $ ls http/docroot/
        postfixadmin-2.3.8

        $ ls -1 http/docroot/postfixadmin-2.3.8/ | head -5
        ADDITIONS
        admin
        backup.php
        broadcast-message.php
        CHANGELOG.TXT

Modification du __Dockerfile__ en conséquence. 

        COPY docroot/postfixadmin-2.3.8/ /var/www/html/

Nous allons aussi profiter du moment pour modifier le fichier __docker-compose.yml__ :


        version: '2'
        services:
            db-coco:
                image: mysql:5.5
                restart: unless-stopped
                container_name : 'coco-db-t'
                hostname: db.coco.com
                environment:
                    - MYSQL_USER=umail
                    - MYSQL_PASSWORD=ZePassword
                    - MYSQL_DATABASE=vmail
                    - MYSQL_RANDOM_ROOT_PASSWORD=yes
                    - TZ=America/Montreal
                    - TERM=xterm
                volumes:
                    - /srv/docker/coco-db-t/var_lib_mysql:/var/lib/mysql
            http-coco:
                image: postfixadmin
                build: ./http/
                restart: unless-stopped
                container_name : 'coco-http-t'
                hostname: mail.coco.com
                links:
                    - db-coco:mysql-db
                environment:
                    - MYSQL_USER=umail
                    - MYSQL_PASSWORD=ZePassword
                    - MYSQL_DATABASE=vmail
                    - TZ=America/Montreal
                    - TERM=xterm

L'ensemble est pas mal déjà maîtrisé , petit détail qui fut ajouté la ligne suivante :

        build: ./http/

Ceci me permet de réaliser des constructions d'image directement avec la commande __docker-compose__ au lieu de changer de répertoire et de faire __docker build -t ....__ :D. Ça commençais  à m'ennuyer de changer de répertoire tous le temps. Résultat  :

        $ docker-compose build http-coco
        Building http-coco
        Step 1 : FROM php:5-apache
         ---> 9013e58a01eb
         Step 2 : MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>
          ---> Using cache
           ---> 1ab4c14a8cbd
        [ ... OUTPUT COUPÉ ... ]


Nous réalisons un teste avec les 2 conteneurs :

        $ docker-compose up
        Starting coco-db-t
        Creating coco-http-t
        Attaching to coco-db-t, coco-http-t
        coco-db-t    | 170221  8:18:38 [Note] mysqld (mysqld 5.5.52) starting as process 1 ...
        coco-db-t    | 170221  8:18:38 [Note] Plugin 'FEDERATED' is disabled.
        coco-db-t    | 170221  8:18:38 InnoDB: The InnoDB memory heap is disabled
        coco-db-t    | 170221  8:18:38 InnoDB: Mutexes and rw_locks use GCC atomic builtins
        coco-db-t    | 170221  8:18:38 InnoDB: Compressed tables use zlib 1.2.3
        coco-db-t    | 170221  8:18:38 InnoDB: Using Linux native AIO

![default_page_postfixadm.png](./imgs/default_page_postfixadm.png)


Pas trop mal :D. Nous pouvons réaliser le **setup** : [http://172.22.0.3/setup.php](http://172.22.0.3/setup.php) Bien entendu votre IP peut être tous autre.

[erreur_setup_postfixadm-01.png](./imgs/erreur_setup_postfixadm-01.png)

**yeahh** des problèmes on finira pas trop tôt la formation ;-).

Bon clairement il manque la configuration du fichier ! Nous allons donc regarder ce dit fichier. Le fichier est dans le répertoire **http/docroot/postfixadmin-2.3.8/config.inc.php**.

Premièrement je vais réaliser une copie du fichier , le nouveau fichier sera de type **jinja2**

        $ mkdir http/conf/
        $ cp http/docroot/postfixadmin-2.3.8/config.inc.php http/conf/config.inc.php.j2


Voici les changements réalisés :


        $ diff http/conf/config.inc.php.j2 http/docroot/postfixadmin-2.3.8/config.inc.php  
        26c26
        < $CONF['configured'] = true;
        ---
        > $CONF['configured'] = false;
        31c31
        < $CONF['setup_password'] = '{{ SETUP_PASS }}';
        ---
        > $CONF['setup_password'] = 'changeme';
        49,53c49,53
        < $CONF['database_type'] = '{{ DB_TYPE }}';
        < $CONF['database_host'] = 'db';
        < $CONF['database_user'] = '{{ MYSQL_USER }}';
        < $CONF['database_password'] = '{{ MYSQL_PASSWORD }}';
        < $CONF['database_name'] = '{{ MYSQL_DATABASE }}';
        ---
        > $CONF['database_type'] = 'mysql';
        > $CONF['database_host'] = 'localhost';
        > $CONF['database_user'] = 'postfix';
        > $CONF['database_password'] = 'postfixadmin';
        > $CONF['database_name'] = 'postfix';
        82c82
        < $CONF['admin_email'] = 'postmaster@{{ MAIL_DOMAIN }}';
        ---
        > $CONF['admin_email'] = 'postmaster@change-this-to-your.domain.tld';
        133,136c133,136
        <     'abuse' => 'abuse@{{ MAIL_DOMAIN }}',
        <     'hostmaster' => 'hostmaster@{{ MAIL_DOMAIN }}',
        <     'postmaster' => 'postmaster@{{ MAIL_DOMAIN }}',
        <     'webmaster' => 'webmaster@{{ MAIL_DOMAIN }}'
        ---
        >     'abuse' => 'abuse@change-this-to-your.domain.tld',
        >     'hostmaster' => 'hostmaster@change-this-to-your.domain.tld',
        >     'postmaster' => 'postmaster@change-this-to-your.domain.tld',
        >     'webmaster' => 'webmaster@change-this-to-your.domain.tld'

J'ai donc modifier les paramètres de définitions de la base de donnée ainsi que la définition du domaine __change-this-to-your.domain.tld__ pour la variable __MAIL\_DOMAIN__ . **ATTENTION** je ne prétend pas que l'ensemble de la configuration est complète je vous invite à refaire une validation !!!

C'est cool tous ça mais on a pas installé le système de conversion __jinja2__ :P faut modifier le __Dockerfile__ :

        # Php Modules a activer
        RUN apt-get update && apt-get install -y  --no-install-recommends libmcrypt-dev python-pip python-wheel python-setuptools \
        && docker-php-ext-install mbstring \
        && docker-php-ext-install mcrypt \
        && docker-php-ext-install mysql \
        && docker-php-ext-install mysqli \
        && docker-php-ext-install pdo_mysql \
        && pip install j2cli

On reconstruit :

        $ docker-compose build http-coco 
        [... OUTPUT COUPÉ ...]
        Removing intermediate container 3a605fd30e74
        Step 5 : COPY docroot/postfixadmin-2.3.8/ /var/www/html/
         ---> 252f7f7de579
         Removing intermediate container b63121cb60e1
         Successfully built 252f7f7de579

__Oupss__ ça a marché du premier coup :P , à avoir su j'aurais tous de suite modifier le fichier __Dockerfile__ pour qu'il copie le fichier de configuration :P .

Donc ajout du fichier de configuration en __template__ dans le __Dockerfile__: 

        # Copie la configuration en format Jinja2
        COPY conf/config.inc.php.j2 /root/

Nous allons aussi modifier le __docker-compose__ afin d'avoir la définition des variables , comme il y a eu 24 heures entre l'écriture du fichier de __template__ et la définition du __docker-compose__ je vais faire l'extraction des variables , car j'ai une petite mémoire :P.

        $ cat http/conf/config.inc.php.j2 | grep {{ | sed "s/.*{{ \([A-Z_]*\) }}'/\1/g"  | tr -d "," | tr -d ";" | sort | uniq
        $CONF['database_name'] = '{{ MYSQL_DATABASE }}'
        DB_TYPE
        MAIL_DOMAIN
        MYSQL_PASSWORD
        MYSQL_USER
        SETUP_PASS


Bon presque, mais on va pas perdre plus de temps :D, l'important ici c'est pas le **sed** :D.
Voici donc nos nouvelles variables pour le __docker-compose__ :

                environment:
                    - MYSQL_USER=umail
                    - MYSQL_PASSWORD=ZePassword
                    - MYSQL_DATABASE=vmail
                    - TZ=America/Montreal
                    - TERM=xterm
                    - DB_TYPE=mysql
                    - MAIL_DOMAIN=coco.com
                    - SETUP_PASS=superPasse



### <a name="setup_http_script" /> Script de démarrage 

Comme vous pouvez le constater actuellement notre __Dockerfile__ ne contient PAS de script d'exécution :

            # Thomas Boutry
            FROM php:5-apache
            MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

            # Ignore APT warnings about not having a TTY
            ENV DEBIAN_FRONTEND noninteractive

            # Php Modules a activer
            RUN apt-get update && apt-get install -y  --no-install-recommends libmcrypt-dev python-pip python-wheel python-setuptools \
                && docker-php-ext-install mbstring \
                && docker-php-ext-install mcrypt \
                && docker-php-ext-install mysql \
                && docker-php-ext-install mysqli \
                && docker-php-ext-install pdo_mysql \
                && pip install j2cli

            # Copie l'application postfix adm
            COPY docroot/postfixadmin-2.3.8/ /var/www/html/

            # Copie la configuration en format Jinja2
            COPY conf/config.inc.php.j2 /root/

Pourtant le service __apache__ fonctionne quand on démarre le conteneur nous l'avons vu lors de la visualisation du fichier __phpinfo__. Ceci est inclut dans l'image de base **php:5-apache** :

        $ docker history php:5-apache                                                                                                                        
        IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
        9013e58a01eb        3 weeks ago         /bin/sh -c #(nop)  CMD ["apache2-foreground"]   0 B
        <missing>           3 weeks ago         /bin/sh -c #(nop)  EXPOSE 80/tcp                0 B
        <missing>           3 weeks ago         /bin/sh -c #(nop)  WORKDIR /var/www/html        0 B
        <missing>           3 weeks ago         /bin/sh -c #(nop) COPY file:24613ecbb1ce6a09f   1.346 kB
        <missing>           4 weeks ago         /bin/sh -c #(nop)  ENTRYPOINT ["docker-php-en   0 B
        <missing>           4 weeks ago         /bin/sh -c #(nop) COPY multi:2b7e23dbf0e975ef   5.33 kB
        <missing>           4 weeks ago         /bin/sh -c set -xe  && buildDeps="   $PHP_EXT   33.21 MB
        <missing>           4 weeks ago         /bin/sh -c #(nop) COPY file:207c686e3fed4f71f   587 B
        <missing>           4 weeks ago         /bin/sh -c set -xe;   fetchDeps='   wget  ';    12.98 MB

Vous pouvez le constater il y a la ligne :

* **CMD ["apache2-foreground"]**
* **ENTRYPOINT ["docker-php-en**

Nous avons besoin nous aussi d'avoir un script qui soit exécuter lors de l'initialisation du conteneur afin de faire la substitution des variables !! 

Cette situation m'a permis d'analyser la question de l'héritage des entrés **CMD** et **ENTRYPOINT** , car il y a 2 instructions possible pour exécuter une script lors de l'initialisation du conteneur. Mon objectif fut de définir une instruction pour le __run__ mais que par la suite il appel le script d'initialisation du parent !

Cependant ceci ne semble pas possible, voici l'interaction entre **CMD** et **ENTRYPOINT** :

[https://docs.docker.com/engine/reference/builder/#/entrypoint](https://docs.docker.com/engine/reference/builder/#/entrypoint)


![cmd_vs_entrypoint.png](./imgs/cmd_vs_entrypoint.png)

Nous allons donc surdéfinir l'instruction **CMD** et appeler le script **apache2-foreground** par la suite !
Donc définition du script **run.sh** :

        $ cat http/run.sh
        #! /usr/bin/env bash
        set -e # exit on error

        # Variables
        export MYSQL_USER=${MYSQL_USER:-"myuser"}
        export MYSQL_PASSWORD=${MYSQL_PASSWORD:-"superpass"}
        export MYSQL_DATABASE=${MYSQL_DATABASE:-"mails"}
        export DB_TYPE=${DB_TYPE:-"mysql"}
        export MAIL_DOMAIN=${MAIL_DOMAIN:-"example.com"}
        export SETUP_PASS=${SETUP_PASS:-"fkrhreiu"}

        # Templates
        j2 /root/config.inc.php.j2 > /var/www/html/config.inc.php

        # Rappel de la commande CMD du script original
        apache2-foreground

Modification du __Dockerfile__ :

        [... OUTPUT COUPÉ ...]
        # Copie la configuration en format Jinja2
        COPY conf/config.inc.php.j2 /root/

        # script pour la substitution
        ADD run.sh /

        CMD ["/run.sh"]

On reconstruit l'image et on valide :

        $ docker-compose build http-coco
        $ docker-compose up http-coco
        $ docker exec coco-http-t cat /var/www/html/config.inc.php | grep -i coco                                                                             
        $CONF['admin_email'] = 'postmaster@coco.com';
        'abuse' => 'abuse@coco.com',
        'hostmaster' => 'hostmaster@coco.com',
        'postmaster' => 'postmaster@coco.com',
        'webmaster' => 'webmaster@coco.com'

Ça semble bon :D

### <a name="setup_http_app_postfixadm" /> Validation de l'application postfixadmin

J'ai arrêté le conteneur __http__ pour démarrer l'ensemble __http__ ET __bd__ 

        $ docker-compose up
        [... OUTPUT COUPÉ ...]
        coco-db-t    | 170223  8:06:13 [Note] Event Scheduler: Loaded 0 events
        coco-db-t    | 170223  8:06:13 [Note] mysqld: ready for connections.
        coco-db-t    | Version: '5.5.52'  socket: '/tmp/mysql.sock'  port: 3306  MySQL Community Server (GPL)
        coco-http-t  | [Thu Feb 23 08:13:25.903190 2017] [mpm_prefork:notice] [pid 8] AH00163: Apache/2.4.10 (Debian) PHP/5.6.30 configured -- resuming normal operations
        coco-http-t  | [Thu Feb 23 08:13:25.903242 2017] [core:notice] [pid 8] AH00094: Command line: 'apache2 -D FOREGROUND'


Extraction de l'IP du serveur __http__ :

        $ docker inspect coco-http-t | grep IPAddre
                    "SecondaryIPAddresses": null,
                        "IPAddress": "",
                        "IPAddress": "172.22.0.2",

Si vous allez à la page [http://172.22.0.2](http://172.22.0.2) , vous aurez la page d'authentification :

![postfixadm-home.png](./imgs/postfixadm-home.png)

Si nous reprenons les instructions d'installation de __postfixadmin__ [INSTALL.TXT](https://github.com/albanpeignier/postfixadmin/blob/master/INSTALL.TXT) vous pourrez voir à l'étape 4 que nous devons aller à l'URL [http://172.22.0.2/setup.php](http://172.22.0.2/setup.php) pour compléter l'installation.

On va le faire ! Donc je vais à la page [http://172.22.0.2/setup.php](http://172.22.0.2/setup.php) 

Voici le résultat 

![postfixadm-setup1.png](./imgs/postfixadm-setup1.png)
![postfixadm-setup2.png](./imgs/postfixadm-setup2.png)

Regardons l'état de la Base de donnée :


        $ docker exec -it coco-db-t mysql -u umail -p
        Enter password:
        Welcome to the MySQL monitor.  Commands end with ; or \g.
        [ ... OUTPUT COUPÉ ...]
        mysql> use vmail;

        mysql> show tables;
        +-----------------------+
        | Tables_in_vmail       |
        +-----------------------+
        | admin                 |
        | alias                 |
        | alias_domain          |
        | config                |
        | domain                |
        | domain_admins         |
        | fetchmail             |
        | log                   |
        | mailbox               |
        | quota                 |
        | quota2                |
        | vacation              |
        | vacation_notification |
        +-----------------------+
        13 rows in set (0.00 sec)

        mysql> select * from admin;
        Empty set (0.00 sec)

        mysql> select * from config;
        +----+---------+-------+
        | id | name    | value |
        +----+---------+-------+
        |  1 | version | 740   |
        +----+---------+-------+
        1 row in set (0.00 sec)



Ajoutons l'administrateur ! 

* __Setup password : password__
* __Admin: xerus@coco.com__
* __Password: blabla__
* __Password (again): blabla__

Une fois l'opération réaliser voici le résultat :

![postfixadm-setup3.png](./imgs/postfixadm-setup3.png)


Si nous regardons dans la BD maintenant :

        mysql> select * from admin;
        Empty set (0.00 sec)

RIEN !!! **ishh** , 

Il y a l'information suivante sur la page web: 

        If you want to use the password you entered as setup password, edit config.inc.php and set
        
        $CONF['setup_password'] = 'e483919d4e684d4bff3669f0a50f6c57:805a8aa8ff92297d7e83c74a5cd1a7f9827ecfdb';

Une fois que j'ai modifier le fichier __coco-http-t:/var/www/html/config.inc.php__ pour définir la variable convenable ceci à très bien fonctionné :-/.
J'ai refait l'opération et j'ai eu l'information suivante :

![postfixadm-setup4.png](./imgs/postfixadm-setup4.png)

Si je valide dans la base de donnée :

        mysql> select * from admin;
        +----------------+------------------------------------+---------------------+---------------------+--------+
        | username       | password                           | created             | modified            | active |
        +----------------+------------------------------------+---------------------+---------------------+--------+
        | xerus@coco.com | $1$f02bfd0b$g.W7zDWmgCve8tBsKo5Fn. | 2017-02-23 08:33:27 | 2017-02-23 08:33:27 |      1 |
        +----------------+------------------------------------+---------------------+---------------------+--------+
        1 row in set (0.00 sec)

Et via l'interface j'arrive bien à m'authentifier :

![postfixadm-main-admin.png](./imgs/postfixadm-main-admin.png)

Bon maintenant LA question , mais comment faire pour que ce soit automatique ?!?! Ce n'est pas quelque chose de compliqué, cependant nous aimerions pouvoir déployer des conteneurs avec le système de __postfixadmin__ __pré-configurer__ en définissant l'administrateur par défaut en variable. N'est-ce pas ?
Bien entendu je démontre ici pour __postfixadmin__ mais c'est une configuration très classique, beaucoup d'application offre l'option de configuration avec 2 ou 3 étapes. 

**Clarifions  quelque choses** : La je vous montre ça puis ça va avoir l'air très simple, mais dans la réalité je viens de l'apprendre !! :P Oui moi aussi j'apprends avec ces formations faut bien que ce soit gagnant / gagnant :D . J'ai mis un peu de temps 1 heure 30 pour juste trouver comment communiquer avec la page __setup.php__ :P.



### <a name="test_feed_automatic_setup" /> Explication pour le remplissage automatique du formulaire avec CURL

Voici l'explication des testes que j'ai réalisé , premièrement j'ai valider quelle application en ligne de commande :

        $ docker exec -it coco-http-t bash
        root@mail:/var/www/html# wget
        bash: wget: command not found
        root@mail:/var/www/html# curl --version
        curl 7.38.0 (x86_64-pc-linux-gnu) libcurl/7.38.0 OpenSSL/1.0.1t zlib/1.2.8 libidn/1.29 libssh2/1.4.3 librtmp/2.3
        Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp scp sftp smtp smtps telnet tftp
        Features: AsynchDNS IDN IPv6 Largefile GSS-API SPNEGO NTLM NTLM_WB SSL libz TLS-SRP

Je ne voulais pas installer une autre application dans le conteneur , donc ce sera **curl** c'est bien :D.

Maintenant nous avons besoin de faire 2 opérations :

1. Générer le mot de passe de __setup__ et le mettre dans le fichier __config.inc.php__ .
2. Définir un administrateur et mot de passe avec le mot de passe utilisé pour la génération.

Avec l'instance du conteneur en place nous pouvons faire autant de teste que l'on désire il faudra juste ajuster le fichier de configuration.

J'ai trouvé si le site très bien fait  [BASH: Filling Web Forms with cURL and wget](https://journalxtra.com/linux/bash-linuxsanity/bash-filling-web-forms-with-curl-and-wget/) une très bonne explication . Mais surtout un script qui permet d'extraire les champs du formulaire, en effet bien que l'on puisse lire le fichier __setup.php__ il n'est pas toujours facile de s'en sortir surtout si on code pas souvent ! 

TODO : fixer le lien
Comme il n'est plus disponible sur __github__ mais uniquement sur l'archive je vous l'ai mis sur le projet __github__ [formfind](TODO).

Voyons comment l'utiliser , premièrement je vais récupérer la page web __setup.php__ puis je vais le transmettre au script pour qu'il me le pré mâche :D.

        $ curl  http://172.22.0.3/setup.php > setup.html
          % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
          i                                 Dload  Upload   Total   Spent    Left  Speed
          100  2597  100  2597    0     0   230k      0 --:--:-- --:--:-- --:--:--  253k

        $ tail setup.html
           </tr>
           </table>
           </form>
           </div>

           <b>Since version 2.3 there is no requirement to delete setup.php!</b><br />
           <b>Check the config.inc.php file for any other settings that you might need to change!<br />
           </div>
           </body>
           </html>
         $ ./formfind < setup.html
         --- FORM report. Uses POST to URL "<form name="create_admin" method="post">"
         Input: NAME="form" VALUE="createadmin" (HIDDEN)
         Input: NAME="setup_password" (PASSWORD)
         Input: NAME="fUsername" (TEXT)
         Input: NAME="fPassword" (PASSWORD)
         Input: NAME="fPassword2" (PASSWORD)
         Input: NAME="submit" VALUE="Add Admin" (SUBMIT)
         --- end of FORM

**WOWWWww** maintenant facilement je vois l'ensemble des nom des champs que je dois fournir pour remplir le formulaire sans lire l'ensemble de la page __html__ :D.

Maintenant je peux utiliser la commande __curl__ pour remplir le formulaire :

        $ curl  -X POST -d "setup_password=tototitittata" -d "form=createadmin" http://172.22.0.3/setup.php | grep "CONF"
          % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                           Dload  Upload   Total   Spent    Left  Speed
          100  2904  100  2859  100    45   276k   4454 --:--:-- --:--:-- --:--:--  310k
          <li>Checking $CONF['configured'] - OK
          <div class="standout"><p><b>Setup password not specified correctly</b></p><p>If you want to use the password you entered as setup password, edit config.inc.php and set</p><pre>$CONF['setup_password'] = '4db3d5aeebfbf0a39bc2e1b8fb2b80a3:7e0ad0394dc7c76dd0185b540cd653f15224945f';</pre></div>

__Yep__ ça marche (1 heure et demi plus tard , je mettrai pas le nombre de tentative :P ) . Maintenant je dois amélioré le résultat pour n'avoir que le texte qui m'intéresse et non toute la ligne. Validons si j'ai __sed__ de présent sur la machine , mais la libre à vous de l'outil !!!

        root@mail:/var/www/html# sed --version
        sed (GNU sed) 4.2.2
        Copyright (C) 2012 Free Software Foundation, Inc.

Parfait, j'ai tous ce qu'il me faut pour travaillé ... Bon 10 minutes plus tard , je dis pas que c'est la plus belle des commandes , c'est a retravailler :) , mais le résultat est présent ! 

        $ curl  -X POST -d "setup_password=tototitittata" -d "form=createadmin" http://172.22.0.3/setup.php 2>/dev/null | grep "CONF" | grep "setup_password"
         | sed "s/.*\$CONF\['setup_password'\] = '\(.*\)';.*/\1/g"                                                                                                    
         830c77bc82bcea9a7b03259a6f56f074:c63a85565e676f3151e211f3c2ffb50b9a9c708b

Maintenant on valide que ceci fonctionne aussi dans le conteneur , car ce n'est peut-être pas la même version de __curl__ il est possible que le comportement soit différent. 

        root@mail:/var/www/html# curl  -X POST -d "setup_password=tototitittata" -d "form=createadmin" http://127.0.0.1/setup.php 2>/dev/null | grep "CONF" | grep "setup_password" | sed "s/.*\$CONF\['setup_password'\] = '\(.*\)';.*/\1/g"
        abaf7d8a20c2c7b3d89d03fc93cd8609:059e2856ff5aef253b5312fe55eaa4858f66a78f

Nous sommes donc en mesure d'extraire le résultat du mot de passe "chiffré" nous allons maintenant valider que nous sommes en mesure en utilisant la même méthode de faire la création du compte administrateur ! Je vais donc modifier manuellement dans le conteneur la valeur de **$CONF['setup_password']** avec le résultat du **hash** . Comme je n'ai pas **vim** de présent et que je n'ai qu'une ligne à modifier je vais utiliser **sed** en même temps ça donne un coup de pratique, car nous utiliserons la même méthode dans le script d'initialisation.

        root@mail:/var/www/html# sed "s/\$CONF\['setup_password'\] = 'superPasse';/\$CONF\['setup_passwo12fe55eaa4858f66a78f'/g" config.inc.php  | grep setup_pf253b531
        $CONF['setup_password'] = 'abaf7d8a20c2c7b3d89d03fc93cd8609:059e2856ff5aef253b5312fe55eaa4858f66a78f'

Ceci était uniquement pour valider je vais ajouter l'option **-i** pour que le **sed** modifie le fichier de configuration original:

        root@mail:/var/www/html# sed -i "s/\$CONF\['setup_password'\] = 'superPasse';/\$CONF\['setup_password'\] = 'abaf7d8a20c2c7b3d89d03fc93cd8609:059e2856ff5aef253b5312fe55eaa4858f66a78f';/g" config.inc.php                
        root@mail:/var/www/html# echo $?
        0
        root@mail:/var/www/html# grep "setup_pass" config.inc.php
        $CONF['setup_password'] = 'abaf7d8a20c2c7b3d89d03fc93cd8609:059e2856ff5aef253b5312fe55eaa4858f66a78f'

Je vais maintenant réutiliser **curl** pour créer un administrateur, je réutilise le script pour extraire les informations du formulaire , car je me rappelle plus des paramètres :D

        $ ./formfind < setup.html
        --- FORM report. Uses POST to URL "<form name="create_admin" method="post">"
        Input: NAME="form" VALUE="createadmin" (HIDDEN)
        Input: NAME="setup_password" (PASSWORD)
        Input: NAME="fUsername" (TEXT)
        Input: NAME="fPassword" (PASSWORD)
        Input: NAME="fPassword2" (PASSWORD)
        Input: NAME="submit" VALUE="Add Admin" (SUBMIT)
        --- end of FORM


Donc je démarre la création de l'administrateur :

        $ curl  -X POST -d "setup_password=tototitittata" -d "fUsername=admin@coco.com" -d "fPassword=superPass" -d "fPassword2=superPass" -d "form=createadmin" http://172.22.0.3/setup.php
        [ ... OUTPUT COUPÉ ... ]
        <li><b>Warning: Depends on: IMAP functions - NOT FOUND</b><br />
        To install IMAP support, install php5-imap<br />
        Without IMAP support, you won't be able to create subfolders when creating mailboxes.</li>
        </ul><p>Everything seems fine... attempting to create/update database structure</p>
        <p>Database is up to date</p>
        <div class="standout">Admin has been added!<br />(admin@coco.com)</br /></div>
        <div id="edit_form">
        <form name="create_admin" method="post">
        <input type="hidden" name="form" value="createadmin" />
        <table>
              <td colspan="3"><h3>Create superadmin account</h3></td>
                 </tr>
        [... OUTPUT COUPÉ ...]

Comme nous pouvons le voir le message indique que l'administrateur fut bien créé : **Admin has been added!** , comme on est jamais trop sûr on va valider dans la base de donnée : 

        $ docker exec -it coco-db-t mysql -u umail -p
        Enter password:
        mysql> use vmail;
        mysql> select * from admin;
        +----------------+------------------------------------+---------------------+---------------------+--------+
        | username       | password                           | created             | modified            | active |
        +----------------+------------------------------------+---------------------+---------------------+--------+
        | xerus@coco.com | $1$f02bfd0b$g.W7zDWmgCve8tBsKo5Fn. | 2017-02-23 08:33:27 | 2017-02-23 08:33:27 |      1 |
        | admin@coco.com | $1$acdd0365$OitGJK6KIulo4reFSe07t. | 2017-02-27 08:13:35 | 2017-02-27 08:13:35 |      1 |
        +----------------+------------------------------------+---------------------+---------------------+--------+

Super :D , on fait la même validation dans le conteneur juste pour être sûr bien que je suis confiant, mais si faut faire un changement je préfère le faire avant de reconstruire l'image du conteneur. 

        root@mail:/var/www/html# curl  -X POST -d "setup_password=tototitittata" -d "fUsername=admin2@coco.com" -d "fPassword=superPass" -d "fPassword2=superPass" -d "form=createadmin" http://127.0.0.1/setup.php | grep "Admin has been added!"
          % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                           Dload  Upload   Total   Spent    Left  Speed
        100  2759  100  2647  100   112  55441   2345 --:--:-- --:--:-- --:--:-- 56319
        <div class="standout">Admin has been added!<br />(admin2@coco.com)</br /></div>

        mysql> select * from admin;
        +-----------------+------------------------------------+---------------------+---------------------+--------+
        | username        | password                           | created             | modified            | active |
        +-----------------+------------------------------------+---------------------+---------------------+--------+
        | xerus@coco.com  | $1$f02bfd0b$g.W7zDWmgCve8tBsKo5Fn. | 2017-02-23 08:33:27 | 2017-02-23 08:33:27 |      1 |
        | admin@coco.com  | $1$acdd0365$OitGJK6KIulo4reFSe07t. | 2017-02-27 08:13:35 | 2017-02-27 08:13:35 |      1 |
        | admin2@coco.com | $1$e12796d0$NHeD1ypJVVdcHuiHvbmFE/ | 2017-02-27 08:19:05 | 2017-02-27 08:19:05 |      1 |
        +-----------------+------------------------------------+---------------------+---------------------+--------+

Je pense que nous sommes en affaire :D, c'est le temps de l'automatiser, nous allons reprendre le fichier **run.sh** du conteneur __http__.

* Référence : 
    * https://journalxtra.com/linux/bash-linuxsanity/bash-filling-web-forms-with-curl-and-wget/
    * https://curl.haxx.se/docs/httpscripting.html

### <a name="automatic_setup_init" /> Création automatique d'un administrateur lors de l'initialisation

Pour débuter nous allons définir des variables d'environnement pour le compte administrateur :

* **ADM_MAIL** : l'adresse de l'administrateur par défaut
* **ADM_PASS** : Mot de passe l'administrateur 
* **SETUP_PASS** : Mot de passe pour la configuration qui sera __hashé__ avec le résultat du formulaire. 

La mise en place dans le __template__ de la valeur de **$SETUP_PASS** était une erreur !!! Je vais donc modifier le fichier : **http/conf/config.inc.php.j2** afin d'avoir une valeur prévisible pour mon **sed** : (**http/conf/config.inc.php.j2**)

        Original :
        $CONF['setup_password'] = '{{ SETUP_PASS }}';

        Nouvelle valeur :
        $CONF['setup_password'] = 'curl_will_change_it';

Maintenant je vais ajouter les 2 autres variable dans le __docker-compose__ : 

            [... OUTPUT COUPÉ ... ]
                environment:
                    - MYSQL_USER=umail
                    - MYSQL_PASSWORD=ZePassword     
                    - MYSQL_DATABASE=vmail          
                    - TZ=America/Montreal           
                    - TERM=xterm
                    - DB_TYPE=mysql
                    - MAIL_DOMAIN=coco.com          
                    - SETUP_PASS=superPasse         
                    - ADM_MAIL=admin@coco.com
                    - ADM_PASS=DockerRock

Bon la partie facile est faite :P , faut bien s'attaquer au fichier **http/run.sh** :P , voici donc la nouvelle version :

        #! /usr/bin/env bash
        set -e # exit on error

        # Variables
        export MYSQL_USER=${MYSQL_USER:-"myuser"}
        export MYSQL_PASSWORD=${MYSQL_PASSWORD:-"superpass"}
        export MYSQL_DATABASE=${MYSQL_DATABASE:-"mails"}
        export DB_TYPE=${DB_TYPE:-"mysql"}
        export MAIL_DOMAIN=${MAIL_DOMAIN:-"example.com"}
        export SETUP_PASS=${SETUP_PASS:-"fkrhreiuTOTO"}
        export ADM_MAIL=${ADM_MAIL:-"NOT_DEFINE"}
        export ADM_PASS=${ADM_PASS:-"NOT_DEFINE"}

        # Validation des variables !!
        if [ "$ADM_MAIL" == "NOT_DEFINE" ] ; then
            echo 'You need to set variable $ADM_MAIL !! '
            echo "I already set all the software , I can't choose your username ;) "
            exit 1
        fi
        if [ "$ADM_PASS" == "NOT_DEFINE" ] ; then
            echo 'You need to set variable $ADM_PASS !! '
            echo "I already set all the software , I can't choose your PASSWORD ;) "
            exit 1
        fi

        # Templates
        j2 /root/config.inc.php.j2 > /var/www/html/config.inc.php

        # Initilisation de la configuration de postfix :
        SETUP_PASS_HASH=$(curl  -X POST -d "setup_password=$SETUP_PASS" -d "form=createadmin" http://127.0.0.1/setup.php 2>/dev/null | grep "CONF" | grep "setup_password" | sed "s/.*\$CONF\['setup_password'\] = '\(.*\)';.*/\1/g")

        # Update postfix configuration file
        sed -i "s/\$CONF\['setup_password'\] = 'curl_will_change_it';/\$CONF\['setup_password'\] = \'$SETUP_PASS_HASH\';/g" /var/www/html/config.inc.php

        # Creation de l'administrateur
        curl  -X POST -d "setup_password=$SETUP_PASS" -d "fUsername=$ADM_MAIL" -d "fPassword=$ADM_PASS" -d "fPassword2=$ADM_PASS" -d "form=createadmin" http://127.0.0.1/setup.php | grep "Admin has been added!"


        if [ $? -ne 0 ] ; then
            echo "ERROR with Admin creation :-/"
            echo "Curl cmd : "
            echo "curl X POST -d "setup_password=$SETUP_PASS" -d "fUsername=$ADM_MAIL" -d "fPassword=$ADM_PASS" -d "fPassword2=$ADM_PASS" -d "form=createadmin" http://127.0.0.1/setup.php"

            exit 1
        fi

        # Rappel de la commande CMD du script original
        apache2-foreground

J'y crois on détruit tous et on relance le tous :D :

        docker-compose build
        db-coco uses an image, skipping
        Building http-coco
        Step 1 : FROM php:5-apache
         ---> 9013e58a01eb

        $ docker-compose stop
        Stopping coco-http-t ... done
        Stopping coco-db-t ...

        $ docker-compose rm
        Going to remove coco-http-t, coco-db-t
        Are you sure? [yN] y
        Removing coco-http-t ... done
        Removing coco-db-t ... done

Ok let's GO :D 

        $ docker-compose up
        Creating coco-db-t
        Creating coco-http-t
        Attaching to coco-db-t, coco-http-t
        coco-db-t    | 170227  8:42:23 [Note] mysqld (mysqld 5.5.52) starting as process 1 ...

        coco-http-t  |   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
        coco-http-t  |                                  Dload  Upload   Total   Spent    Left  Speed
          0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0curl: (7) Failed to connect to 127.0.0.1 port 80: Connection refused
          ^CGracefully stopping... (press Ctrl+C again to force)
          Stopping coco-http-t ... done
          Stopping coco-db-t ... done

**HA !!** ouin effectivement mes commandes __curl__ sont avant que je ne démarre apache :P !!!
Ici nous pouvons constater l'importance d'avoir l'option **set -e # exit on error** dans notre script __bash__, sans cette option je n'aurais pas constater le problème simplement que ça ne fonctionne pas mais le service serait démarrer !

Donc voici la nouvelle version **run.sh** :

        # Templates
        j2 /root/config.inc.php.j2 > /var/www/html/config.inc.php

        # Démarrage du processus apache2 en background 
        apache2-foreground &

        # en attente de l'initialisation de apache TODO : mettre une solution plus belle
        sleep 3

        # Initilisation de la configuration de postfix :
        SETUP_PASS_HASH=$(curl  -X POST -d "setup_password=$SETUP_PASS" -d "form=createadmin" http://127.0.0.1/setup.php 2>/dev/null | grep "CONF" | grep "setup_password" | sed "s/.*\$CONF\['setup_password'\] = '\(.*\)';.*/\1/g")

        echo $SETUP_PASS_HASH

        # Update postfix configuration file
        sed -i "s/\$CONF\['setup_password'\] = 'curl_will_change_it';/\$CONF\['setup_password'\] = \'$SETUP_PASS_HASH\';/g" /var/www/html/config.inc.php

        # Creation de l'administrateur
        curl  -X POST -d "setup_password=$SETUP_PASS" -d "fUsername=$ADM_MAIL" -d "fPassword=$ADM_PASS" -d "fPassword2=$ADM_PASS" -d "form=createadmin" http://127.0.0.1/setup.php | grep "Admin has been added!"

        if [ $? -ne 0 ] ; then
            echo "ERROR with Admin creation :-/" 
            echo "Curl cmd : "
            echo "curl X POST -d "setup_password=$SETUP_PASS" -d "fUsername=$ADM_MAIL" -d "fPassword=$ADM_PASS" -d "fPassword2=$ADM_PASS" -d "form=createadmin" http://127.0.0.1/setup.php"
            exit 1
         fi

         # Show apache logs; TODO revoir la stratégie
         tail -f /var/log/apache2/access.log /var/log/apache2/error.log

Comme vous pouvez le constater je démarre le service **apache2-forground** beaucoup plus tôt , je réalise une petite pause de 3 seconde **sleep 3** afin de laisser le temps à apache de d'initialiser  le service. Par la suite pour que le service reste en premier plan je fait un **tail** des fichiers de logs .

#### <a name="automatic_setup_init_prob" /> Liste de problématique 

Quelle est le problème avec la mise en place de la commande **tail** pour conserver le service ouvert ?

La problématique est que si le service **apache** s'arrête , le conteneur va continuer à fonctionner , résultat si vous avez des systèmes de redémarrage automatique inclus par exemple avec **Kubernet** ou autre votre conteneur ne sera pas redémarrer ! En d'autre mot l'utilisation de **tail** doit être réalisé avec parcimonie . Bon comme j'ai envie de progresser, nous allons continuer avec ça pour le moment cependant ce devrait être réviser si nous allions en production avec cette image !

Autre problème avec cette solution , actuellement à chaque fois que je vais démarrer le conteneur le système va mettre à jour le fichier de configuration de __postfixadmin__ et tenter de créer un administrateur ! Par contre nous désirons avoir ce mécanisme, uniquement lors de l'initialisation du conteneur pas à chaque démarrage je vais donc ajouter une condition pour valider si la configuration fut déjà réalisé.


        #! /usr/bin/env bash
        set -e # exit on error

        # Variables
        export MYSQL_USER=${MYSQL_USER:-"myuser"}
        export MYSQL_PASSWORD=${MYSQL_PASSWORD:-"superpass"}
        export MYSQL_DATABASE=${MYSQL_DATABASE:-"mails"}
        export DB_TYPE=${DB_TYPE:-"mysql"}
        export MAIL_DOMAIN=${MAIL_DOMAIN:-"example.com"}
        export SETUP_PASS=${SETUP_PASS:-"fkrhreiuTOTO"}
        export ADM_MAIL=${ADM_MAIL:-"NOT_DEFINE"}
        export ADM_PASS=${ADM_PASS:-"NOT_DEFINE"}

        export ALREADY_SETUPED=/etc/configured

        # Validation des variables !!
        if [ "$ADM_MAIL" == "NOT_DEFINE" ] ; then
            echo 'You need to set variable $ADM_MAIL !! '
            echo "I already set all the software , I can't choose your username ;) "
            exit 1
        fi
        if [ "$ADM_PASS" == "NOT_DEFINE" ] ; then
            echo 'You need to set variable $ADM_PASS !! '
            echo "I already set all the software , I can't choose your PASSWORD ;) "
            exit 1
        fi

        # Templates
        j2 /root/config.inc.php.j2 > /var/www/html/config.inc.php

        # Démarrage du processus apache2 en background
        apache2-foreground &

        # en attente de l'initialisation de apache TODO : mettre une solution plus belle
        sleep 3

        if [ ! -e $ALREADY_SETUPED ] ; then

            # Initilisation de la configuration de postfix :
            SETUP_PASS_HASH=$(curl  -X POST -d "setup_password=$SETUP_PASS" -d "form=createadmin" http://127.0.0.1/setup.php 2>/dev/null | grep "CONF" | grep "setup_password" | sed "s/.*\$CONF\['setup_password'\] = '\(.*\)';.*/\1/g")


            # Update postfix configuration file
            sed -i "s/\$CONF\['setup_password'\] = 'curl_will_change_it';/\$CONF\['setup_password'\] = \'$SETUP_PASS_HASH\';/g" /var/www/html/config.inc.php

            # Creation de l'administrateur
            curl  -X POST -d "setup_password=$SETUP_PASS" -d "fUsername=$ADM_MAIL" -d "fPassword=$ADM_PASS" -d "fPassword2=$ADM_PASS" -d "form=createadmin" http://127.0.0.1/setup.php | grep "Admin has been added!"


            if [ $? -ne 0 ] ; then
                echo "ERROR with Admin creation :-/"
                echo "Curl cmd : "
                echo "curl X POST -d "setup_password=$SETUP_PASS" -d "fUsername=$ADM_MAIL" -d "fPassword=$ADM_PASS" -d "fPassword2=$ADM_PASS" -d "form=createadmin" http://127.0.0.1/setup.php"
                exit 1
            fi

            # Creation du fichier pour indiquer que le conteneur est configurer
            touch $ALREADY_SETUPED

        fi # END if [ -e $ALREADY_SETUPED ]

        # Show apache logs : TODO : revoir la stratégie
        tail -f /var/log/apache2/access.log /var/log/apache2/error.log

Donc je crée un fichier qui me servira de point de référence à savoir si la configuration est déjà réalisé , bon idéalement je communiquerai avec la base de donnée afin de valider son intégrité, malheureusement ceci demanderai plus d'effort que j'ai pas envie de mettre maintenant :P .
On peut toujours faire mieux :) , mais bon à ce stade , je vais me limité à cette fonctionnalité.

On détruit TOUS et on valide :

        $ docker-compose rm 
        $ docker-compose build
        $ docker-compose up                                            
        Creating coco-db-t
        Creating coco-http-t
        Attaching to coco-db-t, coco-http-t
        coco-db-t    | Initializing database


       $ docker exec -it coco-db-t mysql -u umail -p                                                                                                         
       Enter password:
       mysql> use vmail;

       mysql> select * from admin;
       +----------------+------------------------------------+---------------------+---------------------+--------+
       | username       | password                           | created             | modified            | active |
       +----------------+------------------------------------+---------------------+---------------------+--------+
       | admin@coco.com | $1$0a09f6cb$4CuEpMG2X2Vqd5SV/xA4E/ | 2017-02-28 17:26:00 | 2017-02-28 17:26:00 |      1 |
       +----------------+------------------------------------+---------------------+---------------------+--------+

**MAGIE** 

## <a name="setup_mails" /> Configuration d'un domaine et boite courriel

Bon maintenant que nous avons 2 morceaux 

* Base de donnée
* Application de gestion de comptes

Nous allons créer un domaine et un compte de courriel pour les testes !

        $ docker inspect coco-http-t | grep IPAd
                    "SecondaryIPAddresses": null,
                    "IPAddress": "",
                          "IPAddress": "172.22.0.3",

Nous allons sur la page de login : [http://172.22.0.3/login.php](http://172.22.0.3/login.php), pour les informations de connections regardez dans le __docker-compose.yml__ :P .

![postfix-admin-home.png](./imgs/postfix-admin-home.png)

* __Domain List -> New Domain__

![postfix-admin-createdomain.png](./imgs/postfix-admin-createdomain.png)

* __Virtual List --> New mailbox__

![postfix-admin-createmailbox.png](./imgs/postfix-admin-createmailbox.png)

Bon maintenant on peut plus détruire notre base de donnée :P , il faudra composer avec ou alors refaire la configuration du compte de courriel :D . 
Je voulais introduire cette limitation :-) , bien entendu ce ne serait pas grave ce n'est pas beaucoup d'opération :) .
En plus ça fait du bien voir que ça fonctionne bien :D.



## <a name="setup_smtp" /> Configuration du service SMTP

SUPER, nous avons 2 conteneur sur 4 :D , On a la moitié de réalisé !! Bon on s'est pas trop foulé pour la partie base de donnée, mais si vous avez un chargé de projet sur le dos ça fait toujours bien à dire :D.

En plus maintenant on gère bien postfix ;-)

Bon reprenons la documentation de __postfixadmin__ le fichier d'installation : [INSTALL.txt](https://github.com/mattrude/PostfixAdmin/blob/master/INSTALL.TXT) , les points de 1 à 5 sont réglés . Nous sommes donc bien rendu à la partie Intégration avec postfix , le document dit de voir le fichier : [POSTFIX_CONF.txt](https://github.com/mattrude/PostfixAdmin/blob/master/DOCUMENTS/POSTFIX_CONF.txt). 
C'est donc partie partie !

Malheureusement il n'existe pas de conteneur **postfix** officiel nous allons donc devoir réaliser notre propre conteneur , mais on assure la dessus :D.

Avant de se lancer dans le __Dockerfile__ analysons ce dont nous avons besoin :

* postfix 
* postfix avec __mysql__ 
* nous "maitrisons" lmtp donc nous utiliserons cette méthode pour transmettre les courriels à dovecot

La variables d'environnement :

* Lien avec la BD : Hôte, Utilisateur , mot de passe, base de donnée
* Lien avec Dovecot (__lmtp__)
* Réseaux permit pour transmettre des courriels
* Utilisation d'une __relay host__ ?
* Le nom de la machine pour la configuration postfix

Autre choses ? Pour le moment je ne vois pas , mais comme toujours on ajustera :P

Rédaction du __Dockerfile__ , oui oui j'ai pris comme point de départ celui que nous avions utilisé précédemment :D, j'ai ajouté le support **Mysql** avec le package **postfix-mysql**

        # Using Ubuntu
        # Start Exemple:
        # ou can add -p 25:25 for LAN access
        FROM ubuntu:16.04
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Packages: update
        RUN apt-get update -qq && \
            apt-get install -qq -y --no-install-recommends postfix postfix-mysql \
                python-pip supervisor rsyslog python-wheel python-setuptools  && \
            pip install j2cli

        # Configure: supervisor
        ADD bin/dfg.sh /usr/local/bin/
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/

        # Setup postfix conf
        ADD conf/postfix-main.j2 /root/


        # Runner
        ADD run.sh /root/run.sh
        RUN chmod +x /root/run.sh

        # Declare
        EXPOSE 25

        CMD ["/root/run.sh"]


Bon maintenant je vais reprendre les fichier __bin/dfg.sh__ et __supervisor-all__ :

        $ sudo vim conf/supervisor-all.conf
        [supervisord]
        logfile = /var/log/supervisord.log
        logfile_backups = 0

        [program:rsyslogd]
        command = /usr/sbin/rsyslogd -n

        [program:postfix]
        command = /usr/local/bin/dfg.sh /var/spool/postfix/pid/master.pid /etc/init.d/postfix start
        startsecs = 3

        $ cp ../../srvMailWithImap/smtp/bin/dfg.sh .

On a quelque chose qui fonctionne on va pas se casser la tête à le faire autrement on a eu assez de problème déjà :P. 
Passons maintenant au fichier de configuration postfix **postfix-main.j2** :

        smtpd_banner = $myhostname ESMTP $mail_name

        alias_database = hash:/etc/aliases
        alias_maps = hash:/etc/aliases

        smtpd_relay_restrictions = permit_mynetworks  defer_unauth_destination
        myhostname = $myorigin
        myorigin = {{ SMTP_HOSTNAME }}

        mydestination = localhost $myorigin
        mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 {{ PERMIT_NETWORK }}
        inet_interfaces = all
        inet_protocols = ipv4

        # Configuration du lien avec Mysql:
        virtual_mailbox_domains = proxy:mysql:/etc/postfix/sql/mysql_virtual_domains_maps.cf
        virtual_alias_maps =
           proxy:mysql:/etc/postfix/sql/mysql_virtual_alias_maps.cf,
           proxy:mysql:/etc/postfix/sql/mysql_virtual_alias_domain_maps.cf,
           proxy:mysql:/etc/postfix/sql/mysql_virtual_alias_domain_catchall_maps.cf
        virtual_mailbox_maps =
           proxy:mysql:/etc/postfix/sql/mysql_virtual_mailbox_maps.cf,
           proxy:mysql:/etc/postfix/sql/mysql_virtual_alias_domain_mailbox_maps.cf

        # Configuration pour l'envoie vers lmtp (aka dovecot)
        mailbox_transport = lmtp:{{ DOVECOT_SRV }}:24



        {% if (EXT_RELAY_HOST != "DIRECT") %}relayhost = {{ EXT_RELAYHOST }} {% endif %}

Explication de la configuration postfix :
Nous utilisons le système __virtual__ de postfix , pourquoi __virtual__ ceci permet d'identifier que la gestion pour postfix n'est pas pour une livraison pour l'hôte (__hostname__) mais pour une configuration virtuelle pour un domaine autre . Vous avez une explication a l'URL : [VIRTUAL\_README](http://www.postfix.org/VIRTUAL_README.html).

3 instructions sont introduites ici :

* [**virtual\_mailbox\_domains**](http://www.postfix.org/postconf.5.html#virtual_mailbox_domains) ( == mydestination ) : Ceci définie les domaines qui sont accepté , techniquement il est possible de les définir comme pour la valeur __MyDestination__ en fournissant une liste des domaines (ex: __coco.com toto.ca__) bien entendu dans notre cas nous utilisons un __lookuptable__ qui est __Mysql__
* [**virtual\_alias\_maps**](http://www.postfix.org/postconf.5.html#virtual_alias_maps) (== aliasses): ceci permet de définir les alias des adresses courriels encore une nous utilisons le __Lookuptable__ avec __Mysql__ . __Ho__ mais pourquoi 3 définitions ?? Nous le verrons un peu plus loin mais il y a 3 requêtes __SQL__ distinctes qui sont réalisées :
    * __mysql\_virtual\_alias\_maps__ :  alias des adresses courriels dont __thomas@coco.com --> xerus@coco.com__ classique :D
    * __mysql\_virtual\_alias\_domain\_maps__ : alias de domaine donc __titi.com --> coco.com__ l'ensemble des courriels transmit aux adresses __titi.com__ seront transmis à __coco.com__.
    * __mysql\_virtual\_alias\_domain\_catchall\_maps__ : Permet de définir un __wildcard__ de courriels donc __*@coco.com --> info@coco.com__
* [**virtual\_mailbox\_maps**](http://www.postfix.org/postconf.5.html#virtual_mailbox_maps) : Permet de définir non pas les alias mes les adresses courriels réelle , d'utilisateur.

Nous allons mettre en place les fichiers **jinja2** de configuration dans le répertoire **conf/sql** :

        ============ mysql_virtual_alias_domain_catchall_maps.cf.j2 ========
        user = {{ MYSQL_USER }}
        password = {{ MYSQL_PASSWORD }}
        hosts = {{ DB_HOST }}
        dbname = {{ MYSQL_DATABASE }}
        query  = SELECT goto FROM alias,alias_domain WHERE alias_domain.alias_domain = '%d' and alias.address = CONCAT('@', alias_domain.target_domain) AND alias.active = 1 AND alias_domain.active='1'


        ============ mysql_virtual_alias_domain_mailbox_maps.cf.j2 ========
        user = {{ MYSQL_USER }}
        password = {{ MYSQL_PASSWORD }}
        hosts = {{ DB_HOST }}
        dbname = {{ MYSQL_DATABASE }}
        query = SELECT maildir FROM mailbox,alias_domain WHERE alias_domain.alias_domain = '%d' and mailbox.username = CONCAT('%u', '@', alias_domain.target_domain) AND mailbox.active = 1 AND alias_domain.active='1'

        ============ mysql_virtual_alias_domain_maps.cf.j2 ========
        user = {{ MYSQL_USER }}
        password = {{ MYSQL_PASSWORD }}
        hosts = {{ DB_HOST }}
        dbname = {{ MYSQL_DATABASE }}
        query = SELECT goto FROM alias,alias_domain WHERE alias_domain.alias_domain = '%d' and alias.address = CONCAT('%u', '@', alias_domain.target_domain) AND alias.active = 1 AND alias_domain.active='1'

        ============ mysql_virtual_alias_maps.cf.j2 ========
        user = {{ MYSQL_USER }}
        password = {{ MYSQL_PASSWORD }}
        hosts = {{ DB_HOST }}
        dbname = {{ MYSQL_DATABASE }}
        query = SELECT goto FROM alias WHERE address='%s' AND active = '1'
        #expansion_limit = 100

        ============ mysql_virtual_domains_maps.cf.j2 ========
        user = {{ MYSQL_USER }}
        password = {{ MYSQL_PASSWORD }}
        hosts = {{ DB_HOST }}
        dbname = {{ MYSQL_DATABASE }}
        query = SELECT domain FROM domain WHERE domain='%s' AND active = '1'
        #query          = SELECT domain FROM domain WHERE domain='%s'
        #optional query to use when relaying for backup MX
        #query           = SELECT domain FROM domain WHERE domain='%s' AND backupmx = '0' AND active = '1'
        #expansion_limit = 100

        ============ mysql_virtual_mailbox_maps.cf.j2 ========
        user = {{ MYSQL_USER }}
        password = {{ MYSQL_PASSWORD }}
        hosts = {{ DB_HOST }}
        dbname = {{ MYSQL_DATABASE }}
        query           = SELECT maildir FROM mailbox WHERE username='%s' AND active = '1'
        #expansion_limit = 100

Nous utilisons les mêmes variables qui seront substitué , lors de l'exécution du script **run.sh**.

Maintenant le fichier __run.sh__ , prendre note j'ai changé la variable __ACCEPT\_DOMAIN__ pour __DB\_HOST__ , car faut définir la BD et de toute manière la liste des domaines accepté est définie dedans :D. De plus contrairement à la version original j'ai définie le lien avec __dovecot__ en variable comme ça se conteneur pourrait fonctionner autant avec un autre conteneur ou une __VM / host non dockerisé__ :

        #! /usr/bin/env bash
        set -e # exit on error

        # Variables
        export EXT_RELAY_HOST=${EXT_RELAY_HOST:-"DIRECT"}
        export SMTP_HOSTNAME=${SMTP_HOSTNAME:-"relay.example.com"}
        export PERMIT_NETWORK=${PERMIT_NETWORK:-"192.168.0.0/16"}

        export DB_HOST=${DB_HOST:-"db"}
        export DOVECOT_SRV=${DOVECOT_SRV:-"dovecot-lmtp"}

        echo $SMTP_HOSTNAME > /etc/mailname

        # Templates
        j2 /root/postfix-main.j2 > /etc/postfix/main.cf

        if [ ! -d  /etc/postfix/sql/ ] ; then
            mkdir /etc/postfix/sql/
        fi

        # génération des fichiers de configuration SQL pour postfix
        for sql_file in /root/sql/*.j2 ; do
            filename=$(basename $sql_file)
            filedst="/etc/postfix/sql/${filename::-3}"
            j2 $sql_file > $filedst
        done


        # Launch
        rm -f /var/spool/postfix/pid/*.pid
        exec /usr/bin/supervisord -n


**oupss** j'allais oublier d'inclure le répertoire **sql** dans le __DockerFile__ :

        [... OUTPUT COUPÉ ...]
        # Setup postfix conf
        ADD conf/postfix-main.j2 /root/

        # Ajout fichier de configuration SQL
        ADD conf/sql    /root/sql

        # Runner
        ADD run.sh /root/run.sh
        [... OUTPUT COUPÉ ...]


Maintenant le **docker-compose** et on est prêt pour le __build__ !! :

            - ADM_MAIL=admin@coco.com
            - ADM_PASS=DockerRock
        smtp-coco:
            image: smtp-db
           build: ./smtp/
            restart: unless-stopped
            container_name : 'coco-smtp-t'
            hostname: mail.coco.com
            links:
                - db-coco:db
        #       - imap-coco:dovecot-lmtp
            environment:
                - MYSQL_USER=umail
                - MYSQL_PASSWORD=ZePassword
                - MYSQL_DATABASE=vmail
                - TZ=America/Montreal
                - TERM=xterm

C'est partie pour le __build__ !! 

        $ docker-compose build smtp-coco
        Building smtp-coco
        Step 1 : FROM ubuntu:16.04
         ---> c73a085dc378
         Step 2 : MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>
          ---> Using cache
          ---> 9421a73877a6

**Bon!!** là on a un problème est-ce que nous sommes assez confiant dans notre image ?!? Car nous ne sommes pas en mesure de valider la configuration avant d'avoir le service **lmtp** de dovecot ?!?! Bien entendu on peut faire un test mais il n'y au pas de livraison .... 

C'est partie ... 

        $ docker-compose build && docker-compose up
        [... OUTPUT COUPÉ ...]
        Step 8 : CMD /run.sh
         ---> Using cache
          ---> 12bb085c513d
        Successfully built 12bb085c513d
        Starting coco-db-t
        Recreating coco-smtp-t
        Starting coco-http-t
        Attaching to coco-db-t, coco-http-t, coco-smtp-t
        coco-db-t    | 170302  8:02:38 [Note] mysqld (mysqld 5.5.52) starting as process 1 ...
        coco-db-t    | 170302  8:02:38 [Note] Plugin 'FEDERATED' is disabled.
        [... OUTPUT COUPÉ ...]

Phase de validation :

         $ docker ps
         CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES
         4b2e774fdd33        smtp-db             "/root/run.sh"           About a minute ago   Up About a minute   25/tcp              coco-smtp-t
         8af788755374        postfixadmin        "docker-php-entrypoin"   38 hours ago         Up About a minute   80/tcp              coco-http-t
         b1f332217f58        mysql:5.5           "docker-entrypoint.sh"   38 hours ago         Up About a minute   3306/tcp            coco-db-t

         $ docker exec coco-smtp-t ls /etc/postfix/sql/
         mysql_virtual_alias_domain_catchall_maps.cf
         mysql_virtual_alias_domain_mailbox_maps.cf
         mysql_virtual_alias_domain_maps.cf
         mysql_virtual_alias_maps.cf
         mysql_virtual_domains_maps.cf
         mysql_virtual_mailbox_maps.cf

         $ docker exec coco-smtp-t cat /etc/postfix/sql/mysql_virtual_alias_maps.cf
         user = umail
         password = ZePassword
         hosts = db
         dbname = vmail
         query = SELECT goto FROM alias WHERE address='%s' AND active = '1'
         #expansion_limit = 100


Ça semble bien, bon nous aurons la confirmation uniquement lors de la mise en place du service **dovecot** .

Bon ça s'est bien fait celui la :D , on est content :) !! Allez sur notre lancé on s'attaque au service __lmtp/imap (dovecot)__ ??

## <a name="setup_lmtp" /> Configuration du service LMTP / IMAP

Bon encore cette fois nous avons une base de travail réalisé lors de la dernière séance, je vais donc capitaliser sur cette première configuration !

J'ai validé PAS de conteneur dovecot officiel, nous allons donc devoir créer notre image :D , pas de problème on assure :D !

Bon reprenons la documentation de __postfixadmin__ le fichier d'installation : [INSTALL.txt](https://github.com/mattrude/PostfixAdmin/blob/master/INSTALL.TXT) , les points de 1 à 5 sont réglés . Nous sommes donc bien rendu à la partie Intégration avec dovecot , le document dit de voir le fichier : [POSTFIX_CONF.txt](https://github.com/mattrude/PostfixAdmin/blob/master/DOCUMENTS/DOVECOT.txt). 
Bon petit problème avec cette documentation c'est quelle est pour dovecot 1.X alors que nous nous utilisons la version 2.x. C'est pas ça qui va nous arrêter !!! :D on a google pour les erreurs à venir :D.

C'est donc partie partie ! 

Comme nous avons un aspect d'exploration à réalisé afin de valider que la configuration 1.X ressemble à la version 2.X je vais faire de mon mieux pour la configuration de l'image de base , surtout pour les packages puis je vais expérimenté avec le "pet" conteneur. Par la suite avec **docker diff** , je vais extraire la configuration. Ceci m'évitera de faire 60 __builds__ et de prendre beaucoup plus de temps.


### <a name="setup_lmtp_debug" /> Réalisation de l'image en mode DEBUG

Créons le fichier __Dockerfile__ :

        # Using Ubuntu
        FROM ubuntu:16.04
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Packages: update
        RUN apt-get update -qq && \
            apt-get install -qq -y --no-install-recommends dovecot-imapd dovecot-lmtpd dovecot-mysql \
                    python-pip supervisor rsyslog python-wheel python-setuptools  && \
            pip install j2cli
                            
        # TODO : a supprimer tempo exploration, je le définie dans l'image pour réduire
        # la différence retourné avec docker diff :D
        RUN apt-get install vim telnet mysql-client

        # Configure: supervisor
        ADD bin/dfg.sh /usr/local/bin/
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/

        # Runner
        ADD run.sh /root/run.sh
        RUN chmod +x /root/run.sh

        # Declare
        EXPOSE 143 24

        CMD ["/root/run.sh"]

Comme vous pouvez le voir je crée une couche avec les applications d'exploration que je supprimerai par la suite , afin de réduire le résultat retourné par la commande **docker diff**. J'installe le client __mysql__ en cas de problème de connectivité , tout comme __telnet__ , et __vim__ pour éditer librement mes fichiers.

Je vais copier le fichier __superviser-all.conf__ et le script __dfg.sh__ de notre ancien conteneur. Je définie aussi le fichier __run.sh__ :

        $ cat run.sh
        #! /usr/bin/env bash
        set -e # exit on error

        # Launch
        rm -f /var/run/dovecot/*.pid
        exec /usr/bin/supervisord -n


Réalisons du __docker-compose__ afin d'être sur le bon pied tout de suite :

        smtp-coco:
            image: smtp-db
            build: ./smtp/
            restart: unless-stopped
            container_name : 'coco-smtp-t'
            hostname: mail.coco.com
            links:
                - db-coco:db
            G    - imap-coco:dovecot-lmtp
            environment:
                - MYSQL_USER=umail
                - MYSQL_PASSWORD=ZePassword
                - MYSQL_DATABASE=vmail
                - TZ=America/Montreal
                - TERM=xterm
        imap-coco:
            image: imap-db
            build: ./imap/
            restart: unless-stopped
            container_name : 'coco-imap-t'
            hostname: mail.coco.com
                links:
                - db-coco:db
            environment:
                - MYSQL_USER=umail
                - MYSQL_PASSWORD=ZePassword
                - MYSQL_DATABASE=vmail
                - DB_TYPE=mysql
                - TZ=America/Montreal
                - TERM=xterm



Prendre note que j'ai aussi activé le lien du service __smtp-coco__ avec __imap-coco__ dans la section links :

            links:
                - db-coco:db
                - imap-coco:dovecot-lmtp

Nous allons faire la création de l'image :

        $ docker-compose build imap-coco
        [... OUTPUT COUPÉ ...]
         ---> 25385609a72e
         Removing intermediate container 3da5c99297b4
         Successfully built 25385609a72e

### <a name="setup_lmtp_pet_c" /> Réalisation de la configuration en mode exploration 

Telle que mentionné je vais faire de l'exploitation afin de confirmer ma configuration avec de modifier le __Dockerfile__ .
Suite au __build__ du conteneur __imap-coco__ je supprimer le conteneur __smtp-coco__ ceci dans le but qu'il recréer le conteneur AVEC le lien avec le conteneur __imap-coco__ .
**ATTENTION** : je ne supprime pas la base de donnée pour le moment car je veux conserver la structure de la BD, on sait qu'elle sera recréer , mais pour le moment je ne veux pas me rajouter de problème :P.

        $ docker-compose rm smtp-coco
        Going to remove coco-smtp-t
        Are you sure? [yN] y
        Removing coco-smtp-t ... done

Je peux maintenant redémarrer le tous :

        $ docker-compose up

Pas d'erreur, validons que l'ensemble des conteneurs sont bien actif !

        $  docker ps
        CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES
        c38170a3eda2        smtp-db             "/root/run.sh"           About a minute ago   Up About a minute   25/tcp              coco-smtp-t
        a053827712e2        imap-db             "/root/run.sh"           About a minute ago   Up About a minute   24/tcp, 143/tcp     coco-imap-t
        8af788755374        postfixadmin        "docker-php-entrypoin"   47 hours ago         Up About a minute   80/tcp              coco-http-t
        b1f332217f58        mysql:5.5           "docker-entrypoint.sh"   47 hours ago         Up About a minute   3306/tcp            coco-db-t

Tous est la , un petit **docker diff** afin de voir l'état de notre conteneur :

        $ docker diff coco-imap-t
        C /var
        C /var/lib
        C /var/lib/dovecot
        A /var/lib/dovecot/ssl-parameters.dat
        A /var/lib/dovecot/instances
        C /var/log
        A /var/log/supervisord.log
        A /var/log/kern.log
        A /var/log/syslog
        C /var/log/supervisor
        A /var/log/supervisor/dovecot-stdout---supervisor-mEjN1p.log
        A /var/log/supervisor/rsyslogd-stderr---supervisor-RNAqgg.log
        A /var/log/supervisor/rsyslogd-stdout---supervisor-cxZUoK.log
        A /var/log/supervisor/dovecot-stderr---supervisor-_KcFgQ.log
        A /var/log/mail.log
        C /run
        A /run/rsyslogd.pid
        [ ... OUTPUT COUPÉ ...]

Tous de même pas mal de chose, mais tous dans /var et /run peu probable que je réalise des modifications dans ces répertoires , si je les supprimes du résultat ça donne quoi ?

        $ docker diff coco-imap-t  | egrep -v '/var/lib|/run|/var/log'

Parfait nous ferons ça :D . 

Allons dans le conteneur pour faire nos modifications :

        $ docker exec -it coco-imap-t bash
        root@mail:/#

1. Validation des protocoles actif :

            root@mail:/etc/dovecot# cat dovecot.conf | grep -v "^#" | grep -v "^$"
            !include_try /usr/share/dovecot/protocols.d/*.protocol
            dict {
              #quota = mysql:/etc/dovecot/dovecot-dict-sql.conf.ext
              #expire = sqlite:/etc/dovecot/dovecot-dict-sql.conf.ext
            }
            !include conf.d/*.conf
            !include_try local.conf

            root@mail:/etc/dovecot# ls /usr/share/dovecot/protocols.d/*.protocol
            /usr/share/dovecot/protocols.d/imapd.protocol  /usr/share/dovecot/protocols.d/lmtpd.protocol
2. Activation du système de **maildir** avec la structure : **/var/mail/vhosts/Nom\_Domaine/Utilisateur**

            root@mail:/etc/dovecot# vim /etc/dovecot/conf.d/10-mail.conf
            mail_location = maildir:/var/mail/vhosts/%d/%n
            [... PLUS LOIN ...]
            mail_privileged_group = mail
3. S'assurer que le groupe **mail** peut bien écrire dans le répertoire temporaire de traitement **/var/mail**

            root@mail:/etc/dovecot/conf.d# ls -ld /var/mail
            drwxrwsr-x 2 root mail 6 Sep 23 17:00 /var/mail
4. Création de l'utilisateur virtuel pour dovecot **vmail** et groupe **vmail** , comme nous n'aurons pas d'utilisateur système pour les fichiers nous définissons un utilisateur avec moins de droit. Originalement quand nous avions des utilisateurs systèmes les fichiers étaient déposé avec les permissions de l'utilisateur (__UID/GID__). Maintenant que les utilisateurs sont dans la Base de donnée nous n'avons plus cette association disponible nous devons donc définir un utilisateur spécifique.

            root@mail:/etc/dovecot/conf.d# groupadd -g 5000 vmail
            root@mail:/etc/dovecot/conf.d# useradd -g vmail -u 5000 vmail -d /var/mail
            root@mail:/etc/dovecot/conf.d# chown -R vmail:vmail /var/mail
5. Authentification des utilisateurs , je commente l'authentification système pour activer l'authentification __SQL__.

            root@mail:/etc/dovecot# vim /etc/dovecot/conf.d/10-auth.conf
            disable_plaintext_auth = no
            [... plus loins ...]
            #!include auth-system.conf.ext
            !include auth-sql.conf.ext
6. Authentification avec le service __SQL__ , identification de la livraisons avec l'utilisateur statique __vmail__

            root@mail:/etc/dovecot/conf.d# vim /etc/dovecot/conf.d/auth-sql.conf.ext
            [ ... conservation des lignes avant ... ]
            userdb {
              driver = static
              args = uid=vmail gid=vmail home=/var/mail/vhosts/%d/%n
            }
7. Configuration de la requête pour le __SQL__ :

            root@mail:/etc/dovecot# vim /etc/dovecot/dovecot-sql.conf.ext
            driver = mysql
            connect = host=db dbname=vmail user=umail password=ZePassword

            password_query = SELECT username AS user,password FROM mailbox WHERE username = '%u' AND active='1'
            user_query = SELECT maildir, 5000 AS uid, 5000 AS gid FROM mailbox WHERE username = '%u' AND active='1'

Je vais recharger la configuration , on a vue que le redémarrage été ... Risqué ;)

        root@mail:/etc/dovecot# /etc/init.d/dovecot reload
         * Reloading IMAP/POP3 mail server dovecot                             [ OK ]
        root@mail:/etc/dovecot# tail /var/log/mail.log
        Mar  2 17:12:45 mail dovecot: master: Dovecot v2.2.22 (fe789d2) starting up for imap, lmtp
        Mar  2 17:12:45 mail dovecot: ssl-params: Generating SSL parameters
        Mar  2 17:12:45 mail dovecot: ssl-params: SSL parameters regeneration completed
        Mar  2 17:43:15 mail dovecot: master: Warning: SIGHUP received - reloading configuration
        
### <a name="validation_setup" /> Validation de la configuration 

Bon nous avons un pet conteneur avec __Dovecot__ , cependant nous avons maintenant les 4 conteneurs disponible , nous sommes donc en mesure de réaliser un testes complet de communication. Nous devons garder en tête que le conteneur __Imap/LMTP__ n'est PAS final à ce stade mais j'ai vraiment envie d'essayer l'ensemble de la chaine . Il est fort probable que nous soyons amené à faire des modifications dans le système __postfix__ aussi voir la BD.

Débutons avec l'envoie du courriel, pour rappel nous avions fait la création d'un utilisateur **toto@coco.com** :

        $ docker inspect coco-smtp-t | grep IPA
                    "SecondaryIPAddresses": null,
                    "IPAddress": "",
                    "IPAMConfig": null,
                        "IPAddress": "172.22.0.5",

        $ telnet 172.22.0.5 25
        Trying 172.22.0.5...
        Connected to 172.22.0.5.
        Escape character is '^]'.
        220 relay.example.com ESMTP Postfix
        ehlo toto
        250-relay.example.com
        250-PIPELINING
        250-SIZE 10240000
        250-VRFY
        250-ETRN
        250-ENHANCEDSTATUSCODES
        250-8BITMIME
        250 DSN
        mail from:bonjour@ifjefj.com
        250 2.1.0 Ok
        rcpt to: toto@coco.com
        250 2.1.5 Ok
        data
        354 End data with <CR><LF>.<CR><LF>
        un courriel de test
        .
        250 2.0.0 Ok: queued as 606BC1201310
        quit
        221 2.0.0 Bye
        Connection closed by foreign host.

COOL c'est un bon début , visualisons les logs :

        $ docker exec coco-smtp-t tail /var/log/mail.log
        Mar  3 08:05:23 mail postfix/master[145]: warning: /usr/lib/postfix/sbin/virtual: bad command startup -- throttling
        Mar  3 08:06:23 mail postfix/virtual[752]: fatal: bad string length 0 < 1: virtual_mailbox_base =
        Mar  3 08:06:24 mail postfix/master[145]: warning: process /usr/lib/postfix/sbin/virtual pid 752 exit status 1
        Mar  3 08:06:24 mail postfix/master[145]: warning: /usr/lib/postfix/sbin/virtual: bad command startup -- throttling
        Mar  3 08:07:24 mail postfix/virtual[995]: fatal: bad string length 0 < 1: virtual_mailbox_base =
        Mar  3 08:07:25 mail postfix/master[145]: warning: process /usr/lib/postfix/sbin/virtual pid 995 exit status 1
        Mar  3 08:07:25 mail postfix/master[145]: warning: /usr/lib/postfix/sbin/virtual: bad command startup -- throttling

Bon évidement une réussit du premier coup aurait été étonnant :P !!! Pas besoin de feindre l'étonnement :P 

Bon ceci est mon erreur , là vous pouvez feindre l'étonnement :P !! Je me suis trompé j'avais repris la configuration de notre postfix qui réalisé le transfert vers __lmtp__ quand nous n'utilisions pas le système **virtual**. Lors de l'utilisation de ce mécanisme nous ne devons pas utiliser l'instruction :

        mailbox_transport = lmtp:dovecot-lmtp:24
        Mais nous devons définir :
        virtual_transport = lmtp:dovecot-lmtp:24

Ceci va donc nous permettre de voir comment modifier un conteneur pour modifier la configuration :D (quelle belle opportunité :D ).

Donc je modifie le fichier de __template__ de postfix pour avoir la bonne valeur (modification stipulé plus haut):

        $ vim smtp/conf/postfix-main.j2

Je vais arrêter les conteneurs , détruire le conteneur __smtp__ et redémarrer le tous !!

        coco-smtp-t  | 2017-03-03 08:03:54,054 INFO success: rsyslogd entered RUNNING state, process has stayed up for > than 1 seconds (startsecs)
        coco-imap-t  | 2017-03-03 08:03:54,087 INFO success: dovecot entered RUNNING state, process has stayed up for > than 3 seconds (startsecs)
        coco-smtp-t  | 2017-03-03 08:03:56,057 INFO success: postfix entered RUNNING state, process has stayed up for > than 3 seconds (startsecs)
        ^CGracefully stopping... (press Ctrl+C again to force)
        Stopping coco-smtp-t ... done
        Stopping coco-imap-t ... done
        Stopping coco-http-t ... done
        Stopping coco-db-t ... done

        $ docker-compose rm smtp-coco
        Going to remove coco-smtp-t
        Are you sure? [yN] y
        Removing coco-smtp-t ... done

        $ docker-compose build smtp-coco
        Building smtp-coco
        Step 1 : FROM ubuntu:16.04
         ---> c73a085dc378
        [... OUTPUT COUPÉ ... ]

Et on redémarre :

        $ docker-compose up
        Starting coco-db-t
        Starting coco-http-t
        Starting coco-imap-t
        Creating coco-smtp-t
        Attaching to coco-db-t, coco-imap-t, coco-http-t, coco-smtp-t
        coco-db-t    | 170303  8:19:15 [Note] mysqld (mysqld 5.5.52) starting as process 1 ...

Et on refait le teste, bien entendu !

        $ telnet 172.22.0.5 25
        [ .. OUTPUT COUPÉ (voir plus haut :P ) ...]

        $ docker exec coco-smtp-t tail /var/log/mail.log
        Mar  3 08:19:19 mail postfix/master[145]: daemon started -- version 3.1.0, configuration /etc/postfix
        Mar  3 08:20:10 mail postfix/smtpd[345]: connect from unknown[172.22.0.1]
        Mar  3 08:20:23 mail postfix/smtpd[345]: D21431201310: client=unknown[172.22.0.1]
        Mar  3 08:20:27 mail postfix/cleanup[403]: D21431201310: message-id=<>
        Mar  3 08:20:27 mail postfix/qmgr[148]: D21431201310: from=<bonjour@djek.com>, size=180, nrcpt=1 (queue active)
        Mar  3 08:20:27 mail postfix/lmtp[420]: connect to dovecot-lmtp[172.22.0.3]:24: Connection refused
        Mar  3 08:20:27 mail postfix/lmtp[420]: D21431201310: to=<toto@coco.com>, relay=none, delay=11, delays=11/0.01/0/0, dsn=4.4.1, status=deferred (connect to dovecot-lmtp[172.22.0.3]:24: Connection refused)
        Mar  3 08:20:28 mail postfix/smtpd[345]: disconnect from unknown[172.22.0.1] ehlo=1 mail=1 rcpt=1 data=1 quit=1 commands=5

On est bon !!! Pour ce qui ne voit que l'erreur encore présent , moi je vous dis c'est PAS le même problème on avance , faut savoir ce réjouir !! En plus le conteneur __lmtp__ est pas fini c'est donc NORMALE !! Validons la configuration dans le conteneur __lmtp__ :

        $ docker exec  coco-imap-t ss -lntp
        State      Recv-Q Send-Q Local Address:Port               Peer Address:Port
        LISTEN     0      128    127.0.0.11:36333                    *:*
        LISTEN     0      100          *:143                      *:*                   users:(("dovecot",pid=20,fd=33))
        LISTEN     0      100         :::143                     :::*                   users:(("dovecot",pid=20,fd=34))

Effectivement le port 24 est pas présent , à ce stade vous devrions savoir pourquoi ce n'est pas présent , nous avons déjà vu cette configuration !

La solution j'ai oublié de configurer le service __lmtp__ pour qu'il écoute sur le réseau .

        $ docker exec -it coco-imap-t bash 
        root@mail:/etc/dovecot/conf.d# vim 10-master.conf
        [... OUTPUT COUPÉ ...]
        service lmtp {
            unix_listener lmtp {
              #mode = 0666
            }

            # Create inet listener only if you can't use the above UNIX socket
            inet_listener lmtp {
                # Avoid making LMTP visible for the entire internet
                #address =
                port = 24
            }
        }
        [... OUTPUT COUPÉ ...]
        root@mail:/etc/dovecot/conf.d# /etc/init.d/dovecot reload
        root@mail:/etc/dovecot/conf.d# ss -lntp | grep 24
        LISTEN     0      100          *:24                       *:*                   users:(("dovecot",pid=20,fd=24))
        LISTEN     0      100         :::24                      :::*                   users:(("dovecot",pid=20,fd=25))

Teste encore :

        $ telnet 172.22.0.5 25 
        [... OUTPUT COUPÉ ...]

        $ docker exec coco-smtp-t tail /var/log/mail.log
        Mar  3 08:27:20 mail postfix/smtpd[2068]: connect from unknown[172.22.0.1]
        Mar  3 08:27:33 mail postfix/smtpd[2068]: 1E9981201311: client=unknown[172.22.0.1]
        Mar  3 08:27:36 mail postfix/cleanup[2122]: 1E9981201311: message-id=<>
        Mar  3 08:27:36 mail postfix/qmgr[148]: 1E9981201311: from=<bonjour@dejk.com>, size=180, nrcpt=1 (queue active)
        Mar  3 08:27:36 mail postfix/lmtp[2137]: 1E9981201311: to=<toto@coco.com>, relay=dovecot-lmtp[172.22.0.3]:24, delay=7.5, delays=7.4/0.01/0.02/0.11, dsn=2.0.0, status=sent (250 2.0.0 <toto@coco.com> 2rWFFEhvuVgACAAABKaThQ Saved)
        Mar  3 08:27:36 mail postfix/qmgr[148]: 1E9981201311: removed
        Mar  3 08:27:37 mail postfix/smtpd[2068]: disconnect from unknown[172.22.0.1] ehlo=1 mail=1 rcpt=1 data=1 quit=1 commands=5


**HO YEAHH!!!** Regardons maintenant le service __lmtp__ :

        $ docker exec -it coco-imap-t tail /var/log/mail.log
        Mar  2 17:12:45 mail dovecot: master: Dovecot v2.2.22 (fe789d2) starting up for imap, lmtp
        Mar  2 17:12:45 mail dovecot: ssl-params: Generating SSL parameters
        Mar  2 17:12:45 mail dovecot: ssl-params: SSL parameters regeneration completed
        Mar  2 17:43:15 mail dovecot: master: Warning: SIGHUP received - reloading configuration
        Mar  3 08:03:51 mail dovecot: master: Dovecot v2.2.22 (fe789d2) starting up for imap, lmtp
        Mar  3 08:24:40 mail dovecot: master: Warning: SIGHUP received - reloading configuration
        Mar  3 08:27:36 mail dovecot: lmtp(2048): Connect from 172.22.0.5
        Mar  3 08:27:36 mail dovecot: auth: Warning: sql: Ignoring changed user_query in /etc/dovecot/dovecot-sql.conf.ext, because userdb sql not used. (If this is intentional, set userdb_warning_disable=yes)
        Mar  3 08:27:36 mail dovecot: lmtp(toto@coco.com): 2rWFFEhvuVgACAAABKaThQ: msgid=unspecified: saved mail to INBOX
        Mar  3 08:27:36 mail dovecot: lmtp(2048): Disconnect from 172.22.0.5: Successful quit

Je sens monté l'excitation en vous :D, en tous cas moi ça me fait super plaisir !! Même encore maintenant après temps d'année j'ai du plaisir :D.

        $ docker exec -it coco-imap-t ls -R /var/mail/vhosts/coco.com/
        /var/mail/vhosts/coco.com/:
        toto

        /var/mail/vhosts/coco.com/toto:
        cur              dovecot-uidvalidity           dovecot.index.cache  new
        dovecot-uidlist  dovecot-uidvalidity.58b96f48  dovecot.index.log    tmp

        /var/mail/vhosts/coco.com/toto/cur:

        /var/mail/vhosts/coco.com/toto/new:
        1488547656.M391480P2048.mail.coco.com,S=401,W=411
        1488547759.M396349P2467.mail.coco.com,S=401,W=411

        /var/mail/vhosts/coco.com/toto/tmp:

Mais , car il y a un mais on a pas finit !!! Il faut convertir notre service __imap / lmtp__ en conteneur et plus en __pet conteneur__.

### <a name="conversion_pet_img" /> Conversion du conteneur Dovecot en image propre

Prendre note qu'entre les opérations, mon train est arrivé en gare :P , il y a donc eu redémarrage du conteneurs __dovecot__ , je dis bien redémarrage PAS réinitialisation ! J'en fait mention car lors de la réalisation du __docker diff__ ceci ce voit pour l'œil du renard que vous êtes :P.

        $ docker diff coco-imap-t  | egrep -v '/var/lib|/run|/var/log'                                                                                       
        C /var
        C /var/mail
        A /var/mail/vhosts
        A /var/mail/vhosts/coco.com
        A /var/mail/vhosts/coco.com/toto
        A /var/mail/vhosts/coco.com/toto/dovecot-uidlist
        A /var/mail/vhosts/coco.com/toto/dovecot-uidvalidity
        A /var/mail/vhosts/coco.com/toto/dovecot-uidvalidity.58b96f48
        A /var/mail/vhosts/coco.com/toto/dovecot.index.cache
        A /var/mail/vhosts/coco.com/toto/dovecot.index.log
        A /var/mail/vhosts/coco.com/toto/new
        A /var/mail/vhosts/coco.com/toto/new/1488547656.M391480P2048.mail.coco.com,S=401,W=411
        A /var/mail/vhosts/coco.com/toto/new/1488547759.M396349P2467.mail.coco.com,S=401,W=411
        A /var/mail/vhosts/coco.com/toto/tmp
        A /var/mail/vhosts/coco.com/toto/cur
        C /etc
        C /etc/group
        C /etc/dovecot
        C /etc/dovecot/conf.d
        C /etc/dovecot/conf.d/10-mail.conf
        C /etc/dovecot/conf.d/10-master.conf
        C /etc/dovecot/conf.d/10-auth.conf
        C /etc/dovecot/conf.d/auth-sql.conf.ext
        C /etc/dovecot/dovecot-sql.conf.ext
        C /etc/gshadow-
        C /etc/shadow
        A /etc/subuid-
        C /etc/group-
        C /etc/gshadow
        C /etc/subgid
        A /etc/subgid-
        C /etc/passwd
        C /etc/passwd-
        C /etc/subuid
        C /root
        A /root/.bash_history
        A /root/.viminfo

J'ai donc la liste des fichiers SANS aucun oublie , je vais donc rapporter cette configuration dans mon images . Je vais débuter avec le __Dockerfile__ :

        # Using Ubuntu
        FROM ubuntu:16.04
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Packages: update
        RUN apt-get update -qq && \
            apt-get install -qq -y --no-install-recommends dovecot-imapd dovecot-lmtpd dovecot-mysql \
                    python-pip supervisor rsyslog python-wheel python-setuptools  && \
            pip install j2cli

        # Configure: supervisor
        ADD bin/dfg.sh /usr/local/bin/
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/

        # Création répertoire pour les courriels & utilisateur
        RUN groupadd -g 5000 vmail && \
            useradd -g vmail -u 5000 vmail -d /var/mail && \
            chown -R vmail:vmail /var/mail

        # Fichier configuration Dovecot
        ADD conf/10*.conf conf/auth-sql.conf.ext /etc/dovecot/conf.d/

        # Fichier de configuration de mysql en template pour substitution
        ADD conf/dovecot-sql.conf.ext.j2           /root/

        # Runner
        ADD run.sh /root/run.sh
        RUN chmod +x /root/run.sh

        # Declare
        EXPOSE 143 24

        CMD ["/root/run.sh"]

Rapidement :

* Suppression des applications de debug
* Ajout de l'utilisateur **vmail** et création du répertoire
* Ajout des fichiers de configuration de __dovecot__
* Ajout du fichier de __template__ pour l'accès à la base de donnée.

Je vais copier les fichiers du pet conteneur dans le répertoire de création du conteneur.

        $ cd imap/conf/
        $ docker cp coco-imap-t:/etc/dovecot/conf.d/10-auth.conf .
        $ docker cp coco-imap-t:/etc/dovecot/conf.d/auth-sql.conf.ext .
        $ docker cp coco-imap-t:/etc/dovecot/conf.d/10-mail.conf .
        $ docker cp coco-imap-t:/etc/dovecot/conf.d/10-master.conf .
        $ docker cp coco-imap-t:/etc/dovecot/dovecot-sql.conf.ext .

Je renomme le fichier __dovecot-sql.conf.ext__ avec l'extension __.j2__ 

        $ mv dovecot-sql.conf.ext dovecot-sql.conf.ext.j2

Vous devriez faire une validation du conteneur afin de vous assurer qu'il n'y a pas de problème dans le contenu, quand je parle de problème je veux mentionné de donnée qui devrait être en __template__ .

Débutons la modification du fichier __dovecot-sql.conf.ext.j2__ afin d'inclure les valeurs en variable.
Voici donc le nouveau contenu :

        
        driver ={{ DB_TYPE }}
        connect = host={{ DB_HOST }} dbname={{ MYSQL_DATABASE }} user={{ MYSQL_USER }} password={{ MYSQL_PASSWORD }}

        password_query = SELECT username AS user,password FROM mailbox WHERE username = '%u' AND active='1'
        user_query = SELECT maildir, 5000 AS uid, 5000 AS gid FROM mailbox WHERE username = '%u' AND active='1'

Il nous reste donc le script __run.sh__ afin de modifier la configuration de ce fichier __template__ . 

On refait l'image et on valide :D

        $ docker-compose build imap-coco
        [... OUTPUT COUPÉ ...]
        Step 13 : CMD /root/run.sh
         ---> Running in 45c4fb76e50c
         ---> 6285c5389b91
        Removing intermediate container 45c4fb76e50c
        Successfully built 6285c5389b91

        $ docker-compose rm imap-coco
        Going to remove coco-imap-t
        Are you sure? [yN] y
        Removing coco-imap-t ... done

C'est repartie pour un tour :

        $ docker-compose up
        Starting coco-db-t
        Starting coco-http-t
        Creating coco-imap-t
        Recreating coco-smtp-t
        Attaching to coco-db-t, coco-http-t, coco-imap-t, coco-smtp-t
        [... OUTPUT COUPÉ ...]

        $ docker exec -it coco-imap-t tail /var/log/mail.log
        Mar  3 17:19:24 mail dovecot: master: Dovecot v2.2.22 (fe789d2) starting up for imap, lmtp
        Mar  3 17:19:24 mail dovecot: ssl-params: Generating SSL parameters
        Mar  3 17:19:27 mail dovecot: ssl-params: SSL parameters regeneration completed

Pour le moment pas d'erreur :D, __ZE__ teste :D.

        $ telnet 172.22.0.5 25
        [... c toujours les même instructions ...]

        $ docker exec -it coco-imap-t tail /var/log/mail.log                                                                                  
        Mar  3 17:19:24 mail dovecot: master: Dovecot v2.2.22 (fe789d2) starting up for imap, lmtp
        Mar  3 17:19:24 mail dovecot: ssl-params: Generating SSL parameters
        Mar  3 17:19:27 mail dovecot: ssl-params: SSL parameters regeneration completed
        Mar  3 17:20:48 mail dovecot: lmtp(362): Connect from 172.22.0.5
        Mar  3 17:20:48 mail dovecot: auth: Warning: sql: Ignoring changed user_query in /etc/dovecot/dovecot-sql.conf.ext, because userdb sql not used. (If this is intentional, set userdb_warning_disable=yes)
        Mar  3 17:20:48 mail dovecot: lmtp(toto@coco.com): UifgIEDsuVhqAQAABKaThQ: msgid=unspecified: saved mail to INBOX
        Mar  3 17:20:48 mail dovecot: lmtp(362): Disconnect from 172.22.0.5: Successful quit

**youpii** , mais est-ce que postfix valide réellement l'adresse ?? 

        $ telnet 172.22.0.5 25
        [... c toujours les même instructions ...]
        mail from:toto@kjekjfe.com
        250 2.1.0 Ok
        rcpt to:eohfe@coco.com
        550 5.1.1 <eohfe@coco.com>: Recipient address rejected: User unknown in virtual mailbox table
        quit
        221 2.0.0 Bye

C'est pas mal :D , c'était facile finalement ;-).


# <a name="finalisation" /> Finalisation et analyse des points d'amélioration

Bon maintenant nous avons 4 images :

*  __mysql__ : serveur de base de données.
*  __postfixadmin__ : Service __http__ pour la gestion des comptes. 
*  __smtp-db__ : Service __SMTP__ avec gestion de base de données.
*  __imap-db__ : Service __Imap__ et __LMTP__ pour la livraison des courriels.

Nous avons l'ensemble fonctionnel , mais en fait nous ne sommes jamais repartie de zéro nous avons fait la création au fur et à mesure, la base de donnée fut initialiser, une fois , fait la création d'une compte et connecté nos conteneurs à cette dernière. 
On va valider que nos images sont bonne !!

Le meilleur moyen est de tous détruire et recommencer :P, idéalement on détruirait aussi les images, mais bon ça rendrait trop content mon fournisseur de cellulaire que je dépasse ma consommation donnée mensuel ;-).

        $ docker-compose rm
        Going to remove coco-smtp-t, coco-imap-t, coco-http-t, coco-db-t
        Are you sure? [yN] y
        Removing coco-smtp-t ... done
        Removing coco-imap-t ... done
        Removing coco-http-t ... done
        Removing coco-db-t ... done

On redémarre l'ensemble , bien entendu nous allons devoir refaire la création de notre domaine et d'un compte car les données de la base de données sont perdu, car elles étaient dans le conteneur.

Je dois avouer que si ça redémarre pas bien, je vais un peu pleurer :P.

        $ docker-compose up
        [ ... OUTPUT COUPÉ ...]
        coco-http-t  |   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
        coco-http-t  |                                  Dload  Upload   Total   Spent    Left  Speed
        coco-smtp-t  | 2017-03-03 17:32:21,234 INFO success: postfix entered RUNNING state, process has stayed up for > than 3 seconds (startsecs)
          0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0127.0.0.1 - - [03/Mar/2017:17:32:21 -0500] "POST /setup.php HTTP/1.1" 200 3043 "-" "curl/7.38.0"
        100  2756  100  2646  100   110  10977    456 --:--:-- --:--:-- --:--:-- 11025
        coco-http-t  | <div class="standout">Admin has been added!<br />(admin@coco.com)</br /></div>

Les conteneurs sont bien présent :

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
        f2168851fb32        smtp-db             "/root/run.sh"           38 seconds ago      Up 36 seconds       25/tcp              coco-smtp-t
        8a7a29216642        postfixadmin        "docker-php-entrypoin"   39 seconds ago      Up 37 seconds       80/tcp              coco-http-t
        3cf4562eb701        imap-db             "/root/run.sh"           39 seconds ago      Up 37 seconds       24/tcp, 143/tcp     coco-imap-t
        f66096838419        mysql:5.5           "docker-entrypoint.sh"   40 seconds ago      Up 38 seconds       3306/tcp            coco-db-t

Bon le moment je souris :D. Connexion à l'interface web pour faire la création d'un domaine :

        $ docker inspect coco-http-t  | grep IPAd
                    "SecondaryIPAddresses": null,
                    "IPAddress": "",
                          "IPAddress": "172.22.0.4",

Je consulte le __docker-compose__ pour avoir le non utilisateur et mot de passe :

        $ cat docker-compose.yml  | grep ADM
                    - ADM_MAIL=admin@coco.com
                    - ADM_PASS=DockerRock

Je vais à l'adresse  :  [http://172.22.0.4](http://172.22.0.4) :

* Création du domaine : __super.com__ (juste pour avoir quelque chose d'autre que __coco.com__, si j'ai oublié de changer une variable quelque part)
* Création de la boite de courriel : __moi@super.com__ (faut bien se complimenter :D )

Bon et le moment critique l'envoie d'une courriel et validation de la réception ! 

        $ docker inspect coco-smtp-t | grep IPAd
                    "SecondaryIPAddresses": null,
                    "IPAddress": "",
                          "IPAddress": "172.22.0.5",

Avec beaucoup d'excitation on démarre le __telnet__ :

        $ telnet 172.22.0.5 25
        Trying 172.22.0.5...
        Connected to 172.22.0.5.
        Escape character is '^]'.
        220 relay.example.com ESMTP Postfix
        ehlo toto
        250-relay.example.com
        250-PIPELINING
        250-SIZE 10240000
        250-VRFY
        250-ETRN
        250-ENHANCEDSTATUSCODES
        250-8BITMIME
        250 DSN
        mail from:suspense@insoutenable.com
        250 2.1.0 Ok
        rcpt to:moi@super.com
        250 2.1.5 Ok
        data
        354 End data with <CR><LF>.<CR><LF>
        Hoooo ... vraiment COOL !!! je suis content 
        .
        250 2.0.0 Ok: queued as 7C2ED1201310
        quit
        221 2.0.0 Bye
        Connection closed by foreign host.

On retient son souffle et regarde les logs :

        $ docker exec -it coco-smtp-t tail /var/log/mail.log
        Mar  3 17:32:18 mail postfix[100]: See http://www.postfix.org/COMPATIBILITY_README.html for details
        Mar  3 17:32:18 mail postfix[100]: To disable backwards compatibility use "postconf compatibility_level=2" and "postfix reload"
        Mar  3 17:32:18 mail postfix/master[145]: daemon started -- version 3.1.0, configuration /etc/postfix
        Mar  3 17:39:15 mail postfix/smtpd[1801]: connect from unknown[172.22.0.1]
        Mar  3 17:39:36 mail postfix/smtpd[1801]: 7C2ED1201310: client=unknown[172.22.0.1]
        Mar  3 17:39:48 mail postfix/cleanup[1889]: 7C2ED1201310: message-id=<>
        Mar  3 17:39:48 mail postfix/qmgr[148]: 7C2ED1201310: from=<suspense@insoutenable.com>, size=212, nrcpt=1 (queue active)
        Mar  3 17:39:48 mail postfix/lmtp[1938]: 7C2ED1201310: to=<moi@super.com>, relay=dovecot-lmtp[172.22.0.3]:24, delay=17, delays=17/0.01/0.01/0.1, dsn=2.0.0, status=sent (250 2.0.0 <moi@super.com> ulRzJrTwuVgeBwAABKaThQ Saved)
        Mar  3 17:39:48 mail postfix/qmgr[148]: 7C2ED1201310: removed
        Mar  3 17:39:49 mail postfix/smtpd[1801]: disconnect from unknown[172.22.0.1] ehlo=1 mail=1 rcpt=1 data=1 quit=1 commands=5

        $ docker exec -it coco-imap-t tail /var/log/mail.log
        Mar  3 17:32:15 mail dovecot: master: Dovecot v2.2.22 (fe789d2) starting up for imap, lmtp
        Mar  3 17:32:16 mail dovecot: ssl-params: Generating SSL parameters
        Mar  3 17:32:16 mail dovecot: ssl-params: SSL parameters regeneration completed
        Mar  3 17:39:48 mail dovecot: lmtp(1822): Connect from 172.22.0.5
        Mar  3 17:39:48 mail dovecot: auth: Warning: sql: Ignoring changed user_query in /etc/dovecot/dovecot-sql.conf.ext, because userdb sql not used. (If this is intentional, set userdb_warning_disable=yes)
        Mar  3 17:39:48 mail dovecot: lmtp(moi@super.com): ulRzJrTwuVgeBwAABKaThQ: msgid=unspecified: saved mail to INBOX
        Mar  3 17:39:48 mail dovecot: lmtp(1822): Disconnect from 172.22.0.5: Successful quit

On peut pas attendre mieux , validons le répertoire contenant les fichiers :

        $ docker exec -it coco-imap-t ls -R /var/mail/vhosts/super.com/
        /var/mail/vhosts/super.com/:
        moi

        /var/mail/vhosts/super.com/moi:
        cur              dovecot-uidvalidity           dovecot.index.cache  new
        dovecot-uidlist  dovecot-uidvalidity.58b9f0b4  dovecot.index.log    tmp

        /var/mail/vhosts/super.com/moi/cur:

        /var/mail/vhosts/super.com/moi/new:
        1488580788.M686772P1822.mail.coco.com,S=442,W=452

        /var/mail/vhosts/super.com/moi/tmp:

Bon pour vous c'est probablement pas Vendredi comme en ce moment lors de la rédaction du texte mais MOI je vais passer un bon week-end :D.
Pas que je cherche à trouver un problème, mais on a pas valider l'authentification ... Roulement de tambour , bon pour être honnête je l'ai valider avant d'écrire ces lignes j'en pouvais plus :P.

         $ docker inspect coco-imap-t | grep IPAd
                     "SecondaryIPAddresses": null,
                     "IPAddress": "",
                        "IPAddress": "172.22.0.3",

         $ telnet 172.22.0.3 143
         Trying 172.22.0.3...
         Connected to 172.22.0.3.
         Escape character is '^]'.
         * OK [CAPABILITY IMAP4rev1 LITERAL+ SASL-IR LOGIN-REFERRALS ID ENABLE IDLE AUTH=PLAIN] Dovecot ready.
         * a login moi@super.com toto
         * a OK [CAPABILITY IMAP4rev1 LITERAL+ SASL-IR LOGIN-REFERRALS ID ENABLE IDLE SORT SORT=DISPLAY THREAD=REFERENCES THREAD=REFS THREAD=ORDEREDSUBJECT MULTIAPPEND URL-PARTIAL CATENATE UNSELECT CHILDREN NAMESPACE UIDPLUS LIST-EXTENDED I18NLEVEL=1 CONDSTORE QRESYNC ESEARCH ESORT SEARCHRES WITHIN CONTEXT=SEARCH LIST-STATUS BINARY MOVE SPECIAL-USE] Logged in

**VRAIMENT COOL**, que demander de plus ... En fait il y a plein de chose, mais je les listerai plus tard :D.

Pour parfaire la configuration nous devrions remettre en place les systèmes de volumes afin de conserver les donnés en dehors du conteneur , en effet si nous reprenons le fichier __docker-compose__, j'ai désactivé l'ensemble des volumes. Pourquoi ? Simplement parce que c'est beaucoup plus simple de supprimer et recommencer l'ensemble. De plus ceci nous offert la possibilité de visualiser comment supprimer un composante (conteneur) et de le réintégrer à l'ensemble.

Donc nous devrions remettre les volumes au minimum pour :

* **Mysql** : __/srv/docker/coco-db-t/var\_lib\_mysql:/var/lib/mysql__
* **Imap/smtp** : __/srv/docker/coco-imap-t/var\_mail:/var/mail/__

Et idéalement :

* **smtp** : __srv/docker/coco-smtp-t/var/spool/postfix:/var/spool/postfix__

Maintenant listons les améliorations que nous devrions apporter pour que le système soit **mieux** ou pour la production. 

## <a name="amelioration" /> Point d'amélioration 

Je vais lister des points d'amélioration, cependant je vais vous laisser le plaisir de les explorer , vous n'avez plus le problème de la page blanche, vous avez une base solide pour faire vos explorations :P .
Vous vous rappeler , exploration , réalisation de __docker diff__ transfert de la configuration dans l'image :D.

### <a name"certificat_SSL" /> Mise en place de certificat **SSL**

Premièrement le plus "critique" est que nous n'avons pas mis en place de certificat **SSL**  pour dovecot et voir pour le service __httpd__ afin de faire la gestion via __postfixadmin__. Ceci est critique, car le mot de passe sera transmis en claire sur l'Internet ! 

Je dois dire qu'à ce jour je n'ai malheureusement pas trouvé la meilleur méthode pour gérer de manière sexy les certificats __SSL__ pour mes conteneurs. J'utilise la méthode de volumes pour fournir la clé , le certificat et la chaine de certificats à mon conteneur . L'ensemble définie dans le __docker-compose__.
Je ne suis pas le seul à être à la recherche d'une solution plus élégante !

* [http://stackoverflow.com/questions/26028971/docker-container-ssl-certificates](http://stackoverflow.com/questions/26028971/docker-container-ssl-certificates)

Bien entendu le défis est de taille, car la clé et le certificat sont **unique** pour le service !! 

Petit clin d'œil, sur ce que je vais analyser sous peu : [http://www.automationlogic.com/using-lets-encrypt-and-docker-for-automatic-ssl/](http://www.automationlogic.com/using-lets-encrypt-and-docker-for-automatic-ssl/) .

Cette documentation propose d'utiliser __let's encrypt__ pour faire la gestion __SSL__ bon ici c'est uniquement pour le service __http__ faut voir les autres possibilité. Honnêtement je ne suis pas encore prêt pour __let's encrypt__ pas un problème technique, mais j'ai besoin de mieux comprendre le fonctionnement / le protocole . __Let's encrypt__ demande qu'une application soit présente sur votre serveur c'est la que j'ai un petit problème , je dois comprendre s'ils sont en mesure de déchiffrer mon trafic... Je présume qu'une session de formation aura lieu un fois que j'aurais compris pour partager mon apprentissage, ou pas si j'ai rien compris ;-).

Ne négligé pas l'importance du chiffrement surtout de nos jours !!!

### <a name"systeme_anti-spam" /> Validation des spams

Deuxième point d'amélioration pour une mise en place en production serait la présence d'un système anti-spam, afin de faire le trie dans les courriels reçu !
Bien entendu si votre serveur de courriel est pour vous uniquement et que vous utilisez un compte __gmail.com__ par exemple vous pouvez continuer à faire transiter vos courriels par google qui réalisera le filtrage puis le transmettra à votre adresse courriel.
Bien entendu la __NSA__ pourra en prendre une copie en passant , mais ne vous en faite pas elle sera aussi en mesure de les prendre directement sur votre serveur si elle le veut :P . Ils ont des ressources considérable :D.

Si vous cherchez des solutions voici des suggestions d'application :

* **amavis-ng** : permet de réaliser anti-spam et anti-virus
* **[fuglu](http://fuglu.org)** : permet de réaliser du filtrage de courriel anti-spam et anti-virus.
* **spamassassin** : système d'anti-spam , ce dernier est utilisé par les 2 applications mentionné précédemment

Pour vous fournir une vue général du mécanisme de __fuglu__ et __amavis-ng__ voici 2 images :

![postfix_amavisd.gif](./imgs/postfix_amavisd.gif)

![amavis-flux.png](./imgs/amavis-flux.png)

Rapidement :

1. postfix fait le traitement du courriel
2. postfix transmet le courriel à __amavis__ sur un port X , habituellement sur le port 10024 
3. __amavis__ fait l'analyse du courriel , anti-spam, anti-virus , voir plus . __amavis__ en profite pour ajouter des en-têtes , il peut aussi modifier le sujet pour indiquer que c'est un spam potentiel.
4. Si le courriel est assez "propre" __amavis__ le renvoie à postfix sur le port 10025 
5. postfix reprend la livraison normalement vers les boites utilisateur.

### <a name"utilisation_de_tail_http" /> Monitoring des services

Si vous passez à un système de gestion de type __Kubernet__ ou __swarm__ ces systèmes inclut une gestion des conteneurs et un redémarrage automatique en cas de problème. Encore là je vous parle théoriquement, car mon niveau de maturité __Docker__ n'est pas encore rendu à ce niveau :D. 
J'apprends encore à gérer manuellement mes conteneurs afin d'être en contrôle et comprendre le fonctionnement avec d'inclure des outils pour me facilité la vie . 

Nous avons bien fait la configuration pour que ce mécanisme de redémarrage automatique fonctionne **sauf** pour le service __httpd__ qui utilise la commande __tail__ pour conserver le conteneur actif. Nous devrions trouver une méthode afin que ce soit le service apache en avant plan ou du moins que le conteneur s'arrête si le service apache trébuche. 

ICI ICI ICI
# <a name="suggestion_exercice" /> Une suggestion d'exercice 
