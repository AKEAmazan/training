<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 

# <a name="Intro" /> Introduction

Telle que mentionné plusieurs fois lors des sessions précédente l'utilisation d'utilisateur local ne permet pas une gestion massive d'utilisateur, ceci nous limite beaucoup en particulier pour :

* La délégation de la création des comptes
* La modification des mot de passe
* La gestion des adresses similaire pour plusieurs domaine (ex: __info@coco.com et info@blabla.com__)
* La sécurisation de l'environnement, car chaque personne à un compte localement sur la machine
* ....

Un solution préconiser est l'utilisation d'une base de donnée pour le stockage des informations client. 
Voici ce que nous allons couvrir :

* Mise en place de postfix avec des comptes virtuels
* Intégration de postfix avec une base de données
* Mise en place d'une interface de gestion des comptes
* Intégration avec le serveur dovecot __imap__
* Un __webmail__ ? On verra selon le temps :-/

On va réaliser l'opération dans des conteneurs directement, maintenant que l'on y arrive chaque fois du premier coup :P  !

Voici un schéma des communications entre les conteneurs / application :

![flux_communication_smtp-bd-imap-http.png](./imgs/flux_communication_smtp-bd-imap-http.png)

Comme vous pouvez le constater la base de donnée est centrale dans le système , de les données sont uniquement fournit par le conteneur **imap** !

# <a name="setup_img" /> Configuration des images 

Telle que mentionné pour gagné du temps on va tous de suite le faire avec des conteneurs, si vous désirez le mettre en place uniquement sur une machines il suffira de reprendre l'ensemble des commandes des conteneurs et faire l'opération sur **LA** machine.

## <a name="setup_db" /> Configuration de la base de donnée

Comme l'ensemble du système repose sur la base de donnée, nous allons débuter par ce conteneur et construire autour . L'avantage aussi de débuter par ce conteneur et que l'image est déjà disponible . [https://hub.docker.com](https//hub.docker.com) offre un conteneur officiel de [Mysql](https://hub.docker.com/_/mysql/).

Si nous regardons le descriptif nous avons ceci :

        MYSQL_USER, MYSQL_PASSWORD
        These variables are optional, used in conjunction to create a new user and to set that user's password. This user will be granted superuser permissions (see above) for the database specified by the MYSQL_DATABASE variable. Both variables are required for a user to be created.

En d'autre mot en passant les variables d'environnement le système va automatiquement faire la création de l'utilisateur / mot de passe et de la BD .

On essaye :D , on sait jamais peut-être que le site ment :P.

        $ docker run -e MYSQL_USER=umail -e MYSQL_PASSWORD=ZePassword -e MYSQL_DATABASE=vmail -e MYSQL_RANDOM_ROOT_PASSWORD=yes  mysql:5.5
        Initializing database
        170217 22:18:49 [Note] /usr/local/mysql/bin/mysqld (mysqld 5.5.52) starting as process 60 ...
        170217 22:18:50 [Note] /usr/local/mysql/bin/mysqld (mysqld 5.5.52) starting as process 66 ...

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
        f95afd51c1e2        mysql:5.5           "docker-entrypoint.sh"   28 seconds ago      Up 27 seconds       3306/tcp            pensive_bohr

        $ docker exec -it pensive_bohr mysql -u umail -p
        Enter password:
        mysql> show databases;
        +--------------------+
        | Database           |
        +--------------------+
        | information_schema |
        | vmail              |
        +--------------------+
        2 rows in set (0.00 sec)

        mysql> use vmail;
        Database changed
        mysql> show tables;
        Empty set (0.00 sec)

        mysql> Bye

Là on peut dire du premier coup :P !!!

Bon on fait le __docker-compose__ tous de suite !!

        version: '2'
        services:
            db-coco:
                image: mysql:5.5
                restart: unless-stopped
                container_name : 'coco-db-t'
                hostname: db.coco.com
                environment:
                    - MYSQL_USER=umail
                    - MYSQL_PASSWORD=ZePassword
                    - MYSQL_DATABASE=vmail
                    - MYSQL_RANDOM_ROOT_PASSWORD=yes
                    - TZ=America/Montreal
                    - TERM=xterm
                volumes:
                    - /srv/docker/coco-db-t/var_lib_mysql:/var/lib/mysql

Comme vous pouvez le constater j'ai exporter le répertoire __/var/lib/mysql__ sur le docker host pour conserver les données hors du conteneur.
On le valide :

        $ docker-compose up
        Creating network "srvmailwithimapwithbd_default" with the default driver
        Creating coco-db-t
        Attaching to coco-db-t
        coco-db-t  | Initializing database

Encore du premier coup , on y prend goût :D, pas de panique ça ne durera pas :D.

## <a name="setup_http" /> Configuration du service Web pour la gestion de la base de donnée

Maintenant que l'on a une base de donnée vierge nous allons la remplir avec le système [postfixadmin](http://postfixadmin.sourceforge.net/), ce système permet de contrôler et définir des domaines , adresses courriels, utilisateur , ... Là pas de bol pas de conteneur officiel, on va devoir s'amuser :D. 
Par contre nous avons un conteneur officiel pour [php](https://hub.docker.com/_/php/) , au lieu de démarrer avec un Ubuntu et installer apache et **php** nous allons démarrer avec le conteneur officiel ! Faut bien faire changement un peu de temps en temps :D, histoire d'avoir de nouveau problème :D.

Si vous regardez la page il y a plusieurs type de conteneur disponible :

        5.6.30-cli, 5.6-cli, 5-cli, 5.6.30, 5.6, 5 (5.6/Dockerfile)
        5.6.30-alpine, 5.6-alpine, 5-alpine (5.6/alpine/Dockerfile)
        5.6.30-apache, 5.6-apache, 5-apache (5.6/apache/Dockerfile)
        5.6.30-fpm, 5.6-fpm, 5-fpm (5.6/fpm/Dockerfile)

* **cli** :  pour utiliser __php__ en commande line
* **alpine** : Utilise une version minimal de Linux
* **apache** : Avec le serveur web apache

La version alpine est un conteneur plus minimal , alpine est une distribution moins gourmand en espace disque , alors que la version "non" alpine est un conteneur dérivé de debian (si je ne me trompe pas). On va commencer par la version "normale" et on analysera si on peut passer au mode alpine par la suite.

Avant de se lancer dans __Dockerfile__ définissons les grandes lignes que ceci devra conteneur , nous allons vouloir installer [postfixadmin](http://postfixadmin.sourceforge.net/) , donc prenons la documentation . [https://github.com/albanpeignier/postfixadmin/blob/master/INSTALL.TXT](https://github.com/albanpeignier/postfixadmin/blob/master/INSTALL.TXT) 

Nous avons donc besoin :

* apache (bien entendu)
* __PHP__ 4.1 ou plus (5.X recommandé )
* Module __php__ pour établir une connexion __Mysql__

Je vais d'abord valider l'image __php:5-apache__ Je la récupère donc depuis [hub.docker.com](http://hub.docker.com).

        $ docker pull php:5-apache
        5-apache: Pulling from library/php

Si nous regardons la page du conteneur __php__ nous pourrons constater qu'il y a le lien vers le __dockerFile__ du package : [php:5-apache](https://github.com/docker-library/php/blob/e573f8f7fda5d7378bae9c6a936a298b850c4076/5.6/apache/Dockerfile), nous voyons clairement que la référence est un __debian:jessie__.

Vous pouvez le démarrer pour vous faire la main dessus, car être confortable est très important , bon moi j'ai envie de le faire "live", je vais débuter avec un __dockerfile__ :P après le succès de __MySQL__ j'ai crois :P.

Voici le __dockerfile__ : 

        # Thomas Boutry
        FROM php:5-apache
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Php Modules a activer
        RUN docker-php-ext-install mbstring \
            && docker-php-ext-install mcrypt \
            && docker-php-ext-install mysql \
            && docker-php-ext-install mysqli \
            && docker-php-ext-install pdo_mysql


La particularité ici , entre une machine "classique" et le conteneur __php__ , l'instruction d'installation des modules aurais été comme suit pour une installe classique  :

        RUN apt-get update \
            && apt-get install php-mcrypt php-mysql php-mysqli 

Mais le système de docker officiel offre une autre possibilité , que j'ai envie d'essayer :D , donc j'ai pris la philosophie du conteneur ! 

On construit l'image :

        $ docker build -t postfixadmin .
        [ ... OUTPUT COUPÉ ...]
        checking if nawk is broken... no
        checking for mcrypt support... yes, shared
        configure: error: mcrypt.h not found. Please reinstall libmcrypt.
        The command '/bin/sh -c docker-php-ext-install mbstring     && docker-php-ext-install mcrypt     && docker-php-ext-install mysql     && docker-php-ext-install mysqli     && docker-php-ext-install pdo_mysql' returned a non-zero code: 1


Nous pouvons voir que lors de la création du conteneur , le système compile les modules à ajouter il a donc besoin des packages sources pour réaliser l'opération je vais faire l'ajout. 


        # Thomas Boutry
        FROM php:5-apache
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Php Modules a activer 
        RUN apt-get update && apt-get install -y  --no-install-recommends libmcrypt-dev \
            && docker-php-ext-install mbstring \
            && docker-php-ext-install mcrypt \
            && docker-php-ext-install mysql \
            && docker-php-ext-install mysqli \
            && docker-php-ext-install pdo_mysql


        $ docker build -t postfixadmin .
        [ ... OUTPUT COUPÉ ... ]
        rm -f libphp.la       modules/* libs/*
         ---> 5e8e831c6a96
         Removing intermediate container 6d35d7aee6b8
         Successfully built 5e8e831c6a96


Super nous avons donc notre conteneur avec l'ensemble d'installer ... Du moins on le pense (honnêtement je le sais pas moi même à ce stade :D , on découvre ensemble !! ).

Je vais démarrer le conteneur et mettre en place un fichier __phpinfo__ afin de confirmer ce qui est bien présent :D .

        $ docker run  postfixadmin
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message
        [Mon Feb 20 13:37:20.574334 2017] [mpm_prefork:notice] [pid 1] AH00163: Apache/2.4.10 (Debian) PHP/5.6.30 configured -- resuming normal operations
        [Mon Feb 20 13:37:20.574363 2017] [core:notice] [pid 1] AH00094: Command line: 'apache2 -D FOREGROUND'

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
        095673118d88        postfixadmin        "docker-php-entrypoin"   15 seconds ago      Up 13 seconds       80/tcp              focused_hawking

        $ docker exec -it focused_hawking bash
        root@095673118d88:/var/www/html# pwd
        /var/www/html

Comme je n'ai pas **vi** sur la machine je vais simplement faire la création avec __echo__ 

        root@095673118d88:/var/www/html# echo "<?php  phpinfo(); ?>" >> index.php

Visualisation du résultat :

![php_docker-view-phpinfo.png](./imgs/php_docker-view-phpinfo.png)

Bien entendu vous pouvez visualiser le conteneur de la configuration apache dans **/etc/apache2**, je vous laisse le plaisir !

Parfait après validation nous pouvons dire que ceci semble convenable, nous allons maintenant ajouter la configuration de __postfixadmin__. Je télécharge l'application depuis internet [https://sourceforge.net/projects/postfixadmin/files/postfixadmin/postfixadmin-2.3.8/](https://sourceforge.net/projects/postfixadmin/files/postfixadmin/postfixadmin-2.3.8/).

J'ai placé l'application dans le répertoire __docroot__

        $ ls http/
        Dockerfile  docroot

        $ ls http/docroot/
        postfixadmin-2.3.8

        $ ls -1 http/docroot/postfixadmin-2.3.8/ | head -5
        ADDITIONS
        admin
        backup.php
        broadcast-message.php
        CHANGELOG.TXT

Modification du __Dockerfile__ en conséquence. 

        COPY docroot/postfixadmin-2.3.8/ /var/www/html/

Nous allons aussi profiter du moment pour modifier le fichier __docker-compose.yml__ :


        version: '2'
        services:
            db-coco:
                image: mysql:5.5
                restart: unless-stopped
                container_name : 'coco-db-t'
                hostname: db.coco.com
                environment:
                    - MYSQL_USER=umail
                    - MYSQL_PASSWORD=ZePassword
                    - MYSQL_DATABASE=vmail
                    - MYSQL_RANDOM_ROOT_PASSWORD=yes
                    - TZ=America/Montreal
                    - TERM=xterm
                volumes:
                    - /srv/docker/coco-db-t/var_lib_mysql:/var/lib/mysql
            http-coco:
                image: postfixadmin
                build: ./http/
                restart: unless-stopped
                container_name : 'coco-http-t'
                hostname: mail.coco.com
                links:
                    - db-coco:mysql-db
                environment:
                    - MYSQL_USER=umail
                    - MYSQL_PASSWORD=ZePassword
                    - MYSQL_DATABASE=vmail
                    - TZ=America/Montreal
                    - TERM=xterm

L'ensemble est pas mal déjà maîtrisé , petit détail qui fut ajouté la ligne suivante :

        build: ./http/

Ceci me permet de réaliser des constructions d'image directement avec la commande __docker-compose__ au lieu de changer de répertoire et de faire __docker build -t ....__ :D. Ça commençais  à m'ennuyer de changer de répertoire tous le temps. Résultat  :

        $ docker-compose build http-coco
        Building http-coco
        Step 1 : FROM php:5-apache
         ---> 9013e58a01eb
         Step 2 : MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>
          ---> Using cache
           ---> 1ab4c14a8cbd
        [ ... OUTPUT COUPÉ ... ]


Nous réalisons un teste avec les 2 conteneurs :

        $ docker-compose up
        Starting coco-db-t
        Creating coco-http-t
        Attaching to coco-db-t, coco-http-t
        coco-db-t    | 170221  8:18:38 [Note] mysqld (mysqld 5.5.52) starting as process 1 ...
        coco-db-t    | 170221  8:18:38 [Note] Plugin 'FEDERATED' is disabled.
        coco-db-t    | 170221  8:18:38 InnoDB: The InnoDB memory heap is disabled
        coco-db-t    | 170221  8:18:38 InnoDB: Mutexes and rw_locks use GCC atomic builtins
        coco-db-t    | 170221  8:18:38 InnoDB: Compressed tables use zlib 1.2.3
        coco-db-t    | 170221  8:18:38 InnoDB: Using Linux native AIO

![default_page_postfixadm.png](./imgs/default_page_postfixadm.png)


Pas trop mal :D. Nous pouvons réaliser le **setup** : [http://172.22.0.3/setup.php](http://172.22.0.3/setup.php) Bien entendu votre IP peut être tous autre.

[erreur_setup_postfixadm-01.png](./imgs/erreur_setup_postfixadm-01.png)

**yeahh** des problèmes on finira pas trop tôt la formation ;-).

Bon clairement il manque la configuration du fichier ! Nous allons donc regarder ce dit fichier. Le fichier est dans le répertoire **http/docroot/postfixadmin-2.3.8/config.inc.php**.

Premièrement je vais réaliser une copie du fichier , le nouveau fichier sera de type **jinja2**

        $ mkdir http/conf/
        $ cp http/docroot/postfixadmin-2.3.8/config.inc.php http/conf/config.inc.php.j2


Voici les changements réalisés :


        $ diff http/conf/config.inc.php.j2 http/docroot/postfixadmin-2.3.8/config.inc.php  
        26c26
        < $CONF['configured'] = true;
        ---
        > $CONF['configured'] = false;
        31c31
        < $CONF['setup_password'] = '{{ SETUP_PASS }}';
        ---
        > $CONF['setup_password'] = 'changeme';
        49,53c49,53
        < $CONF['database_type'] = '{{ DB_TYPE }}';
        < $CONF['database_host'] = 'db';
        < $CONF['database_user'] = '{{ MYSQL_USER }}';
        < $CONF['database_password'] = '{{ MYSQL_PASSWORD }}';
        < $CONF['database_name'] = '{{ MYSQL_DATABASE }}';
        ---
        > $CONF['database_type'] = 'mysql';
        > $CONF['database_host'] = 'localhost';
        > $CONF['database_user'] = 'postfix';
        > $CONF['database_password'] = 'postfixadmin';
        > $CONF['database_name'] = 'postfix';
        82c82
        < $CONF['admin_email'] = 'postmaster@{{ MAIL_DOMAIN }}';
        ---
        > $CONF['admin_email'] = 'postmaster@change-this-to-your.domain.tld';
        133,136c133,136
        <     'abuse' => 'abuse@{{ MAIL_DOMAIN }}',
        <     'hostmaster' => 'hostmaster@{{ MAIL_DOMAIN }}',
        <     'postmaster' => 'postmaster@{{ MAIL_DOMAIN }}',
        <     'webmaster' => 'webmaster@{{ MAIL_DOMAIN }}'
        ---
        >     'abuse' => 'abuse@change-this-to-your.domain.tld',
        >     'hostmaster' => 'hostmaster@change-this-to-your.domain.tld',
        >     'postmaster' => 'postmaster@change-this-to-your.domain.tld',
        >     'webmaster' => 'webmaster@change-this-to-your.domain.tld'

J'ai donc modifier les paramètres de définitions de la base de donnée ainsi que la définition du domaine __change-this-to-your.domain.tld__ pour la variable __MAIL\_DOMAIN__ . **ATTENTION** je ne prétend pas que l'ensemble de la configuration est complète je vous invite à refaire une validation !!!

C'est cool tous ça mais on a pas installé le système de conversion __jinja2__ :P faut modifier le __Dockerfile__ :

        # Php Modules a activer
        RUN apt-get update && apt-get install -y  --no-install-recommends libmcrypt-dev python-pip python-wheel python-setuptools \
        && docker-php-ext-install mbstring \
        && docker-php-ext-install mcrypt \
        && docker-php-ext-install mysql \
        && docker-php-ext-install mysqli \
        && docker-php-ext-install pdo_mysql \
        && pip install j2cli

On reconstruit :

        $ docker-compose build http-coco 
        [... OUTPUT COUPÉ ...]
        Removing intermediate container 3a605fd30e74
        Step 5 : COPY docroot/postfixadmin-2.3.8/ /var/www/html/
         ---> 252f7f7de579
         Removing intermediate container b63121cb60e1
         Successfully built 252f7f7de579

__Oupss__ ça a marché du premier coup :P , à avoir su j'aurais tous de suite modifier le fichier __Dockerfile__ pour qu'il copie le fichier de configuration :P .

Donc ajout du fichier de configuration en __template__ dans le __Dockerfile__: 

        # Copie la configuration en format Jinja2
        COPY conf/config.inc.php.j2 /root/

Nous allons aussi modifier le __docker-compose__ afin d'avoir la définition des variables , comme il y a eu 24 heures entre l'écriture du fichier de __template__ et la définition du __docker-compose__ je vais faire l'extraction des variables , car j'ai une petite mémoire :P.

        $ cat http/conf/config.inc.php.j2 | grep {{ | sed "s/.*{{ \([A-Z_]*\) }}'/\1/g"  | tr -d "," | tr -d ";" | sort | uniq
        $CONF['database_name'] = '{{ MYSQL_DATABASE }}'
        DB_TYPE
        MAIL_DOMAIN
        MYSQL_PASSWORD
        MYSQL_USER
        SETUP_PASS


Bon presque, mais on va pas perdre plus de temps :D, l'important ici c'est pas le **sed** :D.
Voici donc nos nouvelles variables pour le __docker-compose__ :

                environment:
                    - MYSQL_USER=umail
                    - MYSQL_PASSWORD=ZePassword
                    - MYSQL_DATABASE=vmail
                    - TZ=America/Montreal
                    - TERM=xterm
                    - DB_TYPE=mysql
                    - MAIL_DOMAIN=coco.com
                    - SETUP_PASS=superPasse



### <a name="setup_http_script" /> Script de démarrage 

Comme vous pouvez le constater actuellement notre __Dockerfile__ ne contient PAS de script d'exécution :

            # Thomas Boutry
            FROM php:5-apache
            MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

            # Ignore APT warnings about not having a TTY
            ENV DEBIAN_FRONTEND noninteractive

            # Php Modules a activer
            RUN apt-get update && apt-get install -y  --no-install-recommends libmcrypt-dev python-pip python-wheel python-setuptools \
                && docker-php-ext-install mbstring \
                && docker-php-ext-install mcrypt \
                && docker-php-ext-install mysql \
                && docker-php-ext-install mysqli \
                && docker-php-ext-install pdo_mysql \
                && pip install j2cli

            # Copie l'application postfix adm
            COPY docroot/postfixadmin-2.3.8/ /var/www/html/

            # Copie la configuration en format Jinja2
            COPY conf/config.inc.php.j2 /root/

Pourtant le service __apache__ fonctionne quand on démarre le conteneur nous l'avons vu lors de la visualisation du fichier __phpinfo__. Ceci est inclut dans l'image de base **php:5-apache** :

        $ docker history php:5-apache                                                                                                                        
        IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
        9013e58a01eb        3 weeks ago         /bin/sh -c #(nop)  CMD ["apache2-foreground"]   0 B
        <missing>           3 weeks ago         /bin/sh -c #(nop)  EXPOSE 80/tcp                0 B
        <missing>           3 weeks ago         /bin/sh -c #(nop)  WORKDIR /var/www/html        0 B
        <missing>           3 weeks ago         /bin/sh -c #(nop) COPY file:24613ecbb1ce6a09f   1.346 kB
        <missing>           4 weeks ago         /bin/sh -c #(nop)  ENTRYPOINT ["docker-php-en   0 B
        <missing>           4 weeks ago         /bin/sh -c #(nop) COPY multi:2b7e23dbf0e975ef   5.33 kB
        <missing>           4 weeks ago         /bin/sh -c set -xe  && buildDeps="   $PHP_EXT   33.21 MB
        <missing>           4 weeks ago         /bin/sh -c #(nop) COPY file:207c686e3fed4f71f   587 B
        <missing>           4 weeks ago         /bin/sh -c set -xe;   fetchDeps='   wget  ';    12.98 MB

Vous pouvez le constater il y a la ligne :

* **CMD ["apache2-foreground"]**
* **ENTRYPOINT ["docker-php-en**

Nous avons besoin nous aussi d'avoir un script qui soit exécuter lors de l'initialisation du conteneur afin de faire la substitution des variables !! 

Cette situation m'a permis d'analyser la question de l'héritage des entrés **CMD** et **ENTRYPOINT** , car il y a 2 instructions possible pour exécuter une script lors de l'initialisation du conteneur. Mon objectif fut de définir une instruction pour le __run__ mais que par la suite il appel le script d'initialisation du parent !

Cependant ceci ne semble pas possible, voici l'interaction entre **CMD** et **ENTRYPOINT** :

[https://docs.docker.com/engine/reference/builder/#/entrypoint](https://docs.docker.com/engine/reference/builder/#/entrypoint)


![cmd_vs_entrypoint.png](./imgs/cmd_vs_entrypoint.png)

Nous allons donc surdéfinir l'instruction **CMD** et appeler le script **apache2-foreground** par la suite !
Donc définition du script **run.sh** :

        $ cat http/run.sh
        #! /usr/bin/env bash
        set -e # exit on error

        # Variables
        export MYSQL_USER=${MYSQL_USER:-"myuser"}
        export MYSQL_PASSWORD=${MYSQL_PASSWORD:-"superpass"}
        export MYSQL_DATABASE=${MYSQL_DATABASE:-"mails"}
        export DB_TYPE=${DB_TYPE:-"mysql"}
        export MAIL_DOMAIN=${MAIL_DOMAIN:-"example.com"}
        export SETUP_PASS=${SETUP_PASS:-"fkrhreiu"}

        # Templates
        j2 /root/config.inc.php.j2 > /var/www/html/config.inc.php

        # Rappel de la commande CMD du script original
        apache2-foreground

Modification du __Dockerfile__ :

        [... OUTPUT COUPÉ ...]
        # Copie la configuration en format Jinja2
        COPY conf/config.inc.php.j2 /root/

        # script pour la substitution
        ADD run.sh /

        CMD ["/run.sh"]

On reconstruit l'image et on valide :

        $ docker-compose build http-coco
        $ docker-compose up http-coco
        $ docker exec coco-http-t cat /var/www/html/config.inc.php | grep -i coco                                                                             
        $CONF['admin_email'] = 'postmaster@coco.com';
        'abuse' => 'abuse@coco.com',
        'hostmaster' => 'hostmaster@coco.com',
        'postmaster' => 'postmaster@coco.com',
        'webmaster' => 'webmaster@coco.com'

Ça semble bon :D

### <a name="setup_http_app_postfixadm" /> Validation de l'application postfixadmin

J'ai arrêté le conteneur __http__ pour démarrer l'ensemble __http__ ET __bd__ 

        $ docker-compose up
        [... OUTPUT COUPÉ ...]
        coco-db-t    | 170223  8:06:13 [Note] Event Scheduler: Loaded 0 events
        coco-db-t    | 170223  8:06:13 [Note] mysqld: ready for connections.
        coco-db-t    | Version: '5.5.52'  socket: '/tmp/mysql.sock'  port: 3306  MySQL Community Server (GPL)
        coco-http-t  | [Thu Feb 23 08:13:25.903190 2017] [mpm_prefork:notice] [pid 8] AH00163: Apache/2.4.10 (Debian) PHP/5.6.30 configured -- resuming normal operations
        coco-http-t  | [Thu Feb 23 08:13:25.903242 2017] [core:notice] [pid 8] AH00094: Command line: 'apache2 -D FOREGROUND'


Extraction de l'IP du serveur __http__ :

        $ docker inspect coco-http-t | grep IPAddre
                    "SecondaryIPAddresses": null,
                        "IPAddress": "",
                        "IPAddress": "172.22.0.2",

Si vous allez à la page [http://172.22.0.2](http://172.22.0.2) , vous aurez la page d'authentification :

![postfixadm-home.png](./imgs/postfixadm-home.png)

Si nous reprenons les instructions d'installation de __postfixadmin__ [INSTALL.TXT](https://github.com/albanpeignier/postfixadmin/blob/master/INSTALL.TXT) vous pourrez voir à l'étape 4 que nous devons aller à l'URL [http://172.22.0.2/setup.php](http://172.22.0.2/setup.php) pour compléter l'installation.

On va le faire ! Donc je vais à la page [http://172.22.0.2/setup.php](http://172.22.0.2/setup.php) 

Voici le résultat 

![postfixadm-setup1.png](./imgs/postfixadm-setup1.png)
![postfixadm-setup2.png](./imgs/postfixadm-setup2.png)

Regardons l'état de la Base de donnée :


        $ docker exec -it coco-db-t mysql -u umail -p
        Enter password:
        Welcome to the MySQL monitor.  Commands end with ; or \g.
        [ ... OUTPUT COUPÉ ...]
        mysql> use vmail;

        mysql> show tables;
        +-----------------------+
        | Tables_in_vmail       |
        +-----------------------+
        | admin                 |
        | alias                 |
        | alias_domain          |
        | config                |
        | domain                |
        | domain_admins         |
        | fetchmail             |
        | log                   |
        | mailbox               |
        | quota                 |
        | quota2                |
        | vacation              |
        | vacation_notification |
        +-----------------------+
        13 rows in set (0.00 sec)

        mysql> select * from admin;
        Empty set (0.00 sec)

        mysql> select * from config;
        +----+---------+-------+
        | id | name    | value |
        +----+---------+-------+
        |  1 | version | 740   |
        +----+---------+-------+
        1 row in set (0.00 sec)



Ajoutons l'administrateur ! 

* __Setup password : password__
* __Admin: xerus@coco.com__
* __Password: blabla__
* __Password (again): blabla__

Une fois l'opération réaliser voici le résultat :

![postfixadm-setup3.png](./imgs/postfixadm-setup3.png)


Si nous regardons dans la BD maintenant :

        mysql> select * from admin;
        Empty set (0.00 sec)

RIEN !!! **ishh** , 

Il y a l'information suivante sur la page web: 

        If you want to use the password you entered as setup password, edit config.inc.php and set
        
        $CONF['setup_password'] = 'e483919d4e684d4bff3669f0a50f6c57:805a8aa8ff92297d7e83c74a5cd1a7f9827ecfdb';

Une fois que j'ai modifier le fichier __coco-http-t:/var/www/html/config.inc.php__ pour définir la variable convenable ceci à très bien fonctionné :-/.
J'ai refait l'opération et j'ai eu l'information suivante :

![postfixadm-setup4.png](./imgs/postfixadm-setup4.png)

Si je valide dans la base de donnée :

        mysql> select * from admin;
        +----------------+------------------------------------+---------------------+---------------------+--------+
        | username       | password                           | created             | modified            | active |
        +----------------+------------------------------------+---------------------+---------------------+--------+
        | xerus@coco.com | $1$f02bfd0b$g.W7zDWmgCve8tBsKo5Fn. | 2017-02-23 08:33:27 | 2017-02-23 08:33:27 |      1 |
        +----------------+------------------------------------+---------------------+---------------------+--------+
        1 row in set (0.00 sec)

Et via l'interface j'arrive bien à m'authentifier :

![postfixadm-main-admin.png](./imgs/postfixadm-main-admin.png)

Bon maintenant LA question , mais comment faire pour que ce soit automatique ?!?! Ce n'est pas quelque chose de compliqué, cependant nous aimerions pouvoir déployer des conteneurs avec le système de __postfixadmin__ __pré-configurer__ en définissant l'administrateur par défaut en variable. N'est-ce pas ?
Bien entendu je démontre ici pour __postfixadmin__ mais c'est une configuration très classique, beaucoup d'application offre l'option de configuration avec 2 ou 3 étapes. 

**Clarifions  quelque choses** : La je vous montre ça puis ça va avoir l'air très simple, mais dans la réalité je viens de l'apprendre !! :P Oui moi aussi j'apprends avec ces formations faut bien que ce soit gagnant / gagnant :D . J'ai mis un peu de temps 1 heure 30 pour juste trouver comment communiquer avec la page __setup.php__ :P.



### <a name="test_feed_automatic_setup" /> Explication pour le remplissage automatique du formulaire avec CURL

Voici l'explication des testes que j'ai réalisé , premièrement j'ai valider quelle application en ligne de commande :

        $ docker exec -it coco-http-t bash
        root@mail:/var/www/html# wget
        bash: wget: command not found
        root@mail:/var/www/html# curl --version
        curl 7.38.0 (x86_64-pc-linux-gnu) libcurl/7.38.0 OpenSSL/1.0.1t zlib/1.2.8 libidn/1.29 libssh2/1.4.3 librtmp/2.3
        Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp scp sftp smtp smtps telnet tftp
        Features: AsynchDNS IDN IPv6 Largefile GSS-API SPNEGO NTLM NTLM_WB SSL libz TLS-SRP

Je ne voulais pas installer une autre application dans le conteneur , donc ce sera **curl** c'est bien :D.

Maintenant nous avons besoin de faire 2 opérations :

1. Générer le mot de passe de __setup__ et le mettre dans le fichier __config.inc.php__ .
2. Définir un administrateur et mot de passe avec le mot de passe utilisé pour la génération.

Avec l'instance du conteneur en place nous pouvons faire autant de teste que l'on désire il faudra juste ajuster le fichier de configuration.

J'ai trouvé si le site très bien fait  [BASH: Filling Web Forms with cURL and wget](https://journalxtra.com/linux/bash-linuxsanity/bash-filling-web-forms-with-curl-and-wget/) une très bonne explication . Mais surtout un script qui permet d'extraire les champs du formulaire, en effet bien que l'on puisse lire le fichier __setup.php__ il n'est pas toujours facile de s'en sortir surtout si on code pas souvent ! 

TODO : fixer le lien
Comme il n'est plus disponible sur __github__ mais uniquement sur l'archive je vous l'ai mis sur le projet __github__ [formfind](TODO).

Voyons comment l'utiliser , premièrement je vais récupérer la page web __setup.php__ puis je vais le transmettre au script pour qu'il me le pré mâche :D.

        $ curl  http://172.22.0.3/setup.php > setup.html
          % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
          i                                 Dload  Upload   Total   Spent    Left  Speed
          100  2597  100  2597    0     0   230k      0 --:--:-- --:--:-- --:--:--  253k

        $ tail setup.html
           </tr>
           </table>
           </form>
           </div>

           <b>Since version 2.3 there is no requirement to delete setup.php!</b><br />
           <b>Check the config.inc.php file for any other settings that you might need to change!<br />
           </div>
           </body>
           </html>
         $ ./formfind < setup.html
         --- FORM report. Uses POST to URL "<form name="create_admin" method="post">"
         Input: NAME="form" VALUE="createadmin" (HIDDEN)
         Input: NAME="setup_password" (PASSWORD)
         Input: NAME="fUsername" (TEXT)
         Input: NAME="fPassword" (PASSWORD)
         Input: NAME="fPassword2" (PASSWORD)
         Input: NAME="submit" VALUE="Add Admin" (SUBMIT)
         --- end of FORM

**WOWWWww** maintenant facilement je vois l'ensemble des nom des champs que je dois fournir pour remplir le formulaire sans lire l'ensemble de la page __html__ :D.

Maintenant je peux utiliser la commande __curl__ pour remplir le formulaire :

        $ curl  -X POST -d "setup_password=tototitittata" -d "form=createadmin" http://172.22.0.3/setup.php | grep "CONF"
          % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                           Dload  Upload   Total   Spent    Left  Speed
          100  2904  100  2859  100    45   276k   4454 --:--:-- --:--:-- --:--:--  310k
          <li>Checking $CONF['configured'] - OK
          <div class="standout"><p><b>Setup password not specified correctly</b></p><p>If you want to use the password you entered as setup password, edit config.inc.php and set</p><pre>$CONF['setup_password'] = '4db3d5aeebfbf0a39bc2e1b8fb2b80a3:7e0ad0394dc7c76dd0185b540cd653f15224945f';</pre></div>

__Yep__ ça marche (1 heure et demi plus tard , je mettrai pas le nombre de tentative :P ) . Maintenant je dois amélioré le résultat pour n'avoir que le texte qui m'intéresse et non toute la ligne. Validons si j'ai __sed__ de présent sur la machine , mais la libre à vous de l'outil !!!

        root@mail:/var/www/html# sed --version
        sed (GNU sed) 4.2.2
        Copyright (C) 2012 Free Software Foundation, Inc.

Parfait, j'ai tous ce qu'il me faut pour travaillé ... Bon 10 minutes plus tard , je dis pas que c'est la plus belle des commandes , c'est a retravailler :) , mais le résultat est présent ! 

        $ curl  -X POST -d "setup_password=tototitittata" -d "form=createadmin" http://172.22.0.3/setup.php 2>/dev/null | grep "CONF" | grep "setup_password"
         | sed "s/.*\$CONF\['setup_password'\] = '\(.*\)';.*/\1/g"                                                                                                    
         830c77bc82bcea9a7b03259a6f56f074:c63a85565e676f3151e211f3c2ffb50b9a9c708b

Maintenant on valide que ceci fonctionne aussi dans le conteneur , car ce n'est peut-être pas la même version de __curl__ il est possible que le comportement soit différent. 

        root@mail:/var/www/html# curl  -X POST -d "setup_password=tototitittata" -d "form=createadmin" http://127.0.0.1/setup.php 2>/dev/null | grep "CONF" | grep "setup_password" | sed "s/.*\$CONF\['setup_password'\] = '\(.*\)';.*/\1/g"
        abaf7d8a20c2c7b3d89d03fc93cd8609:059e2856ff5aef253b5312fe55eaa4858f66a78f

Nous sommes donc en mesure d'extraire le résultat du mot de passe "chiffré" nous allons maintenant valider que nous sommes en mesure en utilisant la même méthode de faire la création du compte administrateur ! Je vais donc modifier manuellement dans le conteneur la valeur de **$CONF['setup_password']** avec le résultat du **hash** . Comme je n'ai pas **vim** de présent et que je n'ai qu'une ligne à modifier je vais utiliser **sed** en même temps ça donne un coup de pratique, car nous utiliserons la même méthode dans le script d'initialisation.

        root@mail:/var/www/html# sed "s/\$CONF\['setup_password'\] = 'superPasse';/\$CONF\['setup_passwo12fe55eaa4858f66a78f'/g" config.inc.php  | grep setup_pf253b531
        $CONF['setup_password'] = 'abaf7d8a20c2c7b3d89d03fc93cd8609:059e2856ff5aef253b5312fe55eaa4858f66a78f'

Ceci était uniquement pour valider je vais ajouter l'option **-i** pour que le **sed** modifie le fichier de configuration original:

        root@mail:/var/www/html# sed -i "s/\$CONF\['setup_password'\] = 'superPasse';/\$CONF\['setup_password'\] = 'abaf7d8a20c2c7b3d89d03fc93cd8609:059e2856ff5aef253b5312fe55eaa4858f66a78f';/g" config.inc.php                
        root@mail:/var/www/html# echo $?
        0
        root@mail:/var/www/html# grep "setup_pass" config.inc.php
        $CONF['setup_password'] = 'abaf7d8a20c2c7b3d89d03fc93cd8609:059e2856ff5aef253b5312fe55eaa4858f66a78f'

Je vais maintenant réutiliser **curl** pour créer un administrateur, je réutilise le script pour extraire les informations du formulaire , car je me rappelle plus des paramètres :D

        $ ./formfind < setup.html
        --- FORM report. Uses POST to URL "<form name="create_admin" method="post">"
        Input: NAME="form" VALUE="createadmin" (HIDDEN)
        Input: NAME="setup_password" (PASSWORD)
        Input: NAME="fUsername" (TEXT)
        Input: NAME="fPassword" (PASSWORD)
        Input: NAME="fPassword2" (PASSWORD)
        Input: NAME="submit" VALUE="Add Admin" (SUBMIT)
        --- end of FORM


Donc je démarre la création de l'administrateur :

        $ curl  -X POST -d "setup_password=tototitittata" -d "fUsername=admin@coco.com" -d "fPassword=superPass" -d "fPassword2=superPass" -d "form=createadmin" http://172.22.0.3/setup.php
        [ ... OUTPUT COUPÉ ... ]
        <li><b>Warning: Depends on: IMAP functions - NOT FOUND</b><br />
        To install IMAP support, install php5-imap<br />
        Without IMAP support, you won't be able to create subfolders when creating mailboxes.</li>
        </ul><p>Everything seems fine... attempting to create/update database structure</p>
        <p>Database is up to date</p>
        <div class="standout">Admin has been added!<br />(admin@coco.com)</br /></div>
        <div id="edit_form">
        <form name="create_admin" method="post">
        <input type="hidden" name="form" value="createadmin" />
        <table>
              <td colspan="3"><h3>Create superadmin account</h3></td>
                 </tr>
        [... OUTPUT COUPÉ ...]

Comme nous pouvons le voir le message indique que l'administrateur fut bien créé : **Admin has been added!** , comme on est jamais trop sûr on va valider dans la base de donnée : 

        $ docker exec -it coco-db-t mysql -u umail -p
        Enter password:
        mysql> use vmail;
        mysql> select * from admin;
        +----------------+------------------------------------+---------------------+---------------------+--------+
        | username       | password                           | created             | modified            | active |
        +----------------+------------------------------------+---------------------+---------------------+--------+
        | xerus@coco.com | $1$f02bfd0b$g.W7zDWmgCve8tBsKo5Fn. | 2017-02-23 08:33:27 | 2017-02-23 08:33:27 |      1 |
        | admin@coco.com | $1$acdd0365$OitGJK6KIulo4reFSe07t. | 2017-02-27 08:13:35 | 2017-02-27 08:13:35 |      1 |
        +----------------+------------------------------------+---------------------+---------------------+--------+

Super :D , on fait la même validation dans le conteneur juste pour être sûr bien que je suis confiant, mais si faut faire un changement je préfère le faire avant de reconstruire l'image du conteneur. 

        root@mail:/var/www/html# curl  -X POST -d "setup_password=tototitittata" -d "fUsername=admin2@coco.com" -d "fPassword=superPass" -d "fPassword2=superPass" -d "form=createadmin" http://127.0.0.1/setup.php | grep "Admin has been added!"
          % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                           Dload  Upload   Total   Spent    Left  Speed
        100  2759  100  2647  100   112  55441   2345 --:--:-- --:--:-- --:--:-- 56319
        <div class="standout">Admin has been added!<br />(admin2@coco.com)</br /></div>

        mysql> select * from admin;
        +-----------------+------------------------------------+---------------------+---------------------+--------+
        | username        | password                           | created             | modified            | active |
        +-----------------+------------------------------------+---------------------+---------------------+--------+
        | xerus@coco.com  | $1$f02bfd0b$g.W7zDWmgCve8tBsKo5Fn. | 2017-02-23 08:33:27 | 2017-02-23 08:33:27 |      1 |
        | admin@coco.com  | $1$acdd0365$OitGJK6KIulo4reFSe07t. | 2017-02-27 08:13:35 | 2017-02-27 08:13:35 |      1 |
        | admin2@coco.com | $1$e12796d0$NHeD1ypJVVdcHuiHvbmFE/ | 2017-02-27 08:19:05 | 2017-02-27 08:19:05 |      1 |
        +-----------------+------------------------------------+---------------------+---------------------+--------+

Je pense que nous sommes en affaire :D, c'est le temps de l'automatiser, nous allons reprendre le fichier **run.sh** du conteneur __http__.

* Référence : 
    * https://journalxtra.com/linux/bash-linuxsanity/bash-filling-web-forms-with-curl-and-wget/
    * https://curl.haxx.se/docs/httpscripting.html

### <a name="automatic_setup_init" /> Création automatique d'un administrateur lors de l'initialisation

Pour débuter nous allons définir des variables d'environnement pour le compte administrateur :

* **ADM_MAIL** : l'adresse de l'administrateur par défaut
* **ADM_PASS** : Mot de passe l'administrateur 
* **SETUP_PASS** : Mot de passe pour la configuration qui sera __hashé__ avec le résultat du formulaire. 

La mise en place dans le __template__ de la valeur de **$SETUP_PASS** était une erreur !!! Je vais donc modifier le fichier : **http/conf/config.inc.php.j2** afin d'avoir une valeur prévisible pour mon **sed** : (**http/conf/config.inc.php.j2**)

        Original :
        $CONF['setup_password'] = '{{ SETUP_PASS }}';

        Nouvelle valeur :
        $CONF['setup_password'] = 'curl_will_change_it';

Maintenant je vais ajouter les 2 autres variable dans le __docker-compose__ : 

            [... OUTPUT COUPÉ ... ]
                environment:
                    - MYSQL_USER=umail
                    - MYSQL_PASSWORD=ZePassword     
                    - MYSQL_DATABASE=vmail          
                    - TZ=America/Montreal           
                    - TERM=xterm
                    - DB_TYPE=mysql
                    - MAIL_DOMAIN=coco.com          
                    - SETUP_PASS=superPasse         
                    - ADM_MAIL=admin@coco.com
                    - ADM_PASS=DockerRock

Bon la partie facile est faite :P , faut bien s'attaquer au fichier **http/run.sh** :P , voici donc la nouvelle version :

        #! /usr/bin/env bash
        set -e # exit on error

        # Variables
        export MYSQL_USER=${MYSQL_USER:-"myuser"}
        export MYSQL_PASSWORD=${MYSQL_PASSWORD:-"superpass"}
        export MYSQL_DATABASE=${MYSQL_DATABASE:-"mails"}
        export DB_TYPE=${DB_TYPE:-"mysql"}
        export MAIL_DOMAIN=${MAIL_DOMAIN:-"example.com"}
        export SETUP_PASS=${SETUP_PASS:-"fkrhreiuTOTO"}
        export ADM_MAIL=${ADM_MAIL:-"NOT_DEFINE"}
        export ADM_PASS=${ADM_PASS:-"NOT_DEFINE"}

        # Validation des variables !!
        if [ "$ADM_MAIL" == "NOT_DEFINE" ] ; then
            echo 'You need to set variable $ADM_MAIL !! '
            echo "I already set all the software , I can't choose your username ;) "
            exit 1
        fi
        if [ "$ADM_PASS" == "NOT_DEFINE" ] ; then
            echo 'You need to set variable $ADM_PASS !! '
            echo "I already set all the software , I can't choose your PASSWORD ;) "
            exit 1
        fi

        # Templates
        j2 /root/config.inc.php.j2 > /var/www/html/config.inc.php

        # Initilisation de la configuration de postfix :
        SETUP_PASS_HASH=$(curl  -X POST -d "setup_password=$SETUP_PASS" -d "form=createadmin" http://127.0.0.1/setup.php 2>/dev/null | grep "CONF" | grep "setup_password" | sed "s/.*\$CONF\['setup_password'\] = '\(.*\)';.*/\1/g")

        # Update postfix configuration file
        sed -i "s/\$CONF\['setup_password'\] = 'curl_will_change_it';/\$CONF\['setup_password'\] = \'$SETUP_PASS_HASH\';/g" /var/www/html/config.inc.php

        # Creation de l'administrateur
        curl  -X POST -d "setup_password=$SETUP_PASS" -d "fUsername=$ADM_MAIL" -d "fPassword=$ADM_PASS" -d "fPassword2=$ADM_PASS" -d "form=createadmin" http://127.0.0.1/setup.php | grep "Admin has been added!"


        if [ $? -ne 0 ] ; then
            echo "ERROR with Admin creation :-/"
            echo "Curl cmd : "
            echo "curl X POST -d "setup_password=$SETUP_PASS" -d "fUsername=$ADM_MAIL" -d "fPassword=$ADM_PASS" -d "fPassword2=$ADM_PASS" -d "form=createadmin" http://127.0.0.1/setup.php"

            exit 1
        fi

        # Rappel de la commande CMD du script original
        apache2-foreground

J'y crois on détruit tous et on relance le tous :D :

        docker-compose build
        db-coco uses an image, skipping
        Building http-coco
        Step 1 : FROM php:5-apache
         ---> 9013e58a01eb

        $ docker-compose stop
        Stopping coco-http-t ... done
        Stopping coco-db-t ...

        $ docker-compose rm
        Going to remove coco-http-t, coco-db-t
        Are you sure? [yN] y
        Removing coco-http-t ... done
        Removing coco-db-t ... done

Ok let's GO :D 

        $ docker-compose up
        Creating coco-db-t
        Creating coco-http-t
        Attaching to coco-db-t, coco-http-t
        coco-db-t    | 170227  8:42:23 [Note] mysqld (mysqld 5.5.52) starting as process 1 ...

        coco-http-t  |   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
        coco-http-t  |                                  Dload  Upload   Total   Spent    Left  Speed
          0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0curl: (7) Failed to connect to 127.0.0.1 port 80: Connection refused
          ^CGracefully stopping... (press Ctrl+C again to force)
          Stopping coco-http-t ... done
          Stopping coco-db-t ... done

**HA !!** ouin effectivement mes commandes __curl__ sont avant que je ne démarre apache :P !!!
Ici nous pouvons constater l'importance d'avoir l'option **set -e # exit on error** dans notre script __bash__, sans cette option je n'aurais pas constater le problème simplement que ça ne fonctionne pas mais le service serait démarrer !

Donc voici la nouvelle version **run.sh** :

        # Templates
        j2 /root/config.inc.php.j2 > /var/www/html/config.inc.php

        # Démarrage du processus apache2 en background 
        apache2-foreground &

        # en attente de l'initialisation de apache TODO : mettre une solution plus belle
        sleep 3

        # Initilisation de la configuration de postfix :
        SETUP_PASS_HASH=$(curl  -X POST -d "setup_password=$SETUP_PASS" -d "form=createadmin" http://127.0.0.1/setup.php 2>/dev/null | grep "CONF" | grep "setup_password" | sed "s/.*\$CONF\['setup_password'\] = '\(.*\)';.*/\1/g")

        echo $SETUP_PASS_HASH

        # Update postfix configuration file
        sed -i "s/\$CONF\['setup_password'\] = 'curl_will_change_it';/\$CONF\['setup_password'\] = \'$SETUP_PASS_HASH\';/g" /var/www/html/config.inc.php

        # Creation de l'administrateur
        curl  -X POST -d "setup_password=$SETUP_PASS" -d "fUsername=$ADM_MAIL" -d "fPassword=$ADM_PASS" -d "fPassword2=$ADM_PASS" -d "form=createadmin" http://127.0.0.1/setup.php | grep "Admin has been added!"

        if [ $? -ne 0 ] ; then
            echo "ERROR with Admin creation :-/" 
            echo "Curl cmd : "
            echo "curl X POST -d "setup_password=$SETUP_PASS" -d "fUsername=$ADM_MAIL" -d "fPassword=$ADM_PASS" -d "fPassword2=$ADM_PASS" -d "form=createadmin" http://127.0.0.1/setup.php"
            exit 1
         fi

         # Show apache logs; TODO revoir la stratégie
         tail -f /var/log/apache2/access.log /var/log/apache2/error.log

Comme vous pouvez le constater je démarre le service **apache2-forground** beaucoup plus tôt , je réalise une petite pause de 3 seconde **sleep 3** afin de laisser le temps à apache de d'initialiser  le service. Par la suite pour que le service reste en premier plan je fait un **tail** des fichiers de logs .

#### <a name="automatic_setup_init_prob" /> Liste de problématique 

Quelle est le problème avec la mise en place de la commande **tail** pour conserver le service ouvert ?

La problématique est que si le service **apache** s'arrête , le conteneur va continuer à fonctionner , résultat si vous avez des systèmes de redémarrage automatique inclus par exemple avec **Kubernet** ou autre votre conteneur ne sera pas redémarrer ! En d'autre mot l'utilisation de **tail** doit être réalisé avec parcimonie . Bon comme j'ai envie de progresser, nous allons continuer avec ça pour le moment cependant ce devrait être réviser si nous allions en production avec cette image !

Autre problème avec cette solution , actuellement à chaque fois que je vais démarrer le conteneur le système va mettre à jour le fichier de configuration de __postfixadmin__ et tenter de créer un administrateur ! Par contre nous désirons avoir ce mécanisme, uniquement lors de l'initialisation du conteneur pas à chaque démarrage je vais donc ajouter une condition pour valider si la configuration fut déjà réalisé.


        #! /usr/bin/env bash
        set -e # exit on error

        # Variables
        export MYSQL_USER=${MYSQL_USER:-"myuser"}
        export MYSQL_PASSWORD=${MYSQL_PASSWORD:-"superpass"}
        export MYSQL_DATABASE=${MYSQL_DATABASE:-"mails"}
        export DB_TYPE=${DB_TYPE:-"mysql"}
        export MAIL_DOMAIN=${MAIL_DOMAIN:-"example.com"}
        export SETUP_PASS=${SETUP_PASS:-"fkrhreiuTOTO"}
        export ADM_MAIL=${ADM_MAIL:-"NOT_DEFINE"}
        export ADM_PASS=${ADM_PASS:-"NOT_DEFINE"}

        export ALREADY_SETUPED=/etc/configured

        # Validation des variables !!
        if [ "$ADM_MAIL" == "NOT_DEFINE" ] ; then
            echo 'You need to set variable $ADM_MAIL !! '
            echo "I already set all the software , I can't choose your username ;) "
            exit 1
        fi
        if [ "$ADM_PASS" == "NOT_DEFINE" ] ; then
            echo 'You need to set variable $ADM_PASS !! '
            echo "I already set all the software , I can't choose your PASSWORD ;) "
            exit 1
        fi

        # Templates
        j2 /root/config.inc.php.j2 > /var/www/html/config.inc.php

        # Démarrage du processus apache2 en background
        apache2-foreground &

        # en attente de l'initialisation de apache TODO : mettre une solution plus belle
        sleep 3

        if [ ! -e $ALREADY_SETUPED ] ; then

            # Initilisation de la configuration de postfix :
            SETUP_PASS_HASH=$(curl  -X POST -d "setup_password=$SETUP_PASS" -d "form=createadmin" http://127.0.0.1/setup.php 2>/dev/null | grep "CONF" | grep "setup_password" | sed "s/.*\$CONF\['setup_password'\] = '\(.*\)';.*/\1/g")


            # Update postfix configuration file
            sed -i "s/\$CONF\['setup_password'\] = 'curl_will_change_it';/\$CONF\['setup_password'\] = \'$SETUP_PASS_HASH\';/g" /var/www/html/config.inc.php

            # Creation de l'administrateur
            curl  -X POST -d "setup_password=$SETUP_PASS" -d "fUsername=$ADM_MAIL" -d "fPassword=$ADM_PASS" -d "fPassword2=$ADM_PASS" -d "form=createadmin" http://127.0.0.1/setup.php | grep "Admin has been added!"


            if [ $? -ne 0 ] ; then
                echo "ERROR with Admin creation :-/"
                echo "Curl cmd : "
                echo "curl X POST -d "setup_password=$SETUP_PASS" -d "fUsername=$ADM_MAIL" -d "fPassword=$ADM_PASS" -d "fPassword2=$ADM_PASS" -d "form=createadmin" http://127.0.0.1/setup.php"
                exit 1
            fi

            # Creation du fichier pour indiquer que le conteneur est configurer
            touch $ALREADY_SETUPED

        fi # END if [ -e $ALREADY_SETUPED ]

        # Show apache logs : TODO : revoir la stratégie
        tail -f /var/log/apache2/access.log /var/log/apache2/error.log

Donc je crée un fichier qui me servira de point de référence à savoir si la configuration est déjà réalisé , bon idéalement je communiquerai avec la base de donnée afin de valider son intégrité, malheureusement ceci demanderai plus d'effort que j'ai pas envie de mettre maintenant :P .
On peut toujours faire mieux :) , mais bon à ce stade , je vais me limité à cette fonctionnalité.

On détruit TOUS et on valide :

        $ docker-compose rm 
        $ docker-compose build
        $ docker-compose up                                            
        Creating coco-db-t
        Creating coco-http-t
        Attaching to coco-db-t, coco-http-t
        coco-db-t    | Initializing database


       $ docker exec -it coco-db-t mysql -u umail -p                                                                                                         
       Enter password:
       mysql> use vmail;

       mysql> select * from admin;
       +----------------+------------------------------------+---------------------+---------------------+--------+
       | username       | password                           | created             | modified            | active |
       +----------------+------------------------------------+---------------------+---------------------+--------+
       | admin@coco.com | $1$0a09f6cb$4CuEpMG2X2Vqd5SV/xA4E/ | 2017-02-28 17:26:00 | 2017-02-28 17:26:00 |      1 |
       +----------------+------------------------------------+---------------------+---------------------+--------+

**MAGIE** 

## <a name="setup_mails" /> Configuration d'un domaine et boite courriel

Bon maintenant que nous avons 2 morceaux 

* Base de donnée
* Application de gestion de comptes

Nous allons créer un domaine et un compte de courriel pour les testes !

        $ docker inspect coco-http-t | grep IPAd
                    "SecondaryIPAddresses": null,
                    "IPAddress": "",
                          "IPAddress": "172.22.0.3",

Nous allons sur la page de login : [http://172.22.0.3/login.php](http://172.22.0.3/login.php), pour les informations de connections regardez dans le __docker-compose.yml__ :P .

![postfix-admin-home.png](./imgs/postfix-admin-home.png)

* __Domain List -> New Domain__

![postfix-admin-createdomain.png](./imgs/postfix-admin-createdomain.png)

* __Virtual List --> New mailbox__

![postfix-admin-createmailbox.png](./imgs/postfix-admin-createmailbox.png)

Bon maintenant on peut plus détruire notre base de donnée :P , il faudra composer avec ou alors refaire la configuration du compte de courriel :D . 
Je voulais introduire cette limitation :-) , bien entendu ce ne serait pas grave ce n'est pas beaucoup d'opération :) .
En plus ça fait du bien voir que ça fonctionne bien :D.



## <a name="setup_smtp" /> Configuration du service SMTP

SUPER, nous avons 2 conteneur sur 4 :D , On a la moitié de réalisé !! Bon on s'est pas trop foulé pour la partie base de donnée, mais si vous avez un chargé de projet sur le dos ça fait toujours bien à dire :D.

En plus maintenant on gère bien postfix ;-)

Bon reprenons la documentation de __postfixadmin__ le fichier d'installation : [INSTALL.txt](https://github.com/mattrude/PostfixAdmin/blob/master/INSTALL.TXT) , les points de 1 à 5 sont réglés . Nous sommes donc bien rendu à la partie Intégration avec postfix , le document dit de voir le fichier : [POSTFIX_CONF.txt](https://github.com/mattrude/PostfixAdmin/blob/master/DOCUMENTS/POSTFIX_CONF.txt). 
C'est donc partie partie !

Malheureusement il n'existe pas de conteneur **postfix** officiel nous allons donc devoir réaliser notre propre conteneur , mais on assure la dessus :D.

Avant de se lancer dans le __Dockerfile__ analysons ce dont nous avons besoin :

* postfix 
* postfix avec __mysql__ 
* nous "maitrisons" lmtp donc nous utiliserons cette méthode pour transmettre les courriels à dovecot

La variables d'environnement :

* Lien avec la BD : Hôte, Utilisateur , mot de passe, base de donnée
* Lien avec Dovecot (__lmtp__)
* Réseaux permit pour transmettre des courriels
* Utilisation d'une __relay host__ ?
* Le nom de la machine pour la configuration postfix

Autre choses ? Pour le moment je ne vois pas , mais comme toujours on ajustera :P

Rédaction du __Dockerfile__ , oui oui j'ai pris comme point de départ celui que nous avions utilisé précédemment :D, j'ai ajouté le support **Mysql** avec le package **postfix-mysql**

        # Using Ubuntu
        # Start Exemple:
        # ou can add -p 25:25 for LAN access
        FROM ubuntu:16.04
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Packages: update
        RUN apt-get update -qq && \
            apt-get install -qq -y --no-install-recommends postfix postfix-mysql \
                python-pip supervisor rsyslog python-wheel python-setuptools  && \
            pip install j2cli

        # Configure: supervisor
        ADD bin/dfg.sh /usr/local/bin/
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/

        # Setup postfix conf
        ADD conf/postfix-main.j2 /root/

        # Runner
        ADD run.sh /root/run.sh
        RUN chmod +x /root/run.sh

        # Declare
        EXPOSE 25

        CMD ["/root/run.sh"]


Bon maintenant je vais reprendre les fichier __bin/dfg.sh__ et __supervisor-all__ :

        $ sudo vim conf/supervisor-all.conf
        [supervisord]
        logfile = /var/log/supervisord.log
        logfile_backups = 0

        [program:rsyslogd]
        command = /usr/sbin/rsyslogd -n

        [program:postfix]
        command = /usr/local/bin/dfg.sh /var/spool/postfix/pid/master.pid /etc/init.d/postfix start
        startsecs = 3

        $ cp ../../srvMailWithImap/smtp/bin/dfg.sh .

On a quelque chose qui fonctionne on va pas se casser la tête à le faire autrement on a eu assez de problème déjà :P. 
Passons maintenant au fichier de configuration postfix **postfix-main.j2** :

        smtpd_banner = $myhostname ESMTP $mail_name

        alias_database = hash:/etc/aliases
        alias_maps = hash:/etc/aliases

        smtpd_relay_restrictions = permit_mynetworks  defer_unauth_destination
        myhostname = $myorigin
        myorigin = {{ SMTP_HOSTNAME }}

        mydestination = localhost $myorigin
        mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 {{ PERMIT_NETWORK }}
        inet_interfaces = all
        inet_protocols = ipv4

        # Configuration du lien avec Mysql:
        virtual_mailbox_domains = proxy:mysql:/etc/postfix/sql/mysql_virtual_domains_maps.cf
        virtual_alias_maps =
           proxy:mysql:/etc/postfix/sql/mysql_virtual_alias_maps.cf,
           proxy:mysql:/etc/postfix/sql/mysql_virtual_alias_domain_maps.cf,
           proxy:mysql:/etc/postfix/sql/mysql_virtual_alias_domain_catchall_maps.cf
        virtual_mailbox_maps =
           proxy:mysql:/etc/postfix/sql/mysql_virtual_mailbox_maps.cf,
           proxy:mysql:/etc/postfix/sql/mysql_virtual_alias_domain_mailbox_maps.cf

        # Configuration pour l'envoie vers lmtp (aka dovecot)
        mailbox_transport = lmtp:{{ DOVECOT_SRV }}:24



        {% if (EXT_RELAY_HOST != "DIRECT") %}relayhost = {{ EXT_RELAYHOST }} {% endif %}

Explication de la configuration postfix :
Nous utilisons le système __virtual__ de postfix , pourquoi __virtual__ ceci permet d'identifier que la gestion pour postfix n'est pas pour une livraison pour l'hôte (__hostname__) mais pour une configuration virtuelle pour un domaine autre . Vous avez une explication a l'URL : [VIRTUAL\_README](http://www.postfix.org/VIRTUAL_README.html).

3 instructions sont introduites ici :

* [**virtual\_mailbox\_domains**](http://www.postfix.org/postconf.5.html#virtual_mailbox_domains) ( == mydestination ) : Ceci définie les domaines qui sont accepté , techniquement il est possible de les définir comme pour la valeur __MyDestination__ en fournissant une liste des domaines (ex: __coco.com toto.ca__) bien entendu dans notre cas nous utilisons un __lookuptable__ qui est __Mysql__
* [**virtual\_alias\_maps**](http://www.postfix.org/postconf.5.html#virtual_alias_maps) (== aliasses): ceci permet de définir les alias des adresses courriels encore une nous utilisons le __Lookuptable__ avec __Mysql__ . __Ho__ mais pourquoi 3 définitions ?? Nous le verrons un peu plus loin mais il y a 3 requêtes __SQL__ distinctes qui sont réalisées :
    * __mysql\_virtual\_alias\_maps__ :  alias des adresses courriels dont __thomas@coco.com --> xerus@coco.com__ classique :D
    * __mysql\_virtual\_alias\_domain\_maps__ : alias de domaine donc __titi.com --> coco.com__ l'ensemble des courriels transmit aux adresses __titi.com__ seront transmis à __coco.com__.
    * __mysql\_virtual\_alias\_domain\_catchall\_maps__ : Permet de définir un __wildcard__ de courriels donc __*@coco.com --> info@coco.com__
* [**virtual\_mailbox\_maps**](http://www.postfix.org/postconf.5.html#virtual_mailbox_maps) : Permet de définir non pas les alias mes les adresses courriels réelle , d'utilisateur.

Maintenant le fichier __run.sh__ , prendre note j'ai changé la variable __ACCEPT\_DOMAIN__ pour __DB\_HOST__ , car faut définir la BD et de toute manière la liste des domaines accepté est définie dedans :D. De plus contrairement à la version original j'ai définie le lien avec __dovecot__ en variable comme ça se conteneur pourrait fonctionner autant avec un autre conteneur ou une __VM / host non dockerisé__ :

        #! /usr/bin/env bash
        set -e # exit on error

        # Variables
        export EXT_RELAY_HOST=${EXT_RELAY_HOST:-"DIRECT"}
        export SMTP_HOSTNAME=${SMTP_HOSTNAME:-"relay.example.com"}
        export PERMIT_NETWORK=${PERMIT_NETWORK:-"192.168.0.0/16"}

        export DB_HOST=${DB_HOST:-"mysql"}
        export DOVECOT_SRV=${DOVECOT_SRV:-"dovecot-lmtp" }

        echo $SMTP_HOSTNAME > /etc/mailname

        # Templates
        j2 /root/postfix-main.j2 > /etc/postfix/main.cf

        # Launch
        rm -f /var/spool/postfix/pid/*.pid
        exec /usr/bin/supervisord -n


