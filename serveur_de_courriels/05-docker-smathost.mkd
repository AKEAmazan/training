<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 

* [ Introduction](#Intro)
* [ Image du conteneur srvmailrelay ](#image)
       * [ DockerFile ](#image_dockerfile)
       * [ DockerFile fichier de configuration](#image_dockerfile_conf)
       * [ DockerFile fichier exécutable (bin) ](#image_dockerfile_bin)
           * [ DockerFile fichier exécutable (bin) DFG](#image_dockerfile_bin_dfg)
           * [ DockerFile fichier exécutable (bin) run](#image_dockerfile_bin_run)

# <a name="Intro" /> Introduction

À la lumière de votre intérêt pour docker , nous allons voir la partie de la __dockerisation__ du serveur de relais , le gros avantage de __dockeriser__ ce service est qu'il change très peu. J'ai créer une images spécialement pour la formation afin de réduire le nombre de paramètre, afin de simplifier la démonstration. 
Pour la petite mise en contexte , cette image est utilisé sur l'ensemble des mes "__datacenters__", bon bon __ok__ je m'excite un peu là , je devrais dire sur mon serveur au centre de donnée et chez moi :P . Il ne reste que l'avantage est que je me suis fait chier une fois et maintenant je peux l'utiliser partout en définissant des paramètres selon le lieu :D. 
En d'autre mot je vais passez en paramètre le nom du serveur de relais , par le fait même que mon __FAI__ soit __BELL__ , __Videotron__ , __Roger__ peut importe lors du démarrage, je vais indiquer la destination. Ceci sera le même principe pour les réseaux que j'autorise à utiliser le service __SMTP__ de mon serveur.

Voyons la configuration maintenant que l'on est confortable avec postfix , ce sera plus simple.

La définition de l'image est disponible ICI : [SrcMailRelay conteneur](https://github.com/x3rus/training/tree/master/serveur_de_courriels/dockers/srvMailRelay)

# <a name="image" /> Image du conteneur srvmailrelay 

C'est partie , pour le plaisir des petits comme des grands :D.

Débutons avec le __DockerFile__ puis nous verrons les fichiers utilisés .

## <a name="image_dockerfile" /> DockerFile 

Voici le contenu : 

        FROM debian:jessie
        MAINTAINER Uri Savelchev <alterrebe@gmail.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Packages: update
        RUN apt-get update -qq && \
            apt-get install -qq -y --no-install-recommends postfix ca-certificates \
                    libsasl2-modules python-pip supervisor rsyslog && \
            pip install j2cli

        # Fix timezone
        RUN ln -s -f /usr/share/zoneinfo/Canada/Eastern /etc/localtime

        # Add files
        ADD conf /root/conf

        # Configure: supervisor
        ADD bin/dfg.sh /usr/local/bin/
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/

        # Runner
        ADD run.sh /root/run.sh
        RUN chmod +x /root/run.sh

        # Declare
        EXPOSE 25

        CMD ["/root/run.sh"]

Bon maintenant que je le regarde, il y a des points qui m'ennuie , ce conteneur date et il y a des choses que j'aime moins ... Mais bon . Comme vous pouvez le voir j'ai laissé le nom du __maintener__ original. J'étais partie d'une image disponible sur internet et j'ai réaliser quelques modifications.

* **FROM debian:jessie** : Donc je suis partie d'une __debian__ version __jessie__ , [Debian 8.7 was released January 14th, 2017)(https://www.debian.org/releases/stable/).
* **ENV DEBIAN_FRONTEND noninteractive** : Une  définition d'une variable d'environnement afin qu'il ne pose pas de question , qui ne pourrait pas être répondu car ce doit être automatique.
* **RUN apt-get update , apt-get install et pip install** : Nous réalisons l'installation des pacquages requis pour le système comme vous pouvez le voir il y a bien entendu **postfix** ainsi que le système de __log__ **rsyslog**. De plus il y a d'autre pacquage **python-pip** et **supervisor** , j'installe le système __python-pip__ car afin de modifier le fichier de configuration de postfix je vais utiliser le système [jinja2](http://jinja.pocoo.org/docs/2.9/) qui est un système de template. Ceci me permettra de modifier la configuration de postfix en passant des paramètres lors du démarrage. L'application que je vais utiliser est **j2cli** [documentation](https://pypi.python.org/pypi/j2cli/0.3.0-0). Pour **supervisor** cette application permet de démarrer des applications en premier plan (__Forground__) ceci permettra de conserver le conteneur en exécution tout en utilisant la commande __service__ , même si l'application est par défaut mis en arrière plan. 
* **RUN ln -s -f /usr/share/zoneinfo/Canada/Eastern /etc/localtime** : Bon ici c'est moins beau , je définie directement dans l'image le timezone du conteneur au lieu d'utiliser la variable d'environnement **TZ=America/Montreal** . Ceci est moins bien car si j'avais un "__datacenter__" au Maroc par exemple je devrais créer une autre image pour que le serveur est la bonne heure. Alors que si j'avais passé la variable au démarrage ceci aurait pu être configuration lors de l'initialisation.  (je fus paresseux , de la changer :P , on se reprendra pour les autres :D )
* **ADD conf /root/conf** : Copie des fichier de configuration , nous allons le voir ceci est les fichiers "__templates__" de postfix
* **ADD bin/dfg.sh /usr/local/bin/** : Ajout d'un script réaliser par __Uri__ , bon ça marche , je trouve qu'il s'est cassé un peu le tête , mais apprenons des méthodes de tous pour créer notre configuration :D. Nous jetterons un œil sur le script aussi.
* **ADD conf/supervisor-all.conf /etc/supervisor/conf.d/** : fichier de configuration du système de démarrage des applications en premier plan (__forground__)
* **ADD run.sh /root/run.sh et RUN chmod +x /root/run.sh** : Script de démarrage du conteneur 
* **EXPOSE 25** : Indique que le port 25 doit être exposé , personnellement je sur définie cette configuration avec lors de l'initialisation du conteneur.
* **CMD ["/root/run.sh"]** : Point d'entré lors du démarrage du conteneur.

Rien de fabuleux l'ensemble du traitement est vraiment dans le script de démarrage et la modification des fichiers de configuration. 

Commençons avec les fichiers de configurations.


## <a name="image_dockerfile_conf" /> DockerFile fichier de configuration

Telle que mentionné l'ensemble des fichiers de configuration sont dans le répertoire **conf** , il y a 2 fichiers :

* **postfix-main.cf** : Ce fichier contient la description de la configuration de postfix, ce fichier est de type [jinja2](http://jinja.pocoo.org/docs/latest/), regardons le contenu :

        smtpd_banner = $myhostname ESMTP $mail_name (Ubuntu)
        biff = no

        # appending .domain is the MUA's job.
        append_dot_mydomain = no

        # Uncomment the next line to generate "delayed mail" warnings
        #delay_warning_time = 4h

        readme_directory = no

        # See /usr/share/doc/postfix/TLS_README.gz in the postfix-doc package for
        # information on enabling SSL in the smtp client.

        smtpd_relay_restrictions = permit_mynetworks permit_sasl_authenticated defer_unauth_destination
        myhostname = $myorigin
        alias_maps = hash:/etc/aliases
        alias_database = hash:/etc/aliases
        myorigin = {{ RELAY_HOST_NAME }}
        mydestination = {{ RELAY_HOST_NAME }}
        {% if (EXT_RELAY_HOST != "Not_DEFINE") %}relayhost = {{ EXT_RELAY_HOST }} {% endif %}
        mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 {{ ACCEPTED_NETWORKS }}
        mailbox_size_limit = 0
        recipient_delimiter = +
        inet_interfaces = all
        inet_protocols = ipv4
    * Nous retrouvons l'ensemble des configurations postfix que nous avons déjà couvert , je ne reviendrais pas sur le sujet , je vais me concentré sur les variables présent dans le fichier qui sont encadré avec {{ et }} 
    * **myorigin = {{ RELAY_HOST_NAME }}** : Cette variable sera le nom de la machine qui sera présenté lors de l'envoie (__hostname__)
    * **mydestination = {{ RELAY_HOST_NAME }}** : Par défaut dans la configuration je définie que la machine accepte les courriels pour son nom de machine.
    * **{% if (EXT_RELAY_HOST != "Not_DEFINE") %}relayhost = {{ EXT_RELAY_HOST }} {% endif %}** : Un peu plus compliqué , pour mettre en contexte je voulais avoir la même image au __datacenter__ (__OVH__) et chez moi , malheureusement chez moi je suis obligé de passé par mon fournisseur d'accès internet. Dans le cadre __d'OVH__ l'envoie de courriel peut être réalisé directement, donc j'ai mis une condition. Si la variable **{{ EXT_RELAY_HOST }}** n'est pas égale à "__Not\_DEFINE__" alors la valeur est assigné à l'instruction __relayhost__. C'est un simple if :D.
    * **mynetworks = ... {{ ACCEPTED_NETWORKS }}** : Permet de définir encore par paramètre les réseaux autorisés à transmettre leurs courriels par cette machine. 
    * Bien entendu le nombre de paramètre n'est pas limité, nous verrons le processus de substitution.
* **supervisor-all.conf** : La configuration pour le système __supervisor__, dans ce cas la configuration est "statique" :

        [supervisord]
        logfile = /var/log/supervisord.log
        logfile_backups = 0

        [program:rsyslogd]
        command = /usr/sbin/rsyslogd -n

        [program:postfix]
        command = /usr/local/bin/dfg.sh /var/spool/postfix/pid/master.pid /etc/init.d/postfix start
        startsecs = 3


## <a name="image_dockerfile_bin" /> DockerFile fichier exécutable (bin) 

### <a name="image_dockerfile_bin_dfg" /> DockerFile fichier exécutable (bin) DFG

Si nous regardons un peu plus haut vous constatez que la commande de démarrage de postfix utilise un script , fait maison, nommé **dfg** pour __daemon Forground__ . Telle que mentionné précédemment ceci à pour but de conservé un processus en avant plan (__forground__) même si le processus fut mis en arrière plan (__background__) par le système comme c'est le cas lors de l'utilisation des scripts sous __/etc/init.d__.

Telle que mentionné je ne l'aurait personnellement pas fait comme telle, mais justement autant montré d'autre manière de faire après tous ça sert aussi à ça le libre apprendre des autres !! Ça peut toujours donner des idées pour d'autre projet / besoin !

        #! /usr/bin/env bash
        set -eu 
        
        # dfg: Daemon Foreground
        # Runs in foreground while a daemon is running and proxies signals to it.
        # As a result, a daemonizing process can be run with supervisor
        
        function display_help(){
            cat <<EOF
        dfg: Daemon Foreground
        Starts a daemon and runs in foreground while the daemon is active, and proxies signals.
        As a result, a daemonizing process can be run with supervisor.
        
        Usage: $(basename $0) <pidfile> <command...>
        EOF
        }
        [ $# -lt 2 ] && display_help
        
        # Arguments
        pidfile="$1"
        shift
        command=$@
        
        # Go foreground, proxy signals
        function kill_app(){
            kill $(cat $pidfile)
            exit 0
        }
        trap "kill_app" SIGINT SIGTERM
        
        # Launch daemon
        $command
        sleep 2
        
        # Loop while the pidfile and the process exist
        while [ -f $pidfile ] && kill -0 $(cat $pidfile) ; do
            sleep 0.5
        done
        exit 1000

Bon rapidement vous pourrez vous amusez , le prendre , le modifier, faire des teste , quelques point :

* **[ $# -lt 2 ] && display_help** : S'il n'y a pas 2 paramètres au script le système affiche l'aide grâce à la fonction __display\_help__.
* **pidfile="$1"** : Le premier paramètre est le fichier contenant le numéro du processus (__PID__)
* **shift** : le système supprimer le premier paramètre de la ligne de commande
* **command=$@** : assignation à la variable __$command__ l'ensemble de la ligne de commande restante ( comme ceci est fait après le __shift__ tous sauf le fichier __pid__ )
* **$command** : Démarrage de la commande passé en paramètre.
* **while** : Le système boucle 
    * **[ -f $pidfile ]** : Il valide que le fichier __pid__ est toujours présent 
    * **kill -0 $(cat $pidfile)** : En plus de valider la présence du fichier, il valide que le __PID__ est bien en fonction en envoyant le signal 0 , donc rien du tous au numéro du processus.
    * Si le fichier ET que l'envoie du signe fonctionne alors il réalise un __sleep__ 0.5 seconde. 

Donc c'est en gros les point important :D, maintenant à vous de vous amuser !!


### <a name="image_dockerfile_bin_run" /> DockerFile fichier exécutable (bin) run

Place au fichier d'exécution du conteneur , le plus important ! Nous allons donc voir la substitution de variable et le démarrage de postfix.

Voyons le contenu du fichier :

        #! /usr/bin/env bash
        set -e # exit on error

        # Variables
        export EXT_RELAY_HOST=${EXT_RELAY_HOST:-"email-smtp.us-east-1.amazonaws.com"}
        export EXT_RELAY_PORT=${EXT_RELAY_PORT:-"25"}
        export RELAY_HOST_NAME=${RELAY_HOST_NAME:-"relay.example.com"}
        export ACCEPTED_NETWORKS=${ACCEPTED_NETWORKS:-"192.168.0.0/16 172.16.0.0/12 10.0.0.0/8"}
        export OTHER_MY_DEST

        echo $RELAY_HOST_NAME > /etc/mailname

        # Templates
        j2 /root/conf/postfix-main.cf > /etc/postfix/main.cf

        # Launch
        rm -f /var/spool/postfix/pid/*.pid
        exec /usr/bin/supervisord -n

__Yep__ c'est pas long :D, puis on aime ça, c'est plus facile à comprendre !!

* Définition des variables , je vais en prendre qu'un pour l'exemple, mais le concept s'applique pour tous .

        export RELAY_HOST_NAME=${RELAY_HOST_NAME:-"relay.example.com"}
    * Nous assignons la variable d'environnement __RELAY\_HOST\_NAME__ à __RELAY\_HOST\_NAME__ , heu c'est le même nom ... (Je sais , on est le matin j'ai pas encore bus !! ) tous ce joue par la suite **:-"rela...** . Si la variable __RELAY\_HOST\_NAME__ est vide pas de valeur alors il assignera la valeur par défaut qui est définie après les caractères : **:-**. Magie !! On apprend tous les jours un peu plus à utiliser **bash** :D. Ceci est réaliser pour l'ensemble des variable ceci ne nous oblige pas à tous définir :D.
* Assignation du nom de la machine au fichier **/etc/mailname** , certaine application l'utilise c'est plus propre.
* **j2** : IMPORTANT toute la manipulation du fichier de configuration est réalisé ici , avec la commande **j2** (installé avec __pip__ ) le système va prendre les variables d'environnement et faire la substitution. Par défaut le résultat est affiché à l'écran nous réalisons donc une redirection dans le bon fichier de postfix soit : **/etc/postfix/main.cf**
* **rm \*.pid**: Un petit __cleanup__ des fichiers de __pid__ au cas où il y aurait des donnée qui traine :D.
* Démarrage de __supervisord__ pour le service .

Et voilà on a notre image prête à l'usage !!!
