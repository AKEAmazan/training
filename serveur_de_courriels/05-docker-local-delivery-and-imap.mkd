<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 

# <a name="Intro" /> Introduction

Nous avons donc vue la mise en place du système de réception de courriel localement ainsi que la possibilité pour les utilisateurs de récupérer leur courriel grâce au système __pop3__ et __imap__. Nous avions fait l'exercice avec un [pet container](http://rhelblog.redhat.com/2016/06/08/in-defense-of-the-pet-container-part-1-prelude-the-only-constant-is-complexity/) en d'autre mot avec un conteneur docker comme si c'était une __VM__. C'est mal , c'est bien je vous laisse lire le blog de RedHat sur le sujet, je suis un puriste sur l'utilisation du logiciel libre après je ne suis pas rigide sur les méthodes. Donc pour moi un pet conteneur c'est pas la fin du monde. 
Par contre il reste que c'est mieux d'avoir des vraies conteneurs qui sont indépendant , bien structuré que l'on peut modifier manipulé de manière indépendante ! Comme nous sommes dans le cadre de la formation nous allons faire l'exercice. 
Mettons tous de suite quelque chose au claire, ma configuration actuelle est un __pet conteneur__ , dû à des contrainte de temps de migration de serveur je n'avais pas eu le temps de faire l'exercice que l'on fait ici !!!
En d'autre mot pas de stress :D .

La grande particularité de la configuration qui suit est que nous allons pour la première fois depuis notre utilisation dans la formation connecter 2 conteneurs ensemble . 

* __postfix__ : réception et envoie de courriel
* __dovecot__ : Récupération des courriels.

# <a name="setup_images" /> Définition des images 

Pour débuter du bon pieds nous allons définir les critères de configuration afin de ne pas tourné en rond lors de la mise en place de postfix , voici les critère à répondre . 

* **réception** : Permettre la réception de courriel pour 1 ou plusieurs domaines
* **envoie** : Permettre l'envoie de courriel sans authentification pour un ou plusieurs réseaux nommé (quand nous mettrons la configuration avec __Mysql__ nous ajouterons l'authentification)
* **MailDir** : Utilisation du système de stockage __maildir__ afin de limité les risques de corruption du fichier unique de courriel définie avec le format __mbox__
* **Validation des adresses à la source** : Nous voulons conservé la validation des adresses de courriels au niveau de postfix afin de ne pas avoir une charge élevé de courriels .
* **imap** : Permettre la réception de courriel via le protocole __imap__ , je vais mettre de coté le __pop3__ pour le moment.

Ça semble bon :D , maintenant passons au variable que nous désirons avoir configurable :

* **domaines** : Avoir une variable configurable pour que l'image soit utilisable pour n'importe quelle domaine
* **mynetwork** : Avoir une variable configuration pour la définition des réseaux qui peuvent transmettre des courriels.
* **relayhost** : Si le déploiement est fait dans un réseau restrictif permettre l'envoie pour via un __relayhost__.
* **authentification en claire** : Paramètre permettant l'authentification en claire sans chiffrement , bon vraiment pas obligatoire mais sinon j'ai rien pour dovecot :P

Comme la formation est sous Ubuntu , nous allons prendre la dernière __LTS__ pour le besoin donc Ubuntu:16.04

# <a name="setup_postfix" /> Création de l'image SMTP (postfix)

Nous allons reprendre bêtement les étapes vue dans la formation pour faire la création du __Dockerfile__ :

1. Installation des packages postfix
2. Mise en place d'un fichier de configuration en __template__ [Jinja2](http://jinja.pocoo.org/docs/2.9/)
3. Script de démarrage de postfix

Nous avons déjà débuter cette configuration lors de la mise en place du conteneur pour le __relayhost__ bien entendu on va s'en inspirer on l'a déjà étudier :D. J'ai tendance à présenter un produit fini quand je présente docker, malheureusement vous n'avez pas la chance de voir le processus de création incluant les erreur :D . Nous allons donc faire la démarche ensemble afin de voir l'avantage de l'utilisation de docker avec l'utilisation des couches (__layer__) en cache . 

Débutons je crée la structure :

        $ ls -R srvMailWithImap/
        srvMailWithImap/:
        imap  smtp

        srvMailWithImap/imap:

        srvMailWithImap/smtp:
        bin  Dockerfile  run.sh

        srvMailWithImap/smtp/bin:
        dfg.sh

Comme vous pouvez le voir , dans le répertoire __srvMailWithImap/__ il y a 2 répertoires 1 pour le service __smtp__ et l'autre pour le service __imap__ . 
Dans le répertoire __smtp__ j'ai repris une partie de la configuration du serveur __srvMailRelay__ , soit le script __dfg.sh__ ainsi que le script de démarrage. Nous le modifierons peut-être par la suite, mais pour le moment ceci nous donne un point de départ, et nous savons qu'il fonctionne !!

Voici le contenu du fichier **Dockerfile**

        $ cat Dockerfile
        # Using debian
        # Start Exemple:
        # ou can add -p 25:25 for LAN access
        FROM ubuntu:16.04
        MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>

        # Ignore APT warnings about not having a TTY
        ENV DEBIAN_FRONTEND noninteractive

        # Packages: update
        RUN apt-get update -qq && \
            apt-get install -qq -y --no-install-recommends postfix \
                    python-pip supervisor rsyslog && \
            pip install j2cli

        # Configure: supervisor
        ADD bin/dfg.sh /usr/local/bin/
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/

        # Runner
        ADD run.sh /root/run.sh
        RUN chmod +x /root/run.sh

        # Declare
        EXPOSE 25

        CMD ["/root/run.sh"]

Bien simple :

* Nous débutons avec l'image **Ubuntu:16.04** comme nous avons utilisé cette distribution depuis le début.
* Installation des packages pour postfix et __supervisor__ ainsi que le système __rsyslog__ pour les logs.
* Nous installons aussi __j2cli__ , toujours dans l'optique d'utiliser le système __jinja2__ comme __template__ pour les fichiers de configuration.
* Installation des fichiers de configuration pour __supervisor__ , j'ai simplement repris ceux déjà présenter lors de la présentation de la __dockerisation__ du serveur de relais.

L'ensemble des fichiers sont disponible sur [github](https://github.com/x3rus/training/tree/master/serveur_de_courriels/dockers/srvMailWithImap/smtp).

## <a name="setup_postfix_install_pkg" /> Installation des packages dans l'image

Passons à la génération de l'image , bien entendu la configuration n'est pas terminé !! 

        $ docker build -t srvsmtp .
        Sending build context to Docker daemon 6.144 kB
        Step 1 : FROM ubuntu:16.04
         ---> c73a085dc378
        Step 2 : MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>
         ---> Running in d42a4e80f101
         ---> 9421a73877a6
       [... OUTPUT COUPÉ ...]

Cette compilation est un peu plus longue, car ceci comprend l'installation des applications.

Super , j'en attendait pas autant :) , on a déjà une erreur :D , la voici :

       [... OUTPUT COUPÉ ...]
        Running hooks in /etc/ca-certificates/update.d...
        done.
        Collecting j2cli
          Downloading j2cli-0.3.1_0-py2-none-any.whl
        Collecting jinja2>=2.7.2 (from j2cli)
          Downloading Jinja2-2.9.5-py2.py3-none-any.whl (340kB)
        Collecting MarkupSafe>=0.23 (from jinja2>=2.7.2->j2cli)
          Downloading MarkupSafe-0.23.tar.gz
        Complete output from command python setup.py egg_info:
          Traceback (most recent call last):
          File "<string>", line 1, in <module>
          ImportError: No module named setuptools
          ----------------------------------------
          Command "python setup.py egg_info" failed with error code 1 in /tmp/pip-build-Gs2DNu/MarkupSafe/
          You are using pip version 8.1.1, however version 9.0.1 is available.
          You should consider upgrading via the 'pip install --upgrade pip' command.
         The command '/bin/sh -c apt-get update -qq &&     apt-get install -qq -y --no-install-recommends postfix         python-pip supervisor rsyslog &&     pip install j2cli' returned a non-zero code: 1



Vous me direz , mais pourquoi ça fonctionnait très bien avec le serveur de relais , effectivement mais nous étions avec une Debian __jessie__ , maintenant nous sommes avec Ubuntu.

Comment analyser le problème , voici comment je procède :

        $ docker run -it ubuntu:16.04 bash
        root@6c3da44d101c:/# apt-get update && apt-get install python-pip
	The following additional packages will be installed:
	  binutils build-essential bzip2 ca-certificates cpp cpp-5 dpkg-dev fakeroot file g++ g++-5 gcc gcc-5 gcc-5-base ifupdown iproute2 isc-dhcp-client
	  isc-dhcp-common libalgorithm-diff-perl libalgorithm-diff-xs-perl libalgorithm-merge-perl libasan2 libatm1 libatomic1 libc-dev-bin libc6 libc6-dev libcc1-0
	  libcilkrts5 libdns-export162 libdpkg-perl libexpat1 libexpat1-dev libfakeroot libffi6 libfile-fcntllock-perl libgcc-5-dev libgdbm3 libgmp10 libgomp1
	  libisc-export160 libisl15 libitm1 liblsan0 libmagic1 libmnl0 libmpc3 libmpfr4 libmpx0 libperl5.22 libpython-all-dev libpython-dev libpython-stdlib
	  libpython2.7 libpython2.7-dev libpython2.7-minimal libpython2.7-stdlib libquadmath0 libsqlite3-0 libssl1.0.0 libstdc++-5-dev libstdc++6 libtsan0 libubsan0
	  libxtables11 linux-libc-dev make manpages manpages-dev mime-support netbase openssl patch perl perl-modules-5.22 python python-all python-all-dev
	  python-dev python-minimal python-pip-whl python-pkg-resources python-setuptools python-wheel python2.7 python2.7-dev python2.7-minimal rename xz-utils
	Suggested packages:
	  binutils-doc bzip2-doc cpp-doc gcc-5-locales debian-keyring g++-multilib g++-5-multilib gcc-5-doc libstdc++6-5-dbg gcc-multilib autoconf automake libtool
	  flex bison gdb gcc-doc gcc-5-multilib libgcc1-dbg libgomp1-dbg libitm1-dbg libatomic1-dbg libasan2-dbg liblsan0-dbg libtsan0-dbg libubsan0-dbg
	  libcilkrts5-dbg libmpx0-dbg libquadmath0-dbg ppp rdnssd iproute2-doc resolvconf avahi-autoipd isc-dhcp-client-ddns apparmor glibc-doc libstdc++-5-doc
	  make-doc man-browser ed diffutils-doc perl-doc libterm-readline-gnu-perl | libterm-readline-perl-perl python-doc python-tk python-setuptools-doc
	  python2.7-doc binfmt-support
	The following NEW packages will be installed:
	  binutils build-essential bzip2 ca-certificates cpp cpp-5 dpkg-dev fakeroot file g++ g++-5 gcc gcc-5 ifupdown iproute2 isc-dhcp-client isc-dhcp-common
	  libalgorithm-diff-perl libalgorithm-diff-xs-perl libalgorithm-merge-perl libasan2 libatm1 libatomic1 libc-dev-bin libc6-dev libcc1-0 libcilkrts5
	  libdns-export162 libdpkg-perl libexpat1 libexpat1-dev libfakeroot libffi6 libfile-fcntllock-perl libgcc-5-dev libgdbm3 libgmp10 libgomp1 libisc-export160
	  libisl15 libitm1 liblsan0 libmagic1 libmnl0 libmpc3 libmpfr4 libmpx0 libperl5.22 libpython-all-dev libpython-dev libpython-stdlib libpython2.7
	  libpython2.7-dev libpython2.7-minimal libpython2.7-stdlib libquadmath0 libsqlite3-0 libssl1.0.0 libstdc++-5-dev libtsan0 libubsan0 libxtables11
	  linux-libc-dev make manpages manpages-dev mime-support netbase openssl patch perl perl-modules-5.22 python python-all python-all-dev python-dev
	  python-minimal python-pip python-pip-whl python-pkg-resources python-setuptools python-wheel python2.7 python2.7-dev python2.7-minimal rename xz-utils
	The following packages will be upgraded:
	  gcc-5-base libc6 libstdc++6
	3 upgraded, 87 newly installed, 0 to remove and 25 not upgraded.
	Need to get 88.4 MB of archives.
	After this operation, 268 MB of additional disk space will be used.
	Do you want to continue? [Y/n] y
	 
        [... Isshhh c beaucoup de packages requis :P ...]

Je démarre un Ubuntu éphémère uniquement pour valider la procédure , ceci me permettra de réaliser l'analyse du problème en mode interactif. 

Recherche du package __j2cli__ 

        root@6c3da44d101c:/# pip search j2cli
        j2cli3 (0.0.7.post0)  - Command-line interface to Jinja2 for templating in shell scripts.
        j2cli (0.3.1-0)       - Command-line interface to Jinja2 for templating in shell scripts.

__Humm__ ça semble bon :-/ on va tenter de l'installer alors :

        root@6c3da44d101c:/# pip install j2cli
        Collecting j2cli
          Downloading j2cli-0.3.1_0-py2-none-any.whl
        Collecting jinja2>=2.7.2 (from j2cli)
          Downloading Jinja2-2.9.5-py2.py3-none-any.whl (340kB)
          100% |################################| 348kB 1.1MB/s
        Collecting MarkupSafe>=0.23 (from jinja2>=2.7.2->j2cli)
        Downloading MarkupSafe-0.23.tar.gz
        Building wheels for collected packages: MarkupSafe
        Running setup.py bdist_wheel for MarkupSafe ... done
        Stored in directory: /root/.cache/pip/wheels/a3/fa/dc/0198eed9ad95489b8a4f45d14dd5d2aee3f8984e46862c5748
        Successfully built MarkupSafe
        Installing collected packages: MarkupSafe, jinja2, j2cli
        Successfully installed MarkupSafe-0.23 j2cli-0.3.1-0 jinja2-2.9.5
        You are using pip version 8.1.1, however version 9.0.1 is available.
        You should consider upgrading via the 'pip install --upgrade pip' command.

Donc :

        $ docker build -t srvsmtp .

Aucun problème ... On va refaire un teste alors avec le __Dockerfile__ :

        Command "python setup.py egg_info" failed with error code 1 in /tmp/pip-build-cpjQyz/MarkupSafe/
        You are using pip version 8.1.1, however version 9.0.1 is available.
        You should consider upgrading via the 'pip install --upgrade pip' command.
        The command '/bin/sh -c apt-get update -qq &&     apt-get install -qq -y --no-install-recommends postfix         python-pip supervisor rsyslog &&     pip install j2cli' returned a non-zero code: 1

Pourquoi ? Si nous regardons une des différences entre la configuration dans le __Dockerfile__ et mon teste est que lors de l'installation dans le __Dockerfile__ il y a l'instruction **--no-install-recommends**. Résultat il manque des packages requis pour l'utilisation de **pip**. 

Bien entendu 2 options s'offre à nous :

* Supprimer le paramètre **--no-install-recommends** dans le __Dockerfile__ , résultat une image plus grosse , est-ce vraiment critique ?!?! À vous de voir.
* Ajuster les packages lors de l'installation afin de conserver l'option d'installation des packages requis uniquement.

Bon , comme la suppression du paramètre est assez simple , je vais prendre l'option, car l'important n'est pas la solution mais le processus pour y arrivé, sinon vous ne seriez pas là :D. 

Donc je quitte mon conteneur de teste , car pollué par trop de packages et en redémarre un nouveau et reprend :

        root@6c3da44d101c:/# exit
        ٩(◠◡◠)۶ $ docker run -it ubuntu:16.04 bash
        root@8f4caf46401e:/#  apt-get update && apt-get --no-install-recommends install python-pip
        The following additional packages will be installed:
          ca-certificates libexpat1 libffi6 libpython-stdlib libpython2.7-minimal libpython2.7-stdlib libsqlite3-0 libssl1.0.0 mime-support openssl python
          python-minimal python-pip-whl python2.7 python2.7-minimal
        Suggested packages:
          python-doc python-tk python2.7-doc binutils binfmt-support
        Recommended packages:
          file build-essential python-all-dev python-setuptools python-wheel
        The following NEW packages will be installed:
          ca-certificates libexpat1 libffi6 libpython-stdlib libpython2.7-minimal libpython2.7-stdlib libsqlite3-0 libssl1.0.0 mime-support openssl python
          python-minimal python-pip python-pip-whl python2.7 python2.7-minimal
        0 upgraded, 16 newly installed, 0 to remove and 28 not upgraded.
        Need to get 7450 kB of archives.
        After this operation, 24.9 MB of additional disk space will be used.

Pas mal moins de packages, bon maintenant nous allons être dans le détail pour le problème spécifique . Regardons le message d'erreur que nous avons avec le conteneur :

        Collecting MarkupSafe>=0.23 (from jinja2>=2.7.2->j2cli)
          Downloading MarkupSafe-0.23.tar.gz
        Complete output from command python setup.py egg_info:
          Traceback (most recent call last):
          File "<string>", line 1, in <module>
          ImportError: No module named setuptools

Si nous regardons , un des packages recommencés il y a **python-setuptools** , ceci correspond au message d'erreur que nous avons :D , installons le pour voir et testons à nouveau .


        root@8f4caf46401e:/# apt-get --no-install-recommends install python-setuptools
        Collecting j2cli
          Downloading j2cli-0.3.1_0-py2-none-any.whl
        Collecting jinja2>=2.7.2 (from j2cli)
          Downloading Jinja2-2.9.5-py2.py3-none-any.whl (340kB)
          100% |################################| 348kB 1.1MB/s
        Collecting MarkupSafe>=0.23 (from jinja2>=2.7.2->j2cli)
          Downloading MarkupSafe-0.23.tar.gz
          Building wheels for collected packages: MarkupSafe
          Running setup.py bdist_wheel for MarkupSafe ... error
          Complete output from command /usr/bin/python -u -c "import setuptools, tokenize;__file__='/tmp/pip-build-NleDVW/MarkupSafe/setup.py';exec(compile(getattr(tokenize, 'open', open)(__file__).read().replace('\r\n', '\n'), __file__, 'exec'))" bdist_wheel -d /tmp/tmp2aCAjppip-wheel- --python-tag cp27:
          usage: -c [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]
          or: -c --help [cmd1 cmd2 ...]
          or: -c --help-commands
          or: -c cmd --help
          error: invalid command 'bdist_wheel'
          ----------------------------------------
          Failed building wheel for MarkupSafe
          Running setup.py clean for MarkupSafe
          Failed to build MarkupSafe
          Installing collected packages: MarkupSafe, jinja2, j2cli
          Running setup.py install for MarkupSafe ... done
          Successfully installed MarkupSafe-0.23 j2cli-0.3.1-0 jinja2-2.9.5

**COOL** encore une erreur mais PAS la même , si nous regardons encore le message il y a le mot __wheel__ de présent , il est aussi dans un des packages recommandés pour l'installation ajoutons le :D .

        root@8f4caf46401e:/# apt-get --no-install-recommends install python-wheel                                                                                     
        root@8f4caf46401e:/# pip install j2cli
        Requirement already satisfied (use --upgrade to upgrade): j2cli in /usr/local/lib/python2.7/dist-packages
        Requirement already satisfied (use --upgrade to upgrade): jinja2>=2.7.2 in /usr/local/lib/python2.7/dist-packages (from j2cli)
        Requirement already satisfied (use --upgrade to upgrade): MarkupSafe>=0.23 in /usr/local/lib/python2.7/dist-packages (from jinja2>=2.7.2->j2cli)
        You are using pip version 8.1.1, however version 9.0.1 is available.
        You should consider upgrading via the 'pip install --upgrade pip' command.
        root@8f4caf46401e:/# echo $?
        0

**Yeahhh** du premier coup :P, nous allons donc ajuster le fichier __Dockerfile__ , voici donc la nouvelle ligne avec la liste des packages :


        # Packages: update
        RUN apt-get update -qq && \
            apt-get install -qq -y --no-install-recommends postfix \
                    python-pip supervisor rsyslog python-wheel python-setuptools  && \
                    pip install j2cli


On reconstruit l'image :

        $ docker build -t srvsmtp .                                                                                                                          
        Sending build context to Docker daemon 6.656 kB
        Step 1 : FROM ubuntu:16.04
         ---> c73a085dc378
         Step 2 : MAINTAINER Boutry Thomas <thomas.boutry@x3rus.com>
         [ ... OUTPUT COUPÉ ...]

        Removing intermediate container ba87a471cb7a
        Step 5 : ADD bin/dfg.sh /usr/local/bin/
         ---> b842eee6ca8a
         Removing intermediate container 4631078aaad4
        Step 6 : ADD conf/supervisor-all.conf /etc/supervisor/conf.d/
         lstat conf/supervisor-all.conf: no such file or directory

Je suis sûr que vous pensez que je l'ai fait volontairement, mais même pas je vous jure ... En temps normale je le cache ça :P . Bon on va capitalisé sur le problème j'ai opté pour vous montrer tous, donc ça sera tous , le bon et le moins bon .

## <a name="setup_postfix_setup_conf" /> Mise en place des fichiers de configuration

Donc suite à l'erreur de mon oublie du fichier de __supervisor__ je vais le mettre dans le répertoire conf , voici le contenu , c'est le même que pour le __relayhost__ je ne prendrai pas le temps d'écrire.

        [supervisord]
        logfile = /var/log/supervisord.log
        logfile_backups = 0

        [program:rsyslogd]
        command = /usr/sbin/rsyslogd -n

        [program:postfix]
        command = /usr/local/bin/dfg.sh /var/spool/postfix/pid/master.pid /etc/init.d/postfix start
        startsecs = 3

Donc on reprend :D : 

        $ docker build -t srvsmtp .
        [... OUTPUT COUPÉ ...]
        Step 3 : ENV DEBIAN_FRONTEND noninteractive
         ---> Using cache
         ---> 7bb41adacabf
        Step 4 : RUN apt-get update -qq &&     apt-get install -qq -y --no-install-recommends postfix         python-pip supervisor rsyslog python-wheel python-setuptools  &&     pip install j2cli
         ---> Using cache
         ---> db7a6b374677
        Step 5 : ADD bin/dfg.sh /usr/local/bin/
         ---> Using cache
         ---> b842eee6ca8a
        [... OUTPUT COUPÉ ...]

Ce qui est super est que le temps pris pour l'installation n'est pas repris maintenant car __docker__ va utiliser le cache des couches (__layers__) déjà compilé. 

État de la situation nous avons un conteneur qui à l'ensemble des packages d'installer ainsi que la configuration minimal pour le démarrage du conteneur , il nous reste :

1. Mettre en place la configuration pour postfix , en __template__
2. Modifier le script **run.sh** afin qu'il traite notre fichier de configuration en __template__ et le dispose dans le bon répertoire
3. Ajuster les valeurs par défaut de notre image si besoin est !

Voici notre fichier de configuration en __template__  (**conf/postfix-main.j2**) : 

        smtpd_banner = $myhostname ESMTP $mail_name

        alias_database = hash:/etc/aliases
        alias_maps = hash:/etc/aliases

        # Si vous le désirez nous pourrions avoir ce paramètre en option
        home_mailbox = Maildir/

        smtpd_relay_restrictions = permit_mynetworks  defer_unauth_destination
        myhostname = $myorigin
        myorigin = {{ SMTP_HOSTNAME }}

        mydestination = {{ ACCEPT_DOMAIN }}
        mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 {{ PERMIT_NETWORK }}
        inet_interfaces = all
        inet_protocols = ipv4

        {% if (EXT_RELAY_HOST != "DIRECT") %}relayhost = {{ EXT_RELAYHOST }} {% endif %}

Nous allons donc l'ajouter dans le __Dockerfile__

        [...OUTPUT COUPÉ ...]
        ADD conf/supervisor-all.conf /etc/supervisor/conf.d/

        # Setup postfix conf
        ADD conf/postfix-main.j2 /root/

        # Runner
        ADD run.sh /root/run.sh
        [...OUTPUT COUPÉ...]

Comme vous pouvez le constater j'ai mis la configuration **après** la définition des packages, ceci principalement pour ne pas à avoir à les réinstaller et profiter du caches de __docker__.

Le fichier sera donc dans le répertoire **/root** , nous devons ajuster le fichier **run.sh** pour le traitement du fichier , voici le nouveau contenu :

        #! /usr/bin/env bash
        set -e # exit on error

        # Variables
        export EXT_RELAY_HOST=${EXT_RELAY_HOST:-"DIRECT"}
        export SMTP_HOSTNAME=${SMTP_HOSTNAME:-"relay.example.com"}
        export PERMIT_NETWORK=${PERMIT_NETWORK:-"192.168.0.0/16"}
        export ACCEPT_DOMAIN=${ACCEPT_DOMAIN:-"localhost $SMTP_HOSTNAME"}
                              
        echo $SMTP_HOSTNAME > /etc/mailname
             
        # Templates
        j2 /root/postfix-main.j2 > /etc/postfix/main.cf

        # Launch
        rm -f /var/spool/postfix/pid/*.pid
        exec /usr/bin/supervisord -n

Principale changement :

* Les variables  et les valeurs par défaut
* Le patch pour le fichier postfix de __template__

On reconstruit l'image :D :

        $ docker build -t srvsmtp . 
        [... OUTPUT COUPÉ ...]
         ---> b842eee6ca8a
         Step 6 : ADD conf/supervisor-all.conf /etc/supervisor/conf.d/
          ---> Using cache
          ---> 98fd86c1b2a2
         Step 7 : ADD conf/postfix-main.j2 /root/
          ---> e6bbe80dbe93
        [... OUTPUT COUPÉ ...]


Comme vous pouvez  le constater le système à utiliser le cache jusqu'à la première modification . **Woot** donc la compilation est un succès on passe à la phase de teste !!

## <a name="setup_postfix_setup_validation" /> Validation de l'image

Bon idéalement on pourrait faire un système de unit teste pour confirmer que tous fonctionne bien mais on est pas encore en mode "production" , on s'amuse plus qu'autre chose :D.

Donc nous allons démarrer un conteneur et valider manuellement , par la suite nous réaliserons un **docker-compose.yml** pour faciliter l'utilisation. J'ai définie des variables :

* __SMTP\_HOSTNAME=mailtraining.x3rus.com__
* __PERMIT\_NETWORK=172.17.0.0/16__
* __ACCEPT\_DOMAIN="mailtraining.x3rus.com toto.x3rus.com"__ 

        $ docker run -h mailtraining.x3rus.com -e SMTP_HOSTNAME=mailtraining.x3rus.com -e PERMIT_NETWORK=172.17.0.0/16 -e ACCEPT_DOMAIN="mailtraining.x3rus.com toto.x3rus.com" srvsmtp
        /usr/lib/python2.7/dist-packages/supervisor/options.py:297: UserWarning: Supervisord is running as root and it is searching for its configuration file in default locations (including its current working directory); you probably want to specify a "-c" argument specifying an absolute path to a configuration file for improved security.
          'Supervisord is running as root and it is searching '
          2017-01-31 13:10:13,071 CRIT Supervisor running as root (no user in config file)
          2017-01-31 13:10:13,071 WARN Included extra file "/etc/supervisor/conf.d/supervisor-all.conf" during parsing
          2017-01-31 13:10:13,090 INFO RPC interface 'supervisor' initialized
          2017-01-31 13:10:13,090 CRIT Server 'unix_http_server' running without any HTTP authentication checking
          2017-01-31 13:10:13,090 INFO supervisord started with pid 1
          2017-01-31 13:10:14,097 INFO spawned: 'postfix' with pid 11
          2017-01-31 13:10:14,100 INFO spawned: 'rsyslogd' with pid 12
          2017-01-31 13:10:15,456 INFO success: rsyslogd entered RUNNING state, process has stayed up for > than 1 seconds (startsecs)
          2017-01-31 13:10:17,459 INFO success: postfix entered RUNNING state, process has stayed up for > than 3 seconds (startsecs)

Prenons un autre terminal et validons l'ensemble :

        $ docker ps
        CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS               NAMES
        21b0aa433d27        srvsmtp             "/root/run.sh"      About a minute ago   Up About a minute   25/tcp              grave_jones
        $ docker exec -it grave_jones bash

        root@mailtraining:/# cat /etc/postfix/main.cf
        smtpd_banner = $myhostname ESMTP $mail_name

        alias_database = hash:/etc/aliases
        alias_maps = hash:/etc/aliases

        # Si vous le désirez nous pourrions avoir ce paramètre en option
        home_mailbox = Maildir/

        smtpd_relay_restrictions = permit_mynetworks  defer_unauth_destination
        myhostname = $myorigin
        myorigin = mailtraining.x3rus.com

        mydestination = mailtraining.x3rus.com toto.x3rus.com
        mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 172.17.0.0/16
        inet_interfaces = all
        inet_protocols = ipv4

        root@mailtraining:/# tail /var/log/mail.log
        Jan 31 13:10:14 mailtraining postfix[87]: Postfix is running with backwards-compatible default settings
        Jan 31 13:10:14 mailtraining postfix[87]: See http://www.postfix.org/COMPATIBILITY_README.html for details
        Jan 31 13:10:14 mailtraining postfix[87]: To disable backwards compatibility use "postconf compatibility_level=2" and "postfix reload"
        Jan 31 13:10:14 mailtraining postfix/master[132]: daemon started -- version 3.1.0, configuration /etc/postfix

Ça semble pas mal :D , on valide en transmettant un petit courriel à l'utilisateur __root__ !!
Je récupère l'IP du conteneur : 

        $ docker inspect grave_jones | grep IPAddress
            "SecondaryIPAddresses": null,
            "IPAddress": "172.17.0.2",
                "IPAddress": "172.17.0.2",

Un petit __telnet__ rapide :

        $ telnet 172.17.0.2 25
        Trying 172.17.0.2...
        Connected to 172.17.0.2.
        Escape character is '^]'.
        220 mailtraining.x3rus.com ESMTP Postfix
        ehlo toto
        250-mailtraining.x3rus.com
        250-PIPELINING
        250-SIZE 10240000
        250-VRFY
        250-ETRN
        250-ENHANCEDSTATUSCODES
        250-8BITMIME
        250 DSN
        mail from: toto@x3rus.com
        250 2.1.0 Ok
        rcpt to: root@mailtraining.x3rus.com
        250 2.1.5 Ok
        data
        354 End data with <CR><LF>.<CR><LF>
        un courriel
        .
        250 2.0.0 Ok: queued as 9A2B460758E
        quit
        221 2.0.0 Bye
        Connection closed by foreign host.

Visualisons les logs et confirmons que le répertoire **Maildir** fut créé .

        $ docker exec grave_jones tail /var/log/mail.log
        Jan 31 13:10:14 mailtraining postfix[87]: See http://www.postfix.org/COMPATIBILITY_README.html for details
        Jan 31 13:10:14 mailtraining postfix[87]: To disable backwards compatibility use "postconf compatibility_level=2" and "postfix reload"
        Jan 31 13:10:14 mailtraining postfix/master[132]: daemon started -- version 3.1.0, configuration /etc/postfix
        Jan 31 13:16:15 mailtraining postfix/smtpd[1589]: connect from unknown[172.17.0.1]
        Jan 31 13:16:36 mailtraining postfix/smtpd[1589]: 9A2B460758E: client=unknown[172.17.0.1]
        Jan 31 13:16:40 mailtraining postfix/cleanup[1676]: 9A2B460758E: message-id=<>
        Jan 31 13:16:40 mailtraining postfix/qmgr[135]: 9A2B460758E: from=<toto@x3rus.com>, size=198, nrcpt=1 (queue active)
        Jan 31 13:16:40 mailtraining postfix/local[1693]: 9A2B460758E: to=<root@mailtraining.x3rus.com>, relay=local, delay=18, delays=18/0.01/0/0.01, dsn=2.0.0, status=sent (delivered to maildir)
        Jan 31 13:16:40 mailtraining postfix/qmgr[135]: 9A2B460758E: removed
        Jan 31 13:16:42 mailtraining postfix/smtpd[1589]: disconnect from unknown[172.17.0.1] ehlo=1 mail=1 rcpt=1 data=1 quit=1 commands=5

        $ docker exec grave_jones ls -R /root/Maildir
        /root/Maildir:
        cur
        new
        tmp

        /root/Maildir/cur:

        /root/Maildir/new:
        1485868600.Vfe01Ie0699bM516582.mailtraining.x3rus.com

        /root/Maildir/tmp:

**SUPER** , l'image fonctionne bien pour la réception des courriels __yeahh__ félicitation !!

Bon avant de débuter la définition du __docker-compose__ prenons un peu de recule sur l'utilisation de l'image .

# <a name="workflow_conteneur_smtp" /> Définition de l'utilisation du conteneur postfix

Le gros défis de **docker** réside ici , faire l'image n'est pas très difficile , par contre nous nous retrouvons maintenant avec un conteneur qui peu être éphémère .Telle que mentionné plus tôt actuellement mon serveur de courriel est un **pet conteneur** il n'y a pas de honte , mais essayons de nous améliorer c'est l'objectif , sinon on ne progresse pas. 
Dans cette objectif nous allons essayer de s'assurer que le conteneur __smtp__ puisse être changé à tous moment.

État de l'image et de son utilisation comme conteneur initialisé :

* Le système accepte les courriels pour le / les domaines fournit en paramètre 
* Le système démarre :P 
* Le système stocke le(s) courriel(s) dans le répertoire personnel de l'utilisateur 
* Le système n'a qu'un seul utilisateur disponible : **root*** et les autres utilisateurs systèmes :-(
* La définition des alias sont statique dans le conteneur (comme les utilisateurs)
* Les courriels sont dans le conteneur :-/ (__issshh__ :P )

Bon regardons les "problèmes" , pour la question des courriels qui sont dans le conteneur , quelle est la solution ? 

__Yep__ la création d'un volume qui réalisera l'association du répertoire **/home** dans le conteneur avec un répertoire sur le __docker host__. COOL problème réglé.

La définition des utilisateurs maintenant , ici ça se complique un peu , en fait faut prendre la bonne approche, voici quelques options :

1. Passez en **paramètre une liste d'utilisateur** pour réaliser la création lors de l'initialisation du conteneur. Pour ce faire nous devrions modifier le script **run.sh** afin de faire la création des utilisateurs ainsi que le répertoire personnel. Point à prendre en considération :
    * Les variables d'environnement ne sont interpréter QUE et UNIQUEMENT lors de l'initialisation initiale du conteneur (nominatif) en d'autre mot , si la liste des utilisateurs est : Robert, Peter et Bonny . Que vous désirez rajouter Bob , vous ne pouvez pas simplement redémarrer le conteneur avec la nouvelle valeur à la variable, il vous faudra détruire le conteneur et en créer un nouveau . Bien entendu même processus lors de la suppression d'un utilisateur !
    * **Contre** : votre premier reflex est probablement , __woww__ c'est vraiment pas une bonne options, commençons par vous conforter dans votre idée :P
        * La suppression du conteneur est "risqué" si ce dernier est mal configurer et surtout si vous réalisez des modifications directement dans le conteneur. Par exemple une personne ajoute manuellement un utilisateur dans le conteneur , lors de la recréation il sera perdu !
        * S'il y a eu une modification dans l'image de références, lors de la recréation il est possible que le service ne fonctionne plus du tous ! 
        * Il peut être difficile sans système autour de déléguer à un __help desk__ l'ajout d'un utilisateur, car il y a l'implication de redémarrage de la production.
        * Mais surtout ceci nous oblige à changer nos habitudes de fonctionnement.
    * **Pour** : Bon maintenant que vous êtes bien conforté dans l'idée que c'est une mauvaise idée, voyons le positif de cette solution.
        * Comme nous sommes obligé de recréer le conteneur, ceci sera une occasion de nous forcer à mettre à jour le conteneur. J'aimerai faire une parenthèse sur le cycle de mise à jour. Mettre en lumière une réalité avec __Docker__ . Regardons le schéma suivant :
        
            ![docker-update_cycle.png](./imgs/docker-update_cycle.png)
        
            Lors de la création de l'image du conteneur les versions sont figé dans le temps, résultat s'il y a une faille de sécurité découvert nous la trainerons dans le temps au lieu de la fixer ! Le fait que nous devons détruire le conteneur nous obligera à réaliser une mise à jour des packages. Ceci est particulièrement important pour les services exposés sur Internet.
        * L'autre point positif de cette opération est que nous avons un système éphémère, qui est régulièrement généré résultat nous avons un niveau de confiance dans le système car régulièrement testé lors de l'ajout d'un utilisateur. S'il y a un problème on le recréer , on pourrait même y voir un système qui augmente le nombre de serveur postfix s'il y a une monté en charge des courriels et qui modifie les DNS afin d'ajouter la définition MX pour la réception . Le système est donc autonome dans ça définition.
2. Avoir un fichier local des utilisateurs qui est à l'extérieur du conteneur !
    * Regardons d'un œil froid, où est définie les utilisateurs ? Dans le fichier **/etc/passwd** , le fichier est présent par défaut sur le système mais pouvons nous le surdéfinir. En fait pas de problème , nous avons le système de volume dans docker qui nous permet d'assigner un répertoire ou un fichier de l'hôte docker dans le conteneur !! Nous n'avons pas besoin du fichier **/etc/shadow** car l'utilisateur n'établis pas de connexion sur ce conteneur.
    * **Contre** : Bon je présume que vous êtes pour mais je peux pas changé le pour / contre d'une section à l'autre trop tard :P
        * La problématique avec cette solution est la définition du fichier **/etc/passwd** qui est sur 1 hôte docker , donc s'il y a un problème avec l'hôte votre conteneur en est dépendant. Vous n'êtes pas en mesure de redémarrer le conteneur sur un autre hôtes de manière transparente. Bien entendu il y a la question des courriels reçu __anyway__ qui seront non disponible. Mais attention , le conteneur postfix ne stock pas obligatoirement le courriel ce dernier reçoit et livre les courriels , il peut aussi agir comme __buffer__ si le service dovecot n'est pas disponible.
        * L'ajout d'un utilisateur se fera sur la machine hôte , il faudra donc éventuellement conserver le fichier dans un contrôleur de révision (git, svn) pour voir les changements et conserver une copie à l'extérieur.
        * Si nous éditons le fichier manuellement , il faudra faire attention de ne pas avoir les même UID , voir les mêmes nom avec un répertoire personnel différent.
    * **Pour** : L'utilisation d'un fichier **/etc/passwd** local , sans être obligé de recréer le conteneur nous rassure nous avons presque le même comportement qu'une VM.
        * Change peu nos habitudes donc c'est réconfortant :P
        * Le fichier **/etc/passwd** pourrait être utilisé par un autre conteneur par exemple __dovecot__ pour la liste des utilisateurs ;-)
3. Autre option , ne pas avoir de définition local d'utilisateur mais unique

# les logs 
http://hokstadconsulting.com/docker/postfix , utilisation de -v /dev/log:/dev/log
