<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>

TODO corriger les \_

# Index 


# <a name="intro" /> Introduction 

Nous aurions probablement dû commencer la formation avec ce chapitre, mais comme cette formation est écrite selon l'envie et les demande , nous ne le couvrons que maintenant. Le bon côté est que vous avez pu déjà commencé à jouer un peu plus avec **apache** , **git** et **docker** :D. 
Ce chapitre va couvrir les opérations importante à faire quand vous mettez un serveur en production , ceci s'applique à l'ensemble des serveurs , bien entendu si vous avez plusieurs serveurs je vous invite à standardisé vos installations.
Nous allons donc voir les étapes à réaliser **avant** de mettre en place votre service , que nous parlions de __apache__, __mysql__ , __django__ , ... 

Nous parlerons un peu sécurité , mais très légèrement ...

# <a name="first_step" /> Réception de la machine 

Je vais partir du principe qu'une entité externe vous a fournit une machine , que ce soit une **VM** , un **VPS** , ou une machine physique. Le principe est le même si vous avez réalisé une nouvelle installation , si vous réalisez vous même l'installation d'une machine:

* Installé le minimum , quand vous réaliserez les mise à jours du serveur vous serez très content que l'opération soit super rapide car il y aura pas une multitude d'application non utilisé à mettre à jours.
* Vous limiterez en plus le nombre de faille de sécurité éventuelle du serveur.
* N'installez pas de compilateur ceci ouvre un nombre de possibilité élevé au attaquant , a moins bien entendu que ce soit requis pour votre utilisation. Je doute que ce soit le cas dans la pratique.

Voici les étapes à réaliser lors de la réception de la machine : 

1. Établir une connexion sur la **box**, __Yep__ :P 
2. Valide les informations de la machine selon les spécifications demandé :
    * Mémoire
        
        $ Free -m 
        total        used        free      shared  buff/cache   available
        Mem:           2009         483        1127           7         398        1490
        Swap:          5006           0        5006

    * CPU

        $ cat /proc/cpuinfo
        [...OUTPUT COUPÉ...]
        processor       : 1
        vendor_id       : GenuineIntel
        cpu family      : 6
        model           : 15
        model name      : Intel(R) Core(TM)2 CPU         U7600  @ 1.20GHz
        stepping        : 2
        microcode       : 0x57
        cpu MHz         : 800.000
        cache size      : 2048 KB
        [...OUTPUT COUPÉ...]

    * Taille du disque dur

        $ df -h | grep sda
        /dev/sda1        51G   33G   16G  68% /
        $ cat /proc/scsi/scsi
        Attached devices:
        Host: scsi0 Channel: 00 Id: 00 Lun: 00
          Vendor: ATA      Model: MCCOE64GEMPP     Rev: 03  
          Type:   Direct-Access                    ANSI  SCSI revision: 05

        $ dmesg  | grep sda
        [    1.242858] sd 0:0:0:0: [sda] 117210240 512-byte logical blocks: (60.0 GB/55.8 GiB)
        [    1.242968] sd 0:0:0:0: [sda] Write Protect is off
        [    1.242975] sd 0:0:0:0: [sda] Mode Sense: 00 3a 00 00
        [    1.243023] sd 0:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA
        [    1.244227]  sda: sda1 sda2

    * Partitionnement (si spécifié)
        
        $ df -h | grep ^/

    * Système de configuration du __RAID__ si disponible 

        $ cat /proc/mdstats

3. Valider la distribution :

        $ cat /etc/lsb-release 
        DISTRIB_ID=Ubuntu
        DISTRIB_RELEASE=14.04
        DISTRIB_CODENAME=trusty
        DISTRIB_DESCRIPTION="Ubuntu 14.04 LTS"

        ou 

        $ cat /etc/redhat-release

4. Prendre un café, une petite bière ou un verre de vin pour de félicité de cette nouvelle machine
5. Vous pouvez toujours remercier votre Sysadmin ou fournisseur du service :D, lui aussi aime les courriels gentils , surtout si c'est le sysadmin __Day__ :P


Pour la suite des opérations je vous suggère d'utiliser un système de gestion de mot de passe par exemple :

* __Keepass__
* __Keepassx__
* ou peu importe , sauf un post-it :P

# <a name="take_controle" /> Prise de contrôle de la machine

Bon c'est le temps de prendre en main la bête !!! C'est le moment de se l'approprier ! 

1. Changer le mot de passe de l'utilisateur fournit, car connu du fournisseur de service , si vous utilisé **root** oublié la deuxième partie .

        $ passwd

2. Changer le mot de passe de l'utilisateur **root** 

        $ su - 
        # passwd 

3. Création d'un utilisateur que vous utiliserez régulièrement , ici j'utiliserai __bob__

        #  adduser bob
        Adding user `bob' ...
        Adding new group `bob' (1000) ...
        Adding new user `bob' (1000) with group `bob' ...
        Creating home directory `/home/bob' ...
        Copying files from `/etc/skel' ...
        Enter new UNIX password:
        Retype new UNIX password: 
        passwd: password updated successfully
        Changing the user information for bob
        Enter the new value, or press ENTER for the default
                Full Name []: Robert Nesta Marley
                Room Number []: 
                Work Phone []: 
                Home Phone []: 
                Other []: 
         Is the information correct? [Y/n] y
         # id bob
         uid=1000(bob) gid=1000(bob) groups=1000(bob)

4. Je préconise l'utilisation **EXCLUSIVE** de la commande **sudo** pour toute opération administrative j'ai pour principe de ne **JAMAIS** établir de connexion sous l'utilisateur **root**. Pourquoi ? 
    * Le mot de passe __root__ je ne l'utilise jamais il est stocké dans mon système de mot de passe et oublié
    * S'il y a une erreur de manipulation , j'en fait aussi ,  l'ensemble des commandes **sudo** sont conservées dans le fichier de logs
    * Comme il faut taper la commande **sudo** avant il y automatiquement réflexion avant de faire __ENTER__ sur la commande.

5. Installation de l'application __sudo__ et configuration d'un groupe 

        # apt-get install sudo
        # getent group sudo 
        sudo:x:27:
        ## S'il n'y a pas de retour avec la commande getent group creer un groupe
        # groupadd --system sudo 

    * Pourquoi la création du groupe __sudo__ , vous constaterez que tous le long de la configuration je vais définir plusieurs groupe auquel il y aura 1 ou 2 utilisateurs , éventuellement plus . Je préconise l'utilisation de groupe plutôt que d'utiliser les noms d'utilisateurs dans les configurations . La raison est simple :
        * La configuration s'exporte plus facilement d'un système à l'autre.
        * S'il y a explosions d'utilisateurs la gestion est plus simple, et surtout je suis prêt.
        * Mais **surtout** , lors de la suppression d'un utilisateur il est beaucoup plus simple de le supprimer des groupes plutôt que de parcourir plusieurs fichiers de configuration pour supprimé la définition de cette utilisateur. Il y a toujours des oublies malgré des __grep__ massif :P
    * Donc les membres du groupe **sudo** aurons la permission d'utiliser la commande **sudo** avec l'ensemble des droits

6. Configuration de __sudo__ , ajout de l'utilisateur **bob** dans le bon groupe et définition du __sudoers__

        # usermod -a -G sudo bob
        # id bob 
        uid=1000(bob) gid=1000(bob) groups=1000(bob),27(sudo)

        # visudo
        [... OUTPUT COUPÉ ...]
        # Members of the admin group may gain root privileges
        #%admin ALL=(ALL) ALL

        # Allow members of group sudo to execute any command
        %sudo   ALL=(ALL:ALL) ALL
        [... OUTPUT COUPÉ ...]

7. Valider la connexion avec l'utilisateur **bob** au serveur et validation de la configuration __sudo__ (ATTENTION: conservez la connexion initiale en cas de problème, donc ouvrir une nouvelle connexion)

        $ ssh bob@votre_serveur
        bob $ sudo -l 
        [sudo] password for bob:
        Matching Defaults entries for bob on atelier:
            env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin

        User bob may run the following commands on atelier:
            (ALL : ALL) ALL

8. A partir ce moment plus **AUCUNE** opération ne sera réalisé avec l'utilisateur **root**.

# <a name="configue_init_with_bob" /> Configuration initial avec votre utilisateur

Donc vous êtes connecté avec votre utilisateur ici __bob__, nous allons pouvoir établir une première base de sécurité de la machine. Ici nous ne couvrirons pas de la sécurité optimal, mais un minimum "vital" .

## <a name="configue_ssh" /> Configuration du service OpenSSH

Pour débuter nous allons modifier un peu la configuration du service __OpenSSH__ , car ce dernier est le point d'entré à notre machine , nous désirons limité l'accès.

1. Création d'un groupe d'accès , nous allons créer un groupe dont les membres seront le seule à pouvoir établir une connexion ssh à la machine.

        $ sudo groupadd permit-ssh
        $ sudo usermod -a -G permit-ssh bob

    Donc nous avons maintenant le groupe **permit-ssh** et **bob** est maintenant membre de ce dernier

2. Configuration du service __OpenSSH__ , nous allons éditer la configuration afin de valider quelques entré 

        $ sudo vim /etc/ssh/sshd_config

    Entré à prendre en considération
    * **PermitRootLogin  without-password** : ceci indique que l'utilisateur __root__ ne peux pas établir de connexion avec un mot de passe. Il peut cependant établir une connexion au serveur via un système de clé SSH. J'active cette possibilité car mon système de backup utilisera ce mécanisme pour faire le transferts de fichier. Vous pouvez aussi définir à **NO** si non requis
    * **PermitEmptyPasswords no** : Désactivation de la possibilité d'établir une connexion si l'utilisateur à pas de mot de passe . :D
    * **Protocol 2** : Utilise uniquement le protocole 2 , qui est sécuritaire :D
    * **UsePrivilegeSeparation yes** : Permet d'avoir le traitement des connexions entrante avec un processus sans droit , une fois l'authentification réalisée avec succès un autre processus avec les bon droit est créé.
    * **AllowTcpForwarding yes** : Personnellement je laisse le défaut qui est à __YES__ , car j'utilise le système de __TCP forwarding__ qui permet d'utiliser SSH pour faire de la redirection de connexion __TCP__ . Cependant libre à vous de le désactiver
    * **AllowGroups root permit-ssh** : Ici nous avons la limitation des personnes qui peut utiliser le service __d'OpenSSH__ pour établir une connexion. Donc uniquement les membres du groupe __root__ et __permit-ssh__ peuvent établir une connexion, le groupe __root__ est présent toujours pour mon système de backup :P.

3. Redémarrage du service __OpenSSH__ pour activé la nouvelle configuration, pour cette étape faut un peu faire attention :P on veut pas de bloquer l'accès :P.
    1. Conservé votre connexion actuelle !!
    2. Redémarrer le service __Openssh__

            $ sudo /etc/init.d/ssh restart

    3. Juste pour être certain valider que votre serveur __SSHD__ a bien redémarrer en vérifiant l'heure, dans mon cas 8:31 c'est bon :D :

            $ sudo ps aux | grep sshd
            root         9  0.0  0.2   7812  4824 ?        S    08:31   0:00 /usr/sbin/sshd -D

    4. Établir une nouvelle connexion avec votre utilisateur , et confirmer que tous fonctionne bien . Surtout ne pas fermer votre connexion __ssh__ avant un succès :P

3. Validation des clés __OpenSSH__ possiblement présent.
    * Bon pas que je fais pas confiance aux personnes qui m'ont fournit la machine , mais , mais ... Voilà quoi :P. Selon votre organisation ou entente de service il est possible que la compagnie veut se conservé une porte d'entré sur le serveur. Avant de procéder à une suppression de configuration assurez vous de l'entente :P.
    1. Recherche des clés __OpenSSH__ sur la machine , 2 méthodes , utilisation de la base de donné __locate__ ou un __find__ récursif, pour installer le __package locate__ **sudo apt-get install locate** .

            $ sudo updatedb    # mise à jour de la BD d'index pour locate
            $ sudo locate authorized_keys   # Tres important de le faire avec sudo sinon vous ne verrez pas tous !
            /home/support/.ssh/authorized_keys
            /root/.ssh/authorized_keys
            /usr/share/augeas/lenses/dist/authorized_keys.aug
            /usr/share/augeas/lenses/dist/tests/test_authorized_keys.aug
            /usr/share/man/man5/authorized_keys.5.gz

            $ sudo find / -name "authorized_keys"  # Ce sera plus long ...
            /home/support/.ssh/authorized_keys
            /root/.ssh/authorized_keys
            /usr/share/augeas/lenses/dist/authorized_keys.aug
            /usr/share/augeas/lenses/dist/tests/test_authorized_keys.aug
            /usr/share/man/man5/authorized_keys.5.gz
            
    2. Analyse du résultat
        * les seules fichiers "problématique" sont ceux contenu dans le répertoire **.ssh** , comme nous avons limité l'accès au groupe **permit-ssh** je présume que l'utilisateur __support__ n'est pas un risque . Pour l'utilisateur  __root__ si ce n'est pas votre clé :P , faut valider. Si nous venons de recevoir la machine personnellement je réaliserai l'opération suivante :
    3. Désactivation des clés, je ne supprime pas, car si un jour j'ai besoin du fournisseur de service ce sera plus rapide de lui re-fournir l'accès en changeant le nom du fichier plutôt qu'attendre qu'il me retransmette la clé.

            $ sudo mv /home/support/.ssh/authorized_keys /home/support/.ssh/disabled_keys
            $ sudo mv /root/.ssh/authorized_keys /root/.ssh/disabled_keys


* ssh
* home
* /data
* Validation DNS
* timeZone + NTP
* Installation app de base 
* Firewall in minimum
* Analyse des crontab en place
* visualisation des logs
* Mise en place d'un système de validation de fichier tripwire
* monitoring de base
*
