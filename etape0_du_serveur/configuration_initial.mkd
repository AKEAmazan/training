<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>

TODO corriger les \_

# Index 


# <a name="intro" /> Introduction 

Nous aurions probablement dû commencer la formation avec ce chapitre, mais comme cette formation est écrite selon l'envie et les demande , nous ne le couvrons que maintenant. Le bon côté est que vous avez pu déjà commencé à jouer un peu plus avec **apache** , **git** et **docker** :D. 
Ce chapitre va couvrir les opérations importante à faire quand vous mettez un serveur en production , ceci s'applique à l'ensemble des serveurs , bien entendu si vous avez plusieurs serveurs je vous invite à standardisé vos installations.
Nous allons donc voir les étapes à réaliser **avant** de mettre en place votre service , que nous parlions de __apache__, __mysql__ , __django__ , ... 

Nous parlerons un peu sécurité , mais très légèrement ...

# <a name="first_step" /> Réception de la machine 

Je vais partir du principe qu'une entité externe vous a fournit une machine , que ce soit une **VM** , un **VPS** , ou une machine physique. Le principe est le même si vous avez réalisé une nouvelle installation , si vous réalisez vous même l'installation d'une machine:

* Installé le minimum , quand vous réaliserez les mise à jours du serveur vous serez très content que l'opération soit super rapide car il y aura pas une multitude d'application non utilisé à mettre à jours.
* Vous limiterez en plus le nombre de faille de sécurité éventuelle du serveur.
* N'installez pas de compilateur ceci ouvre un nombre de possibilité élevé au attaquant , a moins bien entendu que ce soit requis pour votre utilisation. Je doute que ce soit le cas dans la pratique.

Voici les étapes à réaliser lors de la réception de la machine : 

1. Établir une connexion sur la **box**, __Yep__ :P 
2. Valide les informations de la machine selon les spécifications demandé :
    * Mémoire
        
        $ Free -m 
        total        used        free      shared  buff/cache   available
        Mem:           2009         483        1127           7         398        1490
        Swap:          5006           0        5006

    * CPU

        $ cat /proc/cpuinfo
        [...OUTPUT COUPÉ...]
        processor       : 1
        vendor_id       : GenuineIntel
        cpu family      : 6
        model           : 15
        model name      : Intel(R) Core(TM)2 CPU         U7600  @ 1.20GHz
        stepping        : 2
        microcode       : 0x57
        cpu MHz         : 800.000
        cache size      : 2048 KB
        [...OUTPUT COUPÉ...]

    * Taille du disque dur

        $ df -h | grep sda
        /dev/sda1        51G   33G   16G  68% /
        $ cat /proc/scsi/scsi
        Attached devices:
        Host: scsi0 Channel: 00 Id: 00 Lun: 00
          Vendor: ATA      Model: MCCOE64GEMPP     Rev: 03  
          Type:   Direct-Access                    ANSI  SCSI revision: 05

        $ dmesg  | grep sda
        [    1.242858] sd 0:0:0:0: [sda] 117210240 512-byte logical blocks: (60.0 GB/55.8 GiB)
        [    1.242968] sd 0:0:0:0: [sda] Write Protect is off
        [    1.242975] sd 0:0:0:0: [sda] Mode Sense: 00 3a 00 00
        [    1.243023] sd 0:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA
        [    1.244227]  sda: sda1 sda2

    * Partitionnement (si spécifié)
        
        $ df -h | grep ^/

    * Système de configuration du __RAID__ si disponible 

        $ cat /proc/mdstats

3. Valider la distribution :

        $ cat /etc/lsb-release 
        DISTRIB_ID=Ubuntu
        DISTRIB_RELEASE=14.04
        DISTRIB_CODENAME=trusty
        DISTRIB_DESCRIPTION="Ubuntu 14.04 LTS"

        ou 

        $ cat /etc/redhat-release

4. Prendre un café, une petite bière ou un verre de vin pour de félicité de cette nouvelle machine
5. Vous pouvez toujours remercier votre Sysadmin ou fournisseur du service :D, lui aussi aime les courriels gentils , surtout si c'est le sysadmin __Day__ :P


Pour la suite des opérations je vous suggère d'utiliser un système de gestion de mot de passe par exemple :

* __Keepass__
* __Keepassx__
* ou peu importe , sauf un post-it :P

# <a name="take_controle" /> Prise de contrôle de la machine

Bon c'est le temps de prendre en main la bête !!! C'est le moment de se l'approprier ! 

0. Initialisation de la configuration dans un contrôleur de révision
    * Avant de faire des modifications dans la configuration prenons une copie de la configuration en place dans le système de contrôleur de révision.
    * J'utilise le système __GIT__ car ceci ne m'oblige pas à avoir un serveur de source telle que __subversion__ 
    * Par contre ceci me permet de conserver une trace dans le temps et de revenir en arrière en cas de problème.

    1. Installation de __git__ et initialisation du dépôt pour **/etc**
            
            # apt-get install git
            # cd /etc
            # git init .
    2. Personnellement je n'active pas la révision sur l'ensemble des fichiers à tord ou à raison , chacun son plaisir , par exemple je ne désir pas que les mot de passe soit conservé , même chiffré , dans le dépôt. La raison principale est que je synchronise mon dépôt local sur un serveur et pour des considérations de sécurité je ne suis pas confortable. Je vais donc ajouter à la pièce les fichiers 

            # git add passwd group network/interfaces crontab cron.* ssh/sshd_config ssh/ssh_config
            # git config --global --edit   # pour faire la configuration de l'utilisateur avant de commiter
            # git commit -a -m "Configuration initial"

    3. Ajout d'un fichier **.gitignore** afin que le résultat de la commande **git status** ne montre pas une liste énorme de fichier non géré par __git__

            # vim /etc/.gitignore
            X11/
            acpi/
            adjtime
            aliases.db
            alternatives/
            bash.bashrc
            console-setup/
            byobu/
            dbus-1/
            debconf.conf
            debian_version
            default/
            deluser.conf
            dhcp/
            dpkg/
            fuse.conf
            gai.conf
            groff/
            group-
            gshadow-
            gss/
            hddtemp.db   
            ifplugd/
            [ ... OUTPUT COUPÉ ...]
            # template
            *.swp
            [ ... OUTPUT COUPÉ ...]

    4. Ajout du fichier à __git__ et validation des fichiers oublié .

            # cd /etc && git add .gitignore
            # git commit -m "Ajout du fichier .gitignore"
            # git status 

1. Changer le mot de passe de l'utilisateur fournit, car connu du fournisseur de service , si vous utilisé **root** oublié la deuxième partie .

        $ passwd

2. Changer le mot de passe de l'utilisateur **root** 

        $ su - 
        # passwd 

3. Création d'un utilisateur que vous utiliserez régulièrement , ici j'utiliserai __bob__

        #  adduser bob
        Adding user `bob' ...
        Adding new group `bob' (1000) ...
        Adding new user `bob' (1000) with group `bob' ...
        Creating home directory `/home/bob' ...
        Copying files from `/etc/skel' ...
        Enter new UNIX password:
        Retype new UNIX password: 
        passwd: password updated successfully
        Changing the user information for bob
        Enter the new value, or press ENTER for the default
                Full Name []: Robert Nesta Marley
                Room Number []: 
                Work Phone []: 
                Home Phone []: 
                Other []: 
         Is the information correct? [Y/n] y
         # id bob
         uid=1000(bob) gid=1000(bob) groups=1000(bob)

4. Je préconise l'utilisation **EXCLUSIVE** de la commande **sudo** pour toute opération administrative j'ai pour principe de ne **JAMAIS** établir de connexion sous l'utilisateur **root**. Pourquoi ? 
    * Le mot de passe __root__ je ne l'utilise jamais il est stocké dans mon système de mot de passe et oublié
    * S'il y a une erreur de manipulation , j'en fait aussi ,  l'ensemble des commandes **sudo** sont conservées dans le fichier de logs
    * Comme il faut taper la commande **sudo** avant il y automatiquement réflexion avant de faire __ENTER__ sur la commande.

5. Installation de l'application __sudo__ et configuration d'un groupe 

        # apt-get install sudo
        # getent group sudo 
        sudo:x:27:
        ## S'il n'y a pas de retour avec la commande getent group creer un groupe
        # groupadd --system sudo 

    * Pourquoi la création du groupe __sudo__ , vous constaterez que tous le long de la configuration je vais définir plusieurs groupe auquel il y aura 1 ou 2 utilisateurs , éventuellement plus . Je préconise l'utilisation de groupe plutôt que d'utiliser les noms d'utilisateurs dans les configurations . La raison est simple :
        * La configuration s'exporte plus facilement d'un système à l'autre.
        * S'il y a explosions d'utilisateurs la gestion est plus simple, et surtout je suis prêt.
        * Mais **surtout** , lors de la suppression d'un utilisateur il est beaucoup plus simple de le supprimer des groupes plutôt que de parcourir plusieurs fichiers de configuration pour supprimé la définition de cette utilisateur. Il y a toujours des oublies malgré des __grep__ massif :P
    * Donc les membres du groupe **sudo** aurons la permission d'utiliser la commande **sudo** avec l'ensemble des droits

6. Configuration de __sudo__ , ajout de l'utilisateur **bob** dans le bon groupe et définition du __sudoers__

        # usermod -a -G sudo bob
        # id bob 
        uid=1000(bob) gid=1000(bob) groups=1000(bob),27(sudo)

        # visudo
        [... OUTPUT COUPÉ ...]
        # Members of the admin group may gain root privileges
        #%admin ALL=(ALL) ALL

        # Allow members of group sudo to execute any command
        %sudo   ALL=(ALL:ALL) ALL
        [... OUTPUT COUPÉ ...]

7. Valider la connexion avec l'utilisateur **bob** au serveur et validation de la configuration __sudo__ (ATTENTION: conservez la connexion initiale en cas de problème, donc ouvrir une nouvelle connexion)

        $ ssh bob@votre_serveur
        bob $ sudo -l 
        [sudo] password for bob:
        Matching Defaults entries for bob on atelier:
            env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin

        User bob may run the following commands on atelier:
            (ALL : ALL) ALL

8. A partir ce moment plus **AUCUNE** opération ne sera réalisé avec l'utilisateur **root**.

9. Ajout des fichiers et commit dans **git**
    * Ajout des fichiers et commit les changements

            # cd /etc
            # git add /etc/sudoers
            # git status         # Afin de visualiser les autres modifications
            # git add Autre_fichier_si_requis
            # git commit -m "Creation de l'utilisateur bob et ajout de ce dernier dans sudo "

# <a name="configue_init_with_bob" /> Configuration initial avec votre utilisateur

Donc vous êtes connecté avec votre utilisateur ici __bob__, nous allons pouvoir établir une première base de sécurité de la machine. Ici nous ne couvrirons pas de la sécurité optimal, mais un minimum "vital" .

## <a name="configue_ssh" /> Configuration du service OpenSSH

Pour débuter nous allons modifier un peu la configuration du service __OpenSSH__ , car ce dernier est le point d'entré à notre machine , nous désirons limité l'accès.

1. Création d'un groupe d'accès , nous allons créer un groupe dont les membres seront le seule à pouvoir établir une connexion ssh à la machine.

        $ sudo groupadd permit-ssh
        $ sudo usermod -a -G permit-ssh bob

    Donc nous avons maintenant le groupe **permit-ssh** et **bob** est maintenant membre de ce dernier

2. Configuration du service __OpenSSH__ , nous allons éditer la configuration afin de valider quelques entré 

        $ sudo vim /etc/ssh/sshd_config

    Entré à prendre en considération
    * **PermitRootLogin  without-password** : ceci indique que l'utilisateur __root__ ne peux pas établir de connexion avec un mot de passe. Il peut cependant établir une connexion au serveur via un système de clé SSH. J'active cette possibilité car mon système de backup utilisera ce mécanisme pour faire le transferts de fichier. Vous pouvez aussi définir à **NO** si non requis
    * **PermitEmptyPasswords no** : Désactivation de la possibilité d'établir une connexion si l'utilisateur à pas de mot de passe . :D
    * **Protocol 2** : Utilise uniquement le protocole 2 , qui est sécuritaire :D
    * **UsePrivilegeSeparation yes** : Permet d'avoir le traitement des connexions entrante avec un processus sans droit , une fois l'authentification réalisée avec succès un autre processus avec les bon droit est créé.
    * **AllowTcpForwarding yes** : Personnellement je laisse le défaut qui est à __YES__ , car j'utilise le système de __TCP forwarding__ qui permet d'utiliser SSH pour faire de la redirection de connexion __TCP__ . Cependant libre à vous de le désactiver
    * **AllowGroups root permit-ssh** : Ici nous avons la limitation des personnes qui peut utiliser le service __d'OpenSSH__ pour établir une connexion. Donc uniquement les membres du groupe __root__ et __permit-ssh__ peuvent établir une connexion, le groupe __root__ est présent toujours pour mon système de backup :P.

3. Redémarrage du service __OpenSSH__ pour activé la nouvelle configuration, pour cette étape faut un peu faire attention :P on veut pas de bloquer l'accès :P.
    1. Conservé votre connexion actuelle !!
    2. Redémarrer le service __Openssh__

            $ sudo /etc/init.d/ssh restart

    3. Juste pour être certain valider que votre serveur __SSHD__ a bien redémarrer en vérifiant l'heure, dans mon cas 8:31 c'est bon :D :

            $ sudo ps aux | grep sshd
            root         9  0.0  0.2   7812  4824 ?        S    08:31   0:00 /usr/sbin/sshd -D

    4. Établir une nouvelle connexion avec votre utilisateur , et confirmer que tous fonctionne bien . Surtout ne pas fermer votre connexion __ssh__ avant un succès :P

4. Commit les changements à __git__ suite au modification du service __OpenSSH__ et la création des groupes
    * Ajout des fichiers et commit

            # cd /etc
            # git status         # Afin de visualiser les autres modifications
            # git add Autre_fichier_si_requis
            # git commit -m "Modification d'openssh afin de limite avec le groupe "

5. Validation des clés __OpenSSH__ possiblement présent.
    * Bon pas que je fais pas confiance aux personnes qui m'ont fournit la machine , mais , mais ... Voilà quoi :P. Selon votre organisation ou entente de service il est possible que la compagnie veut se conservé une porte d'entré sur le serveur. Avant de procéder à une suppression de configuration assurez vous de l'entente :P.
    1. Recherche des clés __OpenSSH__ sur la machine , 2 méthodes , utilisation de la base de donné __locate__ ou un __find__ récursif, pour installer le __package locate__ **sudo apt-get install locate** .

            $ sudo updatedb    # mise à jour de la BD d'index pour locate
            $ sudo locate authorized_keys   # Tres important de le faire avec sudo sinon vous ne verrez pas tous !
            /home/support/.ssh/authorized_keys
            /root/.ssh/authorized_keys
            /usr/share/augeas/lenses/dist/authorized_keys.aug
            /usr/share/augeas/lenses/dist/tests/test_authorized_keys.aug
            /usr/share/man/man5/authorized_keys.5.gz

            $ sudo find / -name "authorized_keys"  # Ce sera plus long ...
            /home/support/.ssh/authorized_keys
            /root/.ssh/authorized_keys
            /usr/share/augeas/lenses/dist/authorized_keys.aug
            /usr/share/augeas/lenses/dist/tests/test_authorized_keys.aug
            /usr/share/man/man5/authorized_keys.5.gz

    2. Analyse du résultat
        * les seules fichiers "problématique" sont ceux contenu dans le répertoire **.ssh** , comme nous avons limité l'accès au groupe **permit-ssh** je présume que l'utilisateur __support__ n'est pas un risque . Pour l'utilisateur  __root__ si ce n'est pas votre clé :P , faut valider. Si nous venons de recevoir la machine personnellement je réaliserai l'opération suivante :
    3. Désactivation des clés, je ne supprime pas, car si un jour j'ai besoin du fournisseur de service ce sera plus rapide de lui re-fournir l'accès en changeant le nom du fichier plutôt qu'attendre qu'il me retransmette la clé.

            $ sudo mv /home/support/.ssh/authorized_keys /home/support/.ssh/disabled_keys
            $ sudo mv /root/.ssh/authorized_keys /root/.ssh/disabled_keys


## <a name="securisation_directory" /> Sécurisation minimal des répertoires 

1. Sécurisation du répertoire des utilisateurs .
    * Chose étrange par défaut sous Ubuntu le répertoire personnelle des utilisateurs est créé avec les permissions à tous de lire le contenu. Moi ça me dérange un peu je connais mes utilisateurs mais bon c'est pas super propre :P. Nous allons donc corriger le problème pour ceux déjà créer 

            $ cd /home
            $ sudo chmod o= *

    * Nous allons aussi faire en sorte que les prochains soit configurer convenablement , car c'est certain que nous oublierons de réaliser cette opération dans l'avenir.
            
            $ sudo vim /etc/adduser.conf
            # Modifier la ligne suivante  :
            DIR_MODE=0755 
            pour 
            DIR_MODE=0750

2. Validation des répertoires où tous le monde peut lire le contenu
    * Comme nous ne savons pas qui a monté la machine nous allons étendre l'analyse à l'ensemble du système, normalement à ce stade il n'y a pas beaucoup de fichier ce ne sera pas trop long .
    * Recherche des répertoires :
            
            $ cd /
            $ sudo find -perm -o=w  -type d 2>/dev/null| grep -v ^./proc            
            ./run/lock
            ./dev/mqueue
            ./dev/shm
            ./tmp
            ./tmp/.X11-unix
            ./tmp/.ICE-unix
            ./var/lib/php5
            ./var/tmp

    * L'ensemble des répertoires ci-dessus sont **normale** il n'est pas possible de supprimé l'écriture à tous de ces derniers.
    * Recherche des fichiers maintenant
        
            $ cd /
            $ sudo find -perm -o=w  -type f 2>/dev/null| grep -v ^./proc

## <a name="validation_dns" /> Validation de la configuration DNS en place

Malheureusement trop souvent mis de côté les __DNS__ il est essentiels d'avoir de BON __DNS__, et de s'assurer qu'ils sont disponible nous allons donc réaliser la vérification qui s'impose. Mais pourquoi c'est si important, si vos __DNS__ sont invalide ou problématique voici l'impacte:
* Ralentissement de l'ensemble du système : plusieurs processus vont réaliser une validation que ce soit __reverse dns__ (récupération de l'adresse IP et conversion en nom )  ou __DNS__ classique nom vers adresse IP. Si votre premier __DNS timeout__ ça veut dire que tous les processus qui réalise une requête doivent attendre le __timeout__ pour interroger le second.

1. Analyse de la configuration des __DNS__ en place :

        $ cat /etc/resolv.conf
        domain X3rus.com
        search x3rus.com
        nameserver 213.186.33.99
        nameserver 213.186.33.102
        nameserver 8.8.4.4

2. Dans le contexte actuelle comme vous pouvez le voir j'ai la configuration de 3 serveurs __DNS__ voyons c'est qui 

        $ dig -x 213.186.33.99 | grep -A 1 "^;; ANS"
        ;; ANSWER SECTION:
        99.33.186.213.in-addr.arpa. 86352 IN    PTR     cdns.ovh.net.

        $ dig -x 213.186.33.102 | grep -A 1 "^;; ANS"
        ;; ANSWER SECTION:
        102.33.186.213.in-addr.arpa. 86400 IN   PTR     dns.ovh.net.

        $ dig -x 8.8.4.4 | grep -A 1 "^;; ANS"
        ;; ANSWER SECTION:
        4.4.8.8.in-addr.arpa.   82657   IN      PTR     google-public-dns-b.google.com.

3. Nous allons valider que l'ensemble fonctionne , bon là on peut faire un __ping__ et voir le comportement , mais est-ce vraiment valide ?!? Si la résolution __dns__ est en cache nous aurons l'impression que tous fonctionne bien, mais nous n'aurons pas valider chaque serveur. Nous utiliserons la commande **dig** en forçant l'utilisation d'un serveur __DNS__.
    *  Voici un exemple lors d'un problème 
            
            $ dig lequipe.fr @213.186.33.99

            ; <<>> DiG 9.9.5-3ubuntu0.5-Ubuntu <<>> lequipe.fr @213.186.33.99
            ;; global options: +cmd
            ;; connection timed out; no servers could be reached

    * Voici la bonne réponse :

            $ dig lequipe.fr @213.186.33.99

            ; <<>> DiG 9.10.3-P4-Ubuntu <<>> lequipe.fr @213.186.33.99
            ;; global options: +cmd
            ;; Got answer:
            ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 51019
            ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 3

            ;; OPT PSEUDOSECTION:
            ; EDNS: version: 0, flags:; udp: 4096
            ;; QUESTION SECTION:
            ;lequipe.fr.                    IN      A

            ;; ANSWER SECTION:
            lequipe.fr.             300     IN      A       160.92.167.203

            ;; AUTHORITY SECTION:
            lequipe.fr.             79627   IN      NS      ns3.atos.net.
            lequipe.fr.             79627   IN      NS      ns4.atos.net.

            ;; ADDITIONAL SECTION:
            ns3.atos.net.           90092   IN      A       160.92.121.6
            ns4.atos.net.           90092   IN      A       193.56.46.248

            ;; Query time: 110 msec
            ;; SERVER: 213.186.33.99#53(213.186.33.99)
            ;; WHEN: Thu Sep 22 17:19:50 EDT 2016
            ;; MSG SIZE  rcvd: 131

    * Faite l'exercice pour l'ensemble des __dns__ configurer , une fois réaliser analyser le temps de réponse **Query time** indiquer à la fin . 

2. Modification du fichier **/etc/resolv.conf** 
    * Selon le temps de réponse changer l'ordre ou supprimer l'entrée .

            $ sudo vim /etc/resolv.conf

3. Enregistrement de la modification dans **git**

        $ cd /etc/
        $ sudo git status 
        $ sudo git add /etc/resolv.conf
        $ sudo git commit -m "Changement de la configuration DNS pour une meilleur perf :P "

## <a name="setup_timezone" /> Configuration du fuseau horaire et synchronisation du temps

Ici bien souvent c'est une catastrophe :P , j'arrive souvent sur des machines dont l'heure est complètement érroné , le fuseau horaire étant pré configurer c'est mieux mais encore :P. 
Pourquoi l'heure est importante ?
* Lors de l'analyse de problème , la lecture des logs si votre heures est mauvaise il est beaucoup plus dure de réaliser l'analyse de la séquence du problème.
* Si votre fuseau horaire est erroné vous êtes obligé de faire un +5 ou -2 heures c'est franchement pénible 
* Lors de l'analyse des fichiers qui furent créés , vous n'avez pas la bonne information, si votre heure se décale tranquillement vous avez quelques minutes de décalage encore une fois ça ne simplifie pas l'analyse
* Si votre système à trop de décalage sur l'heure l'établissement de connexion avec le protocole __SSL__ risque de ne pas marché, car la date de validation du certificat causera des problèmes
* Si vous utilisez un système d'authentification telle que **Kerberos** si votre système à plus de 15 minutes de décalage l'authentification ne fonctionnera pas
* etc etc 

Comme vous pouvez le voir, l'heure est importante , comme quand vous dites à votre femme que vous rentrez à une certaine heure :P.
Ceci s'applique pour **tous** les systèmes **VM** ou même les **conteneurs**.

1. Configuration du fuseau horaire
    * L'ensemble des fuseau sont contenu dans le répertoire : **/usr/share/zoneinfo/**

            $ ls /usr/share/zoneinfo/
            Africa      Australia  Cuba     Etc      GMT+0      Iceland  Kwajalein  NZ       Poland     Turkey     WET          right
            America     Brazil     EET      Europe   GMT-0      Indian   Libya      NZ-CHAT  Portugal   UCT        Zulu         zone.tab
            Antarctica  CET        EST      Factory  GMT0       Iran     MET        Navajo   ROC        US         iso3166.tab
            Arctic      CST6CDT    EST5EDT  GB       Greenwich  Israel   MST        PRC      ROK        UTC        localtime
            Asia        Canada     Egypt    GB-Eire  HST        Jamaica  MST7MDT    PST8PDT  Singapore  Universal  posix
            Atlantic    Chile      Eire     GMT      Hongkong   Japan    Mexico     Pacific  SystemV    W-SU       posixrules

    * Modification de la configuration pour avoir le bon fuseau horaire , dans mon cas je vais définir Montréal comme fuseau horaire, je vous laisse parcourir le répertoire afin d'identifier le plus proche de votre position :-)

            $ sudo ln -sf /usr/share/zoneinfo/America/Montreal /etc/localtime

    * Vous pouvez aussi utiliser la commande suivante qui permet d'avoir un menu vous aidant à faire la configuration

             $ sudo dpkg-reconfigure tzdata

2. Activation de la nouvelle configuration dans __git__

        $ cd /etc
        $ sudo git add localtime
        $ sudo git commit -m "Correction du fuseau horaire "

3. Redémarrage du système 
    Je vous suggère très fortement de réaliser un redémarrage du système afin de s'assurer que l'ensemble des applications prenne en considération la nouvelle configuration ! 

        $ sudo reboot

4. Mise en place de la synchronisation de l'heure avec des serveurs de référence avec le protocole **NTP (Network Time Protocol)**

    1. Installation de l'application et ajout du fichier de configuration par défaut dans git
                
                $ sudo apt-get install ntp ntpdate
                $ cd /etc
                $ sudo git add ntp.conf
                $ sudo git commit -m "Ajout fichier original de ntp"

    2. Configuration du service __ntp__ via le fichier **/etc/ntp.conf** , juste pour information je vais mettre en lumière 2 paramètre du fichier.

                $ cat /etc/ntp.conf | egrep  "^[server|restric]" | grep -v "#" 
                statistics loopstats peerstats clockstats
                server 0.ubuntu.pool.ntp.org
                server 1.ubuntu.pool.ntp.org
                server 2.ubuntu.pool.ntp.org
                server 3.ubuntu.pool.ntp.org
                server ntp.ubuntu.com
                restrict -4 default kod notrap nomodify nopeer noquery
                restrict -6 default kod notrap nomodify nopeer noquery
                restrict 127.0.0.1
                restrict ::1

       * l'instruction serveur est assez claire :P , vous pouvez avoir une liste différente sur le site de [ntp.org](http://support.ntp.org/bin/view/Servers/WebHome#Finding_A_Time_Server) . Je le met en lumière surtout si vous filtrez les communications en sortie
       * Vous pouvez valider le fonctionnement avec les serveurs avec la commande **ntpq** 

                $ sudo /etc/init.d/ntp start
                $ sudo ntpq -pn
                  remote           refid      st t when poll reach   delay   offset  jitter
                  ==============================================================================
                  211.233.40.78   131.107.13.100   2 u  151   64   14  390.465  -950167   1.659
                  131.234.137.64  .DCF.            1 u   89   64   16  188.313  -950198   9.302
                  24.122.14.21    .PPS.            1 u   18   64    7   89.726  -950193   5.180
                  +194.71.144.71   192.36.144.22    2 u   26   64   17  360.986  -950143  55.067
                  *91.189.94.4     193.79.237.14    2 u   23   64   17  169.261  -950200  14.560

       * Il est possible si vous avez une trop grande différence de temps entre "le monde" et votre système que malgré le démarrage du service ntp , le temps reste à la mauvaise heure. Ceci est du au fait que le système ne veut pas faire un trop gros saut dans le temps . Pour corriger le problème vous devez effectué l'opération manuellement 
      
                $ sudo /etc/init.d/ntp stop
                $ sudo ntpdate 91.189.94.4
                23 Sep 08:36:10 ntpdate[8423]: step time server 91.189.94.4 offset -950.214027 sec
                $ sudo /etc/init.d/ntp start


5. C'est le temps d'un boisson réconfortante je pense :D ... 


## <a name="checkup_crontab" /> Validation des tâches planifier mise en place

Encore une fois pas que je ne fait pas confiance au prestataire de service, cependant je désire savoir s'il y a eu une configuration mise en place qui est exécuté régulièrement. Pour donner un exemple **ovh** avait mis en place un système de monitoring qui transmet l'information sur la consommation __CPU__ , mémoire, etc . Ceci est très pratique quand on va sur l'interface client pour voir l'utilisation de la machine, donc l'idée n'est pas d'arracher les configurations en place mais en prendre connaissance :)  et prendre action si requis .



* Analyse des crontab en place
* visualisation des logs
* Installation app de base 
* Firewall in minimum
* Mise en place d'un système de validation de fichier tripwire
* monitoring de base
*
