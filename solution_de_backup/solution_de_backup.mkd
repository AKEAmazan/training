<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>

# Index  
* [Introduction ](#intro) 
* [Stratégie de sauvegarde ](#strategie) 
       * [Formulaire par client](#form_client) 
       * [Planification du chef d'orchestre (serveur / logiciel)](#chef_orchestre) 
           * [Formulaire pour le chef d'orchestre](#form_chef_orchestre) 
           * [Type de sauvegarde ](#type_sauvegarde) 
           * [Support de sauvegarde](#lst_support) 
           * [ Manipulation des données](#manip_data) 
           * [Méthode de prise de sauvegarde](#methode_sauv) 
           * [ Défis des équipements mobile](#defi_mobile) 
           * [Sortir les sauvegardes du lieu ](#sortir_bk) 
* [Résultat pour l'écosystème de démonstration](#resultat_eco) 
       * [Stratégie pour le chef d'orchestre ](#strategie_chef_orches) 
* [Mise en place de logiciel](#mise_en_place) 
       * [ Rsnapshot](#rsnapshot) 
           * [ Installation et configuration de Rsnapshot ](#install_rsnapshot) 
               * [ L'installation ](#install_rsnapshot_2) 
               * [La configuration](#configure_rsnapshot) 
               * [ Utilisation ](#use_rsnapshot) 
               * [Configuration des tâches planifiées](#planif_rsnapshot) 
           * [ Ma configuration de Rsnapshot serveur](#setup_x3_rsnapshot_serveur) 
               * [ Organisation des fichiers de configuration ](#files_rsnapshot) 
               * [ Création de clés __SSH__ pour la communication avec les machines distantes](#ssh_key_rsnapshot) 
               * [Configuration du client __SSH__ pour l'utilisation de la clé](#ssh-setup_client_rsnapshot) 
               * [ script d'abstraction **backup_runner.sh**](#backup_runner.sh) 
               * [ script de backup et fichier de configuration (__FullBackup.sh__ et __FullBackup.conf__)](#script_bk_rsnapshot) 
               * [ script satellite ](#script_satellite) 
           * [ Ma configuration de Rsnapshot client](#setup_x3_rsnapshot_client) 
               * [ configuration de la clé __ssh__ client](#setup_ssh_client_rsnapshot) 
               * [ limitation de l'utilisation de la clé](#limitation_ssh_key_rsnapsho) 
           * [ Ma configuration validation](#setup_x3_rsnapshot_test) 
       * [ BackupPC](#backupPC) 
           * [ Installation](#installation_backuppc) 
           * [Configuration ](#config_backuppc) 
           *  [ Réalisation d'une sauvegarde manuel du serveur backupPC](#backupmanuel_backuppc) 
           *  [ Planification des sauvegardes](#planif_backuppc) 
           * [Configuration d'un client sur le réseau](#setup_net_client_backuppc) 
           * [ Restauration d'un fichier](#restore_backuppc) 
           * [ Un petit mot sur Backup PC](#conclusion_backuppc) 
       * [ CloneZilla](#clonezilla) 
           * [ Installation CloneZilla](#install_clonezilla) 
           * [ Utilisation de CloneZilla](#use_clonezilla) 
* [Quelques points pour peaufiner la solution](#la_glue_autour) 
       * [Réalisation de la sauvegarde des équipements mobile](#Sauvegarde_des_mobiles) 
       * [Mise en place d'une stratégie de la validation de sauvegarde automatique.](#Validation) 
       * [ Sauvegarde de la PS4](#bk_ps4) 
* [Autre Méthode pour des besoins precis.](#other_technique) 
       * [lvm export](#lvm_export) 
       * [Backup de sanpshot de VM](#backup_snapshot_vmware) 
* [Référence ](#ref) 

# <a name="intro" />Introduction 

La sauvegarde de donnée ou __backup__ en anglais est une chose très importante de nos jours. Combien de donnée avez vous sur votre machine qu'il ne faut surtout pas perdre ?! Que nous parlions des photos de famille, des rapports d'impôt, ... Tous est numérisés, il est important de ne pas perdre les fichiers.

Nous désirons nous protéger des problèmes suivant :

* Panne d'un disque dur 
* Suppression accidentel de fichiers
* Corruption de fichiers
* Destruction de la machine

Sans vouloir avoir l'air simpliste dans le propos, mais j'aimerai clarifier un point:

* **L'important ce n'est pas la prise de sauvegarde, mais la restauration des fichiers**

Nous allons voir comment définir une stratégie de sauvegarde ainsi que les outils disponible pour la mettre en place. Peu importe le logiciel que vous mettez en place , la stratégie que vous définirez , il sera important de tester régulièrement vos sauvegardes.

Afin de faciliter le dialogue voici un exemple d'environnement que nous désirions prendre en sauvegarde : [Infrastructure de démonstration](./infrastructure_demo.html). 

# <a name="strategie" />Stratégie de sauvegarde 

Comme pour tous il est important de prendre quelques minutes de recule et d'évaluer la stratégie de sauvegarde que l'on veut mettre en place , afin de répondre à nos besoins et contraintes (coût, temps , niveau technique , ...) . 

Voici quelques question que vous devriez vous posez :

* Quelle sont les systèmes qui doivent avoir un sauvegarde de sécurité ?
    * Les système d'exploitation
    * Leurs disponibilités  (portable , téléphone cellulaire , tablette )
    * Les logiciels à sauvegarder
* Qui sont vos utilisateurs , sont ils conscient de l'importance des sauvegardes ?
* La quantité de donnée 
* Classification de la sensibilité des données
* Le nombre de jours à conserver
* La fréquence de la sauvegarde
* Le support où écrire les données ( DVD , disque dur externe, clé __USB__, __cloud__ )
* Le lieu de stockage ( maison , bureau , coffre fort, __cloud__)
* Vitesse de restauration
* Granularité de la restauration 


## <a name="form_client" />Formulaire par client

Nous avons souvent le reflex de commencé par chercher le logiciel disponible avant dévaluer le plus important ce que l'on doit prendre en backup ! 
Je vais donc commencer par identifier ce que je dois sauvegarder, car comment ceci me permettra :

* d'identifier les protocole disponible pour communiquer avec le client.
* Définir la quantité total requise pour ma sauvegarde , et par conséquence choisir le support en prenant en considération le coût final.
* Grâce à la quantité de donnée je serai aussi en mesure dévaluer le temps de transfert si je préconise l'utilisation du réseau pour le transfert des données.
* Nous aurons une vision global des données ainsi que leurs sensibilité.

Voici un formulaire qui peut vous aider à structurer ces réflexions :

* Formulaire par système : [Formulaire_backup_client.pdf](./formulaire_ajout_systeme.pdf)

Ceci est un __PDF__ éditable , pas de panique je n'ai pas planifier de faire 2 fois de l'entrée de donnée :P. Nous verrons par la suite comment __scripter__ l'extraction des données :D. Pour les personnes qui désirent savoir comment faire un __PDF__ avec des champs voici la documentation que j'ai suivie : [Création d'un PDF editable (EN)](https://www.maketecheasier.com/create-a-pdf-with-fillable-forms-in-libreoffice/)

À ce stade nous avons une bonne idée de l'ensemble des données et des acteurs qui participe au processus de sauvegarde. Il nous manque un point critique le chef d'orchestre, soit le serveur / logiciel qui orchestre le processus.

## <a name="chef_orchestre" />Planification du chef d'orchestre (serveur / logiciel)

### <a name="form_chef_orchestre" />Formulaire pour le chef d'orchestre

Avant de présenter des logiciels j'aimerais clarifier certain concept de sauvegarde afin de pouvoir remplir de manière approprié et surtout en tout connaissance le document. Tout comme pour la partie client j'ai réalisé un formulaire __PDF__ éditable pour entrer l'ensemble des informations.
Encore une fois l'ensemble de ces questions sont générique peut importe le choix du logiciel.

Voici le Formulaire et nous allons le remplir avec l'information présenté ci-dessous

* Formulaire pour le chef d'orchestre : TODO faire le formulaire

### <a name="type_sauvegarde" />Type de sauvegarde 

Voici plusieurs mode de sauvegarde , nous allons donc faire notre choix au mieux de notre désire nous verrons par la suite ce que le logiciels choisi nous permettra. En d'autre mots toutes ces méthodes ne sont pas offertes par les logiciels de sauvegarde, mais je préfère définir mes besoins et voir par la suite ce que les logiciels me permette. 

* **Sauvegarde complète** : tous les fichiers sont sauvegardés sans tenir compte d'une sauvegarde antérieure. 
    * __Pour__ : La restauration des fichiers est simple car la dernière sauvegarde toujours complète, si une planification n'a pas lieu la suivante sera complète
    * __Contre__ : L'espace disque requis est plus que significatif , le temps de prise de sauvegarde est long car tous est copié .

* **Sauvegarde différentielle** : on ne sauvegarde que ce qui a changé depuis la dernière sauvegarde complète. Ainsi, pour tout restaurer, il suffit de restaurer la sauvegarde complète puis la dernière différentielle. En d'autre mot si nous avons pris une sauvegarde complète le Dimanche, le Lundi la sauvegarde différentielle comprendra uniquement les changements de la journée. Le mardi la sauvegarde comprendra les changements de mardi ET lundi  ainsi de suite jusqu'à ce que l'on reprenne une sauvegarde complète.
    * __Pour__ : Ceci nous permet d'économiser le temps de la prise sauvegarde car uniquement les changements sont transféré, l'espace disque utilisé est aussi réduite. La restauration est simple la sauvegarde complète + le dernier différentielle.
    * __Contre__ : Il faut s'assurer que la prise de sauvegarde complète est bonne sinon l'ensemble du différentielle est invalide ou est équivalent à une sauvegarde complète , car la source de référence est null. Il faut planifié , une sauvegarde complète régulièrement sinon le différentielle peut devenir très gros. .

* **Sauvegarde incrémentale** : on ne sauvegarde que ce qui a changé depuis la dernière sauvegarde quelle qu'elle soit (complète, différentielle ou incrémentale). La plupart des logiciels dédiés à la sauvegarde gèrent les sauvegardes incrémentales. Ainsi, pour tout restaurer, il faut restaurer la dernière sauvegarde complète puis toutes les sauvegardes incrémentales effectuées depuis, et dans l'ordre. En d'autre mot si nous avons pris une sauvegarde complète le dimanche, le lundi la sauvegarde incrémentale comprendra uniquement les changements de lundi . Le mardi la sauvegarde comprendra uniquement les changements de mardi. 
    * __Pour__ : L'espace disque dur est encore plus réduire que lors du différentielle car il n'y a pas accumulation ou de journée, par le fait même le temps de sauvegarde est réduite.
    * __Contre__ : La restauration est plus compliqué, car il faut rejouer l'ensemble des sauvegardes pour restaurer (complet + n incrémentale) imaginé si l'ensemble de la sauvegarde n'est pas localement disponible... Chaque prise de sauvegarde est critique car il n'y a pas d'autre sauvegarde de prise avec ces données. 

* **Sauvegarde décrémentale** : on ne sauvegarde que ce qui a changé depuis la dernière sauvegarde mais à l'inverse de la sauvegarde incrémentale, c'est la sauvegarde la plus récente qui est complète, les plus anciennes sont des différences par rapport à la sauvegarde suivante. Pour tout restaurer il suffit d'utiliser la dernière sauvegarde, mais on conserve l'historique pour récupérer même longtemps après un fichier qui aurait été effacé par erreur. 
    * __Pour__ : Tous comme la sauvegarde incrémentale ceci permet de réduire significativement le transfert de donnée , ainsi que l'espace disque utilisé. Contrairement au système incrémentale la restauration est beaucoup plus simple.
    * __Contre__ : L'accès au fichier historique est moins évident car selon le système il peut être moins simple d'identifier le lieu de stockage. Chaque prise de sauvegarde est critique, car il est unique.

L'ensemble de ses solutions sont bonne , elles comportent des avantages est inconvénients telle que listé ci-dessus. C'est toujours un équilibre entre les avantages et inconvénient.

### <a name="lst_support" />Support de sauvegarde

Tous comme les types de sauvegarde, il existe plusieurs possibilités de support où écrire nos données , avantage inconvénient , c'est repartie 

* **Bande magnétique** : L'utilisation des bandes magnétiques est de plus en plus rare surtout pour les petites entreprises et les particuliers , le prix des systèmes de stockages externe ayant beaucoup baissé. Dans la situation ou vous auriez un grand volume de donnée , nous parlons de __Téra__ au moins par semaines voir par jours , les bandes magnétiques offre un ratio prix / quantité de stockage intéressant (il reste le coût de l'équipement). 
    * __Pour__ : Le ratio prix / quantité de stockage, la robustesse des cassettes très important lorsqu'elle sont stocké hors site; La cassette comprend très peu de pièce mobile ceci en fait une valeur sûr comparativement au disque dur si plusieurs année après nous désirons accédé au donnée , il n'est pas garantie que le disque dur soit coopératif. 
    * __Contre__ : Le coût du lecteur de bande est significatif; Les performances d'écriture ou lecture d'une bande magnétique sont bonne lorsqu'elles sont réalisé de manière séquentielle il est donc important d'offrir un bon débit lors de l'écriture au lecteur et de lire séquentiellement cette dernière.

* **Disque Dur Interne** : Solution la plus commode qui permet de réaliser une sauvegarde rapidement et facilement
    * __Pour__ : Simple à mettre en place et permet de stocker une bonne quantité de donnée à un coût raisonnable , l'accès au sauvegarde est simple et rapide
    * __Contre__ : Ne permet pas sortir les sauvegardes, donc si le site géographique où se trouve le système de sauvegarde est compromis l'ensemble des sauvegardes de sécurité sont perdu. 

* **Disque Dur Externe**: Deuxième solution simple à mettre en place, le matériel est facilement accessible. Il est possible de réutiliser le matériel pour le backup de manière temporaire ou permanent.
    * __Pour__ : Le coût d'achat n'est pas très élevé, la solution __scale__ relativement , si nous avons besoin de plus d'espace il est possible d'acheter un disque dur avec plus de capacité . Il est possible de déplacer le disque dur pour le mettre géographiquement dans un autre lie.
    * __Contre__ : Ce support ne permet pas un conservation pour plusieurs année du à la fragilité (est-ce que les SSD corrige ce problème ?!? ) , la rotation des disques est manuelle, comparativement au bande magnétique.

* **cle USB** : Pour de petite quantité de sauvegarde cette solution peut être idéal.
    * __Pour__ : Le coût n'est pas très grand pour des quantités entre 32 Gigs et 64 Gigs . Le transport est simple dû à la taille des clés. La résistance des __clés USB__ est très bonne en cas de chute ou autre. Comme il n'y a pas de pièces mobile, nous pouvons présumer que la conservation des données peut être conservé pour plusieurs année.
    * __Contre__ : L'avantage de la taille est aussi un problème car plus facile de les perdre. La taille est tout de même réduit si vous avez une grosse quantité de données.

* **DVD, blu-ray** : Autre possibilité l'utilisation de DVD , solution de moins en moins utilisé principalement à cause de la taille du stockage du support.
    * __Pour__ : Le support permet une conservation des données pour plusieurs années . Permet de disposer des copies à plusieurs endroit à moindre de coût, Le prix d'un DVD ou Blu-ray  est nettement moins élevé qu'un disque externe. Moins sensible à l'humidité que les disques durs
    * __Contre__ : La quantité de donnée disponible sur le support. Le temps d'écriture sur le support lors de la sauvegarde , l'obligation de réaliser une rotation manuel.

* **Service en ligne** : Cette solution prends de plus en plus d'ampleur avec le temps, les offres étant de moins en moins chère, la quantité de stockage offert est bonne (selon le prix) , les connexions internet ayant un débit plus important nous pouvons évaluer ces solutions. (information : je ne suis pas un partisan de cette solution , je ne suis donc pas impartial )
    * __Pour__ : La solution est extensible si vous avez besoin de plus d'espace généralement il est simple d'augmenter la taille offert. Vous n'avez pas à gérer l'infrastructure . La solution de backup est même parfois offert en prime :P. Comme le serveur est sur internet , la prise de sauvegarde peut être réalisé n'importe où.
    * __Contre__ : Vous n'êtes pas mettre de la solution , si le service s'arrête vous devez changer la solution dans un délais variable. Il faut faire attention où sont stocké vos données , pour avoir un prix intéressant il faut allé au États-Unis cependant les lois protégeant le données ne sont pas les mêmes. Si le logiciel de sauvegarde est fournit est-il libre ? Est-ce que le système utilise des protocoles ouvert ?. Si votre connexion internet est limité , il faut faire attention au coût du au transfert.


### <a name="manip_data" /> Manipulation des données

Nous voyons l'ensemble des fonctionnalités offert par les logiciels de sauvegarde nous analyserons par la suite les options disponibles pour nous.

* __Compression__ : Beaucoup de système de sauvegarde offre la possibilité de compresser les données lors du stockage , la solution peut être logiciel ou matériel . Le lecteur de bande magnétique offre généralement une compression matériel.
* __Chiffrement__: Nous parlions un peu plus tôt de sortir les sauvegardes du lieu géographique où ils sont pris, bien entendu il y a toujours un risque de perdre ou de vol de nos sauvegardes. Afin de ce prévenir contre cette situation il est possible de chiffrer les données. Nous avons deux possibilités de réaliser cette opération :
    * Chiffrement réalisé par le logiciel de sauvegarde
    * Chiffrement réalisé par le système de fichier , GNU/Linux permet de créer une partition chiffré
* __Déduplication__ : Le système de sauvegarde peut éviter de conserver plusieurs fois le même fichier en effet si nous avons plusieurs machines qui ont le même fichier zip qui est pris en sauvegarde certain logiciel de sauvegarde peut ne conserver qu'un fichier et réaliser un pointeur pour les autres. Ceci permet d'économiser l'espace disque dur de manière significatif s'il y a redondance de fichier.

### <a name="methode_sauv" />Méthode de prise de sauvegarde

Voici un liste de méthode de prise de sauvegarde, tous les systèmes de sauvegarde n'ont pas l'ensemble des fonctionnalités , il est possible que vous désiriez combiner une ou plusieurs méthodes dans votre environnement. Ceci n'est pas une liste exhaustive , cependant ce sont les méthodes les plus courantes. 

* __Copie de fichiers__ : Le méthode classique la copie de fichiers , nous prenons les fichiers sur un système et ces derniers sont copiés sur le [support](#lst_support) choisi. Cette méthode peut être combiné avec plusieurs [manipulation de donnée](#manip_data) et peut être sujet au différent [type de sauvegarde](#type_sauvegarde). L'important avec cette méthode de sauvegarde est de ne pas oublié de répertoires et de revisiter la liste périodiquement.

* __Snapshot OS ,prise d'image__ : La prise de __snapshot__ ou d'image d'un système , ceci va permettre de prendre l'ensemble du système et de l'exporter dans un fichier. Ce fichier contient généralement l'ensemble des fichiers , dans le cadre de __snapshot__ de machine virtuelle, il peut même contenir les informations sur le "matériel" virtuel qui fut utilisé. Dans le cadre d'une image d'une machines physique selon le logiciel il peut prendre une copie de la structure des tables de partition. Ceci à l'avantage de permettre la restauration **complète** du système dans un délai très court. L'inconvénient selon le système d'exploitation sauvegardé l'image ne peut pas être réutilisé selon le matériel. Autre point problématique la taille des sauvegardes qui sont souvent volumineuse pour des données non critiques ou requises, cependant vous êtes sûr de rien oublier.

* __Snapshot du système de fichier__ : Selon le système de fichier que vous utilisez il est parfois possible de réaliser des __snapshot__ temporaire ou permanent du système de fichier donc une partition. Ceci à l'avantage d'offrir la possibilité de valider une mise à jour par exemple et de réaliser un retour arrière en cas de problème ou de réaliser une image complète d'un système de fichier. Ceci permet d'avoir une alternative entre la prise d'image complète de l'ensemble du système incluant le système d'exploitation et uniquement le système de fichier contenant les données.


* __Base de donnée__ (chaud / froid) : Les systèmes de base de données sont particulier il est fortement déconseiller de prendre uniquement les fichiers de données si la base de données est en activité. L'ensemble de la littérature tant au niveau des logiciel de sauvegarde que des logiciels de base de donnée , la sauvegarde a de forte chance d'être invalide. Pour solutionner ce problème nous pouvons réaliser 2 type de sauvegarde :
    * __Chaud__ : nous utilisons un agent fournit par le logiciel de sauvegarde pour qu'il se connecte à la base de donnée pour réaliser une copie. L'autre option si votre logiciel de sauvegarde ne supporte pas d'agent ou que le prix est excessif , la réalisation d'un __dump__ local sur le serveur de base de donnée et le logiciel de sauvegarde récupère ce dernier.
    * __Froid__ : Nous arrêtons la base de donnée et nous prenons l'ensemble des fichiers binaire sous le répertoire du serveur.

### <a name="defi_mobile" /> Défis des équipements mobile

Bla bla bla bla , je présume que lister les possibilités des types, méthodes, et  support de sauvegarde   n'est pas forcément ce que vous désirez avoir. Nous allons aller dans le vif du sujet avec  des considérations de réalisation de sauvegarde.

L'ensemble de notre vie est de plus en plus connecter, si nous reprenons l'infrastructure d'exemple sur laquelle nous allons bâtir nos solutions, vous constaterez que sur 11 équipements nous avons 5 qui sont des équipements mobile. Comment allons traiter ses équipements qui ne sont pas toujours disponible ? Nous ne pouvons simplement pas les ignorer, l'importance que prend le téléphone cellulaire et la quantité de données qu'il contient ne peut pas être mis de côté.

Je vais vous présenter ici la solution que j'ai mis en place pour répondre à ce besoin, comme toujours si vous avez des suggestions pour d'autre méthode je suis à l'écoute :P.

Voici l'état de la situation :

* L'équipement n'est pas toujours disponible où le logiciel de sauvegarde est en fonction
* La présence peut varier être présent quelques heures et repartir cependant nous ne savons pas l'heure exacte de ça présence.
* Demander à l'utilisateur de réaliser la copie de ses fichiers comporte un risque important d'oublis et surtout ceci est très ennuyeux.

Afin de répondre à ses problèmes voici la solution que j'ai mis en place, j'ai suivie ces principes :

1. Réaliser la copie des données quand l'équipement est sur un réseau __WIFI__, afin de ne peut utiliser de bande passante payante.
2. Permettre le transfert via le réseaux mobile (LTE,4G,...) sur demande.
3. Réaliser la copie des fichiers vers un serveur distant.
 
Une des solutions la plus "simple" et la plus répandu est l'utilisation d'un service en ligne, ceci à l'avantage de permettre le transfert des fichiers peut importe où l'équipement mobile se trouve. Le seule critère important est la présence d'un point d'accès __WIFI__.
N'étant pas un adepte des solutions de service en ligne en impartition, nous allons suivre ce principe mais en utilisant nos serveurs. Si nous reprenons  [l'infrastructure de démonstration](./infrastructure_demo.html), deux systèmes pourrons faire le travaille de passerelle soit le serveur dans le centre de donnée ou la station de travaille avec 1.5 Téra disponible.

Pour le moment nous ne sommes que dans l'étape de planification pour la réalisation proprement dite, voici la section pour les TROP pressés. [Sauvegarde mobile](#Sauvegarde_des_mobiles)

### <a name="sortir_bk" />Sortir les sauvegardes du lieu 

**IMPORTANT** 

La majorité des entreprises sortent les sauvegardes des bureaux pour les entreposer dans les lieux sécuritaire :

* Fournisseur de service de voûte telle que : __Iron Montaine__
* Coffre fort dans une institution bancaire 

Ceci à l'avantage d'offrir une sécurité physique des sauvegardes dans un environnement approprié humidité, température, café des collègues :P, verre de lait des enfants :P ...

Cette pratique est malheureusement moins fréquente lors que l'on parle de sauvegarde des données des particuliers , bien souvent nous réalisons des sauvegardons que nous conservons sur le bureau à coté de la machine d'origine. Ceci nous protège très bien des risques :

* Problème matériel (disque dur , ...)
* Erreur de manipulation ( suppression de données)
* Corruption des données 

Malheureusement en cas de sinistre, notre sauvegarde risque d'être endommagé en même temps que la machine d'origine, que nous parlons de dégât d'eau et de feu. C'est pourquoi il est primordial de sortir les sauvegardes, car vous avez des données précieuse , que l'on parle de photos de famille ou de document de travail une fois perdu c'est fini !

Lorsque nous avons listé les supports disponible j'ai fait mention de lors qu'il est  possible d'utiliser le média pour sortir les données revoici la liste des supports :

* __DVD, blu-ray__
* __Disque Externe__
* __Bande Magnétique__
* __Clé USB__
* __Service en ligne__ de par la nature du support :D

# <a name="resultat_eco"/>Résultat pour l'écosystème de démonstration

Courage, la théorie achève sous peu, nous allons maintenant procéder avec la compilation de l'ensemble de cette théorie et voir comment j'ai mis en place les différents critères pour définir ma stratégie de sauvegarde. Ceci est un point de départ afin d'avoir un dialogue sur du concret, cependant tous comme les recettes de cuisine je vous invite à y faire des modifications afin de répondre à VOS besoin.

Voici un résumé de l'ensemble des répertoires et données a prendre en sauvegarde .
L'information est disponible dans l'ensemble des fichiers __PDF__ contenu dans le répertoire : [Formulaires PDF](./forms/)

## <a name="strategie_chef_orches"/>Stratégie pour le chef d'orchestre 

* **Type de sauvegarde** :
    Mon critère primaire est de pouvoir réalisé une restauration RAPIDE de mes fichiers en cas de problème, je n'ai pas envie de courir après les supports pour réaliser une restauration ! Mon choix se penche donc sur 2 options , je donne 2 options car selon le logiciel de sauvegarde il est possible qu'un de mes choix ne soit pas disponible. Bien entendu l'idée de prendre uniquement des sauvegardes complète est aussi valide cependant l'espace disque requis serait trop volumineux.
    1. __Sauvegarde décrémentale__ : Ceci me permettra d'avoir le dernier backup complet et de recherché les fichiers plus vieux au besoin. De plus l'utilisation de cette solution me permettra de réduire la quantité des sauvegardes.
    2. __Sauvegarde différentielle__ : Cette solution rejoint l'idée d'avoir peut d'étape pour réaliser la restauration , soit restauration de la sauvegarde complète + le dernier différenciel. De plus tous comme la solution décrémentale ceci réduit le temps de prise de sauvegarde. 


* **Type de support** :
    Mon critère ici est le rapport taille / prix, bien que pour cette aspect les bandes magnétique serait une bonne idée le coût de l'achat du lecteur me décourage. De plus en cas de bris du lecteur je ne pourrais plus utiliser mes bandes à moins de réinvestir. Autre critère pouvoir sortir mes sauvegardes
    1. __Disque dur Externe__: La meilleur option reste les disques dur externe qui aujourd'hui offre un coût très intéressant , de toutes taille physique et espace de donnée.
    2. __DVD , blu-ray__ : j'analyse l'option de stocké des données sur disque optique telle que les photos de famille afin d'avoir une conservation à plus long terme dans un coffre. Je ne suis pas prêt a déployer cette solution donc pour le moment je dupliquerai de manière perpétuel mes données sur les disques Externe.

* **Manipulation des données** :
    Je vais chercher a réduire la taille de mes backups afin d'optimiser l'espace, bien que le chiffrement des sauvegardes est intéressant je ne désire pas donnée cette tâches au logiciel de sauvegarde. Le problème est que ceci limiterai mes choix, car le nombre d'option réduit. Si je désire réaliser ce type d'opération je le ferai en amont soit en chiffrant l'ensemble du système de fichier de mon disque externe. 
    1. __Déduplication__ : J'aimerai que le logiciel de sauvegarde puisse réaliser de la déduplication afin de réduire l'espace utilisé lors de la sauvegarde. Car je suis d'accord avec l'idée de ne pas écrire 2 fois les mêmes données.

* **Méthode de prise de sauvegarde** :
    Ici nous parlons encore de temps de prise de sauvegarde et rapidité de restauration. Je pars du principe que réinstaller un système n'est pas un problème voir même une opportunité :D. Donc je cherche principalement à copies les données du système, je parle ici pour les opérations courante éventuellement il est possible que je prenne une image d'un système afin de pouvoir le restaurer rapidement , principalement si je suis moins confortable avec le système d'exploitation.
    1. __Copie de fichiers__ : Comme il y a un risque d'oublier de configurer un répertoire il faudra revisité la configuration.
    2. __Base de donnée à froid__ : n'ayant que très peu de base de donnée et aucune avec une charge énorme la prise de sauvegarde à froid est la plus simple. Ceci ne nécessitera pas de configuration particulière et l'ensemble des logiciels de sauvegarde seront en mesure de faire l'opération.

* **Rotation des sauvegardes avec l'externe**
    Pour la rotation des disques dur externe, ma technique n'étais pas optimal à l'origine j'apportai un disque dur au travail et occasionnellement je pensais à reprendre un autre disque externe pour faire la rotation. Le problème avec cette solution est que parfois j'oublie et allant au travaille tous les jours, il y a peu d'indication de la journée particulière et qu'il faut apporter le disque. Lors de la préparation cette formation une personne m'a présenter une autre solution que je vais mettre en place maintenant , ce sera à l'essaie. 
    Le disque dur sera entreposé chez ma mère, donc lors du repas dominical , on pense aux fleurs et au disque dur. Attention de ne pas offrir le disque ça risquerai de faire un impair :-). Résultat un risque de perte de donnée d'une semaine uniquement, ou un mois selon les visites.

# <a name="mise_en_place" />Mise en place de logiciel

Suite à la mise en place de la stratégie de sauvegarde il est temps de la mettre en pratique, nous avons définie nos requis et besoin nous allons voir à présent les logiciels disponibles. Nous allons être obligé de faire des concessions car il est possible que les logiciels ne répondes pas à l'ensemble de nos requis. Comme nous utilisons des logiciels libre il serait toujours possible de programmer les fonctionnalités manquante, mais nous sortons du cadre. 
Je n'ai pas la prétention de présenter l'ensemble des solutions disponibles , en fait à l'origine je n'avais prévue présenter qu'une solution **rsnapshot**, mais pour avoir une formation complète j'ai préféré vous offrir plus de choix. Nous verrons donc 3 solutions de sauvegarde :

* **Rsnapshot** : Solution que j'utilise depuis plusieurs année et qui réponds a mes besoins 
* **BackupPC** : Solution très populaire dans le monde du libre qui offre une interface web de gestion , donc plus conviviale pour les utilisateurs. (Prendre note que j'ai moins d'expérience avec cette solution)
* **CloneZilla** : Solution similaire à  __Norton Ghost__ , il clone un disque dur dans son intégralité. 

## <a name="rsnapshot" /> Rsnapshot

__Rsnapshot__ est basé sur le logiciel **rsync** , en fait il est une couche d'abstraction sur __rsync__ nous permettant de définir des sauvegardes de manière périodique d'une machine local ou à distance grâce au protocole **ssh**. La configuration se fait grâce à un fichier texte simple et il est possible de l'industrialiser. 

* Point Fort : __Rsnapshot__ est l'utilisation de lien dur (__Hard Link__) quand les fichiers sont identique ceci à l'avantage de réduire l'utilisation de l'espace disque dur. Le système est aussi très personnalisé les opérations à l'aide de scripts. Offre l'ensemble de la structure du dernier backup complète. Ne nous oblige pas a installer un agent sur l'ensemble des machines ni d'ouvrir des ports réseaux en plus.
* Point Faible : __Rsnapshot__ n'offre pas d'interface graphique de configuration et gestion ce qui peut rebuté un peu le client ou l'utilisateur.

Débutons avec la mise en place de la solution, j'entends certain dire enfin :P.

* Référence :
    * site officiel : http://rsnapshot.org/
    * __wiki archlinux__ : https://wiki.archlinux.org/index.php/Rsnapshot

### <a name="install_rsnapshot" /> Installation et configuration de Rsnapshot 

#### <a name="install_rsnapshot_2" /> L'installation 

L'installation est très simple la majorité des distributions offre un pacquage pour __rsnapshot__ .

        $ sudo apt-get install rsnapshot

On peut pas me dire que GNU/Linux c'est compliqué :P !



#### <a name="configure_rsnapshot" />La configuration

Le fichier de configuration par défaut est **/etc/rsnapshot.conf**, je vous laisse le plaisir de lire le contenu du fichier fournie par la distribution pour vous inspirer.

        $ cd /etc
        $ git init
        $ git config --global user.email "Bob@exemple.com "
        $ git config --global user.name "Bob :D "
        $ sudo git add rsnapshot.conf 
        $ sudo git commit -a -m " Ajout du fichier original rsnapshot "
        [master (root-commit) be15580]  Ajout du fichier original rsnapshot
         1 file changed, 254 insertions(+)
          create mode 100644 rsnapshot.conf
        bob@xerus:/etc$ sudo git log
        commit be15580f0a5e6048e03b69ecf6049bc91617235e
        Author: Bob :D <Bob@exemple.com>
        Date:   Fri Jan 22 17:31:12 2016 -0500

            Ajout du fichier original rsnapshot

Éditer le fichier pour refléter votre configuration , lire les commentaires explicatif fournit dans le fichier.
Il est aussi possible de consulter le fichier **/usr/share/doc/rsnapshot/examples/rsnapshot.conf.default.gz** contenant un exemple de configuration.

Voici le résultat de la configuration sans les commentaires et les lignes vide :

        $  cat rsnapshot.conf | grep -v "#" | grep -v "^$"
        config_version  1.2
        snapshot_root   /var/cache/rsnapshot/
        cmd_cp          /bin/cp
        cmd_du          /usr/bin/du
        cmd_logger      /usr/bin/logger
        cmd_rm          /bin/rm
        cmd_rsnapshot_diff      /usr/bin/rsnapshot-diff
        cmd_rsync       /usr/bin/rsync
        cmd_ssh /usr/bin/ssh
        interval        daily           7
        interval        weekly          4
        interval        monthly         6
        verbose         2
        loglevel        3
        logfile         /var/log/rsnapshot.log
        lockfile        /var/run/rsnapshot.pid
        backup  /etc/           localhost/

Information sur la configuration 

* __snapshot\_root__ : Ceci décrit le répertoire où sera stocké les configurations.
* __cmd_*__ : Permet de définir les chemins où les binaires sont disponible.
* __interval__ :  Définie le nombre de rétention selon le type journalier , hebdomadaire , ...
* __verbose__ et __loglevel__ : Comprend les informations pour les logs :P
* __backup__ : Décrit les répertoires à prendre en sauvegarde et le répertoire de destination ici __localhost__ sous le répertoire définie par __snapshot_root__


**IMPORTANT** : __Rsnapshot__ oblige l'utilisation des tabulations entre les arguments si vous utilisez des espaces vous aurez un message d'erreur, comme ci-dessous :P

        ERROR: interval daily 7 - missing tabs to separate words - change spaces to \
                 tabs. 


#### <a name="use_rsnapshot" /> Utilisation 

Test d'exécution  et validation du résultat : 

        $ sudo rsnapshot -c /etc/rsnapshot.conf daily
        $ sudo ls -l /var/cache/rsnapshot/
        total 4
        drwxr-xr-x 3 root root 4096 Jan 25 08:31 daily.0
        $ sudo ls -l /var/cache/rsnapshot/daily.0/localhost/etc/passwd
        -rw-r--r-- 1 root root 1043 Jan 22 17:18 /var/cache/rsnapshot/daily.0/localhost/etc/passwd

Nous avons a présent un répertoire **daily.0** contenant le dernier backup disponible , dans ce dernier comme nous l'avions définie dans le fichier de configuration, nous avons le répertoire __localhost__ contenant la structure que nous voulions prendre en sauvegarde. Si nous listons un fichier , par exemple __/etc/passwd__.

Je relance l'opération normalement rien ou presque ne fut modifier, cette opération est normalement réaliser une fois par jour :P.

        $ sudo rsnapshot -c /etc/rsnapshot.conf daily
        $ sudo ls -l /var/cache/rsnapshot/
        total 8
        drwxr-xr-x 3 root root 4096 Jan 25 08:34 daily.0
        drwxr-xr-x 3 root root 4096 Jan 25 08:31 daily.1
        $ sudo du -hsc /var/cache/rsnapshot/daily.0 /var/cache/rsnapshot/daily.1
        3.7M    /var/cache/rsnapshot/daily.0
        588K    /var/cache/rsnapshot/daily.1
        4.3M    total
        $ sudo ls -li /var/cache/rsnapshot/daily.1/localhost/etc/passwd
        534727 -rw-r--r-- 2 root root 1043 Jan 22 17:18 /var/cache/rsnapshot/daily.1/localhost/etc/passwd
        $ sudo ls -li /var/cache/rsnapshot/daily.0/localhost/etc/passwd
        534727 -rw-r--r-- 2 root root 1043 Jan 22 17:18 /var/cache/rsnapshot/daily.0/localhost/etc/passwd

Nous avons à présent **daily.0** et **daily.1** qui sont respectivement **la sauvegarde la plus récenter** et la **sauvegarde veille d'un jour**. Nous constatons que l'espace disque utilisé par les sauvegardes ne sont pas équivalente, mais que nous parcourions le répertoires __daily.0__ ou __daily.1__ nous aurons l'ensemble de la structure.
Nous pouvons le voir avec le fichier __/etc/passwd__. __Rsnapshot__ réalise des liens dur (__hard link__) pour faire la référence des fichiers. L'avantage est que nous ne sommes pas obligé de reconstruire la structure des  répertoires avec les anciennes sauvegarde le répertoire  est complet. 
Comme démontré dans l'exemple ci-dessus nous pouvons constater que le fichier __etc/passwd__ à le même __inode__ et la chiffre indiquant qu'il y a un lien symbolique est à 2 .

Pour bien faire la démonstration je l'exécute une fois de plus, nous passerons donc a 3 le nombre de lien dur.

        $ sudo rsnapshot -c /etc/rsnapshot.conf daily
        $ sudo ls -li /var/cache/rsnapshot/daily.0/localhost/etc/passwd
        534727 -rw-r--r-- 3 root root 1043 Jan 22 17:18 /var/cache/rsnapshot/daily.0/localhost/etc/passwd
        $ sudo ls -li /var/cache/rsnapshot/daily.1/localhost/etc/passwd
        534727 -rw-r--r-- 3 root root 1043 Jan 22 17:18 /var/cache/rsnapshot/daily.1/localhost/etc/passwd
        $ sudo ls -li /var/cache/rsnapshot/daily.2/localhost/etc/passwd
        534727 -rw-r--r-- 3 root root 1043 Jan 22 17:18 /var/cache/rsnapshot/daily.2/localhost/etc/passwd

Pour pouvoir exécuter la sauvegarde hebdomadaire, vous devez avoir l'ensemble des exécutions journalier, sinon vous aurez l'erreur suivante dans vos __log__ :

        [25/Jan/2016:08:53:54] /usr/bin/rsnapshot -c /etc/rsnapshot.conf weekly: started
        [25/Jan/2016:08:53:54] /var/cache/rsnapshot/daily.6 not present (yet), nothing to copy

Donc une fois les 6 instances créé il est possible d'exécuter la sauvegarde hebdomadaire 

        $ sudo rsnapshot -c /etc/rsnapshot.conf weekly
        $ sudo ls -l /var/cache/rsnapshot/
        total 28
        drwxr-xr-x 3 root root 4096 Jan 25 08:57 daily.0
        drwxr-xr-x 3 root root 4096 Jan 25 08:57 daily.1
        drwxr-xr-x 3 root root 4096 Jan 25 08:57 daily.2
        drwxr-xr-x 3 root root 4096 Jan 25 08:57 daily.3
        drwxr-xr-x 3 root root 4096 Jan 25 08:57 daily.4
        drwxr-xr-x 3 root root 4096 Jan 25 08:50 daily.5
        drwxr-xr-x 3 root root 4096 Jan 25 08:34 weekly.0
        $ sudo ls -l -i /var/cache/rsnapshot/weekly.0/localhost/etc/passwd
        534727 -rw-r--r-- 7 root root 1043 Jan 22 17:18 /var/cache/rsnapshot/weekly.0/localhost/etc/passwd

Le concept est le même pour les sauvegardes par mois ou année.


#### <a name="planif_rsnapshot" />Configuration des tâches planifiées

L'utilisation à la ligne de commande est pratique pour faire des testes, cependant nous désirons mettre en place cette opérations de manière régulière et planifier. Pour ce faire nous allons éditer le **crontab**. 

Les manières de réaliser l'opération sont multiple , éditer la tache planifié de l'utilisateur __root__ ou éditer le fichier **/etc/crontab** . Je vais prendre la deuxième option, ce qui ne change presque rien à la définition.

Je vais ajouter les lignes suivante au fichier de **/etc/crontab**

        00 02 2-31 * 1-6 root /usr/bin/rsnapshot -c /etc/rsnapshot.conf daily
        00 02 2-31 * 7   root /usr/bin/rsnapshot -c /etc/rsnapshot.conf weekly
        00 02 01 * *     root /usr/bin/rsnapshot -c /etc/rsnapshot.conf monthly

* __daily__ : La sauvegarde est exécutée à 2:00 (00 02) le matin , date 02 au 31 (2-31) , du lundi au samedi (1-6)
* __weekly__ : La sauvegarde est exécutée à 2:00 (00 02) le matin , date 02 au 31 (2-31) , le dimanche (7)
* __monthly__ : La sauvegarde est exécutée à 2:00 (00 02) le matin , le 1 du mois

Comme vous pouvez le constater les sauvegardes sont programmer pour ne pas se marché dessus. Si nous regardons les fichiers de configuration vous constaterez qu'il y a la définition d'un fichier de verrou afin que si nous réalisons une erreur le problème ne cause pas de problème majeur.


### <a name="setup_x3_rsnapshot_serveur" /> Ma configuration de Rsnapshot serveur

Je présume que bien que la solution soit d'une simplicité déconcertante, il y a un peu d'incrédulité par le manque d'information sur l'état des copies , la quantité de donnée transférer , ... En gros on manque de visibilité sur ce qui s'est produit et surtout on aimerait bien recevoir un courriel avec le résultat afin de ne pas le lire et classer dans un répertoire pourvu à cette effet !
De plus comment on fais pour réaliser la sauvegarde d'une machine distant ? Afin de répondre à la question je vais vous présenter ma configuration.

Je vais donc faire la présentation de l'écosystème que j'ai mis autour pour répondre à ce besoin, je ne prétend pas que c'est la meilleur solution cependant elle a le mérite d'être flexible. L'ensemble des scripts son disponible sous le dépôt [github scripts](https://github.com/x3rus/scripts/).

Comme je désire avoir un graphique sur le temps utilisé pour la réalisation de la sauvegarde nous aurons besoin de [rrd](http://oss.oetiker.ch/rrdtool/) outil qui permet de réaliser des graphiques avec n'importe quelle donnée. 
De plus pour faire l'envoie de courriel en __HTML__ j'utilise un script python. Nous devons donc installer ces deux pacquages.

        $ sudo apt-get install rrdtool python-minimal


#### <a name="files_rsnapshot" /> Organisation des fichiers de configuration 

Premièrement je ne vais pas utiliser le fichier de configuration __/etc/rsnapshot.conf__ , j'ai créé un répertoire **/etc/rsnapshot/hosts** sous ce dernier j'ai mis la configuration désirer pour chacune des machines.

        $ sudo mkdir -p  /etc/rsnapshot/hosts
        $ ls /etc/rsnapshot/hosts
        goban_x3rus_com.conf  hoshi_x3rus_com.conf  tengen_x3rus_com.conf

De plus par défaut __rsnapshot__ utilise uniquement 1 fichier de __log /var/log/rsnapshot__ nous allons créer un répertoire pour contenir les logs pour chaque sauvegarde.

        $ sudo mkdir /var/log/rsnapshot/

Nous allons aussi créer un répertoire pour stocker le fichier de graphique __rrd__ généré

        $ sudo mkdir /var/lib/rrd/

#### <a name="ssh_key_rsnapshot" /> Création de clés __SSH__ pour la communication avec les machines distantes

Nous n'avons pas encore couvert le processus de sauvegarde d'une machine distante, le système __rsnapshot__ utilise __ssh__ pour communiquer. Comme le système de sauvegarde doit être exécuter de manière automatique sans l'intervention humaine, donc sans entrer un mot de passe nous utiliserons l'authentification par clé. Nous allons créer une pair de clé. Contrairement à l'utilisation classique qui crée la clé de le home de l'utilisateur nous allons la créer dans le répertoire __/etc/rsnapshot/keys/__ . La clé ne comprend pas de __passphrase__

        
        $ sudo mkdir -p  /etc/rsnapshot/keys 
        $ sudo ssh-keygen
        Generating public/private rsa key pair.
        Enter file in which to save the key (/root/.ssh/id_rsa): /etc/rsnapshot/keys/rsnapshot_rsa
        Enter passphrase (empty for no passphrase): 
        Enter same passphrase again: 
        Your identification has been saved in /etc/rsnapshot/keys/rsnapshot_rsa.
        Your public key has been saved in /etc/rsnapshot/keys/rsnapshot_rsa.pub.

Nous aurons donc la clé disponible sous __/etc/rsnapshot/keys/rsnapshot_rsa__

#### <a name="ssh-setup_client_rsnapshot" />Configuration du client __SSH__ pour l'utilisation de la clé

Nous avons définie une clé __ssh__ nous allons maintenant définir une configuration pour que le client __ssh__ de l'utilisateur **root** utilise cette configuration ! Deux option d'offre à nous , la première définir dans le fichier de configuration de __rsnapshot__ du client d'utiliser spécifiquement cette clé. Personnellement n'utilisant jamais le compte __root__ autre que pour des opérations automatisé j'ai définie cette configuration global à l'utilisateur. 
J'ai édité le fichier **/root/.ssh/config** avec les instructions suivante :

        Host *
            IdentityFile /etc/rsnapshot/keys/rsnapshot_rsa
            StrictHostKeyChecking no

Ceci ce traduit comme suit , pour toutes les machines (__Host *__)  utilise la clé __rsnapshot\_rsa__ (__IdentityFile__) lors de l'initialisation de connexion ne pas faire de validation sur l'échange de clé initiale (__StrictHostKeyChecking__)


### <a name="backup_runner.sh" /> script d'abstraction **backup_runner.sh**

Ce script disponible sous le dépôt [backup_runner.sh](https://github.com/x3rus/scripts/blob/master/backup-scripts/rsnapshot/backup_runner.sh), permet d'avoir une validation des paramètres transmis. 
Si vous lisez le script vous constaterez qu'il valide les paramètres, valide que l'utilisateur utilisé est bien **root**.

Résultat au lieu d'utiliser la commande __rsnapshot__ nous utiliserons :

        $ sudo backup_runner.sh -c Fichier-de-configuration.conf daily

#### <a name="script_bk_rsnapshot" /> script de backup et fichier de configuration (__FullBackup.sh__ et __FullBackup.conf__)

__Backup\_runner.sh__ ne réalise la sauvegarde que pour un fichier de configuration nous utiliserons le script __FullBackup.sh__ pour orchestrer l'ensemble du processus de sauvegarde. Ce dernier réalise les opérations suivante :

1. __Mount__ le disque dur externe sur le système de fichier
2. Réalise la sauvegarde pour l'ensemble des fichiers de configuration présent dans __/etc/rsnapshot/hosts/__
3. Réalise un graphique des performances.
4. Envoie un courriel récapitulatif du processus de sauvegarde

Ce fichier utilise un fichier de configuration contenant l'ensemble des paramètres requis pour le bon fonctionnement.
Le fichier [FullBackup.sh](https://github.com/x3rus/scripts/blob/master/backup-scripts/rsnapshot/FullBackup.sh) et [FullBackup.conf](https://github.com/x3rus/scripts/blob/master/backup-scripts/rsnapshot/FullBackup.conf), sont disponible sur __github__.

Bien entendu il est important de modifier le contenu du fichier de configuration **FullBackup.conf** pour que ce soit représentatif de votre installation !

#### <a name="script_satellite" /> script satellite 

Le script [FullBackup.sh](https://github.com/x3rus/scripts/blob/master/backup-scripts/rsnapshot/FullBackup.sh) appel un autre script nommé [html-email-sender.py](https://github.com/x3rus/scripts/blob/master/backup-scripts/rsnapshot/html-email-sender.py), ce petit script en python est utilisé pour envoyer un courriel. Pour ceux qui se demande pourquoi je n'ai pas simplement utilisé la commande __mail__ , simplement parce que j'avais besoin de composer un courriel en __html__ pour inclure une image.
Tout comme les autres script ceci est disponible sur __github__ [html-email-sender.py](https://github.com/x3rus/scripts/blob/master/backup-scripts/rsnapshot/html-email-sender.py).

Je vous laisse le plaisir de le lire.

Le script [rsnapreport.pl](https://github.com/x3rus/scripts/blob/master/backup-scripts/rsnapshot/rsnapshot.pl) est en fait un script inclut dans le __package rsnapshot__ vous le retrouverez dans le répertoire __/usr/share/doc/rsnapshot/examples/utils/rsnapreport.pl.gz__. Je l'ai inclue dans le dépôt pour facilité le déploiement de la solution.

### <a name="setup_x3_rsnapshot_client" /> Ma configuration de Rsnapshot client

Pour que le système de sauvegarde fonctionne vous devez avoir sur le client :

* service __ssh__ pour la connexion ( __apt-get install openssh-server__ )
* l'application __rsync__ pour la synchronisation / copie des fichiers ( __apt-get install rsync__ )

Lors de la configuration du serveur nous avons créé une clé __SSH__ afin de permettre au serveur d'établir une connexion sur les machines clients sans mot de passe. Nous allons maintenant procéder à la configuration de cette clé sur le / les clients.

#### <a name="setup_ssh_client_rsnapshot" /> configuration de la clé __ssh__ client

Afin de permettre la réalisation de la sauvegarde de l'ensemble du système peut importe les permissions l'opération de sauvegarde sera réalisé par l'utilisateur __root__ . La configuration de __ssh__ doit donc permettre la connexion via l'utilisateur __root__ . Afin de réduire les risques ( __brute force__, ...) en autorisant les accès avec le compte administrateur directement, nous n'autoriseront l'accès que grâce au système de clé. Voici la ligne à valider / modifier dans votre configuration , assurez vous d'avoir __without-password__ :

        $ cat /etc/ssh/sshd_config  | grep PermitRootLogin
        PermitRootLogin without-password

Si vous avez réalisé une configuration avec limitation d'accès par utilisateur __AllowUsers__ ou __AllowGroups__ il faudra rajouter l'usagé __root__ pour lui permettre la connexion. Bien entendu nous redémarrons le service s'il y a eu modification dans le fichier 

        $ sudo /etc/init.d/ssh restart

Le serveur est configuré , nous allons mettre en place la clé :D. Car si vous avez été trop pressé puis fait le teste , ça marche pas encore :P.

Nous créer le répertoire __ssh__ pour l'utilisateur __root__ puis nous allons déposer la clé publique __rsa__ (**/etc/rsnapshot/keys/rsnapshot_rsa.pub**) , c'est partie.

        client $ sudo mkdir ~root/.ssh
        client $ sudo chmod u=rwx,g=rx,o= ~root/.ssh
        server $ cat /etc/rsnapshot/keys/rsnapshot_rsa.pub
        ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOqBjtdIK/ybEVTJopK4ZXmYo02ZJcyItXfAY
        [ .. OUTPUT COUPÉ ... ]
        client $ sudo vim ~root/.ssh/authorized_keys
        [ COPIEZ le contenu ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOqBjtdIK/ybE .... ]
        client $ sudo cat ~root/.ssh/authorized_keys
        ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOqBjtdIK/ybEVTJopK4ZXmYo02ZJcyItXfAY6h0d3/SlrTS7xzBcJArgNq48DCKXnug5MQazJBgqFI6kLFT9Eox1Tbp74laCyGQgpQtl7Ehl6nG0iIpd9QdjwR5j3vFmj9gzTOumg5bp07/JSZ/AIvCpojSio/1R1ftEDJMYG01shhYZhBn2RKrWqoQxTjMiUYfTwxw+ZmDapVC+PtoDWk014iTEg0p+c67PxduMrVnBxJvo7bQI3bBt/KTtZnA9BPoVIBZnkn4v0zGaJMXG9NFiSg2O+hK3oxBAseaGO46/Y0seeGVYzfG5jgzwZjgQVSuVJ01XjZbk9oFkdb36L root@xerus.example.com
        client $ sudo chmod u=rw,g=,o= ~root/.ssh/authorized_keys


Maintenant nous pouvons réaliser une validation, nous utiliserons la commande __ssh__ "normalement" en passant l'argument **-i** afin d'indiquer quelle clé utiliser :

        server $ sudo ssh -i /etc/rsnapshot/keys/rsnapshot_rsa root@client

Nous sommes obligé d'utiliser la commande __sudo__ car le fichier **/etc/rsnapshot/keys/rsnapshot_rsa** n'est lisible QUE par l'utilisateur __root__. Si vous n'avez pas mis l'instruction __sudo__ le système vous demandera un mot de passe. Normalement vous êtes maintenant sur le client avec un __shell__. Vous pouvez faire __logout__. 

À ce stade tous va fonctionné, mais nous allons mettre un peu plus de sécurité sur l'utilisation de cette clé car comme l'ensemble de la sécurité est basé sur un seul fichier **/etc/rsnapshot/keys/rsnapshot_rsa** . Nous allons mettre des mesures de contrôle en plus.

#### <a name="limitation_ssh_key_rsnapsho" /> limitation de l'utilisation de la clé

Premièrement nous allons limité d'où les connexions peuvent venir, avec l'instruction **from=** sur le client. Ceci nous permet de définir des adresses __IP__ ou des segments réseaux. Voici le résultat :

         client $  sudo cat ~root/.ssh/authorized_keys
         from="192.168.30.30" ssh-rsa AAAAB3NzaC1yc2EAAAADAQAB
         [ .. OUTPUT COUPÉ ... ]

À ce stade l'authentification par clé devrait très bien fonctionné depuis la machine __192.168.30.30__ mais d'une autre machine sur le réseau le système va demander le mot de passe .

Cool !! Mais  en fait nous on veut juste permettre l'utilisation de **rsync** est-ce vraiment pertinent de permettre un __shell__ comme __root__  ?!?! (la réponse c'est non :P, pourquoi ? Parce qu'on peut le faire :D.)

Nous allons limité l'utilisation de commandes qui peuvent être réalisé avec cette clé __ssh__ , nous n'allons permettre QUE l'utilisation de la commande __rsync__ car nous n'avons pas besoin de plus. Pour ce faire nous allons rajouter l'instruction **command=** à la définition de la clé sur le client 

        client $ sudo cat ~root/.ssh/authorized_keys
        from="192.168.30.30",command="/root/backup/validate-rsync" ssh-rsa AAAAB3NzaC1yc2EAAAADA
         [ .. OUTPUT COUPÉ ... ]

Lors de la connexion __ssh__ le système va appeler le script __/root/backup/validate-rsync__ afin de voir si c'est OK ou NON.

HEU mais il sort d'où ce fichier **/root/backup/validate-rsync**  ? Nous ne l'avons pas encore créé :P... Voici le contenu :

        client $ cat client-site/validate-rsync
        #!/bin/sh
        #
        # Command original from web site : http://troy.jdmz.net/rsync/#validate-rsync
        #


        case "$SSH_ORIGINAL_COMMAND" in
        *\&*)
        echo "Rejected"
        ;;
        *\(*)
        echo "Rejected"
        ;;
        *\{*)
        echo "Rejected"
        ;;
        *\;*)
        echo "Rejected"
        ;;
        *\<*)
        echo "Rejected"
        ;;
        *\`*)
        echo "Rejected"
        ;;
        *\|*)
        echo "Rejected"
        ;;
        rsync\ --server*)
        $SSH_ORIGINAL_COMMAND
        ;;
        *)
        echo "Rejected"
        ;;
        esac

En gros  le script prend la variable **$SSH_ORIGINAL_COMMAND** qui est transmis par __ssh__ au script et réalise la validation pour __rsync__. Bien entendu pour que ceci fonctionne le script doit être exécutable par l'utilisateur .

        client $ sudo chmod u=rx  /root/backup/validate-rsync

Si maintenant nous réalisons un test pour établir une connexion au système avec un __shell__ voici le résultat 

        server $ sudo ssh -i /etc/rsnapshot/keys/rsnapshot_rsa root@192.168.30.100
        Rejected
        Connection to 127.0.0.1 closed.

C'est  magnifique :D, mais ça marche vraiment avec __rsync__ :P, validons ...

        server $ sudo rsync -av -e "ssh -i /etc/rsnapshot/keys/rsnapshot_rsa" root@192.168.30.100:/etc /tmp/toto/
        receiving incremental file list
        etc/
        etc/.pwd.lock
        etc/adduser.conf
        etc/anacrontab
        [ ... OUTPUT COUPÉ ... ]
        etc/xml/xml-core.xml
        etc/xml/xml-core.xml.old

        sent 11,453 bytes  received 1,228,991 bytes  826,962.67 bytes/sec
        total size is 1,173,430  speedup is 0.95

### <a name="setup_x3_rsnapshot_test" /> Ma configuration validation

Nous sommes donc à l'étape de faire un teste passant de la configuration et bien entendu faire les petits correctif qui vont s'imposer , malheureusement ça marche rarement complètement du premier coup .

Donc si je prend ce fichier de configuration

        $ cat /etc/rsnapshot/hosts/client_domain_com.conf 
        config_version                  1.2
        snapshot_root                   /mnt/hd_backup/zato
        no_create_root                  0
        cmd_cp                          /bin/cp
        cmd_rm                          /bin/rm
        cmd_rsync                       /usr/bin/rsync
        cmd_ssh                         /usr/bin/ssh
        cmd_logger                      /usr/bin/logger
        cmd_du                          /usr/bin/du
        cmd_rsnapshot_diff              /usr/bin/rsnapshot-diff
        interval                        daily           7
        interval                        weekly          6
        interval                        monthly         6
        verbose                         2
        loglevel                        3
        logfile                         /var/log/rsnapshot/zato.log
        lockfile                        /var/run/rsnapshot-zato.pid
        #ssh_args                       -i /etc/rsnapshot/keys/rsnapshot_rsa
        rsync_long_args                 -z --delete --relative --numeric-ids --delete-excluded --stats

        #       List    directory
        backup                          root@192.168.30.100:/etc 

Je vais faire un teste passant : 

        $ sudo /usr/local/sysadmin/backup-scripts/rsnapshot/backup_runner.sh /etc/rsnapshot/hosts/client_domain_com.conf  daily
        echo 836 > /var/run/rsnapshot-zato.pid
        mv /mnt/hd_backup/zato/daily.1/ /mnt/hd_backup/zato/daily.2/
        /bin/cp -al /mnt/hd_backup/zato/daily.0 /mnt/hd_backup/zato/daily.1
        /usr/bin/rsync -av -z --delete --relative --numeric-ids --delete-excluded \
            --stats --rsh=/usr/bin/ssh root@127.0.0.1:/etc \
            /mnt/hd_backup/zato/daily.0/.
        receiving incremental file list
        etc/
        etc/.pwd.lock
        etc/adduser.conf
       [ ... OUTPUT COUPÉ ... ] 
       touch /mnt/hd_backup/zato/daily.0/
       rm -f /var/run/rsnapshot-zato.pid
       /usr/bin/logger -i -p user.info -t rsnapshot /usr/bin/rsnapshot -c \
           /etc/rsnapshot/hosts/client_domain_com.conf -V daily: completed \
           successfully

Nous pouvons maintenant utilise le script qui englobe  tous ça :D.

        $ sudo /usr/local/sysadmin/backup-scripts/rsnapshot/FullBackup.sh daily

Si vous n'avez pas de message d'erreur ça veut dire que tout vas bien vous pouvez regarder vos courriel , vous devriez avoir l'état de la sauvegarde.


## <a name="backupPC" /> BackupPC


**BackupPC** est un logiciel libre de sauvegarde de système de fichier publié sous licence **GPL**.

Il est utilisé pour sauvegarder sur disque un ensemble de postes clients et de serveurs, sous Unix, Linux, Windows ou Mac OS X. Les protocoles utilisables pour les transferts sont : __SMB, tar over SSH/rsh/nfs, et rsync__. Il ne nécessite l'installation d'aucun logiciel client sur les machines à sauvegarder. Il possède une interface web pour lancer des sauvegardes ou restaurer des fichiers. Il est également possible de sauvegarder des bases de données via un script __shell__ lancé avant la sauvegarde.

Originalement je n'avais pas prévu en faire la démonstration, cependant afin d'offrir plus de choix au personne j'ai changé d'avis , je tiens à préciser que je n'ai que très peu d'expérience avec l'outil. Je vous invite à communiquer tous erreur que vous trouvez , en fait ceci s'applique sur l'ensemble des sections :P.

Site web officiel : [http://backuppc.sourceforge.net/](http://backuppc.sourceforge.net/)

### <a name="installation_backuppc" /> Installation


* Réalisation de l'installation avec le système de pacquage :

        $ sudo apt-get install apache2-utils  backuppc

Je ne prendrais pas beaucoup de temps pour la partie de la configuration de __backuppc__ dans le serveur web __apache__ , car nous verrons en détail le serveur web à la prochaine section.

* Activation de la configuration de __backuppc__ dans apache 

        $ sudo ln -s /etc/backuppc/apache.conf /etc/apache2/sites-enabled/backuppc.conf

* Initialisation du mot de passe pour l'accès à l'interface web, définir le mot de passe que vous désirez.

        $ sudo htpasswd /etc/backuppc/htpasswd backuppc

* Accès à l'interface web : http://le-nom-ou-ip-du-serveur/backuppc/

### <a name="config_backuppc" />Configuration 

L'ensemble de la configuration de __backupPc__ est disponible dans le répertoire __/etc/__ comme la majorité des applications installé par le système de pacquage. Nous y retrouvons :

* __apache.conf__ :  Fichier de configuration pour apache .
* __config.pl__ : Fichier de configuration général du système.
* __hosts__ : Fichier réalisant l'association des nom des machines et des utilisateurs responsable , ces derniers recevrons le courriel de l'état de la prise de sauvegarde. De plus il est indiqué si la machine récupère sont adresse __ip__ par __DHCP__.
* __htpasswd__ : Fichier contenant les nom d'utilisateurs et mot de passe des utilisateur du système.
* __localhost.pl__ : Fichier de configuration du client __localhost__, nous y reviendrons.


* Correction d'un problème d'installation sous Ubuntu conformément au [forum ubuntu](http://ubuntuforums.org/showthread.php?t=2237618) . Nous allons changer le paramètre __Ping6Path__ sinon nous aurons une erreur __impossible de réaliser un ping__.

        $ cat -n /etc/backuppc/config.pl  | egrep 'PingPath|Ping6Pa'
          1643  #     $Conf{PingPath} = '/bin/echo';
          1645  $Conf{PingPath} = '/bin/ping';
          1646  $Conf{Ping6Path} = '/bin/ping6';
          1651  #   $pingPath      path to ping ($Conf{PingPath})
J'ai ajuster la ligne 1646 , afin de fournir le chemin au binaire


* Correction pour l'erreur 512 de __tar__ lors de l'utilisation local pour __localhost__ , comme les fichiers contenu dans __/etc__ par exemple ne sont pas tous accessible à l'utilisateur __backup__ il devra pouvoir utiliser la commande **sudo** por obtenir les privilèges requis.

        $ sudo visudo 
        backuppc ALL=NOPASSWD: /bin/tar

        $ sudo cat -n /etc/backuppc/localhost.pl | grep sudo
           10  $Conf{TarClientCmd} = '/usr/bin/env LC_ALL=C sudo $tarPath -c -v -f - -C $shareName --totals';
Ajout à la ligne 10 de la commande **sudo** entre la définition du langage et la variable **$tarPath**.

Démarrage des services, nous avons 2 services requis **backuppc** et **apache** pour l'interface web.

        $ sudo /etc/init.d/backuppc start
        $ sudo /etc/init.d/apache2 start


###  <a name="backupmanuel_backuppc" /> Réalisation d'une sauvegarde manuel du serveur backupPC

Nous avons fait mentions que le système __backupc__ supporte plusieurs mode de communication, il supporte aussi **tar**, simple mais efficace pour un petit nombre de fichier. Sous Ubuntu le système prés configuration le serveur __localhost__ avec ce mode . Nous allons donc prendre quelques minutes pour voir la configuration avant de réaliser la configuration d'un client avec __rsync__. L'avantage de __tar__ est la simplicité :D.

Commençons donc par réaliser une sauvegarde complète du serveur.

1. Cliquez en haut à gauche sur "__select a host__"
2. Sélectionnez la machine.

![01-select-hosts.png](./imgs/01-select-hosts.png)

Vous avez maintenant 2 bouton  :

* __Start Full Backup__ : Pour démarrer une sauvegarde complète 
* __Stop/Dequeue Backup__ : Permet de planifier une sauvegarde dans le temps.

![02-show-localhost-hosts.png](./imgs/02-show-localhost-hosts.png)

Nous allons réaliser un backup complète , donc cliquez sur **Start  Full Backup**, après avoir confirmer , vous revenez à la page et vous devriez avoir le backup complète disponible .

![03-resultat-full-backup.png](./imgs/03-resultat-full-backup.png)

Si vous cliquez sur le numéro de la sauvegarde vous verrez le contenu de la sauvegarde .

![04-list-le-contenu-du-backup.png](./imgs/04-list-le-contenu-du-backup.png)

Nous reviendrons pour la restauration :D.

###  <a name="planif_backuppc" /> Planification des sauvegardes

J'espère réussir à bien exprimer la configuration en place par défaut de __backupPc__ et a représenter de manière adéquate les possibilité de la modifier. Commençons par consulter la configuration disponible, j'aimerai préciser que la modification de la configuration peut être aussi réalisé avec votre éditeur préféré vous n'êtes pas obligé d'utiliser l'interface web pour cette exercice. La fichier **/etc/backuppc/config.pl** est éditable .

Pour visualiser nous :

1. Cliquez dans le menu de gauche sur __Edit config__
2. Puis sur la page sur l'onglet __Schedule__
3. Voici le résultat

![05-planification-des-sauvegardes.png](./imgs/05-planification-des-sauvegardes.png)


Par défaut le système est configuré comme suit :

* Réalisation d'une sauvegarde complet 
    * tous les 7 jours 
    * conservation uniquement du dernier
* Réalisation d'une sauvegarde incrémentale
    * tous les jours
    * conservation des 6 plus récent

Bon maintenant c'est écrit où ça dans la page ?!?! Personnellement, je ne l'ai pas visualisé du premier coup !
Voici la même lecture avec les variables, si vous désirez réaliser des modifications .

La réalisation de la sauvegarde complète au 7 jour est définie par la variable :

* __FullBackup__ : 6.97 , La raison pourquoi ce n'est pas écrit 7 est décrite sur [la page de configuration](http://backuppc.sourceforge.net/faq/BackupPC.html#_conf_fullperiod_). __Typically this is set slightly less than an integer number of days. The time taken for the backup, plus the granularity of $Conf{WakeupSchedule} will make the actual backup interval a bit longer.__

La conservation des sauvegardes complète est définie par les deux variables **FullKeepCnt** et **FullKeepCntMin** , actuellement à 1 . 

L'idée est identique pour les sauvegardes incrémentales. Nous avons la variable :

* __IncrPeriod__ : 0.97, qui définie la fréquence de l'exécution des sauvegardes de ce type , nous avons la même explication du chiffre que pour les sauvegardes complètes.

La définition de la conservation des sauvegardes donc définie par les variables :

* __IncrKeepCnt__ : 6 , définie le nombre maximum de sauvegarde incrémentale .
* __IncrKeepCntMin__ : 1 , définie le nombre minimum de sauvegarde.


Woot !!! Mais ça démarre quand ? Le système  ne définie pas d'heure d'exécution mais des heures pendant laquelle les backups ne doivent pas être exécuté. Ceci est définie la variable [blackoutperiods](http://backuppc.sourceforge.net/faq/BackupPC.html#_conf_blackoutperiods_), si nous reprenons la copie d'écran ceci donne :

* de 7:00 heure le matin à 19:50  le soir , du lundi au vendredi pas de sauvegarde sinon c'est disponible.

Point de référence : https://www.digitalocean.com/community/tutorials/how-to-use-backuppc-to-create-a-backup-server-on-an-ubuntu-12-04-vps

### <a name="setup_net_client_backuppc" />Configuration d'un client sur le réseau

La solution avec __tar__ est bien pratique pour le système hébergeant le serveur __backupPc__ cependant ceci ne permet pas de réaliser la sauvegarde d'un serveur distant. Nous allons donc voir comment mettre en place __backupPc__ pour utiliser la combinaisons __Rsnapshot__ + __ssh__ , comme nous avons déjà mis en place pour __rsnapshot__ . Ceci nous permettra aussi d'avoir un point de comparaison entre les 2 systèmes.

Dans la même idée que lors de la mise en place de la solution __rsnapshot__ nous allons créer une paire de clé __SSH__ qui seront utilisé pour établir la connexion par le protocole __ssh__. La clé sera disposé dans le répertoire de configuration de __backuppc /etc/backuppc/keys/backupps\_rsa__

        $ sudo mkdir /etc/backuppc/keys
        $ sudo chown backuppc:backuppc /etc/backuppc/keys
        $ $ sudo -u backuppc ssh-keygen -t rsa
        Generating public/private rsa key pair.
        Enter file in which to save the key (/var/lib/backuppc/.ssh/id_rsa): /etc/backuppc/keys/backupps_rsa
        Enter passphrase (empty for no passphrase): 
        [ ... OUTPUT COUPÉ ...]

Nous allons configurer pour que l'utilisateur __backuppc__ utilise maintenant cette clé pour l'ensemble de ses connexions __ssh__. Pour ce faire nous allons éditer le fichier __~backuppc/.ssh/config__

        $ sudo -u backuppc mkdir ~backuppc/.ssh
        $ sudo -u backuppc vim ~backuppc/.ssh/config
        $ sudo -u backuppc cat ~backuppc/.ssh/config
        Host *
                IdentityFile  /etc/backuppc/keys/backupps_rsa
                StrictHostKeyChecking no

J'installe la clé publique sur l'ensemble des clients sous l'utilisateur __root__ , voici le contenu du fichier __/root/.ssh/authorized\_keys__

        client $ sudo cat ~root/.ssh/authorized_keys
        ssh-rsa AAAAB3Nza
        [ ... OUTPUT COUPÉ ... ]

Vous pouvez valider la connexion :

        $ sudo su - backuppc
        $ bash
        $ ssh root@172.17.0.3
        Warning: Permanently added '172.17.0.3' (ECDSA) to the list of known hosts.
        root@172.17.0.3 $

Nous constatons que le système à bien ajouter la machine dans les listes des machines connu avec le message d'avertissement. Le système nous rejette sans nous demander le mot de passe , comme nous avons mis la limitation de l'accès __bash__ ceci semble bon !.


Dans le menu de gauche sélectionnez __Edit Hosts__

![06-ajout-machine.png](./imgs/06-ajout-machine.png)

Puis cliquez sur __add__ pour avoir une nouvelle ligne entrez le nom de la machine et l'utilisateur étant responsable , il est possible d'avoir d'autre utilisateur en mesure de voir le système en les ajoutant dans la section __moreUsers__. Ne pas oublié de faire __save__ :P.

![07-ajout-machine-step2.png](./imgs/07-ajout-machine-step2.png)

Sélectionnez la machine dans le menu à gauche ,  pour pouvoir éditer la configuration , vous pouvez cliquez par la suite la configuration en cliquant sur __Edit Config__

![08-select-new-system.png](./imgs/08-select-new-system.png)

Cliquez sur l'onglet **Xfer** afin de déterminé le mode de communication , changé la configuration par défaut du protocole **smb** pour **rsync**. Voici le résultat , j'ai laissé la majorité des configurations par défaut.

![09-setup-xfer-backup.png](./imgs/09-setup-xfer-backup.png)


Dans le menu de gauche cliquez sur le nom du client et cliquez sur **Start Full Backup**, une fois réalisé vous devriez être aussi en mesure de réaliser des sauvegardes incrémentiel. 
Pour les personnes comme moi qui n'ont pas un amour particulier pour les interfaces graphiques le résultat de l'ensemble de cette configuration est définie dans 2 fichiers :

* **/etc/backuppc/hosts** : Contenant la définition de la machine et des utilisateurs en charge 

        host        dhcp    user    moreUsers     # <--- do not edit this line
        #farside    0       craig   jill,jeff     # <--- example static IP host entry
        #larson     1       bill                  # <--- example DHCP host entry
        client_test     0       backuppc
        localhost       0       backuppc

* **/etc/backuppc/client_test.pl** : Contenant la configuration du protocole à utiliser pour la sauvegarde ainsi que l'ensemble des valeurs propre à cette machine 

        $ sudo cat client_test.pl
        $Conf{RsyncClientCmd} = '$sshPath -q -x -l root $host $rsyncPath $argList+';
        $Conf{RsyncShareName} = [
          '/etc'
          ];
          $Conf{XferMethod} = 'rsync';

Donc si nous reprenons la même opération pour ajouter une machine 

1. Édition du fichier **/etc/backuppc/hosts** 

        ma_super_machine 0      backuppc
2. Ajout du fichier **/etc/backuppc/ma\_super\_machine** :

        $Conf{RsyncClientCmd} = '$sshPath -q -x -l root $host $rsyncPath $argList+';
        $Conf{RsyncShareName} = [
          '/etc'
          ];
          $Conf{XferMethod} = 'rsync';

Pour executer manuellement la sauvegarde vous pouvez utilisé la commande suivante, cette dernière réalise une sauvegarde complète :

        $ sudo -u backuppc  /usr/share/backuppc/bin/BackupPC_serverMesg backup
        ma_super_machine backuppc 1

### <a name="restore_backuppc" /> Restauration d'un fichier

* Dans le menu de gauche cliquez sur le nom de la machine que vous désirez , et cliquez sur **browse backups**

![10-restauration-de-fichier.png](./imgs/10-restauration-de-fichier.png)

Cochez les fichiers désirés et à la fin complètement de la page vous avez le bouton __Restore selected files__.

Plusieurs option s'offre à vous le remettre sur un des serveurs distants , télécharger un __zip__ ou un __tar__

### <a name="conclusion_backuppc" /> Un petit mot sur Backup PC

Il est possible d'en faire bien plus avec le produit, l'objectif de ce chapitre été d'offrir une présentation des fonctionnalité de base. Je vous invite à consulter le site web du produit et voir l'ensemble des possibilités que ce dernier offre.

Voici l'adresse :  [backuppc.sourceforge.net/info.html](http://backuppc.sourceforge.net/info.html)

## <a name="clonezilla" /> CloneZilla

La solution de __rsnapshot__ ou __backuppc__ sont excellente pour la sauvegarde et la restauration de document cependant si vous perdez l'ensemble du système il vous faudra le réinstaller . Selon le système d'exploitation, ceci peut être très simple et même vu comme une opportunité ou comme un vraie calvaire surtout si vous avez des pilotes (drivers) problématique. 
Une solution s'offre à vous la réalisation d'une image du système, communément appeler __ghost__ , ceci fut très populaire par le logiciel privatif [Norton Ghost](http://en.wikipedia.org/wiki/Ghost_%28software%29).
Je vais donc vous présenter une solution **libre** du nom de [CloneZilla](http://clonezilla.org/).

La principe du clone ou __ghost__ d'un système est simple , indépendamment du système d'exploitation en place le logiciel lis les partitions disponible et génère un fichier avec l'intégralité de l'information. Il n'y a pas de logiciel à installé sur le système, car afin de contourner tous les problèmes de verrouillage de fichiers , pour réalisé le clone il faut démarrer le système __cloneZilla__ depuis une __clé USB__.

Le nombre de partition supporté par le logiciel est significatif :
* __ext2, ext3, ext4, reiserfs, reiser4, xfs, jfs, btrfs and f2fs of GNU/Linux, (2) FAT12, FAT16, FAT32, NTFS of MS Windows, (3) HFS+ of Mac OS, (4) UFS of FreeBSD, NetBSD, and OpenBSD, (5) minix of Minix, and (6) VMFS3 and VMFS5 of VMWare ESX. Therefore you can clone GNU/Linux, MS windows, Intel-based Mac OS, FreeBSD, NetBSD, OpenBSD, Minix, VMWare ESX and Chrome OS/Chromium OS, no matter it's 32-bit (x86) or 64-bit (x86-64) OS__

Pour l'ensemble des systèmes de fichier mentionné ci-dessus uniquement les bloques de données réellement utilisé sont sauvegardé, pour les systèmes de fichiers non supporter le logiciel utilise la méthode **dd** qui copie l'ensemble de bloques de donnée de la partition. Ceci est une solution de contournement car la conséquence est que si la partition fait 100 __Gig__ mais uniquement 30 __Gig__ est utilisé le résultat sera de 100.

* L'image résultant peut être chiffré avec [ecryptfs](http://ecryptfs.org/).
* L'image peut être sauvegarder sur le disque local , un serveur **ssh :D**, un partage samba, __NFS__ ou un serveur __WebDav__.

### <a name="install_clonezilla" /> Installation CloneZilla

Telle que mentionné précédemment il n'y a pas d'installation de logiciel a réaliser , il faut créer un CD/DVD ou une clé __USB__ pour démarrer le système. 

* Allez  sur la page de [Téléchargement de cloneZilla](http://clonezilla.org/downloads/download.php?branch=stable)

* Il y a deux type de fichier :
    * **ISO**  : Ceci vous permet de créer le CD/DVD .
    * **zip**  : Ceci comprend le contenu pour installé le fichier sur une clé __USB__

Si vous désirez créer une clé __USB__ je vous invite à consulter le site [http://tuxboot.org/about/](http://tuxboot.org/about/). Ceci est la solution la plus simple une fois __TuxBoot__ d'installer le démarrer et choisir la création de __CloneZilla__ depuis le menu, telle que décrit dans la copie d'écran ci-dessous :

![img-tuxboot-creation-clonezilla](http://tuxboot.org/images/Tuxboot-sel-dist.png)


### <a name="use_clonezilla" /> Utilisation de CloneZilla

Configurer le système afin qu'il essaye de démarrer sur le __cd-rom__ ou sur la clé __USB__ avant le disque dur local.

Voici le résultat lorsque le système démarrera avec __cloneZilla__

![01-boot-clonezilla.png](./imgs/01-boot-clonezilla.png)


* Vous devrez choisir la langue et le type de clavier que vous désirez utiliser.
* Deux mode s'offre à vous par la suite démarrer __CloneZilla__ ou avoir uniquement un terminal .

Si nous sélectionnons d'utiliser __CloneZilla__ nous avons encore 2 choix :

* Réaliser un clone / image d'une partition vers un fichier de type image
* Réaliser un clone / image d'une partition vers une autre partition

![02-choice-source-clonezilla.png](./imgs/02-choice-source-clonezilla.png)

Dans la démonstration , j'ai sélectionné __device-image__. Je dois à présent choisir la source ou la destination ou sera l'image . Comme vous pouvez le constater j'ai plusieurs choix 

* **local_dev** : utilisation d'un équipement local telle qu'un disque externe ou un clé __USB__
* **ssh_server** : Utilisation d'un serveur __ssh__ sur le réseau
* **samba_server** : Utilisation d'un serveur de partage utilisant le protocole Windows.
* **nfs_server** : Utilisation d'un serveur __nfs__ sur le réseau, protocole de partage de fichier __Unix__
* **webdav_server** : Utilisation d'un serveur utilisant le protocole __webdav__, ceci est nouveau :D

Personnellement j'ai choisi pour la démonstration un équipement local , donc l'utilisation d'une clé __USB__.

![03-save-image-local-drive-clonezilla.png](./imgs/03-save-image-local-drive-clonezilla.png)

Nous allons maintenant indiquer à __CloneZilla__ quelle partition __mounté__ et quelle répertoire. **ATTENTION** ici nous définissons la destination , où l'image sera sauvegardé ! 

Nous avons 2 disques de présent dans la démonstration , __sda__ le premier disque dur avec 2 partition (__sda1__, __sda2__) et nous avons le deuxième disque dur __sdb__ qui n'a qu'une partition (__sdb1__). Nous utiliserons ce deuxième disque pour sauvegarder l'image.

![04-select-device-destination-colonzille.png](./imgs/04-select-device-destination-colonzille.png)

Dans un second temps le système vous demandera d'entrer le répertoire présent sur la partition où sauvegarder l'image.

Vous aurez le choix entre 2 modes :

* **beginner** : Avec l'ensemble des options par défaut
* **expert** : Comme le mode __beginner__fonctionne très bien je n'ai pas d'expérience avec le mode expert.

Vous avez 2 possibilité de sauvegarde :

* **savedisk** : Réalisation de la sauvegarde de l'ensemble du disque dur dans le fichier image
* **saveparts** : Réalisation de la sauvegarde de(s) partition(s)

Pour la démonstration je vais sélectionner **savedisk**

![05-select-save-mode-clonezilla.png](./imgs/05-select-save-mode-clonezilla.png)

Le système demandera le nom de l'image qui devra être utilisé lors de la sauvegarde.
Une fois le nom définie le système demande / valide le disque dur qui doit être pris en sauvegarde .

![06-select-disque-to-save-clonezilla.png](./imgs/06-select-disque-to-save-clonezilla.png)

Selon le système de fichier que vous utilisez, il est possible que __CloneZilla__ vous demande s'il fait une validation du système de fichier avant de réalisé l'image. Ceci à l'avantage de corrigé des problèmes avant la restauration future. 

__CloneZilla__ vous demandera aussi si une fois l'image réalisé s'il faut effectuer une validation de cette dernière , bien entendu ceci augmente le temps de prise de sauvegarde. 

Optionnellement vous pouvez chiffrer l'image avec un mot de passe .

Avant de procéder vous aurez une dernière validation :

![07-confirmation-clonezilla.png](./imgs/07-confirmation-clonezilla.png)

Et voilà c'est partie pour la sauvegarde de chaque partition qui compose le disque !

![08-realisation-de-la-sauvegarde-clonezilla.png](./imgs/08-realisation-de-la-sauvegarde-clonezilla.png)

Une fois terminé vous aurez le menu vous offrant de réaliser un redémarrage du système , éteindre le système ou refaire le processus ...

L'ensemble des instructions provient du site de __CloneZilla__:

* Référence : [clonezilla  - fine-print-live](http://clonezilla.org/fine-print-live-doc.php)

# <a name="la_glue_autour" />Quelques points pour peaufiner la solution

Nous avons donc à présent 2 solutions de sauvegarde de fichier ainsi qu'une solution d'image (__ghost__) total du système. Nous allons mettre en place quelques mécanisme afin de nous assurer que les sauvegardes sont bonne, nous avons confiance au système de sauvegarde ... Mais nous parlons de sauvegarde de NOS données , ceci est "critique" !

## <a name="Sauvegarde_des_mobiles" />Réalisation de la sauvegarde des équipements mobile

Nous avons couvert la réalisation de sauvegarde pour des machines "fixe" disponible sur le réseau, mais lors de la définition de la liste des équipements à supporter nous avions 3 téléphones et 1 tablette. Telle que mentionné au début la stratégie adopté fut la synchronisation des données sur le serveur de fichiers interne qui lui est pris en sauvegarde.


### Android

Voici comment le mettre en place, ce fut testé sur __android__, mais le concept s'applique peut importe l'__OS__.

1. Sur chaque équipement installé un logiciel de synchronisation , dans mon cas j'utilise [FileSync](https://play.google.com/store/apps/details?id=dk.tacit.android.foldersync.full) il est aussi possible d'utiliser la version gratuite [FilSync Lite](https://play.google.com/store/apps/details?id=dk.tacit.android.foldersync.lite) 
Le logiciel support plusieurs protocoles utilisable :

    * FTP
    * FTPS (SSL/TLS implicit)
    * FTPES (SSL/TLS explicit)
    * SFTP (SSH File Transfer)
    * Samba/CIFS/Windows Share
    * WebDAV (HTTP/HTTPS)

2. Configurer sur votre serveur de fichiers l'un des protocoles listé ci-dessus afin de permettre au téléphone de réaliser le transfert

3. Configurer __FileSync__ pour que le transfert ce réalise , quand le __wifi__ est disponible à l'heure de votre convenance :D

### Portable GNU/Linux

Le concept est le même pour un ordinateur portable, la différence est la logiciel , voici donc les instructions pour GNU/Linux . Voici donc les instructions comment démarrer un script lors de l'établissement de connexion du __Wifi__ ou de l'interface filaire. L'exemple ci-dessous n'est pas parfait car vous ne voulez peut-être pas que la synchronisation débute tous de suite lors de l'établissement de connexion cependant ceci est un point de départ.

Dans mon cas j'utilise le système **NetworkManager** pour faire la gestion de mes connexions réseaux, c'est le système par défaut sous __Ubuntu__ . Pour les autres système, je ne pourrais pas me prononcer , sous __Arch Linux__ vous devez le configurer manuellement.

Nous allons mettre un script dans le répertoire **/etc/NetworkManager/dispatcher.d/** nous le nommerons **99sync_files.sh**, bien que je n'ai qu'un script en place j'utilise le chiffre 99 afin qu'il soit exécuté en dernier . 
Le système de **NetworkManager** va appeler ce script avec 2 arguments :

* l'interface , le premier argument
* l'état de la connexion : deuxième argument

Voici un exemple du script :

        #!/bin/sh
        ESSID="MAISON"
        DATE=$(date)
        LOG_FILE="/var/log/sync_files_backup.log"

        interface=$1 status=$2

        echo "LOG $interface $status at $DATE" >> $LOG_FILE

        case $status in
            up)
                if iwgetid | grep -qs ":\"$ESSID\""; then
                    rsync -az -e ' ssh -i /etc/ssh/keys/bck_keys.id' /etc root@backup_server:/data/backup/$HOSTNAME/ & >> $LOG_FILE
                fi
            ;;
            down)
                if iwgetid | grep -qs ":\"$ESSID\""; then
                    echo "Quit Wireless connexion" >> $LOG_FILE
                fi
            ;;
        esac


Petite explication du script lors de l'établissement de connexion au __wifi__ avec le __SSID__ maison le système va réaliser un rsync du répertoire __/etc__ vers le serveur __backup\_server__ par __ssh__ avec l'utilisateur __root__.

Une fois le script créé, il est important que les permissions soit convenable , vous pouvez exécuter les commandes suivante :

        $ sudo chown root:root /etc/NetworkManager/dispatcher.d/99sync_files 
        $ sudo chmod 755 /etc/NetworkManager/dispatcher.d/99sync_files 

Et voilà  aussi simple que ça :D.

* Référence
    * https://wiki.archlinux.org/index.php/NetworkManager#Use_dispatcher_to_connect_to_a_VPN_after_a_network_connection_is_established


## <a name="Validation" />Mise en place d'une stratégie de la validation de sauvegarde automatique.

Chaque logiciel offre des validations de sauvegarde, nous pouvons faire confiance au système , mais ne serions nous pas plus confortable d'avoir une validation externe certifiant les fichiers. Je propose en plus de réalise une validation de fichiers de manière aléatoire, ceci permettra de confirmer que tous est sous contrôle.

J'ai réalisé un script qui réalise l'opération, prenant la configuration de __rsnapshot__ et valide le fichier sur le disque dur de sauvegarde et sur le serveur distant. 

Le script est disponible ici : [validation_rsnapshot_bk.py](./tools/validation_rsnapshot_bk.py)

## <a name="bk_ps4" /> Sauvegarde de la PS4

Pour les personnes qui espérait lire une méthode de sauvegarde à distance ici, j'ai le regret de vous dire que __Sony__ ne le veut pas :P. Donc la sauvegarde sera réalisé sur le même principe que les sauvegardes de téléphone mobile, cependant ce sera pire, car vous devrez réaliser la sauvegarde avec une clé __USB__ et copier les fichiers sur votre machine GNU/Linux . 

Alors pourquoi ce paragraphe, car comme nous avons une opération manuelle nous allons l'oublier , nous allons donc voir comment mettre en place un système de validation de sauvegarde de fichier. 

Nous allons mettre un script dans la tâche planifier afin de valider la date des fichiers de sauvegarde de la __PS4__ si les fichiers sont trop vieux un courriel vous sera transmis. Ce n'est certainement pas l'idéal ,mais c'est mieux que rien.

# <a name="other_technique" />Autre Méthode pour des besoins precis.

## <a name="lvm_export" />lvm export

http://tldp.org/HOWTO/LVM-HOWTO/snapshots_backup.html

## <a name="backup_snapshot_vmware" />Backup de sanpshot de VM

Voici une application vous permettant de réaliser des sauvegardes de machine virtuelle pour les systèmes ESX. Ceci va réaliser un snapshot de la VM et récupérer le fichier complète du vmdk.

* [GhettoVCB application](https://github.com/lamw/ghettoVCB)
* [GhettoVCD Documentation](https://communities.vmware.com/docs/DOC-8760)

# <a name="ref" />Référence 

* https://openclassrooms.com/courses/la-sauvegarde-sous-gnu-linux
* https://debian-handbook.info/browse/fr-FR/stable/sect.backup.html
* https://www.freebsd.org/doc/fr_FR.ISO8859-1/books/handbook/backup-strategies.html
* https://fr.wikipedia.org/wiki/Sauvegarde\_%28informatique%29#Finalit.C3.A9
* https://en.wikipedia.org/wiki/Backup
