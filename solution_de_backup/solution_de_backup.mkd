<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>

# Index  
* [Introduction ](#intro) 
* [Stratégie de sauvegarde ](#strategie) 
       * [Formulaire par client](#form_client) 
       * [Planification du chef d'orchestre (serveur / logiciel)](#chef_orchestre) 
           * [Formulaire pour le chef d'orchestre](#form_chef_orchestre) 
           * [Type de sauvegarde ](#type_sauvegarde) 
           * [Support de sauvegarde](#lst_support) 
           * [ Manipulation des données](#manip_data) 
           * [Méthode de prise de sauvegarde](#methode_sauv) 
           * [ Défis des équipements mobile](#defi_mobile) 
           * [Sortir les sauvegardes du lieu ](#sortir_bk) 
* [Résultat pour l'écosystème de démonstration](#resultat_eco) 
       * [Stratégie pour le chef d'orchestre ](#strategie_chef_orches) 
* [Mise en place de logiciel](#mise_en_place) 
       * [Rsnapshot](#rsnapshot) 
       *<a name"backupPC" />BackupPC
       * [lvm export](#lvm_export) 
       * [ghost bare metal](#ghost_bare_metal) 
       * [Backup de sanpshot de VM](#backup_snapshot_vmware) 
       * [Mise en place d'une stratégie de la validation de sauvegarde automatique.](#Validation) 
       * [Indicateur de prise de backup pour PS4 ](#bk_ps4) 
       * [Indicateur d'absence de backup des Téléphone](#mobile_bk_check) 
* [Référence ](#ref) 

# <a name="intro" />Introduction 

La sauvegarde de donnée ou __backup__ en anglais est une chose très importante de nos jours. Combien de donnée avez vous sur votre machine qu'il ne faut surtout pas perdre ?! Que nous parlions des photos de famille, des rapports d'impôt, ... Tous est numérisés, il est important de ne pas perdre les fichiers.

Nous désirons nous protéger des problèmes suivant :

* Panne d'un disque dur 
* Suppression accidentel de fichiers
* Corruption de fichiers
* Destruction de la machine

Sans vouloir avoir l'air simpliste dans le propos, mais j'aimerai clarifier un point:

* **L'important ce n'est pas la prise de sauvegarde, mais la restauration des fichiers**

Nous allons voir comment définir une stratégie de sauvegarde ainsi que les outils disponible pour la mettre en place. Peu importe le logiciel que vous mettez en place , la stratégie que vous définirez , il sera important de tester régulièrement vos sauvegardes.

Afin de faciliter le dialogue voici un exemple d'environnement que nous désirions prendre en sauvegarde : [Infrastructure de démonstration](./infrastructure_demo.html). 

# <a name="strategie" />Stratégie de sauvegarde 

Comme pour tous il est important de prendre quelques minutes de recule et d'évaluer la stratégie de sauvegarde que l'on veut mettre en place , afin de répondre à nos besoins et contraintes (coût, temps , niveau technique , ...) . 

Voici quelques question que vous devriez vous posez :

* Quelle sont les systèmes qui doivent avoir un sauvegarde de sécurité ?
    * Les système d'exploitation
    * Leurs disponibilités  (portable , téléphone cellulaire , tablette )
    * Les logiciels à sauvegarder
* Qui sont vos utilisateurs, niveau de contientisation de l'importance des sauvegardes ? TODO : corriger
* La quantité de donnée 
* Classification de la sensibilité des données
* Le nombre de jours à conserver
* La fréquence de la sauvegarde
* Le support où écrire les données ( DVD , disque dur externe, clé __USB__, __cloud__ )
* Le lieu de stockage ( maison , bureau , coffre fort, __cloud__)
* Vitesse de restauration
* Granularité de la restauration 


## <a name="form_client" />Formulaire par client

Nous avons souvent le reflex de commencé par chercher le logiciel disponible avant dévaluer le plus important ce que l'on doit prendre en backup ! 
Je vais donc commencer par identifier ce que je dois sauvegarder, car comment ceci me permettra :

* d'identifier les protocole disponible pour communiquer avec le client.
* Définir la quantité total requise pour ma sauvegarde , et par conséquence choisir le support en prenant en considération le coût final.
* Grâce à la quantité de donnée je serai aussi en mesure dévaluer le temps de transfert si je préconise l'utilisation du réseau pour le transfert des données.
* Nous aurons une vision global des données ainsi que leurs sensibilité.

Voici un formulaire qui peut vous aider à structurer ces réflexions :

* Formulaire par système : TODO: faire le formulaire par système

Ceci est un __PDF__ éditable , pas de panique je n'ai pas planifier de faire 2 fois de l'entrée de donnée :P. Nous verrons par la suite comment __scripter__ l'extraction des données :D. Pour les personnes qui désirent savoir comment faire un __PDF__ avec des champs voici la documentation que j'ai suivie : [Création d'un PDF editable (EN)](https://www.maketecheasier.com/create-a-pdf-with-fillable-forms-in-libreoffice/)

À ce stade nous avons une bonne idée de l'ensemble des données et des acteurs qui participe au processus de sauvegarde. Il nous manque un point critique le chef d'orchestre, soit le serveur / logiciel qui orchestre le processus.

## <a name="chef_orchestre" />Planification du chef d'orchestre (serveur / logiciel)

### <a name="form_chef_orchestre" />Formulaire pour le chef d'orchestre

Avant de présenter des logiciels j'aimerais clarifier certain concept de sauvegarde afin de pouvoir remplir de manière approprié et surtout en tout connaissance le document. Tout comme pour la partie client j'ai réalisé un formulaire __PDF__ éditable pour entrer l'ensemble des informations.
Encore une fois l'ensemble de ces questions sont générique peut importe le choix du logiciel.

Voici le Formulaire et nous allons le remplir avec l'information présenté ci-dessous

* Formulaire pour le chef d'orchestre : TODO faire le formulaire

### <a name="type_sauvegarde" />Type de sauvegarde 

Voici plusieurs mode de sauvegarde , nous allons donc faire notre choix au mieux de notre désire nous verrons par la suite ce que le logiciels choisi nous permettra. En d'autre mots toutes ces méthodes ne sont pas offertes par les logiciels de sauvegarde, mais je préfère définir mes besoins et voir par la suite ce que les logiciels me permette. 

* **Sauvegarde complète** : tous les fichiers sont sauvegardés sans tenir compte d'une sauvegarde antérieure. 
    * __Pour__ : La restauration des fichiers est simple car la dernière sauvegarde toujours complète, si une planification n'a pas lieu la suivante sera complète
    * __Contre__ : L'espace disque requis est plus que significatif , le temps de prise de sauvegarde est long car tous est copié .

* **Sauvegarde différentielle** : on ne sauvegarde que ce qui a changé depuis la dernière sauvegarde complète. Ainsi, pour tout restaurer, il suffit de restaurer la sauvegarde complète puis la dernière différentielle. En d'autre mot si nous avons pris une sauvegarde complète le Dimanche, le Lundi la sauvegarde différentielle comprendra uniquement les changements de la journée. Le mardi la sauvegarde comprendra les changements de mardi ET lundi  ainsi de suite jusqu'à ce que l'on reprenne une sauvegarde complète.
    * __Pour__ : Ceci nous permet d'économiser le temps de la prise sauvegarde car uniquement les changements sont transféré, l'espace disque utilisé est aussi réduite. La restauration est simple la sauvegarde complète + le dernier différentielle.
    * __Contre__ : Il faut s'assurer que la prise de sauvegarde complète est bonne sinon l'ensemble du différentielle est invalide ou est équivalent à une sauvegarde complète , car la source de référence est null. Il faut planifié , une sauvegarde complète régulièrement sinon le différentielle peut devenir très gros. .

* **Sauvegarde incrémentale** : on ne sauvegarde que ce qui a changé depuis la dernière sauvegarde quelle qu'elle soit (complète, différentielle ou incrémentale). La plupart des logiciels dédiés à la sauvegarde gèrent les sauvegardes incrémentales. Ainsi, pour tout restaurer, il faut restaurer la dernière sauvegarde complète puis toutes les sauvegardes incrémentales effectuées depuis, et dans l'ordre. En d'autre mot si nous avons pris une sauvegarde complète le dimanche, le lundi la sauvegarde incrémentale comprendra uniquement les changements de lundi . Le mardi la sauvegarde comprendra uniquement les changements de mardi. 
    * __Pour__ : L'espace disque dur est encore plus réduire que lors du différentielle car il n'y a pas accumulation ou de journée, par le fait même le temps de sauvegarde est réduite.
    * __Contre__ : La restauration est plus compliqué, car il faut rejouer l'ensemble des sauvegardes pour restaurer (complet + n incrémentale) imaginé si l'ensemble de la sauvegarde n'est pas localement disponible... Chaque prise de sauvegarde est critique car il n'y a pas d'autre sauvegarde de prise avec ces données. 

* **Sauvegarde décrémentale** : on ne sauvegarde que ce qui a changé depuis la dernière sauvegarde mais à l'inverse de la sauvegarde incrémentale, c'est la sauvegarde la plus récente qui est complète, les plus anciennes sont des différences par rapport à la sauvegarde suivante. Pour tout restaurer il suffit d'utiliser la dernière sauvegarde, mais on conserve l'historique pour récupérer même longtemps après un fichier qui aurait été effacé par erreur. 
    * __Pour__ : Tous comme la sauvegarde incrémentale ceci permet de réduire significativement le transfert de donnée , ainsi que l'espace disque utilisé. Contrairement au système incrémentale la restauration est beaucoup plus simple.
    * __Contre__ : L'accès au fichier historique est moins évident car selon le système il peut être moins simple d'identifier le lieu de stockage. Chaque prise de sauvegarde est critique, car il est unique.

L'ensemble de ses solutions sont bonne , elles comportent des avantages est inconvénients telle que listé ci-dessus. C'est toujours un équilibre entre les avantages et inconvénient.

### <a name="lst_support" />Support de sauvegarde

Tous comme les types de sauvegarde, il existe plusieurs possibilités de support où écrire nos données , avantage inconvénient , c'est repartie 

* **Bande magnétique** : L'utilisation des bandes magnétiques est de plus en plus rare surtout pour les petites entreprises et les particuliers , le prix des systèmes de stockages externe ayant beaucoup baissé. Dans la situation ou vous auriez un grand volume de donnée , nous parlons de __Téra__ au moins par semaines voir par jours , les bandes magnétiques offre un ratio prix / quantité de stockage intéressant (il reste le coût de l'équipement). 
    * __Pour__ : Le ratio prix / quantité de stockage, la robustesse des cassettes très important lorsqu'elle sont stocké hors site; La cassette comprend très peu de pièce mobile ceci en fait une valeur sûr comparativement au disque dur si plusieurs année après nous désirons accédé au donnée , il n'est pas garantie que le disque dur soit coopératif. 
    * __Contre__ : Le coût du lecteur de bande est significatif; Les performances d'écriture ou lecture d'une bande magnétique sont bonne lorsqu'elles sont réalisé de manière séquentielle il est donc important d'offrir un bon débit lors de l'écriture au lecteur et de lire séquentiellement cette dernière.

* **Disque Dur Interne** : Solution la plus commode qui permet de réaliser une sauvegarde rapidement et facilement
    * __Pour__ : Simple à mettre en place et permet de stocker une bonne quantité de donnée à un coût raisonnable , l'accès au sauvegarde est simple et rapide
    * __Contre__ : Ne permet pas sortir les sauvegardes, donc si le site géographique où se trouve le système de sauvegarde est compromis l'ensemble des sauvegardes de sécurité sont perdu. 

* **Disque Dur Externe**: Deuxième solution simple à mettre en place, le matériel est facilement accessible. Il est possible de réutiliser le matériel pour le backup de manière temporaire ou permanent.
    * __Pour__ : Le coût d'achat n'est pas très élevé, la solution __scale__ relativement , si nous avons besoin de plus d'espace il est possible d'acheter un disque dur avec plus de capacité . Il est possible de déplacer le disque dur pour le mettre géographiquement dans un autre lie.
    * __Contre__ : Ce support ne permet pas un conservation pour plusieurs année du à la fragilité (est-ce que les SSD corrige ce problème ?!? ) , la rotation des disques est manuelle, comparativement au bande magnétique.

* **cle USB** : Pour de petite quantité de sauvegarde cette solution peut être idéal.
    * __Pour__ : Le coût n'est pas très grand pour des quantités entre 32 Gigs et 64 Gigs . Le transport est simple dû à la taille des clés. La résistance des __clés USB__ est très bonne en cas de chute ou autre. Comme il n'y a pas de pièces mobile, nous pouvons présumer que la conservation des données peut être conservé pour plusieurs année.
    * __Contre__ : L'avantage de la taille est aussi un problème car plus facile de les perdre. La taille est tout de même réduit si vous avez une grosse quantité de données.

* **DVD, blu-ray** : Autre possibilité l'utilisation de DVD , solution de moins en moins utilisé principalement à cause de la taille du stockage du support.
    * __Pour__ : Le support permet une conservation des données pour plusieurs années . Permet de disposer des copies à plusieurs endroit à moindre de coût, Le prix d'un DVD ou Blu-ray  est nettement moins élevé qu'un disque externe. Moins sensible à l'humidité que les disques durs
    * __Contre__ : La quantité de donnée disponible sur le support. Le temps d'écriture sur le support lors de la sauvegarde , l'obligation de réaliser une rotation manuel.

* **Service en ligne** : Cette solution prends de plus en plus d'ampleur avec le temps, les offres étant de moins en moins chère, la quantité de stockage offert est bonne (selon le prix) , les connexions internet ayant un débit plus important nous pouvons évaluer ces solutions. (information : je ne suis pas un partisan de cette solution , je ne suis donc pas impartial )
    * __Pour__ : La solution est extensible si vous avez besoin de plus d'espace généralement il est simple d'augmenter la taille offert. Vous n'avez pas à gérer l'infrastructure . La solution de backup est même parfois offert en prime :P. Comme le serveur est sur internet , la prise de sauvegarde peut être réalisé n'importe où.
    * __Contre__ : Vous n'êtes pas mettre de la solution , si le service s'arrête vous devez changer la solution dans un délais variable. Il faut faire attention où sont stocké vos données , pour avoir un prix intéressant il faut allé au États-Unis cependant les lois protégeant le données ne sont pas les mêmes. Si le logiciel de sauvegarde est fournit est-il libre ? Est-ce que le système utilise des protocoles ouvert ?. Si votre connexion internet est limité , il faut faire attention au coût du au transfert.


### <a name="manip_data" /> Manipulation des données

Nous voyons l'ensemble des fonctionnalités offert par les logiciels de sauvegarde nous analyserons par la suite les options disponibles pour nous.

* __Compression__ : Beaucoup de système de sauvegarde offre la possibilité de compresser les données lors du stockage , la solution peut être logiciel ou matériel . Le lecteur de bande magnétique offre généralement une compression matériel.
* __Chiffrement__: Nous parlions un peu plus tôt de sortir les sauvegardes du lieu géographique où ils sont pris, bien entendu il y a toujours un risque de perdre ou de vol de nos sauvegardes. Afin de ce prévenir contre cette situation il est possible de chiffrer les données. Nous avons deux possibilités de réaliser cette opération :
    * Chiffrement réalisé par le logiciel de sauvegarde
    * Chiffrement réalisé par le système de fichier , GNU/Linux permet de créer une partition chiffré
* __Déduplication__ : Le système de sauvegarde peut éviter de conserver plusieurs fois le même fichier en effet si nous avons plusieurs machines qui ont le même fichier zip qui est pris en sauvegarde certain logiciel de sauvegarde peut ne conserver qu'un fichier et réaliser un pointeur pour les autres. Ceci permet d'économiser l'espace disque dur de manière significatif s'il y a redondance de fichier.

### <a name="methode_sauv" />Méthode de prise de sauvegarde

Voici un liste de méthode de prise de sauvegarde, tous les systèmes de sauvegarde n'ont pas l'ensemble des fonctionnalités , il est possible que vous désiriez combiner une ou plusieurs méthodes dans votre environnement. Ceci n'est pas une liste exhaustive , cependant ce sont les méthodes les plus courantes. 

* __Copie de fichiers__ : Le méthode classique la copie de fichiers , nous prenons les fichiers sur un système et ces derniers sont copiés sur le [support](#lst_support) choisi. Cette méthode peut être combiné avec plusieurs [manipulation de donnée](#manip_data) et peut être sujet au différent [type de sauvegarde](#type_sauvegarde). L'important avec cette méthode de sauvegarde est de ne pas oublié de répertoires et de revisiter la liste périodiquement.

* __Snapshot OS ,prise d'image__ : La prise de __snapshot__ ou d'image d'un système , ceci va permettre de prendre l'ensemble du système et de l'exporter dans un fichier. Ce fichier contient généralement l'ensemble des fichiers , dans le cadre de __snapshot__ de machine virtuelle, il peut même contenir les informations sur le "matériel" virtuel qui fut utilisé. Dans le cadre d'une image d'une machines physique selon le logiciel il peut prendre une copie de la structure des tables de partition. Ceci à l'avantage de permettre la restauration **complète** du système dans un délai très court. L'inconvénient selon le système d'exploitation sauvegardé l'image ne peut pas être réutilisé selon le matériel. Autre point problématique la taille des sauvegardes qui sont souvent volumineuse pour des données non critiques ou requises, cependant vous êtes sûr de rien oublier.

* __Snapshot du système de fichier__ : Selon le système de fichier que vous utilisez il est parfois possible de réaliser des __snapshot__ temporaire ou permanent du système de fichier donc une partition. Ceci à l'avantage d'offrir la possibilité de valider une mise à jour par exemple et de réaliser un retour arrière en cas de problème ou de réaliser une image complète d'un système de fichier. Ceci permet d'avoir une alternative entre la prise d'image complète de l'ensemble du système incluant le système d'exploitation et uniquement le système de fichier contenant les données.


* __Base de donnée__ (chaud / froid) : Les systèmes de base de données sont particulier il est fortement déconseiller de prendre uniquement les fichiers de données si la base de données est en activité. L'ensemble de la littérature tant au niveau des logiciel de sauvegarde que des logiciels de base de donnée , la sauvegarde a de forte chance d'être invalide. Pour solutionner ce problème nous pouvons réaliser 2 type de sauvegarde :
    * __Chaud__ : nous utilisons un agent fournit par le logiciel de sauvegarde pour qu'il se connecte à la base de donnée pour réaliser une copie. L'autre option si votre logiciel de sauvegarde ne supporte pas d'agent ou que le prix est excessif , la réalisation d'un __dump__ local sur le serveur de base de donnée et le logiciel de sauvegarde récupère ce dernier.
    * __Froid__ : Nous arrêtons la base de donnée et nous prenons l'ensemble des fichiers binaire sous le répertoire du serveur.

### <a name="defi_mobile" /> Défis des équipements mobile

Bla bla bla bla , je présume que lister les possibilités des types, méthodes, et  support de sauvegarde   n'est pas forcément ce que vous désirez avoir. Nous allons aller dans le vif du sujet avec  des considérations de réalisation de sauvegarde.

L'ensemble de notre vie est de plus en plus connecter, si nous reprenons l'infrastructure d'exemple sur laquelle nous allons bâtir nos solutions, vous constaterez que sur 11 équipements nous avons 5 qui sont des équipements mobile. Comment allons traiter ses équipements qui ne sont pas toujours disponible ? Nous ne pouvons simplement pas les ignorer, l'importance que prend le téléphone cellulaire et la quantité de données qu'il contient ne peut pas être mis de côté.

Je vais vous présenter ici la solution que j'ai mis en place pour répondre à ce besoin, comme toujours si vous avez des suggestions pour d'autre méthode je suis à l'écoute :P.

Voici l'état de la situation :

* L'équipement n'est pas toujours disponible où le logiciel de sauvegarde est en fonction
* La présence peut varier être présent quelques heures et repartir cependant nous ne savons pas l'heure exacte de ça présence.
* Demander à l'utilisateur de réaliser la copie de ses fichiers comporte un risque important d'oublis et surtout ceci est très ennuyeux.

Afin de répondre à ses problèmes voici la solution que j'ai mis en place, j'ai suivie ces principes :

1. Réaliser la copie des données quand l'équipement est sur un réseau __WIFI__, afin de ne peut utiliser de bande passante payante.
2. Permettre le transfert via le réseaux mobile (LTE,4G,...) sur demande.
3. Réaliser la copie des fichiers vers un serveur distant.
 
Une des solutions la plus "simple" et la plus répandu est l'utilisation d'un service en ligne, ceci à l'avantage de permettre le transfert des fichiers peut importe où l'équipement mobile se trouve. Le seule critère important est la présence d'un point d'accès __WIFI__.
N'étant pas un adepte des solutions de service en ligne en (TODO )impartition, nous allons suivre ce principe mais en utilisant nos serveurs. Si nous reprenons  [l'infrastructure de démonstration](./infrastructure_demo.html), deux systèmes pourrons faire le travaille de passerelle soit le serveur dans le centre de donnée ou la station de travaille avec 1.5 Téra disponible.

Pour le moment nous ne sommes que dans l'étape de planification pour la réalisation proprement dite, voici la section pour les TROP pressés. (TODO  : ajouter lien vers section mobile)

### <a name="sortir_bk" />Sortir les sauvegardes du lieu 

**IMPORTANT** 

La majorité des entreprises sortent les sauvegardes des bureaux pour les entreposer dans les lieux sécuritaire :

* Fournisseur de service de voûte telle que : __Iron Montaine__
* Coffre fort dans une institution bancaire 

Ceci à l'avantage d'offrir une sécurité physique des sauvegardes dans un environnement approprié humidité, température, café des collègues :P, verre de lait des enfants :P ...

Cette pratique est malheureusement moins fréquente lors que l'on parle de sauvegarde des données des particuliers , bien souvent nous réalisons des sauvegardons que nous conservons sur le bureau à coté de la machine d'origine. Ceci nous protège très bien des risques :

* Problème matériel (disque dur , ...)
* Erreur de manipulation ( suppression de données)
* Corruption des données 

Malheureusement en cas de sinistre, notre sauvegarde risque d'être endommagé en même temps que la machine d'origine, que nous parlons de dégât d'eau et de feu. C'est pourquoi il est primordial de sortir les sauvegardes, car vous avez des données précieuse , que l'on parle de photos de famille ou de document de travail une fois perdu c'est fini !

Lorsque nous avons listé les supports disponible j'ai fait mention de lors qu'il est  possible d'utiliser le média pour sortir les données revoici la liste des supports :

* __DVD, blu-ray__
* __Disque Externe__
* __Bande Magnétique__
* __Clé USB__
* __Service en ligne__ de par la nature du support :D

# <a name="resultat_eco"/>Résultat pour l'écosystème de démonstration

Courage, la théorie achève sous peu, nous allons maintenant procéder avec la compilation de l'ensemble de cette théorie et voir comment j'ai mis en place les différents critères pour définir ma stratégie de sauvegarde. Ceci est un point de départ afin d'avoir un dialogue sur du concret, cependant tous comme les recettes de cuisine je vous invite à y faire des modifications afin de répondre à VOS besoin.

Voici un résumé de l'ensemble des répertoires et données a prendre en sauvegarde .
TODO: ajouter l'info

## <a name="strategie_chef_orches"/>Stratégie pour le chef d'orchestre 

* **Type de sauvegarde** :
    Mon critère primaire est de pouvoir réalisé une restauration RAPIDE de mes fichiers en cas de problème, je n'ai pas envie de courir après les supports pour réaliser une restauration ! Mon choix se penche donc sur 2 options , je donne 2 options car selon le logiciel de sauvegarde il est possible qu'un de mes choix ne soit pas disponible. Bien entendu l'idée de prendre uniquement des sauvegardes complète est aussi valide cependant l'espace disque requis serait trop volumineux.
    1. __Sauvegarde décrémentale__ : Ceci me permettra d'avoir le dernier backup complet et de recherché les fichiers plus vieux au besoin. De plus l'utilisation de cette solution me permettra de réduire la quantité des sauvegardes.
    2. __Sauvegarde différentielle__ : Cette solution rejoint l'idée d'avoir peut d'étape pour réaliser la restauration , soit restauration de la sauvegarde complète + le dernier différenciel. De plus tous comme la solution décrémentale ceci réduit le temps de prise de sauvegarde. 


* **Type de support** :
    Mon critère ici est le rapport taille / prix, bien que pour cette aspect les bandes magnétique serait une bonne idée le coût de l'achat du lecteur me décourage. De plus en cas de bris du lecteur je ne pourrais plus utiliser mes bandes à moins de réinvestir. Autre critère pouvoir sortir mes sauvegardes
    1. __Disque dur Externe__: La meilleur option reste les disques dur externe qui aujourd'hui offre un coût très intéressant , de toutes taille physique et espace de donnée.
    2. __DVD , blu-ray__ : j'analyse l'option de stocké des données sur disque optique telle que les photos de famille afin d'avoir une conservation à plus long terme dans un coffre. Je ne suis pas prêt a déployer cette solution donc pour le moment je dupliquerai de manière perpétuel mes données sur les disques Externe.

* **Manipulation des données** :
    Je vais chercher a réduire la taille de mes backups afin d'optimiser l'espace, bien que le chiffrement des sauvegardes est intéressant je ne désire pas donnée cette tâches au logiciel de sauvegarde. Le problème est que ceci limiterai mes choix, car le nombre d'option réduit. Si je désire réaliser ce type d'opération je le ferai en amont soit en chiffrant l'ensemble du système de fichier de mon disque externe. 
    1. __Déduplication__ : J'aimerai que le logiciel de sauvegarde puisse réaliser de la déduplication afin de réduire l'espace utilisé lors de la sauvegarde. Car je suis d'accord avec l'idée de ne pas écrire 2 fois les mêmes données.

* **Méthode de prise de sauvegarde** :
    Ici nous parlons encore de temps de prise de sauvegarde et rapidité de restauration. Je pars du principe que réinstaller un système n'est pas un problème voir même une opportunité :D. Donc je cherche principalement à copies les données du système, je parle ici pour les opérations courante éventuellement il est possible que je prenne une image d'un système afin de pouvoir le restaurer rapidement , principalement si je suis moins confortable avec le système d'exploitation.
    1. __Copie de fichiers__ : Comme il y a un risque d'oublier de configurer un répertoire il faudra revisité la configuration.
    2. __Base de donnée à froid__ : n'ayant que très peu de base de donnée et aucune avec une charge énorme la prise de sauvegarde à froid est la plus simple. Ceci ne nécessitera pas de configuration particulière et l'ensemble des logiciels de sauvegarde seront en mesure de faire l'opération.

* **Rotation des sauvegardes avec l'externe**
    Pour la rotation des disques dur externe, ma technique n'étais pas optimal à l'origine j'apportai un disque dur au travail et occasionnellement je pensais à reprendre un autre disque externe pour faire la rotation. Le problème avec cette solution est que parfois j'oublie et allant au travaille tous les jours, il y a peu d'indication de la journée particulière et qu'il faut apporter le disque. Lors de la préparation cette formation une personne m'a présenter une autre solution que je vais mettre en place maintenant , ce sera à l'essaie. 
    Le disque dur sera entreposé chez ma mère, donc lors du repas dominical , on pense aux fleurs et au disque dur. Attention de ne pas offrir le disque ça risquerai de faire un impair :-). Résultat un risque de perte de donnée d'une semaine uniquement, ou un mois selon les visites.

# <a name="mise_en_place" />Mise en place de logiciel

Suite à la mise en place de la stratégie de sauvegarde il est temps de la mettre en pratique, nous avons définie nos requis et besoin nous allons voir à présent les logiciels disponibles. Nous allons être obligé de faire des concessions car il est possible que les logiciels ne répondes pas à l'ensemble de nos requis. Comme nous utilisons des logiciels libre il serait toujours possible de programmer les fonctionnalités manquante, mais nous sortons du cadre. 
Je n'ai pas la prétention de présenter l'ensemble des solutions disponibles , en fait à l'origine je n'avais prévue présenter qu'une solution **rsnapshot**, mais pour avoir une formation complète j'ai préféré vous offrir plus de choix. Nous verrons donc 3 solutions de sauvegarde :

* **Rsnapshot** : Solution que j'utilise depuis plusieurs année et qui réponds a mes besoins 
* **BackupPC** : Solution très populaire dans le monde du libre qui offre une interface web de gestion , donc plus conviviale pour les utilisateurs. (Prendre note que j'ai moins d'expérience avec cette solution)
* **CloneZilla** : Solution similaire à  __Norton Ghost__ , il clone un disque dur dans son intégralité. 

## <a name="rsnapshot" /> Rsnapshot

__Rsnapshot__ est basé sur le logiciel **rsync** , en fait il est une couche d'abstraction sur __rsync__ nous permettant de définir des sauvegardes de manière périodique d'une machine local ou à distance grâce au protocole **ssh**. La configuration se fait grâce à un fichier texte simple et il est possible de l'industrialiser. 

* Point Fort : __Rsnapshot__ est l'utilisation de lien dur (__Hard Link__) quand les fichiers sont identique ceci à l'avantage de réduire l'utilisation de l'espace disque dur. Le système est aussi très personnalisé les opérations à l'aide de scripts. Offre l'ensemble de la structure du dernier backup complète. Ne nous oblige pas a installer un agent sur l'ensemble des machines ni d'ouvrir des ports réseaux en plus.
* Point Faible : __Rsnapshot__ n'offre pas d'interface graphique de configuration et gestion ce qui peut rebuté un peu le client ou l'utilisateur.

Débutons avec la mise en place de la solution, j'entends certain dire enfin :P.

* Référence :
    * site officiel : http://rsnapshot.org/
    * __wiki archlinux__ : https://wiki.archlinux.org/index.php/Rsnapshot

### <a name="install_rsnapshot" /> Installation et configuration de Rsnapshot 

####  L'installation 

L'installation est très simple la majorité des distributions offre un pacquage pour __rsnapshot__ .

        $ sudo apt-get install rsnapshot

On peut pas me dire que GNU/Linux c'est compliqué :P !

TODO: FAUT ABSOLUMENT VALIDER l'install dans le docker de formation 64 bits ... J'ai du mettre anacron au lieu de cron pour le systeme 32 bits du laptop :(


#### La configuration

Le fichier de configuration par défaut est **/etc/rsnapshot.conf**, je vous laisse le plaisir de lire le contenu du fichier fournie par la distribution pour vous inspirer.

TODO : sortir d'ici la section ci-dessous mais bon juste pour garder une trace

        $ cd /etc
        $ git init
        $ git config --global user.email "Bob@exemple.com "
        $ git config --global user.name "Bob :D "
        $ sudo git add rsnapshot.conf 
        $ sudo git commit -a -m " Ajout du fichier original rsnapshot "
        [master (root-commit) be15580]  Ajout du fichier original rsnapshot
         1 file changed, 254 insertions(+)
          create mode 100644 rsnapshot.conf
        bob@xerus:/etc$ sudo git log
        commit be15580f0a5e6048e03b69ecf6049bc91617235e
        Author: Bob :D <Bob@exemple.com>
        Date:   Fri Jan 22 17:31:12 2016 -0500

            Ajout du fichier original rsnapshot

Éditer le fichier pour refléter votre configuration , lire les commentaires explicatif fournit dans le fichier.
Il est aussi possible de consulter le fichier **/usr/share/doc/rsnapshot/examples/rsnapshot.conf.default.gz** contenant un exemple de configuration.

Voici le résultat de la configuration sans les commentaires et les lignes vide :

        $  cat rsnapshot.conf | grep -v "#" | grep -v "^$"
        config_version  1.2
        snapshot_root   /var/cache/rsnapshot/
        cmd_cp          /bin/cp
        cmd_du          /usr/bin/du
        cmd_logger      /usr/bin/logger
        cmd_rm          /bin/rm
        cmd_rsnapshot_diff      /usr/bin/rsnapshot-diff
        cmd_rsync       /usr/bin/rsync
        cmd_ssh /usr/bin/ssh
        interval        daily           7
        interval        weekly          4
        interval        monthly         6
        verbose         2
        loglevel        3
        logfile         /var/log/rsnapshot.log
        lockfile        /var/run/rsnapshot.pid
        backup  /etc/           localhost/

Information sur la configuration 

* __snapshot\_root__ : Ceci décrit le répertoire où sera stocké les configurations.
* __cmd_*__ : Permet de définir les chemins où les binaires sont disponible.
* __interval__ :  Définie le nombre de rétention selon le type journalier , hebdomadaire , ...
* __verbose__ et __loglevel__ : Comprend les informations pour les logs :P
* __backup__ : Décrit les répertoires à prendre en sauvegarde et le répertoire de destination ici __localhost__ sous le répertoire définie par __snapshot_root__


**IMPORTANT** : __Rsnapshot__ oblige l'utilisation des tabulations entre les arguments si vous utilisez des espaces vous aurez un message d'erreur, comme ci-dessous :P

        ERROR: interval daily 7 - missing tabs to separate words - change spaces to \
                 tabs. 


#### Utilisation 

Test d'exécution  et validation du résultat : 

        $ sudo rsnapshot -c /etc/rsnapshot.conf daily
        $ sudo ls -l /var/cache/rsnapshot/
        total 4
        drwxr-xr-x 3 root root 4096 Jan 25 08:31 daily.0
        $ sudo ls -l /var/cache/rsnapshot/daily.0/localhost/etc/passwd
        -rw-r--r-- 1 root root 1043 Jan 22 17:18 /var/cache/rsnapshot/daily.0/localhost/etc/passwd

Nous avons a présent un répertoire **daily.0** contenant le dernier backup disponible , dans ce dernier comme nous l'avions définie dans le fichier de configuration, nous avons le répertoire __localhost__ contenant la structure que nous voulions prendre en sauvegarde. Si nous listons un fichier , par exemple __/etc/passwd__.

Je relance l'opération normalement rien ou presque ne fut modifier, cette opération est normalement réaliser une fois par jour :P.

        $ sudo rsnapshot -c /etc/rsnapshot.conf daily
        $ sudo ls -l /var/cache/rsnapshot/
        total 8
        drwxr-xr-x 3 root root 4096 Jan 25 08:34 daily.0
        drwxr-xr-x 3 root root 4096 Jan 25 08:31 daily.1
        $ sudo du -hsc /var/cache/rsnapshot/daily.0 /var/cache/rsnapshot/daily.1
        3.7M    /var/cache/rsnapshot/daily.0
        588K    /var/cache/rsnapshot/daily.1
        4.3M    total
        $ sudo ls -li /var/cache/rsnapshot/daily.1/localhost/etc/passwd
        534727 -rw-r--r-- 2 root root 1043 Jan 22 17:18 /var/cache/rsnapshot/daily.1/localhost/etc/passwd
        $ sudo ls -li /var/cache/rsnapshot/daily.0/localhost/etc/passwd
        534727 -rw-r--r-- 2 root root 1043 Jan 22 17:18 /var/cache/rsnapshot/daily.0/localhost/etc/passwd

Nous avons à présent **daily.0** et **daily.1** qui sont respectivement **la sauvegarde la plus récenter** et la **sauvegarde veille d'un jour**. Nous constatons que l'espace disque utilisé par les sauvegardes ne sont pas équivalente, mais que nous parcourions le répertoires __daily.0__ ou __daily.1__ nous aurons l'ensemble de la structure.
Nous pouvons le voir avec le fichier __/etc/passwd__. __Rsnapshot__ réalise des liens dur (__hard link__) pour faire la référence des fichiers. L'avantage est que nous ne sommes pas obligé de reconstruire la structure des  répertoires avec les anciennes sauvegarde le répertoire  est complet. 
Comme démontré dans l'exemple ci-dessus nous pouvons constater que le fichier __etc/passwd__ à le même __inode__ et la chiffre indiquant qu'il y a un lien symbolique est à 2 .

Pour bien faire la démonstration je l'exécute une fois de plus, nous passerons donc a 3 le nombre de lien dur.

        $ sudo rsnapshot -c /etc/rsnapshot.conf daily
        $ sudo ls -li /var/cache/rsnapshot/daily.0/localhost/etc/passwd
        534727 -rw-r--r-- 3 root root 1043 Jan 22 17:18 /var/cache/rsnapshot/daily.0/localhost/etc/passwd
        $ sudo ls -li /var/cache/rsnapshot/daily.1/localhost/etc/passwd
        534727 -rw-r--r-- 3 root root 1043 Jan 22 17:18 /var/cache/rsnapshot/daily.1/localhost/etc/passwd
        $ sudo ls -li /var/cache/rsnapshot/daily.2/localhost/etc/passwd
        534727 -rw-r--r-- 3 root root 1043 Jan 22 17:18 /var/cache/rsnapshot/daily.2/localhost/etc/passwd

Pour pouvoir exécuter la sauvegarde hebdomadaire, vous devez avoir l'ensemble des exécutions journalier, sinon vous aurez l'erreur suivante dans vos __log__ :

        [25/Jan/2016:08:53:54] /usr/bin/rsnapshot -c /etc/rsnapshot.conf weekly: started
        [25/Jan/2016:08:53:54] /var/cache/rsnapshot/daily.6 not present (yet), nothing to copy

Donc une fois les 6 instances créé il est possible d'exécuter la sauvegarde hebdomadaire 

        $ sudo rsnapshot -c /etc/rsnapshot.conf weekly
        $ sudo ls -l /var/cache/rsnapshot/
        total 28
        drwxr-xr-x 3 root root 4096 Jan 25 08:57 daily.0
        drwxr-xr-x 3 root root 4096 Jan 25 08:57 daily.1
        drwxr-xr-x 3 root root 4096 Jan 25 08:57 daily.2
        drwxr-xr-x 3 root root 4096 Jan 25 08:57 daily.3
        drwxr-xr-x 3 root root 4096 Jan 25 08:57 daily.4
        drwxr-xr-x 3 root root 4096 Jan 25 08:50 daily.5
        drwxr-xr-x 3 root root 4096 Jan 25 08:34 weekly.0
        $ sudo ls -l -i /var/cache/rsnapshot/weekly.0/localhost/etc/passwd
        534727 -rw-r--r-- 7 root root 1043 Jan 22 17:18 /var/cache/rsnapshot/weekly.0/localhost/etc/passwd

Le concept est le même pour les sauvegardes par mois ou année.


#### Configuration des tâches planifiées

L'utilisation à la ligne de commande est pratique pour faire des testes, cependant nous désirons mettre en place cette opérations de manière régulière et planifier. Pour ce faire nous allons éditer le **crontab**. 

Les manières de réaliser l'opération sont multiple , éditer la tache planifié de l'utilisateur __root__ ou éditer le fichier **/etc/crontab** . Je vais prendre la deuxième option, ce qui ne change presque rien à la définition.

Je vais ajouter les lignes suivante au fichier de **/etc/crontab**

        00 02 2-31 * 1-6 root /usr/bin/rsnapshot -c /etc/rsnapshot.conf daily
        00 02 2-31 * 7   root /usr/bin/rsnapshot -c /etc/rsnapshot.conf weekly
        00 02 01 * *     root /usr/bin/rsnapshot -c /etc/rsnapshot.conf monthly

* __daily__ : La sauvegarde est exécutée à 2:00 (00 02) le matin , date 02 au 31 (2-31) , du lundi au samedi (1-6)
* __weekly__ : La sauvegarde est exécutée à 2:00 (00 02) le matin , date 02 au 31 (2-31) , le dimanche (7)
* __monthly__ : La sauvegarde est exécutée à 2:00 (00 02) le matin , le 1 du mois

Comme vous pouvez le constater les sauvegardes sont programmer pour ne pas se marché dessus. Si nous regardons les fichiers de configuration vous constaterez qu'il y a la définition d'un fichier de verrou afin que si nous réalisons une erreur le problème ne cause pas de problème majeur.


### <a name="setup_x3_rsnapshot_serveur" /> Ma configuration de Rsnapshot serveur

Je présume que bien que la solution soit d'une simplicité déconcertante, il y a un peu d'incrédulité par le manque d'information sur l'état des copies , la quantité de donnée transférer , ... En gros on manque de visibilité sur ce qui s'est produit et surtout on aimerait bien recevoir un courriel avec le résultat afin de ne pas le lire et classer dans un répertoire pourvu à cette effet !
De plus comment on fais pour réaliser la sauvegarde d'une machine distant ? Afin de répondre à la question je vais vous présenter ma configuration.

Je vais donc faire la présentation de l'écosystème que j'ai mis autour pour répondre à ce besoin, je ne prétend pas que c'est la meilleur solution cependant elle a le mérite d'être flexible. L'ensemble des scripts son disponible sous le dépôt [github scripts](https://github.com/x3rus/scripts/).

Comme je désire avoir un graphique sur le temps utilisé pour la réalisation de la sauvegarde nous aurons besoin de [rrd](http://oss.oetiker.ch/rrdtool/) outil qui permet de réaliser des graphiques avec n'importe quelle donnée. 
De plus pour faire l'envoie de courriel en __HTML__ j'utilise un script python. Nous devons donc installer ces deux pacquages.

        $ sudo apt-get install rrdtool python-minimal


#### Organisation des fichiers de configuration 

Premièrement je ne vais pas utiliser le fichier de configuration __/etc/rsnapshot.conf__ , j'ai créé un répertoire **/etc/rsnapshot/hosts** sous ce dernier j'ai mis la configuration désirer pour chacune des machines.

        $ sudo mkdir -p  /etc/rsnapshot/hosts
        $ ls /etc/rsnapshot/hosts
        goban_x3rus_com.conf  hoshi_x3rus_com.conf  tengen_x3rus_com.conf

De plus par défaut __rsnapshot__ utilise uniquement 1 fichier de __log /var/log/rsnapshot__ nous allons créer un répertoire pour contenir les logs pour chaque sauvegarde.

        $ sudo mkdir /var/log/rsnapshot/

Nous allons aussi créer un répertoire pour stocker le fichier de graphique __rrd__ généré

        $ sudo mkdir /var/lib/rrd/

####  Création de clés __SSH__ pour la communication avec les machines distantes

Nous n'avons pas encore couvert le processus de sauvegarde d'une machine distante, le système __rsnapshot__ utilise __ssh__ pour communiquer. Comme le système de sauvegarde doit être exécuter de manière automatique sans l'intervention humaine, donc sans entrer un mot de passe nous utiliserons l'authentification par clé. Nous allons créer une pair de clé. Contrairement à l'utilisation classique qui crée la clé de le home de l'utilisateur nous allons la créer dans le répertoire __/etc/rsnapshot/keys/__ . La clé ne comprend pas de __passphrase__

        
        $ sudo mkdir -p  /etc/rsnapshot/keys 
        $ sudo ssh-keygen
        Generating public/private rsa key pair.
        Enter file in which to save the key (/root/.ssh/id_rsa): /etc/rsnapshot/keys/rsnapshot_rsa
        Enter passphrase (empty for no passphrase): 
        Enter same passphrase again: 
        Your identification has been saved in /etc/rsnapshot/keys/rsnapshot_rsa.
        Your public key has been saved in /etc/rsnapshot/keys/rsnapshot_rsa.pub.

Nous aurons donc la clé disponible sous __/etc/rsnapshot/keys/rsnapshot_rsa__

#### Configuration du client __SSH__ pour l'utilisation de la clé

Nous avons définie une clé __ssh__ nous allons maintenant définir une configuration pour que le client __ssh__ de l'utilisateur **root** utilise cette configuration ! Deux option d'offre à nous , la première définir dans le fichier de configuration de __rsnapshot__ du client d'utiliser spécifiquement cette clé. Personnellement n'utilisant jamais le compte __root__ autre que pour des opérations automatisé j'ai définie cette configuration global à l'utilisateur. 
J'ai édité le fichier **/root/.ssh/config** avec les instructions suivante :

        Host *
            IdentityFile /etc/rsnapshot/keys/rsnapshot_rsa
            StrictHostKeyChecking no

Ceci ce traduit comme suit , pour toutes les machines (__Host *__)  utilise la clé __rsnapshot\_rsa__ (__IdentityFile__) lors de l'initialisation de connexion ne pas faire de validation sur l'échange de clé initiale (__StrictHostKeyChecking__)


#### script d'abstraction **backup_runner.sh**

Ce script disponible sous le dépôt [backup_runner.sh](https://github.com/x3rus/scripts/blob/master/backup-scripts/rsnapshot/backup_runner.sh), permet d'avoir une validation des paramètres transmis. 
Si vous lisez le script vous constaterez qu'il valide les paramètres, valide que l'utilisateur utilisé est bien **root**.

Résultat au lieu d'utiliser la commande __rsnapshot__ nous utiliserons :

        $ sudo backup_runner.sh -c Fichier-de-configuration.conf daily

#### script de backup et fichier de configuration (__FullBackup.sh__ et __FullBackup.conf__)

__Backup\_runner.sh__ ne réalise la sauvegarde que pour un fichier de configuration nous utiliserons le script __FullBackup.sh__ pour orchestrer l'ensemble du processus de sauvegarde. Ce dernier réalise les opérations suivante :

1. __Mount__ le disque dur externe sur le système de fichier
2. Réalise la sauvegarde pour l'ensemble des fichiers de configuration présent dans __/etc/rsnapshot/hosts/__
3. Réalise un graphique des performances.
4. Envoie un courriel récapitulatif du processus de sauvegarde

Ce fichier utilise un fichier de configuration contenant l'ensemble des paramètres requis pour le bon fonctionnement.
Le fichier [FullBackup.sh](https://github.com/x3rus/scripts/blob/master/backup-scripts/rsnapshot/FullBackup.sh) et [FullBackup.conf](https://github.com/x3rus/scripts/blob/master/backup-scripts/rsnapshot/FullBackup.conf), sont disponible sur __github__.

Bien entendu il est important de modifier le contenu du fichier de configuration **FullBackup.conf** pour que ce soit représentatif de votre installation !

#### script satellite 

Le script [FullBackup.sh](https://github.com/x3rus/scripts/blob/master/backup-scripts/rsnapshot/FullBackup.sh) appel un autre script nommé [html-email-sender.py](https://github.com/x3rus/scripts/blob/master/backup-scripts/rsnapshot/html-email-sender.py), ce petit script en python est utilisé pour envoyer un courriel. Pour ceux qui se demande pourquoi je n'ai pas simplement utilisé la commande __mail__ , simplement parce que j'avais besoin de composer un courriel en __html__ pour inclure une image.
Tout comme les autres script ceci est disponible sur __github__ [html-email-sender.py](https://github.com/x3rus/scripts/blob/master/backup-scripts/rsnapshot/html-email-sender.py).

Je vous laisse le plaisir de le lire.

Le script [rsnapreport.pl](https://github.com/x3rus/scripts/blob/master/backup-scripts/rsnapshot/rsnapshot.pl) est en fait un script inclut dans le __package rsnapshot__ vous le retrouverez dans le répertoire __/usr/share/doc/rsnapshot/examples/utils/rsnapreport.pl.gz__. Je l'ai inclue dans le dépôt pour facilité le déploiement de la solution.

### <a name="setup_x3_rsnapshot_client" /> Ma configuration de Rsnapshot client

Pour que le système de sauvegarde fonctionne vous devez avoir sur le client :

* service __ssh__ pour la connexion ( __apt-get install openssh-server__ )
* l'application __rsync__ pour la synchronisation / copie des fichiers ( __apt-get install rsync__ )

Lors de la configuration du serveur nous avons créé une clé __SSH__ afin de permettre au serveur d'établir une connexion sur les machines clients sans mot de passe. Nous allons maintenant procéder à la configuration de cette clé sur le / les clients.

#### configuration de la clé __ssh__ client

Afin de permettre la réalisation de la sauvegarde de l'ensemble du système peut importe les permissions l'opération de sauvegarde sera réalisé par l'utilisateur __root__ . La configuration de __ssh__ doit donc permettre la connexion via l'utilisateur __root__ . Afin de réduire les risques ( __brute force__, ...) en autorisant les accès avec le compte administrateur directement, nous n'autoriseront l'accès que grâce au système de clé. Voici la ligne à valider / modifier dans votre configuration , assurez vous d'avoir __without-password__ :

        $ cat /etc/ssh/sshd_config  | grep PermitRootLogin
        PermitRootLogin without-password

Si vous avez réalisé une configuration avec limitation d'accès par utilisateur __AllowUsers__ ou __AllowGroups__ il faudra rajouter l'usagé __root__ pour lui permettre la connexion. Bien entendu nous redémarrons le service s'il y a eu modification dans le fichier 

        $ sudo /etc/init.d/ssh restart

Le serveur est configuré , nous allons mettre en place la clé :D. Car si vous avez été trop pressé puis fait le teste , ça marche pas encore :P.

Nous créer le répertoire __ssh__ pour l'utilisateur __root__ puis nous allons déposer la clé publique __rsa__ (**/etc/rsnapshot/keys/rsnapshot_rsa.pub**) , c'est partie.

        client $ sudo mkdir ~root/.ssh
        client $ sudo chmod u=rwx,g=rx,o= ~root/.ssh
        server $ cat /etc/rsnapshot/keys/rsnapshot_rsa.pub
        ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOqBjtdIK/ybEVTJopK4ZXmYo02ZJcyItXfAY
        [ .. OUTPUT COUPÉ ... ]
        client $ sudo vim ~root/.ssh/authorized_keys
        [ COPIEZ le contenu ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOqBjtdIK/ybE .... ]
        client $ sudo cat ~root/.ssh/authorized_keys
        ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOqBjtdIK/ybEVTJopK4ZXmYo02ZJcyItXfAY6h0d3/SlrTS7xzBcJArgNq48DCKXnug5MQazJBgqFI6kLFT9Eox1Tbp74laCyGQgpQtl7Ehl6nG0iIpd9QdjwR5j3vFmj9gzTOumg5bp07/JSZ/AIvCpojSio/1R1ftEDJMYG01shhYZhBn2RKrWqoQxTjMiUYfTwxw+ZmDapVC+PtoDWk014iTEg0p+c67PxduMrVnBxJvo7bQI3bBt/KTtZnA9BPoVIBZnkn4v0zGaJMXG9NFiSg2O+hK3oxBAseaGO46/Y0seeGVYzfG5jgzwZjgQVSuVJ01XjZbk9oFkdb36L root@xerus.example.com
        client $ sudo chmod u=rw,g=,o= ~root/.ssh/authorized_keys


Maintenant nous pouvons réaliser une validation, nous utiliserons la commande __ssh__ "normalement" en passant l'argument **-i** afin d'indiquer quelle clé utiliser :

        server $ sudo ssh -i /etc/rsnapshot/keys/rsnapshot_rsa root@client

Nous sommes obligé d'utiliser la commande __sudo__ car le fichier **/etc/rsnapshot/keys/rsnapshot_rsa** n'est lisible QUE par l'utilisateur __root__. Si vous n'avez pas mis l'instruction __sudo__ le système vous demandera un mot de passe. Normalement vous êtes maintenant sur le client avec un __shell__. Vous pouvez faire __logout__. 

À ce stade tous va fonctionné, mais nous allons mettre un peu plus de sécurité sur l'utilisation de cette clé car comme l'ensemble de la sécurité est basé sur un seul fichier **/etc/rsnapshot/keys/rsnapshot_rsa** . Nous allons mettre des mesures de contrôle en plus.

#### limitation de l'utilisation de la clé

Premièrement nous allons limité d'où les connexions peuvent venir, avec l'instruction **from=** sur le client. Ceci nous permet de définir des adresses __IP__ ou des segments réseaux. Voici le résultat :

         client $  sudo cat ~root/.ssh/authorized_keys
         from="192.168.30.30" ssh-rsa AAAAB3NzaC1yc2EAAAADAQAB
         [ .. OUTPUT COUPÉ ... ]

À ce stade l'authentification par clé devrait très bien fonctionné depuis la machine __192.168.30.30__ mais d'une autre machine sur le réseau le système va demander le mot de passe .

Cool !! Mais  en fait nous on veut juste permettre l'utilisation de **rsync** est-ce vraiment pertinent de permettre un __shell__ comme __root__  ?!?! (la réponse c'est non :P, pourquoi ? Parce qu'on peut le faire :D.)

Nous allons limité l'utilisation de commandes qui peuvent être réalisé avec cette clé __ssh__ , nous n'allons permettre QUE l'utilisation de la commande __rsync__ car nous n'avons pas besoin de plus. Pour ce faire nous allons rajouter l'instruction **command=** à la définition de la clé sur le client 

        client $ sudo cat ~root/.ssh/authorized_keys
        from="192.168.30.30",command="/root/backup/validate-rsync" ssh-rsa AAAAB3NzaC1yc2EAAAADA
         [ .. OUTPUT COUPÉ ... ]

Lors de la connexion __ssh__ le système va appeler le script __/root/backup/validate-rsync__ afin de voir si c'est OK ou NON.

HEU mais il sort d'où ce fichier **/root/backup/validate-rsync**  ? Nous ne l'avons pas encore créé :P... Voici le contenu :

        client $ cat client-site/validate-rsync
        #!/bin/sh
        #
        # Command original from web site : http://troy.jdmz.net/rsync/#validate-rsync
        #


        case "$SSH_ORIGINAL_COMMAND" in
        *\&*)
        echo "Rejected"
        ;;
        *\(*)
        echo "Rejected"
        ;;
        *\{*)
        echo "Rejected"
        ;;
        *\;*)
        echo "Rejected"
        ;;
        *\<*)
        echo "Rejected"
        ;;
        *\`*)
        echo "Rejected"
        ;;
        *\|*)
        echo "Rejected"
        ;;
        rsync\ --server*)
        $SSH_ORIGINAL_COMMAND
        ;;
        *)
        echo "Rejected"
        ;;
        esac

En gros  le script prend la variable **$SSH_ORIGINAL_COMMAND** qui est transmis par __ssh__ au script et réalise la validation pour __rsync__. Bien entendu pour que ceci fonctionne le script doit être exécutable par l'utilisateur .

        client $ sudo chmod u=rx  /root/backup/validate-rsync

Si maintenant nous réalisons un test pour établir une connexion au système avec un __shell__ voici le résultat 

        server $ sudo ssh -i /etc/rsnapshot/keys/rsnapshot_rsa root@192.168.30.100
        Rejected
        Connection to 127.0.0.1 closed.

C'est  magnifique :D, mais ça marche vraiment avec __rsync__ :P, validons ...

        server $ sudo rsync -av -e "ssh -i /etc/rsnapshot/keys/rsnapshot_rsa" root@192.168.30.100:/etc /tmp/toto/
        receiving incremental file list
        etc/
        etc/.pwd.lock
        etc/adduser.conf
        etc/anacrontab
        [ ... OUTPUT COUPÉ ... ]
        etc/xml/xml-core.xml
        etc/xml/xml-core.xml.old

        sent 11,453 bytes  received 1,228,991 bytes  826,962.67 bytes/sec
        total size is 1,173,430  speedup is 0.95

### <a name="setup_x3_rsnapshot_test" /> Ma configuration validation

Nous sommes donc à l'étape de faire un teste passant de la configuration et bien entendu faire les petits correctif qui vont s'imposer , malheureusement ça marche rarement complètement du premier coup .

Donc si je prend ce fichier de configuration

        $ cat /etc/rsnapshot/hosts/client_domain_com.conf 
        config_version                  1.2
        snapshot_root                   /mnt/hd_backup/zato
        no_create_root                  0
        cmd_cp                          /bin/cp
        cmd_rm                          /bin/rm
        cmd_rsync                       /usr/bin/rsync
        cmd_ssh                         /usr/bin/ssh
        cmd_logger                      /usr/bin/logger
        cmd_du                          /usr/bin/du
        cmd_rsnapshot_diff              /usr/bin/rsnapshot-diff
        interval                        daily           7
        interval                        weekly          6
        interval                        monthly         6
        verbose                         2
        loglevel                        3
        logfile                         /var/log/rsnapshot/zato.log
        lockfile                        /var/run/rsnapshot-zato.pid
        #ssh_args                       -i /etc/rsnapshot/keys/rsnapshot_rsa
        rsync_long_args                 -z --delete --relative --numeric-ids --delete-excluded --stats

        #       List    directory
        backup                          root@192.168.30.100:/etc 

Je vais faire un teste passant : 

        $ sudo /usr/local/sysadmin/backup-scripts/rsnapshot/backup_runner.sh /etc/rsnapshot/hosts/client_domain_com.conf  daily
        echo 836 > /var/run/rsnapshot-zato.pid
        mv /mnt/hd_backup/zato/daily.1/ /mnt/hd_backup/zato/daily.2/
        /bin/cp -al /mnt/hd_backup/zato/daily.0 /mnt/hd_backup/zato/daily.1
        /usr/bin/rsync -av -z --delete --relative --numeric-ids --delete-excluded \
            --stats --rsh=/usr/bin/ssh root@127.0.0.1:/etc \
            /mnt/hd_backup/zato/daily.0/.
        receiving incremental file list
        etc/
        etc/.pwd.lock
        etc/adduser.conf
       [ ... OUTPUT COUPÉ ... ] 
       touch /mnt/hd_backup/zato/daily.0/
       rm -f /var/run/rsnapshot-zato.pid
       /usr/bin/logger -i -p user.info -t rsnapshot /usr/bin/rsnapshot -c \
           /etc/rsnapshot/hosts/client_domain_com.conf -V daily: completed \
           successfully

Nous pouvons maintenant utilise le script qui englobe  tous ça :D.

        $ sudo /usr/local/sysadmin/backup-scripts/rsnapshot/FullBackup.sh daily

Si vous n'avez pas de message d'erreur ça veut dire que tout vas bien vous pouvez regarder vos courriel , vous devriez avoir l'état de la sauvegarde.


## <a name="backupPC" />BackupPC


**BackupPC** est un logiciel libre de sauvegarde de système de fichier publié sous licence **GPL**.

Il est utilisé pour sauvegarder sur disque un ensemble de postes clients et de serveurs, sous Unix, Linux, Windows ou Mac OS X. Les protocoles utilisables pour les transferts sont : __SMB, tar over SSH/rsh/nfs, et rsync__. Il ne nécessite l'installation d'aucun logiciel client sur les machines à sauvegarder. Il possède une interface web pour lancer des sauvegardes ou restaurer des fichiers. Il est également possible de sauvegarder des bases de données via un script __shell__ lancé avant la sauvegarde.

Originalement je n'avais pas prévu en faire la démonstration, cependant afin d'offrir plus de choix au personne j'ai changé d'avis , je tiens à préciser que je n'ai que très peu d'expérience avec l'outil. Je vous invite à communiquer tous erreur que vous trouvez , en fait ceci s'applique sur l'ensemble des sections :P.

Site web officiel : [http://backuppc.sourceforge.net/](http://backuppc.sourceforge.net/)

### Installation

TODO: valider l'installation peut-être juste problème avec mon docker 
TODO: voir comme référence > http://www.klipz.fr/tutoriel_backuppc.html

* Réalisation de l'installation avec le système de pacquage :

        $ sudo apt-get install apache2-utils  backuppc

Je ne prendrais pas beaucoup de temps pour la partie de la configuration de __backuppc__ dans le serveur web __apache__ , car nous verrons en détail le serveur web à la prochaine section.

* Activation de la configuration de __backuppc__ dans apache 

        $ sudo ln -s /etc/backuppc/apache.conf /etc/apache2/sites-enabled/backuppc.conf

* Initialisation du mot de passe pour l'accès à l'interface web, définir le mot de passe que vous désirez.

        $ sudo htpasswd /etc/backuppc/htpasswd backuppc

* Accès à l'interface web : http://le-nom-ou-ip-du-serveur/backuppc/

### Configuration 

* Correction d'un problème d'installation sous Ubuntu conformément au [forum ubuntu](http://ubuntuforums.org/showthread.php?t=2237618) . Nous allons changer le paramètre __Ping6Path__ sinon nous aurons une erreur __impossible de réaliser un ping__.

        $ cat -n /etc/backuppc/config.pl  | egrep 'PingPath|Ping6Pa'
          1643  #     $Conf{PingPath} = '/bin/echo';
          1645  $Conf{PingPath} = '/bin/ping';
          1646  $Conf{Ping6Path} = '/bin/ping6';
          1651  #   $pingPath      path to ping ($Conf{PingPath})
J'ai ajuster la ligne 1646 , afin de fournir le chemin au binaire


* Correction pour l'erreur 512 de __tar__ lors de l'utilisation local pour __localhost__ , comme les fichiers contenu dans __/etc__ par exemple ne sont pas tous accessible à l'utilisateur __backup__ il devra pouvoir utiliser la commande **sudo** por obtenir les privilèges requis.

        $ sudo visudo 
        backuppc ALL=NOPASSWD: /bin/tar

        $ sudo cat -n /etc/backuppc/localhost.pl | grep sudo
           10  $Conf{TarClientCmd} = '/usr/bin/env LC_ALL=C sudo $tarPath -c -v -f - -C $shareName --totals';
Ajout à la ligne 10 de la commande **sudo** entre la définition du langage et la variable **$tarPath**.

TODO : INFO a extraire pour la schedule https://www.digitalocean.com/community/tutorials/how-to-use-backuppc-to-create-a-backup-server-on-an-ubuntu-12-04-vps

## <a name="clonezilla" />CloneZilla

# <a name="la_glue_autour" />Quelques points pour peaufiner la solution

## <a name="Validation" />Mise en place d'une stratégie de la validation de sauvegarde automatique.
## <a name="bk_ps4" />Indicateur de prise de backup pour PS4 
## <a name="mobile_bk_check" />Indicateur d'absence de backup des Téléphone

# <a name="other_technique" />Autre Méthode pour des besoins precis.

## <a name="lvm_export" />lvm export
http://tldp.org/HOWTO/LVM-HOWTO/snapshots_backup.html

## <a name="backup_snapshot_vmware" />Backup de sanpshot de VM


# <a name="ref" />Référence 

* https://openclassrooms.com/courses/la-sauvegarde-sous-gnu-linux
* https://debian-handbook.info/browse/fr-FR/stable/sect.backup.html
* https://securityinabox.org/fr/chapter_5_2 : TODO confirmer
* https://www.freebsd.org/doc/fr_FR.ISO8859-1/books/handbook/backup-strategies.html
* https://fr.wikipedia.org/wiki/Sauvegarde\_%28informatique%29#Finalit.C3.A9
* https://en.wikipedia.org/wiki/Backup
