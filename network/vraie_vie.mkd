<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 


# <a name="Introduction" /> Introduction 

Nous avons vue dans la première partie la théorie des protocoles réseaux __TCP__ , __UDP__ et __IP__. Lors des différentes démonstration tous fonctionnait sans problème. Dans la vie ce n'est pas aussi jolie , quand on vous demande de réaliser une analyse sur un problème, il faut être en mesure d'identifier les problèmes. Nous allons donc maintenant passer à l'étape quand tous ne fonctionne pas afin d'avoir des indices pour identifier les problématiques .
Bien entendu je ne serai jamais en mesure de couvrir l'ensemble des problèmes que vous pouvez rencontrer, cependant j'espère en couvrir assez afin de vous offrir les outils pour diagnostiquer la source du problème . Vous pourrez par la suite identifier l'équipement et la méthode de résolution approprié.

# <a name="couche_IP"/> Communication entre 2 systèmes

Commençons par la couche inférieur donc la couche IP puis nous monterons tranquillement , vers la couche applicative. Nous aurons l'occasion par la suite de voir les protocoles applicatifs telle que __HTTP__**S** avec __wireshark__.

## <a name="ip_probleme_route"/> Problème de routage de paquets

Nous allons maintenant voir un problème de communication entre 2 machines , voici le schéma :

![dia_network_docker_plus_roger.png](./imgs/dia_network_docker_plus_roger.png)

Donc nous avons 2 cartes réseau:

* **wlan0** : la carte sans file avec l'adresse IP 192.168.43.191
* **docker0** : carte virtuelle docker avec l'IP  172.17.0.1

Sous l'interface **docker0** il y a un sous réseau connecté directement sur la carte qui comprend l'ensemble du réseau 172.17.0.0/16 . Dans le réseau 172.17.0.0/16 , nous avons une machine 172.17.0.4 de disponible .

Si j'essaye de réaliser un **PING** de la machine voici le retour : 

        $ ping 172.17.0.4
        PING 172.17.0.4 (172.17.0.4) 56(84) bytes of data.
        From 192.168.142.2 icmp_seq=1 Packet filtered
        From 192.168.142.2 icmp_seq=2 Packet filtered
        From 192.168.142.2 icmp_seq=3 Packet filtered
        ^C
        --- 172.17.0.4 ping statistics ---
        3 packets transmitted, 0 received, +3 errors, 100% packet loss, time 2002ms

Nous avons le message que le paquet fut filtré par le routeur 192.168.142.2 , ce qui est étrange , voyons ce que la commande **traceroute** nous retourne  :

        $ traceroute 172.17.0.4
        traceroute to 172.17.0.4 (172.17.0.4), 30 hops max, 60 byte packets
         1  gateway (192.168.43.1)  3.181 ms  2.724 ms  3.004 ms
         2  * * *
         3  192.168.142.2 (192.168.142.2)  415.969 ms !X 192.168.142.66 (192.168.142.66)  463.790 ms !X  463.809 ms !X

Reprenons le schéma réseau un peu plus haut, ce n'est PAS normale que le paquet soit dirigé var le routeur **192.168.43.1** , selon le schéma ceci devrait être dirigé vers l'interface **docker0** .

Je vais démarrer **wireshark** sur l'interface **wlan0** pour voir le comportement et refaire le __ping__:

![prob_route_wireshark_wlan0_filtered.png](./imgs/prob_route_wireshark_wlan0_filtered.png)

Nous voyons clairement que sur l'interface **wlan0** il y a du trafic et le message est très explicite : __Destination unreachable (Communication administratively filtered)__

Si je réalise le même filtrage sur l'interface **docker0** je n'ai aucun trafic , aucun paquet RIEN !!!

Essayons peut-être un accès SSH après tous juste un problème de __ping__ ce n'est pas la fin du monde :P  :

        $ telnet 172.17.0.4 22
        Trying 172.17.0.4...
        telnet: Unable to connect to remote host: No route to host

Et au niveau du __wireshark__ :

![prob_route_wireshark_wlan0_filtered_telnet_22.png](./imgs/prob_route_wireshark_wlan0_filtered_telnet_22.png)

Humm, c'est pas mieux :p , __nice try__ :)
Visualisons  les routes à présent indiquant le chemin que doit prendre les communications IP 

        $ route -n
        Kernel IP routing table
        Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
        0.0.0.0         192.168.43.1    0.0.0.0         UG    600    0        0 wlan0
        192.168.43.0    0.0.0.0         255.255.255.0   U     600    0        0 wlan0

Effectivement il n'y a aucune instruction pour l'interface **docker0** . Je vais donc faire l'ajout de l'instruction à la table de routage :

        $ sudo route add -net 172.17.0.0 netmask 255.255.0.0 dev docker0
        $ route -n
        Kernel IP routing table
        Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
        0.0.0.0         192.168.43.1    0.0.0.0         UG    600    0        0 wlan0
        172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
        192.168.43.0    0.0.0.0         255.255.255.0   U     600    0        0 wlan0

ENCORE , comme dirait mon fils :D  :

        $  ping 172.17.0.4
        PING 172.17.0.4 (172.17.0.4) 56(84) bytes of data.
        64 bytes from 172.17.0.4: icmp_seq=1 ttl=64 time=0.176 ms
        64 bytes from 172.17.0.4: icmp_seq=2 ttl=64 time=0.114 ms


Et voilà , quand on prend le bon chemin ça va mieux :D 

# <a name="couche_TCP"/> Communication entre 2 systèmes

## <a name="tcp_timeout_drop"/> Analyse d'un problème de communication TCP ou UDP

Un problème classique avec le protocole __TCP__ est un problème de connexion entre le client et le serveur, nous avons un problème et le réflexe est de blâmé le __firewall__ ou le réseau. Ce réflexe est naturel, car souvent cette partie est géré par une autre équipe et nous n'avons pas le contrôle. Nous allons donc voir comment identifier le problème afin de faire la demande approprié pour solutionné le problème . 

Si j'ai un problème de communication entre le client et le serveur il y a 3 possibilités :

* La connectivité est problématique : __Firewall__ bloque les communications ou le paquets n'arrive pas a destination 
* Le serveur ne traite pas la communication adéquatement ne fournissant la de réponse adéquate 
* Le client n'envoie pas la requête au bon serveur ou la requête est mal formé

Je vais partir du principe que vous avez accès au 2 équipements suivant :

* La machine client 
* Le serveur 

Pour les besoins de la démonstration je vais utiliser 2 services __snmpd__ pour __l'UDP__ et __apache__ pour la partie __TCP__ . Nous utiliserons 2 utilitaires __netcat (nc)__ pour simulé un client/serveur __UDP__ et __TCP__ ainsi que __telnet__ car je l'aime bien pour la partie __TCP__

### <a name="tcp_timout"/> Visualisation d'un problème de communication à cause du firewall pour TCP

Pour commencé nous allons voir comment identifier s'il y a un problème de __firewall__ . Voyons le comportement quand il y a une indisponibilité de connexion dû au __firewall__.

J'ai :

* client : 172.17.42.1 
* serveur (apache) : 172.17.0.1 

Pour rappel quand tous va bien lors de l'établissement de connexion entre le client et le serveur je doit avoir :

* Établissement de connexion  ( __3 way handshake__ ) / __SYN__, __SYN-ACK__ , __ACK__
* Transfert de données avec accusé de réception (__ACK__)
* Fermeture de connexion  (__FIN-ACK__, __FIN-ACK__, __ACK__)

Voici un rappel de la copie d'écran de __wireshark__ :

![wireshark_visualisation_fureteur_07.png](./imgs/wireshark_visualisation_fureteur_07.png)

Maintenant, je vais ajouter une règle de __firewall__ qui bloque la communication , je vais utilisé un **DROP** ce qui fait en sorte que le paquet est mis à la poubelle sans avertissement au client .

Je met ici les instructions __iptables__ cependant ceci est en dehors de la formation, je ne veux pas faire de Linux ici. Par contre si vous avez des questions n'hésitez pas à communiquer avec moi en dehors :).

Comme j'utilise docker j'installe __iptables__ si requis et j'active la règle pour bloquer l'accès en entré :

        $ iptables -I INPUT -p tcp --destination-port 80 -j DROP
        Chain INPUT (policy ACCEPT)
        target     prot opt source               destination
        DROP       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80

        Chain FORWARD (policy ACCEPT)
        target     prot opt source               destination

        Chain OUTPUT (policy ACCEPT)
        target     prot opt source               destination

Reprenons la requête avec le fureteur afin de voir le comportement ...  Le résultat est que la roulette tourne , tourne , tourne ... Sans retour . Le premier réflexe que je vous conseil est d'enlever le fureteur de l'équation afin de valider si la communication __TCP__ fonctionne :

        $ telnet 172.17.0.8 80
        Trying 172.17.0.8...
        telnet: Unable to connect to remote host: Connection timed out

Nous avons aussi un __timeout__ , visualisons le comportement avec __wireshark__ :

![proc_tcp_drop_firewall.png](./imgs/proc_tcp_drop_firewall.png)

Donc nous voyons les 3 tentatives du protocole __TCP__ qui sont transmis ainsi que les retransmissions , ceci fut réalisé avec le fureteur . Comme le protocole __TCP__ sait que le réseau IP est non fiables il essaye plusieurs fois :P , peut-être que le paquet fut perdu lors du transfert.
Voici la même opération avec __telnet__ :

![proc_tcp_telnet_drop_firewall.png](./imgs/proc_tcp_telnet_drop_firewall.png)

Nous voyons que ce dernier est moins agressif. 

Nous pouvons aussi constater que lorsqu'il y a un __Firewall__ la méthode "classique" est de **droppé** les paquets donc de ne pas y répondre . Si le service apache n'écoutais pas  sur le port comme c'est le cas pour le port 8080 par exemple nous aurions un comportement différent .

        $ telnet 172.17.0.8 8080
        Trying 172.17.0.8...
        telnet: Unable to connect to remote host: Connection refused

Et au niveau de __wireshark__ :

![connexion_refused_no_process.png](./imgs/connexion_refused_no_process.png)

Au risque de me tromper je vous suggère cette règle : 

* Si vous avez une connexion refusé alors le processus n'est pas en exécution 
* S'il y a un __timeout__ , il y a possiblement un __firewall__ entre les 2 :P

Mais pourquoi utiliser __telnet__ et pas mon __fureteur__ il fonctionne aussi bien , la réponse est NON :P . L'avantage de __telnet__ est qu'il vous indique si la connexion __TCP__ (__3 way handshake__) à fonctionné et après traite les données , votre fureteur ne fait pas la distinction. 

Je vais désactivé la règle de __firewall__ :

        $ iptables -D INPUT -p tcp --destination-port 80 -j DROP

Maintenant j'accède à l'URL : http://172.17.0.8/time.php

Vous pouvez voir mon fureteur tourne dans le beurre encore une fois ... Si je fais la commande avec __telnet__

        $ telnet 172.17.0.8 80
        Trying 172.17.0.8...
        Connected to 172.17.0.8.
        Escape character is '^]'.
        ^]
        telnet> q
        Connection closed.

Je vois clairement que la communication __TCP__ à fonctionné , donc le problème n'est PAS au niveau réseau, mais au niveau de l'application ! Bon effectivement __time.php__ fait plein de __sleep__ pour mettre une éternité pour répondre :P.
Voilà pourquoi vous me voyez toujours utiliser __telnet__ pour analyser si j'ai la ligne **Connected to 172.17.0.8.** donc voir si le lien réseau fonctionne !!


#### <a name="tcp_timout_firewall_loc"/> Quelle firewall me bloque ?

Je vais partir du principe que vous êtes le client ET que vous avez accès au serveur. Vous avez identifier qu'il y a une règle de firewall qui bloque. Vous avez analyser votre serveur mais de votre point de vue par de problème et vous ne voyez pas de règle de firewall en place . Nous allons voir comment identifier la source du problème, du moins avoir une idée .

Nous allons établir une connexion vers le serveur , je n'utiliserai QUE __telnet__ car le reste peut me porter à confusion :).



## <a name="tcp_drop_restart"/> Visualisation d'une coupure de communication lors d'un transfert de paquet

Maintenant que nous avons identifié un problème de connexion qui ne fonctionne pas passons à un problème intermittent .
Ceci est le plus compliqué à identifier , je ne dis pas que j'ai la solution exacte, cependant vous permettra d'avoir un aperçu concret lorsque la situation ce produit. Chaque problème étant particulier à vous de l'adapter dans votre réalité .

Je vais utilisé le protocole SSH afin de faire la démonstration , j'ai une machine avec l'IP : __172.17.0.2__ qui a le service SSH présent nous allons faire un transfert de fichier avec __SCP__ pour le transfert.

* client : 172.17.42.1
* serveur : 172.17.0.2

Voici l'opération quand tous vas bien :

        $ scp bob@172.17.0.2:./usr-share-vim.tar /tmp/
        bob@172.17.0.2's password: 
        usr-share-vim.tar                              100%   25MB  25.2MB/s   00:01


Bon si nous regardons nous avons bien le __3 way handshake__ (__SYN , SYN/ACK, ACK__) , nous avons du transfert et la fin de connexion ( __FIN/ACK , ACK, FIN/ACK, ACK__). Si vous regardez attentivement vous constaterez qu'il y a aussi des messages étrange que nous n'avions encore jamais vu : **TCP Full Window** et **TCP ZeroWindows** , puis ils sont en noir et rouge , ça sonne PAS bon pourtant nous n'avons pas encore créer de __noise__ sur la ligne.

![transfert_scp_msg_windows_full.png](./imgs/transfert_scp_msg_windows_full.png)

Référence du problème __wireshark__ :  [https://ask.wireshark.org/questions/24501/why-would-tcp-full-window-happen](https://ask.wireshark.org/questions/24501/why-would-tcp-full-window-happen)

Premièrement ce n'est PAS une erreur ceci est simplement un avertissement , si vous avez le message **TCP Full Window** et que vous avez après **TCP ZeroWindows** il n'y a PAS de problème. Ok cool mais POURQUOI ?

Regardons cette nouvelle copie d'écran :

![transfert_scp_msg_windows_full_2.png](./imgs/transfert_scp_msg_windows_full_2.png)

Afin d'optimiser le transfert __TCP__ entre le client et le serveur négocie un nombre de paquet (__windows size__) qui peut être transféré entre le client et le serveur sans que le client soit obligé de confirmer la réception. 

Voici un exemple :

* Le client (récepteur) ssh avise qu'il va prendre une fenêtre TCP de 5000 bytes
* Le serveur (émetteur) envoie 5 paquets TCP d'une longueurs de 1000 chaque
* Il n'y a AUCUN accusé de réception des paquets pour ces 5 .
* __Wireshark__ mark le 5ieme paquet avec l'identifiant __TCP WINDOWS FULL__ afin d'indiquer qu'il n'y a pas eu de __ACK__ pour ces dernier.

Le client à 3 possibilités :

* Transmettre le message __\[Zero Windows\]__ : indiquant que son __buffer__ est plein et d'attendre que ce dernier est fini de traiter les données
* Transmettre le message __\[TCP Window Update\]__ : indiquant qu'il traite encore des données mais que ça fenêtre est un peu libre donc que le serveur peut remplir N bytes
* Transmettre le __ACK__ : Afin d'indiquer au serveur que l'on peut reprendre le transfert .


Maintenant que nous avons vu le comportement quand tous va "bien" malgré les messages d'avertissement de __wireshark__ sur la question de la fenêtre de transmission reprenons l'opération. Cette fois ci, je vais faire le transfert mais en plein milieu je vais bloquer la communication avec une règle de __firewall__ afin de simuler une coupure de connexion. La coupure sera temporaire quelques secondes afin de voir le comportement quand la communication reprend.
La règle de __firewall__ fut mis en place pour coupé les communications sur le port 22 du __client__ **vers** le __serveur__.

Voici le résultat à l'écran:

        $ scp bob@172.17.0.2:./usr-share-vim.tar /tmp/
        bob@172.17.0.2's password:
        usr-share-vim.tar                                           35% 9088KB   2.8MB/s - stalled -
        [... COUPURE PUIS la reprise ...]
        usr-share-vim.tar                                           100%   25MB  25.2MB/s   00:01

Si nous regardons le résultat au niveau de __wireshark__ :

![transfert_scp_bloque_with_iptables.png](./imgs/transfert_scp_bloque_with_iptables.png)

C'est partie :D :D , le plaisir commence :D , pour bien comprendre le mécanisme de récupération et retransmission il faut ce concentré sur les numéros de séquence des paquets (**seq**) qui permet de suivre le numéro de chaque paquet , ainsi que les confirmation de réception (**ACK**) qui sont en relation avec séquence de transmission. Au lieu décrire un long texte difficile à comprendre nous allons le voir avec le cas pratique : 

* #1583 : Le client transmet __ACK__ pour confirmer la réception du transfert (malheureusement la règle de __firewall__ bloque la transmission vers serveur, mais le client ne le sais pas encore) (__seq=5046, Ack=9337176__)
* #1584 : Le client transmet un paquet chiffré au serveur ( mais ce dernier ne le recevra PAS à cause du __firewall__) (__seq=5046, Ack=9337176__)
* #1585 : Le serveur transmet un paquet car lui n'a aucun problème de communication avec le client (__seq=9337176,Ack=5046__)
* #1586 : Le client transmet un paquet chiffré toujours (__seq=5082,ack=9338624__)
* #1587 : Le client transmet un autre paquet chiffré (__seq=5118,ack=9338624__)
* #1588 : Le client retransmet le dernier paquet(__seq=5118,ack=9338624__), pourquoi ? Car il à attendu un certain temps mais le serveur n'a pas continuer à retransmettre des paquets. Si vous regarder la colonne __time__ le chiffre est significativement plus haut que lors du transfert régulier de paquet. Bien entendu ce paquet n'arrivera JAMAIS au serveur
* #1589 : Le client transmet un paquet , car comme nous avons activé le mode __drop__ dans le __firewall__ le client croit que le paquet est arrivé RIEN ne lui indique qu'il y a eu un problème il doit attendre la confirmation de réception du serveur ou l'absence de confirmation pour savoir qu'il y a eu un problème (__seq=5154,ack=9338624__)
* #1590 : Le client transmet un paquet car il croit que les 2 derniers furent reçu (__seq=5190,ack=9338624__)
* #1591 : Le serveur ne recevant pas d'accusé de réception refait l'envoie : (__seq=9261596,ack=5046__)

TODO 


# Visualisation du cheminement du paquet afin d'identifier les équipements potentiellement problématique

* Comme nous avions vu avec le timeout du TCP keep alive 
* TODO voir comment faire la démo :(.

# Problème DNS IP  externe VS ip interne

* Visualisation d'une problématique de DNS qui utilise l'IP externe VS l'ip interne pour la communication.




# Faire attention au netmask 

* Voir que parfois on a l'impression que c le même network mais le netmask est important

# Explication rapide VLAN trunk pour ESX

* Expliquer pourquoi un ESX peut avoir plusieurs réseaux alors qu'il n'a que 2 prises

# Utilisation de TcPdump pour visualiser la communication serveur

* Utilisation de snmp afin de visualiser la communication sur le serveur
* Récupération du fichier de data

# Problème de communication avec un service SSL 

* réalisation script python , communication avec le service https normale + un 404 sans msg bien
* Prendre la clef prive du srv https et déchiffrer le contenu de la communication

https://wiki.wireshark.org/SSL

# Calcule taille de la communication

* Faire une communication normale avec un serveur http, avec calcule size communication
* Activer le mod deflate
* Refaire la meme communication et faire le calcule de la taille des paquet de la communications

# Avec time.php montré le keep-alive lors du tcpdump

* Pour visualisé l'opération du browser lors d'un traitement trop long.
