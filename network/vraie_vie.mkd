<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 


# <a name="Introduction" /> Introduction 

Nous avons vue dans la première partie la théorie des protocoles réseaux __TCP__ , __UDP__ et __IP__. Lors des différentes démonstration tous fonctionnait sans problème. Dans la vie ce n'est pas aussi jolie , quand on vous demande de réaliser une analyse sur un problème, il faut être en mesure d'identifier les problèmes. Nous allons donc maintenant passer à l'étape quand tous ne fonctionne pas afin d'avoir des indices pour identifier les problématiques .
Bien entendu je ne serai jamais en mesure de couvrir l'ensemble des problèmes que vous pouvez rencontrer, cependant j'espère en couvrir assez afin de vous offrir les outils pour diagnostiquer la source du problème . Vous pourrez par la suite identifier l'équipement et la méthode de résolution approprié.

# <a name="couche_IP"/> Communication entre 2 systèmes

Commençons par la couche inférieur donc la couche IP puis nous monterons tranquillement , vers la couche applicative. Nous aurons l'occasion par la suite de voir les protocoles applicatifs telle que __HTTP__**S** avec __wireshark__.

## <a name="ip_probleme_route"/> Problème de routage de paquets

Nous allons maintenant voir un problème de communication entre 2 machines , voici le schéma :

![dia_network_docker_plus_roger.png](./imgs/dia_network_docker_plus_roger.png)

Donc nous avons 2 cartes réseau:

* **wlan0** : la carte sans file avec l'adresse IP 192.168.43.191
* **docker0** : carte virtuelle docker avec l'IP  172.17.0.1

Sous l'interface **docker0** il y a un sous réseau connecté directement sur la carte qui comprend l'ensemble du réseau 172.17.0.0/16 . Dans le réseau 172.17.0.0/16 , nous avons une machine 172.17.0.4 de disponible .

Si j'essaye de réaliser un **PING** de la machine voici le retour : 

        $ ping 172.17.0.4
        PING 172.17.0.4 (172.17.0.4) 56(84) bytes of data.
        From 192.168.142.2 icmp_seq=1 Packet filtered
        From 192.168.142.2 icmp_seq=2 Packet filtered
        From 192.168.142.2 icmp_seq=3 Packet filtered
        ^C
        --- 172.17.0.4 ping statistics ---
        3 packets transmitted, 0 received, +3 errors, 100% packet loss, time 2002ms

Nous avons le message que le paquet fut filtré par le routeur 192.168.142.2 , ce qui est étrange , voyons ce que la commande **traceroute** nous retourne  :

        $ traceroute 172.17.0.4
        traceroute to 172.17.0.4 (172.17.0.4), 30 hops max, 60 byte packets
         1  gateway (192.168.43.1)  3.181 ms  2.724 ms  3.004 ms
         2  * * *
         3  192.168.142.2 (192.168.142.2)  415.969 ms !X 192.168.142.66 (192.168.142.66)  463.790 ms !X  463.809 ms !X

Reprenons le schéma réseau un peu plus haut, ce n'est PAS normale que le paquet soit dirigé var le routeur **192.168.43.1** , selon le schéma ceci devrait être dirigé vers l'interface **docker0** .

Je vais démarrer **wireshark** sur l'interface **wlan0** pour voir le comportement et refaire le __ping__:

![prob_route_wireshark_wlan0_filtered.png](./imgs/prob_route_wireshark_wlan0_filtered.png)

Nous voyons clairement que sur l'interface **wlan0** il y a du trafic et le message est très explicite : __Destination unreachable (Communication administratively filtered)__

Si je réalise le même filtrage sur l'interface **docker0** je n'ai aucun trafic , aucun paquet RIEN !!!

Essayons peut-être un accès SSH après tous juste un problème de __ping__ ce n'est pas la fin du monde :P  :

        $ telnet 172.17.0.4 22
        Trying 172.17.0.4...
        telnet: Unable to connect to remote host: No route to host

Et au niveau du __wireshark__ :

![prob_route_wireshark_wlan0_filtered_telnet_22.png](./imgs/prob_route_wireshark_wlan0_filtered_telnet_22.png)

Humm, c'est pas mieux :p , __nice try__ :)
Visualisons  les routes à présent indiquant le chemin que doit prendre les communications IP 

        $ route -n
        Kernel IP routing table
        Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
        0.0.0.0         192.168.43.1    0.0.0.0         UG    600    0        0 wlan0
        192.168.43.0    0.0.0.0         255.255.255.0   U     600    0        0 wlan0

Effectivement il n'y a aucune instruction pour l'interface **docker0** . Je vais donc faire l'ajout de l'instruction à la table de routage :

        $ sudo route add -net 172.17.0.0 netmask 255.255.0.0 dev docker0
        $ route -n
        Kernel IP routing table
        Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
        0.0.0.0         192.168.43.1    0.0.0.0         UG    600    0        0 wlan0
        172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
        192.168.43.0    0.0.0.0         255.255.255.0   U     600    0        0 wlan0

ENCORE , comme dirait mon fils :D  :

        $  ping 172.17.0.4
        PING 172.17.0.4 (172.17.0.4) 56(84) bytes of data.
        64 bytes from 172.17.0.4: icmp_seq=1 ttl=64 time=0.176 ms
        64 bytes from 172.17.0.4: icmp_seq=2 ttl=64 time=0.114 ms


Et voilà , quand on prend le bon chemin ça va mieux :D 

## <a name="ip_probleme_nat"/> Problème de cheminement de paquet

Regardons cette infrastructure :

![infra_demo_formaton.png](./imgs/infra_demo_formaton.png)

Nous avons le réseau réseau 172.30.0.0/16 qui est le réseau utilisé dans l'infrastructure , nous avons aussi 2 réseaux en dehors du réseau 192.168.42.0/24 et 192.168.43.0/24 . Les 2 réseaux 192 sont routé sur le réseau globale par la machine 172.30.4.48 , ce qui leur permet de communiquer avec les autres machines . 

Nous allons voir une situation particulière qui fait en sorte que la machine 192.168.42.10 n'est pas en mesure de communiquer avec la machine 172.30.38.38. 

Si je suis sur la machine 172.30.4.48 donc le routeur des réseaux 192.168.42.0/24 , je suis en mesure de réaliser un __ping__ de la machine.

        $  ping 172.30.38.38
        PING 172.30.38.38 (172.30.38.38) 56(84) bytes of data.
        64 bytes from 172.30.38.38: icmp_seq=1 ttl=64 time=0.176 ms
        64 bytes from 172.30.38.38: icmp_seq=2 ttl=64 time=0.114 ms


Si j établie une connexion sur la machine 192.168.42.10 et que je réalise la même opération :


        $  ping 172.30.38.38

Je n'ai pas de résultat , POURQUOI ?

Analysons la situation , nous allons utiliser la commande __tcpdump__ pour réaliser l'analyse de la situation .

TODO

# <a name="couche_TCP"/> Communication entre 2 systèmes

## <a name="tcp_timeout_drop"/> Analyse d'un problème de communication TCP ou UDP

Un problème classique avec le protocole __TCP__ est un problème de connexion entre le client et le serveur, nous avons un problème et le réflexe est de blâmé le __firewall__ ou le réseau. Ce réflexe est naturel, car souvent cette partie est géré par une autre équipe et nous n'avons pas le contrôle. Nous allons donc voir comment identifier le problème afin de faire la demande approprié pour solutionné le problème . 

Si j'ai un problème de communication entre le client et le serveur il y a 3 possibilités :

* La connectivité est problématique : __Firewall__ bloque les communications ou le paquets n'arrive pas a destination 
* Le serveur ne traite pas la communication adéquatement ne fournissant la de réponse adéquate 
* Le client n'envoie pas la requête au bon serveur ou la requête est mal formé

Je vais partir du principe que vous avez accès au 2 équipements suivant :

* La machine client 
* Le serveur 

Pour les besoins de la démonstration je vais utiliser 2 services __snmpd__ pour __l'UDP__ et __apache__ pour la partie __TCP__ . Nous utiliserons 2 utilitaires __netcat (nc)__ pour simulé un client/serveur __UDP__ et __TCP__ ainsi que __telnet__ car je l'aime bien pour la partie __TCP__

### <a name="tcp_timout"/> Visualisation d'un problème de communication à cause du firewall pour TCP

Pour commencé nous allons voir comment identifier s'il y a un problème de __firewall__ . Voyons le comportement quand il y a une indisponibilité de connexion dû au __firewall__.

J'ai :

* client : 172.17.42.1 
* serveur (apache) : 172.17.0.1 

Pour rappel quand tous va bien lors de l'établissement de connexion entre le client et le serveur je doit avoir :

* Établissement de connexion  ( __3 way handshake__ ) / __SYN__, __SYN-ACK__ , __ACK__
* Transfert de données avec accusé de réception (__ACK__)
* Fermeture de connexion  (__FIN-ACK__, __FIN-ACK__, __ACK__)

Voici un rappel de la copie d'écran de __wireshark__ :

![wireshark_visualisation_fureteur_07.png](./imgs/wireshark_visualisation_fureteur_07.png)

Maintenant, je vais ajouter une règle de __firewall__ qui bloque la communication , je vais utilisé un **DROP** ce qui fait en sorte que le paquet est mis à la poubelle sans avertissement au client .

Je met ici les instructions __iptables__ cependant ceci est en dehors de la formation, je ne veux pas faire de Linux ici. Par contre si vous avez des questions n'hésitez pas à communiquer avec moi en dehors :).

Comme j'utilise docker j'installe __iptables__ si requis et j'active la règle pour bloquer l'accès en entré :

        $ iptables -I INPUT -p tcp --destination-port 80 -j DROP
        Chain INPUT (policy ACCEPT)
        target     prot opt source               destination
        DROP       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80

        Chain FORWARD (policy ACCEPT)
        target     prot opt source               destination

        Chain OUTPUT (policy ACCEPT)
        target     prot opt source               destination

Reprenons la requête avec le fureteur afin de voir le comportement ...  Le résultat est que la roulette tourne , tourne , tourne ... Sans retour . Le premier réflexe que je vous conseil est d'enlever le fureteur de l'équation afin de valider si la communication __TCP__ fonctionne :

        $ telnet 172.17.0.8 80
        Trying 172.17.0.8...
        telnet: Unable to connect to remote host: Connection timed out

Nous avons aussi un __timeout__ , visualisons le comportement avec __wireshark__ :

![proc_tcp_drop_firewall.png](./imgs/proc_tcp_drop_firewall.png)

Donc nous voyons les 3 tentatives du protocole __TCP__ qui sont transmis ainsi que les retransmissions , ceci fut réalisé avec le fureteur . Comme le protocole __TCP__ sait que le réseau IP est non fiables il essaye plusieurs fois :P , peut-être que le paquet fut perdu lors du transfert.
Voici la même opération avec __telnet__ :

![proc_tcp_telnet_drop_firewall.png](./imgs/proc_tcp_telnet_drop_firewall.png)

Nous voyons que ce dernier est moins agressif. 

Nous pouvons aussi constater que lorsqu'il y a un __Firewall__ la méthode "classique" est de **droppé** les paquets donc de ne pas y répondre . Si le service apache n'écoutais pas  sur le port comme c'est le cas pour le port 8080 par exemple nous aurions un comportement différent .

        $ telnet 172.17.0.8 8080
        Trying 172.17.0.8...
        telnet: Unable to connect to remote host: Connection refused

Et au niveau de __wireshark__ :

![connexion_refused_no_process.png](./imgs/connexion_refused_no_process.png)

Au risque de me tromper je vous suggère cette règle : 

* Si vous avez une connexion refusé alors le processus n'est pas en exécution 
* S'il y a un __timeout__ , il y a possiblement un __firewall__ entre les 2 :P

Mais pourquoi utiliser __telnet__ et pas mon __fureteur__ il fonctionne aussi bien , la réponse est NON :P . L'avantage de __telnet__ est qu'il vous indique si la connexion __TCP__ (__3 way handshake__) à fonctionné et après traite les données , votre fureteur ne fait pas la distinction. 

Je vais désactivé la règle de __firewall__ :

        $ iptables -D INPUT -p tcp --destination-port 80 -j DROP

Maintenant j'accède à l'URL : http://172.17.0.8/time.php

Vous pouvez voir mon fureteur tourne dans le beurre encore une fois ... Si je fais la commande avec __telnet__

        $ telnet 172.17.0.8 80
        Trying 172.17.0.8...
        Connected to 172.17.0.8.
        Escape character is '^]'.
        ^]
        telnet> q
        Connection closed.

Je vois clairement que la communication __TCP__ à fonctionné , donc le problème n'est PAS au niveau réseau, mais au niveau de l'application ! Bon effectivement __time.php__ fait plein de __sleep__ pour mettre une éternité pour répondre :P.
Voilà pourquoi vous me voyez toujours utiliser __telnet__ pour analyser si j'ai la ligne **Connected to 172.17.0.8.** donc voir si le lien réseau fonctionne !!


### <a name="tcp_validation_comm"/> Validation de la communication sans application

Mise en situation , vous avez une mise en production planifier en pleine nuit, vous avez transmis votre demande à l'équipe de réseau pour l'ouverture de flux entre 2 système malheureusement votre application n'est pas encore déployer. De prime à bord, vous ne pouvez pas valider la communication avant la mise en production qui est en pleine nuit.
Vous êtes stressé, car la fenêtre de maintenance est très courte et vous avez déjà des inquiétudes sur le déploiement applicatif, vous vous dites que s'il y a un problème de flux vous n'arriverez jamais dans le temps. Même si l'équipe de réseau est disponible sur appel __7x24__. 

Comme nous n'aimons pas le stress voici une solution pour vous , nous allons utiliser la commande **nc** et **netcat** le couteau suisse du réseau. Non ce n'est pas comme le fromage suisse il n'y a pas de trou dedans :P.

J'ai :

* client : 172.17.42.1
* serveur : 172.17.0.1

Si j établie une connexion sur le serveur et que je réalise la commande __netstat__ afin de visualiser les ports disponible:

        server$ sudo netstat -lntp
        Active Internet connections (only servers)
        Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
        tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      8/sshd      

Donc je n'ai que le port 22 de disponible , mais mon application qui sera déployée utilise le port 31337 :P. Normalement l'ensemble du flux est ouvert mais si je réalise la commande __telnet__ sur ce port bien entendu j'aurais le résultat suivant :

        client$ telnet 172.17.0.1 31337
        Trying 172.17.0.1...
        telnet: Unable to connect to remote host: Connection refused

Bon si je fais un raccourci , je sais que le __firewall__ est ouvert car j'ai un refus de connexion  et non un __timeout__ mais si c'était avec le protocole **udp** ?!?!

        client$ nc -u 172.17.0.1 31337
        blabla
        read(net): Connection refused

Bon ma démonstration marche pas :P , je voulais une absence de connexion , mais bon ça change peu de chose à ce stade on n'a pas la CONFIRMATION que la communication fonctionne ...

Je vais démarrer sur le serveur l'application **nc** pour qu'il écoute sur le port 31337 en __TCP__.

        server$ nc -l -p 31337

Sur le coté client j'établis la connexion 

        client$ telnet 172.17.0.1 31337
        Trying 172.17.0.1...
        Connected to 172.17.0.1.
        Escape character is '^]'.
        SUPER COOL
        blabla
        ^]
        telnet> q
        Connection closed.

Voici le résultat coté serveur 

        server$  nc -l -p 31337
        SUPER COOL
        blabla

Nous pouvons réaliser la même opération avec le protocole __UDP__:
au niveau serveur , je change la commande pour avoir l'option **-u** pour __UDP__

        server$ nc  -u -l -p 31337

Si j'essaye une communication __TCP__ nous aurons une connexion refusée :

        client$ telnet 172.17.0.1 31337
        Trying 172.17.0.1...
        telnet: Unable to connect to remote host: Connection refused

Avec **nc** en mode __UDP__

        client$ nc -u 172.17.0.1 31337
        bonjour
        blabla en UDP

Côté serveur : 

        server$ nc  -u -l -p 31337
        bonjour
        blabla en UDP
        ^C

Voici quelques utilisation très courante de **nc** :

* Désire valider la communication avec un service __UDP__ , principalement avec le service __snmp__ quand je ne sais pas si la communication arrive au serveur ou s'il y a un problème avec ma configuration __snmpd__ . L'utilisation de l'option en __UDP__ est particulièrement intéressante, car ceci me permet d'enlever l'application serveur de l'équation
* Quand je désire ouvrir un port pour un service dynamique , exemple j'utilise le protocole FTP , le protocole utilise des ports pour l'échange des données malheureusement ces ports ne sont pas ouvert de manière constante , ceci est uniquement lors de l'utilisation. Avec __nc__ ceci me permet d'ouvrir le port et de valider que la communication transige bien par le __firewall__.

Voilà c'est déjà pas mal :D.

## <a name="tcp_drop_restart"/> Visualisation d'une coupure de communication lors d'un transfert de paquet

Maintenant que nous avons identifié un problème de connexion qui ne fonctionne pas passons à un problème intermittent .
Ceci est le plus compliqué à identifier , je ne dis pas que j'ai la solution exacte, cependant vous permettra d'avoir un aperçu concret lorsque la situation ce produit. Chaque problème étant particulier à vous de l'adapter dans votre réalité .

Je vais utilisé le protocole SSH afin de faire la démonstration , j'ai une machine avec l'IP : __172.17.0.2__ qui a le service SSH présent nous allons faire un transfert de fichier avec __SCP__ pour le transfert.

* client : 172.17.42.1
* serveur : 172.17.0.2

Voici l'opération quand tous vas bien :

        $ scp bob@172.17.0.2:./usr-share-vim.tar /tmp/
        bob@172.17.0.2's password: 
        usr-share-vim.tar                              100%   25MB  25.2MB/s   00:01


Bon si nous regardons nous avons bien le __3 way handshake__ (__SYN , SYN/ACK, ACK__) , nous avons du transfert et la fin de connexion ( __FIN/ACK , ACK, FIN/ACK, ACK__). Si vous regardez attentivement vous constaterez qu'il y a aussi des messages étrange que nous n'avions encore jamais vu : **TCP Full Window** et **TCP ZeroWindows** , puis ils sont en noir et rouge , ça sonne PAS bon pourtant nous n'avons pas encore créer de __noise__ sur la ligne.

![transfert_scp_msg_windows_full.png](./imgs/transfert_scp_msg_windows_full.png)

Référence du problème __wireshark__ :  [https://ask.wireshark.org/questions/24501/why-would-tcp-full-window-happen](https://ask.wireshark.org/questions/24501/why-would-tcp-full-window-happen)

Premièrement ce n'est PAS une erreur ceci est simplement un avertissement , si vous avez le message **TCP Full Window** et que vous avez après **TCP ZeroWindows** il n'y a PAS de problème. Ok cool mais POURQUOI ?

Regardons cette nouvelle copie d'écran :

![transfert_scp_msg_windows_full_2.png](./imgs/transfert_scp_msg_windows_full_2.png)

Afin d'optimiser le transfert __TCP__ entre le client et le serveur négocie un nombre de paquet (__windows size__) qui peut être transféré entre le client et le serveur sans que le client soit obligé de confirmer la réception. 

Voici un exemple :

* Le client (récepteur) ssh avise qu'il va prendre une fenêtre TCP de 5000 bytes
* Le serveur (émetteur) envoie 5 paquets TCP d'une longueurs de 1000 chaque
* Il n'y a AUCUN accusé de réception des paquets pour ces 5 .
* __Wireshark__ mark le 5ieme paquet avec l'identifiant __TCP WINDOWS FULL__ afin d'indiquer qu'il n'y a pas eu de __ACK__ pour ces dernier.

Le client à 3 possibilités :

* Transmettre le message __\[Zero Windows\]__ : indiquant que son __buffer__ est plein et d'attendre que ce dernier est fini de traiter les données
* Transmettre le message __\[TCP Window Update\]__ : indiquant qu'il traite encore des données mais que ça fenêtre est un peu libre donc que le serveur peut remplir N bytes
* Transmettre le __ACK__ : Afin d'indiquer au serveur que l'on peut reprendre le transfert .


Maintenant que nous avons vu le comportement quand tous va "bien" malgré les messages d'avertissement de __wireshark__ sur la question de la fenêtre de transmission reprenons l'opération. Cette fois ci, je vais faire le transfert mais en plein milieu je vais bloquer la communication avec une règle de __firewall__ afin de simuler une coupure de connexion. La coupure sera temporaire quelques secondes afin de voir le comportement quand la communication reprend.
La règle de __firewall__ fut mis en place pour coupé les communications sur le port 22 du __client__ **vers** le __serveur__.

Voici le résultat à l'écran:

        $ scp bob@172.17.0.2:./usr-share-vim.tar /tmp/
        bob@172.17.0.2's password:
        usr-share-vim.tar                                           35% 9088KB   2.8MB/s - stalled -
        [... COUPURE PUIS la reprise ...]
        usr-share-vim.tar                                           100%   25MB  25.2MB/s   00:01

Si nous regardons le résultat au niveau de __wireshark__ :

![transfert_scp_bloque_with_iptables.png](./imgs/transfert_scp_bloque_with_iptables.png)

C'est partie :D :D , le plaisir commence :D , pour bien comprendre le mécanisme de récupération et retransmission il faut ce concentré sur les numéros de séquence des paquets (**seq**) qui permet de suivre le numéro de chaque paquet , ainsi que les confirmation de réception (**ACK**) qui sont en relation avec séquence de transmission. Un petit rattrapage sur la théorie, car j'avais mis de coté cette aspect dans l'attente d'avoir un exemple concret.
Avec __wireshark__ vous pouvez visualiser la séquence d'échange **seq** et **ack** , pour ce faire ouvrez un fichier de trace et sélectionnez dans le menu **statistics --> Flow graph**.

Voici un exemple de résultat:

![tcp_flow.png](./imgs/tcp_flow.png)

* Client : 192.168.1.2
* Serveur : 174.143.213.18

Voici une petite explication quand tous fonctionne bien ;-) :

1. Établissement de connexion
    1. Client : **Syn** (__seq=0,ack=94856056__) , le premier paquet , le numéro de __ack__ est aléatoire dans ce cas il sera réinitialisé à zéro par la suite une fois le dialogue établie.
    2. Serveur : **Syn,Ack** (__seq=0,ack=1__) Le client débute ça séquence aussi à 0, mais la valeur de __ack__ est à 1 , lors de la présence d'un **SYN** ou **FIN** le numéro de **ACK** est incrémenté.
    3. Client : **Ack** (__seq=1,ack=1__) Le client transmet le **ack** de fin d'établissement de connexion , il prend la valeur du __ACK__ reçu et l'assigne au numéro de séquence.
2. Transfert de donnée du client vers le serveur 
    * Client : **Psh,Ack len(725)** (__seq=1,ack=1__) Le client transfert un paquet d'une longueur de 725 au serveur
3. Réponse du serveur des données reçu
    * Serveur : **ACK** (__seq=1,ack=726__) , le serveur confirme la réception du paquet précédent , lors du __ack__ il incrément la valeur **1** original de son coté et l'incrément de la longueur du dernier paquet reçu soit **725** . Résultat lors de ça réponse la valeur de __ack__ est (1+725=726). C'est comme si le serveur répondais j'ai bien reçu un paquet de 725.
4. Transfert du serveur vers le client
    * Serveur : **ACK len(1448)** (__seq=1,ack=726__), le serveur transmet un paquet __ack__ d'une taille de 1448. 
5. Réponse du client après la réception des données du serveur
    * Client : **ACK** (__seq=726,ack=1449__), donc de la séquence du client à augmenté représentant la quantité de données déjà transmisse. Tous comme le serveur il incrémente la valeur de __ack__ avec la quantité de donnée reçu du serveur
6. Serveur retransmet des données
    * Serveur : **ACK len(1448)** (__seq=1449,ack=726__) le serveur retransmet un paquet de 1448, le numéro de séquence est 1449 car le serveur n'a transmit pour le moment qu'un paquet de 1448 + 1 , le numéro de confirmation (__ack__) correspond à 1 + 725 (quantité de donnée transmise par le client)
7. Le client confirme la réception
    * Client : **ACK** (__seq=726,ack=2897__) , le client à transmit un paquet paquet d'une taille de 1 + 725 donc sont numéro de séquence n'augmente PAS, uniquement le numéro de confirmation __ack__ qui représente (1+1448+1448).
8. Etc jusque la fin de la connexion :P...

Référence : [http://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/](http://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/)

Bon après se long texte quand tous va bien maintenant on revient à notre problème :P :

* #1583 : Le client transmet __ACK__ pour confirmer la réception du transfert (malheureusement la règle de __firewall__ bloque la transmission vers serveur, mais le client ne le sais pas encore) (__seq=5046, Ack=9337176__)
* #1584 : Le client transmet un paquet chiffré au serveur ( mais ce dernier ne le recevra PAS à cause du __firewall__) (__seq=5046, Ack=9337176__)
* #1585 : Le serveur transmet un paquet car lui n'a aucun problème de communication avec le client (__seq=9337176,Ack=5046__)
* #1586 : Le client transmet un paquet chiffré toujours (__seq=5082,ack=9338624__)
* #1587 : Le client transmet un autre paquet chiffré (__seq=5118,ack=9338624__)
* #1588 : Le client retransmet le dernier paquet(__seq=5118,ack=9338624__), pourquoi ? Car il à attendu un certain temps mais le serveur n'a pas continuer à retransmettre des paquets. Si vous regarder la colonne __time__ le chiffre est significativement plus haut que lors du transfert régulier de paquet. Bien entendu ce paquet n'arrivera JAMAIS au serveur
* #1589 : Le client transmet un paquet , car comme nous avons activé le mode __drop__ dans le __firewall__ le client croit que le paquet est arrivé RIEN ne lui indique qu'il y a eu un problème il doit attendre la confirmation de réception du serveur ou l'absence de confirmation pour savoir qu'il y a eu un problème (__seq=5154,ack=9338624__)
* #1590 : Le client transmet un paquet car il croit que les 2 derniers furent reçu (__seq=5190,ack=9338624__)
* #1591 : Le serveur ne recevant pas d'accusé de réception refait l'envoie : (__seq=9261396,ack=5046__)
* #1592 : Le client à reçu la demande du serveur , car la communication n'est pas bloqué dans ce sens il renvoie donc le __ACK__ en fait il dit qu'il a de la disponibilité dans la fenêtre __TCP__ (__seq=5226,ack=9338624__)
* #1593 : Le client retransmet  (__seq=5046,ack=9338624__)
* #1594 : Le serveur retransmet le paquet **#1591** (__seq=9261396,ack=5046__)
* #1595 : Le client retransmet le paquet **#1592** (__seq=5226,ack=9338624__)
* #1596 : Le client retransmet le paquet (__seq=5046,ack=9338624__)
* #1597 : Le serveur retransmet le paquet **#1578** (__seq=9261396,ack=5046__)
* #1598 : Le client retransmet un autre __ACK__ équivalent au paquet **#1595** et **#1592** (__seq=5226,ack=9338624__)
* #1599 : Le client retransmet le paquet **#1596**(__seq=5046,ack=9338624__)
* #1600 : Le serveur renvoie le paquet **#1594** ou **#1591**(__seq=9261396,ack=5046__)

Le jeu va continuer comme ça jusqu'au moment ou le __timeout__ de communication sera atteint et que le serveur coupe la communication, car il ne reçoit plus d'information du client.


## <a name="dns_problem"/> Problème DNS IP  externe VS ip interne

Une problématique que j'ai rencontré de manière récurrente est l'utilisation des adresses IP externe pour l'accès à des service Interne voyons le diagramme suivant :

|[Dia_network_DNS-ip_interne_externe.png](./imgs/Dia_network_DNS-ip_interne_externe.png)

Environnement classique un réseau __LAN__ (192.168.10.0/24) et une __DMZ__ (192.168.66.0/24) , la __DMZ__ permet de fournir des service sur internet tous en limitant l'accès depuis internet vers le réseau local (__LAN__).

Le serveur web à une adresse IP interne 192.168.66.20 et écoute sur le port 80. Le serveur web peut aussi être rejoint depuis internet le __Firewall__ réalise une redirection de port / __port forward__ (__PNAT, port Nat__)  vers l'IP internet.
Donc quand il y a une requête sur l'IP 64.73.4.82:80 ceci est redirigé vers l'IP 192.168.66.20:80. Nous voyons clairement le cheminement avec la flèche **BLEU**.

Si nous prenons la configuration __DNS__ pour le nom __mouton.x3rus.com__ par exemple depuis l'extérieure les __DNS__ retournerons l'IP 64.73.4.82. 

Arrivons maintenant à la situation problématique, quand le client interne désire communiquer avec le serveur web dans la __DMZ__ ? Si le client interne réalise la même requête qu'à l'externe et qu'il récupère l'IP externe . (voir flèche **ROUGE**).

Le client (IP : 192.168.10.30) transmet le paquet __TCP__ au :

1. __firewall__ donc vers l'Internet, car la table de routage, indique que c'est une IP qui n'est pas sur le réseaux donc passerelle par défaut . 
2. Lors de la réception de la requête le __firewall__ analyse le paquet dont la destination est __64.73.4.82:80__ provenant de la carte réseau **LAN**. (Prendre note que l'adresse IP externe est configurer sur la carte **WAN**)  
3. Le __firewall__ **NAT** la requête avec l'adresse IP extérieur car l'IP dans le paquet __TCP__ stipule une destination publique.
    * Résultat :
        * de : **src:** 192.168.10.30:87367 | **dst:** 64.73.4.82:80 
        * à : **src:** 64.73.4.81:87367 | **dst:** 64.73.4.82:80 
4. Le paquet __NAT__ est prêt à sortir de la carte **WAN** , malheureusement la destination est lui même , le paquet ne revient pas dans le __firewall__ car il est sortie de la séquence de traitement.

À l'URL suivant vous aurez le chemin des paquets pour le  __TCP__ : [https://commons.wikimedia.org/wiki/File:Netfilter-packet-flow.svg](https://commons.wikimedia.org/wiki/File:Netfilter-packet-flow.svg) 

Si nous reprenons la même situation lors de la connexion depuis l'externe :

1. __Firewall__ reçoit la requête depuis le client externe (204.73.29.72:9837) pour l'IP __64.73.4.82:80__
2. La requête arrive sur le port **WAN** et le traitement du **PNAT** (redirection de port) est réalisé dans le traitement de __pre-ROUTING__ .
    * Résultat :
        * de : **src** 204.73.29.72:9837 | **dst** 64.73.4.82:80
        * à : **src** 204.73.29.72:9837 | **dst** 192.168.66.20:80
3. Le traitement de routage est fait **après** le __prerouting__ , le paquet est transmis à l'interface __DMZ__
4. Le paquet est transmis à la machine 192.168.66.20 soit le serveur WEB.

La solution au problème est d'avoir un système de __split-DNS__ en d'autre mot lors que le client réalise des requêtes depuis l'interne au lieu d'avoir comme réponse l'IP externe (Internet) il reçoit l'adresse IP interne corrigeant le problème de double __Nating__ problématique. 

**ATTENTION**: Je ne dis pas qu'il est impossible de faire en sorte que le __firewall__ réussisse à faire un tour de passe passe pour que ça fonctionne . Le problème est que ça complexifie **énormément** la configuration et encore plus l'analyse de problème !! De plus certain __firewall__ privatif ne le permette pas !

# Visualisation du cheminement du paquet afin d'identifier les équipements potentiellement problématique

* Comme nous avions vu avec le timeout du TCP keep alive 
* TODO voir comment faire la démo :(.

# Faire attention au netmask 

* Voir que parfois on a l'impression que c le même network mais le netmask est important

# Explication rapide VLAN trunk pour ESX

* Expliquer pourquoi un ESX peut avoir plusieurs réseaux alors qu'il n'a que 2 prises

# Utilisation de TcPdump pour visualiser la communication serveur

* Utilisation de snmp afin de visualiser la communication sur le serveur
* Récupération du fichier de data

# Problème de communication avec un service SSL 

* réalisation script python , communication avec le service https normale + un 404 sans msg bien
* Prendre la clef prive du srv https et déchiffrer le contenu de la communication

https://wiki.wireshark.org/SSL

# Calcule taille de la communication

* Faire une communication normale avec un serveur http, avec calcule size communication
* Activer le mod deflate
* Refaire la meme communication et faire le calcule de la taille des paquet de la communications

# Avec time.php montré le keep-alive lors du tcpdump

* Pour visualisé l'opération du browser lors d'un traitement trop long.
