<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 


# <a name="Introduction" /> Introduction 

Nous avons vue dans la première partie la théorie des protocoles réseaux __TCP__ , __UDP__ et __IP__. Lors des différentes démonstration tous fonctionnait sans problème. Dans la vie ce n'est pas aussi jolie , quand on vous demande de réaliser une analyse sur un problème, il faut être en mesure d'identifier les problèmes. Nous allons donc maintenant passer à l'étape quand tous ne fonctionne pas afin d'avoir des indices pour identifier les problématiques .
Bien entendu je ne serai jamais en mesure de couvrir l'ensemble des problèmes que vous pouvez rencontrer, cependant j'espère en couvrir assez afin de vous offrir les outils pour diagnostiquer la source du problème . Vous pourrez par la suite identifier l'équipement et la méthode de résolution approprié.

# <a name="couche_IP"/> Communication entre 2 systèmes

Commençons par la couche inférieur donc la couche IP puis nous monterons tranquillement , vers la couche applicative. Nous aurons l'occasion par la suite de voir les protocoles applicatifs telle que __HTTP__**S** avec __wireshark__.

## <a name="ip_probleme_route"/> Problème de routage de paquets

Nous allons maintenant voir un problème de communication entre 2 machines , voici le schéma :

![dia_network_docker_plus_roger.png](./imgs/dia_network_docker_plus_roger.png)

Donc nous avons 2 cartes réseau:

* **wlan0** : la carte sans file avec l'adresse IP 192.168.43.191
* **docker0** : carte virtuelle docker avec l'IP  172.17.0.1

Sous l'interface **docker0** il y a un sous réseau connecté directement sur la carte qui comprend l'ensemble du réseau 172.17.0.0/16 . Dans le réseau 172.17.0.0/16 , nous avons une machine 172.17.0.4 de disponible .

Si j'essaye de réaliser un **PING** de la machine voici le retour : 

        $ ping 172.17.0.4
        PING 172.17.0.4 (172.17.0.4) 56(84) bytes of data.
        From 192.168.142.2 icmp_seq=1 Packet filtered
        From 192.168.142.2 icmp_seq=2 Packet filtered
        From 192.168.142.2 icmp_seq=3 Packet filtered
        ^C
        --- 172.17.0.4 ping statistics ---
        3 packets transmitted, 0 received, +3 errors, 100% packet loss, time 2002ms

Nous avons le message que le paquet fut filtré par le routeur 192.168.142.2 , ce qui est étrange , voyons ce que la commande **traceroute** nous retourne  :

        $ traceroute 172.17.0.4
        traceroute to 172.17.0.4 (172.17.0.4), 30 hops max, 60 byte packets
         1  gateway (192.168.43.1)  3.181 ms  2.724 ms  3.004 ms
         2  * * *
         3  192.168.142.2 (192.168.142.2)  415.969 ms !X 192.168.142.66 (192.168.142.66)  463.790 ms !X  463.809 ms !X

Reprenons le schéma réseau un peu plus haut, ce n'est PAS normale que le paquet soit dirigé var le routeur **192.168.43.1** , selon le schéma ceci devrait être dirigé vers l'interface **docker0** .

Je vais démarrer **wireshark** sur l'interface **wlan0** pour voir le comportement et refaire le __ping__:

![prob_route_wireshark_wlan0_filtered.png](./imgs/prob_route_wireshark_wlan0_filtered.png)

Nous voyons clairement que sur l'interface **wlan0** il y a du trafic et le message est très explicite : __Destination unreachable (Communication administratively filtered)__

Si je réalise le même filtrage sur l'interface **docker0** je n'ai aucun trafic , aucun paquet RIEN !!!

Essayons peut-être un accès SSH après tous juste un problème de __ping__ ce n'est pas la fin du monde :P  :

        $ telnet 172.17.0.4 22
        Trying 172.17.0.4...
        telnet: Unable to connect to remote host: No route to host

Et au niveau du __wireshark__ :

![prob_route_wireshark_wlan0_filtered_telnet_22.png](./imgs/prob_route_wireshark_wlan0_filtered_telnet_22.png)

Humm, c'est pas mieux :p , __nice try__ :)
Visualisons  les routes à présent indiquant le chemin que doit prendre les communications IP 

        $ route -n
        Kernel IP routing table
        Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
        0.0.0.0         192.168.43.1    0.0.0.0         UG    600    0        0 wlan0
        192.168.43.0    0.0.0.0         255.255.255.0   U     600    0        0 wlan0

Effectivement il n'y a aucune instruction pour l'interface **docker0** . Je vais donc faire l'ajout de l'instruction à la table de routage :

        $ sudo route add -net 172.17.0.0 netmask 255.255.0.0 dev docker0
        $ route -n
        Kernel IP routing table
        Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
        0.0.0.0         192.168.43.1    0.0.0.0         UG    600    0        0 wlan0
        172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
        192.168.43.0    0.0.0.0         255.255.255.0   U     600    0        0 wlan0

ENCORE , comme dirait mon fils :D  :

        $  ping 172.17.0.4
        PING 172.17.0.4 (172.17.0.4) 56(84) bytes of data.
        64 bytes from 172.17.0.4: icmp_seq=1 ttl=64 time=0.176 ms
        64 bytes from 172.17.0.4: icmp_seq=2 ttl=64 time=0.114 ms


Et voilà , quand on prend le bon chemin ça va mieux :D 

## <a name="ip_probleme_nat"/> Problème de cheminement de paquet

Regardons cette infrastructure :

![infra_demo_formaton.png](./imgs/infra_demo_formaton.png)

Nous avons le réseau réseau 172.30.0.0/16 qui est le réseau utilisé dans l'infrastructure , nous avons aussi 2 réseaux en dehors du réseau 192.168.42.0/24 et 192.168.43.0/24 . Les 2 réseaux 192 sont routé sur le réseau globale par la machine 172.30.4.48 , ce qui leur permet de communiquer avec les autres machines . 

Nous allons voir une situation particulière qui fait en sorte que la machine 192.168.42.10 n'est pas en mesure de communiquer avec la machine 172.30.38.38. 

Si je suis sur la machine 172.30.4.48 donc le routeur des réseaux 192.168.42.0/24 , je suis en mesure de réaliser un __ping__ de la machine.

        $  ping 172.30.38.38
        PING 172.30.38.38 (172.30.38.38) 56(84) bytes of data.
        64 bytes from 172.30.38.38: icmp_seq=1 ttl=64 time=0.176 ms
        64 bytes from 172.30.38.38: icmp_seq=2 ttl=64 time=0.114 ms


Si j établie une connexion sur la machine 192.168.42.10 et que je réalise la même opération :


        $  ping 172.30.38.38

Je n'ai pas de résultat , POURQUOI ?

Analysons la situation , nous allons utiliser la commande __tcpdump__ pour réaliser l'analyse de la situation .

TODO

# <a name="couche_TCP"/> Communication entre 2 systèmes

## <a name="tcp_timeout_drop"/> Analyse d'un problème de communication TCP ou UDP

Un problème classique avec le protocole __TCP__ est un problème de connexion entre le client et le serveur, nous avons un problème et le réflexe est de blâmé le __firewall__ ou le réseau. Ce réflexe est naturel, car souvent cette partie est géré par une autre équipe et nous n'avons pas le contrôle. Nous allons donc voir comment identifier le problème afin de faire la demande approprié pour solutionné le problème . 

Si j'ai un problème de communication entre le client et le serveur il y a 3 possibilités :

* La connectivité est problématique : __Firewall__ bloque les communications ou le paquets n'arrive pas a destination 
* Le serveur ne traite pas la communication adéquatement ne fournissant la de réponse adéquate 
* Le client n'envoie pas la requête au bon serveur ou la requête est mal formé

Je vais partir du principe que vous avez accès au 2 équipements suivant :

* La machine client 
* Le serveur 

Pour les besoins de la démonstration je vais utiliser 2 services __snmpd__ pour __l'UDP__ et __apache__ pour la partie __TCP__ . Nous utiliserons 2 utilitaires __netcat (nc)__ pour simulé un client/serveur __UDP__ et __TCP__ ainsi que __telnet__ car je l'aime bien pour la partie __TCP__

### <a name="tcp_timout"/> Visualisation d'un problème de communication à cause du firewall pour TCP

Pour commencé nous allons voir comment identifier s'il y a un problème de __firewall__ . Voyons le comportement quand il y a une indisponibilité de connexion dû au __firewall__.

J'ai :

* client : 172.17.42.1 
* serveur (apache) : 172.17.0.1 

Pour rappel quand tous va bien lors de l'établissement de connexion entre le client et le serveur je doit avoir :

* Établissement de connexion  ( __3 way handshake__ ) / __SYN__, __SYN-ACK__ , __ACK__
* Transfert de données avec accusé de réception (__ACK__)
* Fermeture de connexion  (__FIN-ACK__, __FIN-ACK__, __ACK__)

Voici un rappel de la copie d'écran de __wireshark__ :

![wireshark_visualisation_fureteur_07.png](./imgs/wireshark_visualisation_fureteur_07.png)

Maintenant, je vais ajouter une règle de __firewall__ qui bloque la communication , je vais utilisé un **DROP** ce qui fait en sorte que le paquet est mis à la poubelle sans avertissement au client .

Je met ici les instructions __iptables__ cependant ceci est en dehors de la formation, je ne veux pas faire de Linux ici. Par contre si vous avez des questions n'hésitez pas à communiquer avec moi en dehors :).

Comme j'utilise docker j'installe __iptables__ si requis et j'active la règle pour bloquer l'accès en entré :

        $ iptables -I INPUT -p tcp --destination-port 80 -j DROP
        Chain INPUT (policy ACCEPT)
        target     prot opt source               destination
        DROP       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80

        Chain FORWARD (policy ACCEPT)
        target     prot opt source               destination

        Chain OUTPUT (policy ACCEPT)
        target     prot opt source               destination

Reprenons la requête avec le fureteur afin de voir le comportement ...  Le résultat est que la roulette tourne , tourne , tourne ... Sans retour . Le premier réflexe que je vous conseil est d'enlever le fureteur de l'équation afin de valider si la communication __TCP__ fonctionne :

        $ telnet 172.17.0.8 80
        Trying 172.17.0.8...
        telnet: Unable to connect to remote host: Connection timed out

Nous avons aussi un __timeout__ , visualisons le comportement avec __wireshark__ :

![proc_tcp_drop_firewall.png](./imgs/proc_tcp_drop_firewall.png)

Donc nous voyons les 3 tentatives du protocole __TCP__ qui sont transmis ainsi que les retransmissions , ceci fut réalisé avec le fureteur . Comme le protocole __TCP__ sait que le réseau IP est non fiables il essaye plusieurs fois :P , peut-être que le paquet fut perdu lors du transfert.
Voici la même opération avec __telnet__ :

![proc_tcp_telnet_drop_firewall.png](./imgs/proc_tcp_telnet_drop_firewall.png)

Nous voyons que ce dernier est moins agressif. 

Nous pouvons aussi constater que lorsqu'il y a un __Firewall__ la méthode "classique" est de **droppé** les paquets donc de ne pas y répondre . Si le service apache n'écoutais pas  sur le port comme c'est le cas pour le port 8080 par exemple nous aurions un comportement différent .

        $ telnet 172.17.0.8 8080
        Trying 172.17.0.8...
        telnet: Unable to connect to remote host: Connection refused

Et au niveau de __wireshark__ :

![connexion_refused_no_process.png](./imgs/connexion_refused_no_process.png)

Au risque de me tromper je vous suggère cette règle : 

* Si vous avez une connexion refusé alors le processus n'est pas en exécution 
* S'il y a un __timeout__ , il y a possiblement un __firewall__ entre les 2 :P

Mais pourquoi utiliser __telnet__ et pas mon __fureteur__ il fonctionne aussi bien , la réponse est NON :P . L'avantage de __telnet__ est qu'il vous indique si la connexion __TCP__ (__3 way handshake__) à fonctionné et après traite les données , votre fureteur ne fait pas la distinction. 

Je vais désactivé la règle de __firewall__ :

        $ iptables -D INPUT -p tcp --destination-port 80 -j DROP

Maintenant j'accède à l'URL : http://172.17.0.8/time.php

Vous pouvez voir mon fureteur tourne dans le beurre encore une fois ... Si je fais la commande avec __telnet__

        $ telnet 172.17.0.8 80
        Trying 172.17.0.8...
        Connected to 172.17.0.8.
        Escape character is '^]'.
        ^]
        telnet> q
        Connection closed.

Je vois clairement que la communication __TCP__ à fonctionné , donc le problème n'est PAS au niveau réseau, mais au niveau de l'application ! Bon effectivement __time.php__ fait plein de __sleep__ pour mettre une éternité pour répondre :P.
Voilà pourquoi vous me voyez toujours utiliser __telnet__ pour analyser si j'ai la ligne **Connected to 172.17.0.8.** donc voir si le lien réseau fonctionne !!


### <a name="tcp_validation_comm"/> Validation de la communication sans application

Mise en situation , vous avez une mise en production planifier en pleine nuit, vous avez transmis votre demande à l'équipe de réseau pour l'ouverture de flux entre 2 système malheureusement votre application n'est pas encore déployer. De prime à bord, vous ne pouvez pas valider la communication avant la mise en production qui est en pleine nuit.
Vous êtes stressé, car la fenêtre de maintenance est très courte et vous avez déjà des inquiétudes sur le déploiement applicatif, vous vous dites que s'il y a un problème de flux vous n'arriverez jamais dans le temps. Même si l'équipe de réseau est disponible sur appel __7x24__. 

Comme nous n'aimons pas le stress voici une solution pour vous , nous allons utiliser la commande **nc** et **netcat** le couteau suisse du réseau. Non ce n'est pas comme le fromage suisse il n'y a pas de trou dedans :P.

J'ai :

* client : 172.17.42.1
* serveur : 172.17.0.1

Si j établie une connexion sur le serveur et que je réalise la commande __netstat__ afin de visualiser les ports disponible:

        server$ sudo netstat -lntp
        Active Internet connections (only servers)
        Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
        tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      8/sshd      

Donc je n'ai que le port 22 de disponible , mais mon application qui sera déployée utilise le port 31337 :P. Normalement l'ensemble du flux est ouvert mais si je réalise la commande __telnet__ sur ce port bien entendu j'aurais le résultat suivant :

        client$ telnet 172.17.0.1 31337
        Trying 172.17.0.1...
        telnet: Unable to connect to remote host: Connection refused

Bon si je fais un raccourci , je sais que le __firewall__ est ouvert car j'ai un refus de connexion  et non un __timeout__ mais si c'était avec le protocole **udp** ?!?!

        client$ nc -u 172.17.0.1 31337
        blabla
        read(net): Connection refused

Bon ma démonstration marche pas :P , je voulais une absence de connexion , mais bon ça change peu de chose à ce stade on n'a pas la CONFIRMATION que la communication fonctionne ...

Je vais démarrer sur le serveur l'application **nc** pour qu'il écoute sur le port 31337 en __TCP__.

        server$ nc -l -p 31337

Sur le coté client j'établis la connexion 

        client$ telnet 172.17.0.1 31337
        Trying 172.17.0.1...
        Connected to 172.17.0.1.
        Escape character is '^]'.
        SUPER COOL
        blabla
        ^]
        telnet> q
        Connection closed.

Voici le résultat coté serveur 

        server$  nc -l -p 31337
        SUPER COOL
        blabla

Nous pouvons réaliser la même opération avec le protocole __UDP__:
au niveau serveur , je change la commande pour avoir l'option **-u** pour __UDP__

        server$ nc  -u -l -p 31337

Si j'essaye une communication __TCP__ nous aurons une connexion refusée :

        client$ telnet 172.17.0.1 31337
        Trying 172.17.0.1...
        telnet: Unable to connect to remote host: Connection refused

Avec **nc** en mode __UDP__

        client$ nc -u 172.17.0.1 31337
        bonjour
        blabla en UDP

Côté serveur : 

        server$ nc  -u -l -p 31337
        bonjour
        blabla en UDP
        ^C

Voici quelques utilisation très courante de **nc** :

* Désire valider la communication avec un service __UDP__ , principalement avec le service __snmp__ quand je ne sais pas si la communication arrive au serveur ou s'il y a un problème avec ma configuration __snmpd__ . L'utilisation de l'option en __UDP__ est particulièrement intéressante, car ceci me permet d'enlever l'application serveur de l'équation
* Quand je désire ouvrir un port pour un service dynamique , exemple j'utilise le protocole FTP , le protocole utilise des ports pour l'échange des données malheureusement ces ports ne sont pas ouvert de manière constante , ceci est uniquement lors de l'utilisation. Avec __nc__ ceci me permet d'ouvrir le port et de valider que la communication transige bien par le __firewall__.

Voilà c'est déjà pas mal :D.

## <a name="tcp_drop_restart"/> Visualisation d'une coupure de communication lors d'un transfert de paquet

Maintenant que nous avons identifié un problème de connexion qui ne fonctionne pas passons à un problème intermittent .
Ceci est le plus compliqué à identifier , je ne dis pas que j'ai la solution exacte, cependant vous permettra d'avoir un aperçu concret lorsque la situation ce produit. Chaque problème étant particulier à vous de l'adapter dans votre réalité .

Je vais utilisé le protocole SSH afin de faire la démonstration , j'ai une machine avec l'IP : __172.17.0.2__ qui a le service SSH présent nous allons faire un transfert de fichier avec __SCP__ pour le transfert.

* client : 172.17.42.1
* serveur : 172.17.0.2

Voici l'opération quand tous vas bien :

        $ scp bob@172.17.0.2:./usr-share-vim.tar /tmp/
        bob@172.17.0.2's password: 
        usr-share-vim.tar                              100%   25MB  25.2MB/s   00:01


Bon si nous regardons nous avons bien le __3 way handshake__ (__SYN , SYN/ACK, ACK__) , nous avons du transfert et la fin de connexion ( __FIN/ACK , ACK, FIN/ACK, ACK__). Si vous regardez attentivement vous constaterez qu'il y a aussi des messages étrange que nous n'avions encore jamais vu : **TCP Full Window** et **TCP ZeroWindows** , puis ils sont en noir et rouge , ça sonne PAS bon pourtant nous n'avons pas encore créer de __noise__ sur la ligne.

![transfert_scp_msg_windows_full.png](./imgs/transfert_scp_msg_windows_full.png)

Référence du problème __wireshark__ :  [https://ask.wireshark.org/questions/24501/why-would-tcp-full-window-happen](https://ask.wireshark.org/questions/24501/why-would-tcp-full-window-happen)

Premièrement ce n'est PAS une erreur ceci est simplement un avertissement , si vous avez le message **TCP Full Window** et que vous avez après **TCP ZeroWindows** il n'y a PAS de problème. Ok cool mais POURQUOI ?

Regardons cette nouvelle copie d'écran :

![transfert_scp_msg_windows_full_2.png](./imgs/transfert_scp_msg_windows_full_2.png)

Afin d'optimiser le transfert __TCP__ entre le client et le serveur négocie un nombre de paquet (__windows size__) qui peut être transféré entre le client et le serveur sans que le client soit obligé de confirmer la réception. 

Voici un exemple :

* Le client (récepteur) ssh avise qu'il va prendre une fenêtre TCP de 5000 bytes
* Le serveur (émetteur) envoie 5 paquets TCP d'une longueurs de 1000 chaque
* Il n'y a AUCUN accusé de réception des paquets pour ces 5 .
* __Wireshark__ mark le 5ieme paquet avec l'identifiant __TCP WINDOWS FULL__ afin d'indiquer qu'il n'y a pas eu de __ACK__ pour ces dernier.

Le client à 3 possibilités :

* Transmettre le message __\[Zero Windows\]__ : indiquant que son __buffer__ est plein et d'attendre que ce dernier est fini de traiter les données
* Transmettre le message __\[TCP Window Update\]__ : indiquant qu'il traite encore des données mais que ça fenêtre est un peu libre donc que le serveur peut remplir N bytes
* Transmettre le __ACK__ : Afin d'indiquer au serveur que l'on peut reprendre le transfert .


Maintenant que nous avons vu le comportement quand tous va "bien" malgré les messages d'avertissement de __wireshark__ sur la question de la fenêtre de transmission reprenons l'opération. Cette fois ci, je vais faire le transfert mais en plein milieu je vais bloquer la communication avec une règle de __firewall__ afin de simuler une coupure de connexion. La coupure sera temporaire quelques secondes afin de voir le comportement quand la communication reprend.
La règle de __firewall__ fut mis en place pour coupé les communications sur le port 22 du __client__ **vers** le __serveur__.

Voici le résultat à l'écran:

        $ scp bob@172.17.0.2:./usr-share-vim.tar /tmp/
        bob@172.17.0.2's password:
        usr-share-vim.tar                                           35% 9088KB   2.8MB/s - stalled -
        [... COUPURE PUIS la reprise ...]
        usr-share-vim.tar                                           100%   25MB  25.2MB/s   00:01

Si nous regardons le résultat au niveau de __wireshark__ :

![transfert_scp_bloque_with_iptables.png](./imgs/transfert_scp_bloque_with_iptables.png)

C'est partie :D :D , le plaisir commence :D , pour bien comprendre le mécanisme de récupération et retransmission il faut ce concentré sur les numéros de séquence des paquets (**seq**) qui permet de suivre le numéro de chaque paquet , ainsi que les confirmation de réception (**ACK**) qui sont en relation avec séquence de transmission. Un petit rattrapage sur la théorie, car j'avais mis de coté cette aspect dans l'attente d'avoir un exemple concret.
Avec __wireshark__ vous pouvez visualiser la séquence d'échange **seq** et **ack** , pour ce faire ouvrez un fichier de trace et sélectionnez dans le menu **statistics --> Flow graph**.

Voici un exemple de résultat:

![tcp_flow.png](./imgs/tcp_flow.png)

* Client : 192.168.1.2
* Serveur : 174.143.213.18

Voici une petite explication quand tous fonctionne bien ;-) :

1. Établissement de connexion
    1. Client : **Syn** (__seq=0,ack=94856056__) , le premier paquet , le numéro de __ack__ est aléatoire dans ce cas il sera réinitialisé à zéro par la suite une fois le dialogue établie.
    2. Serveur : **Syn,Ack** (__seq=0,ack=1__) Le client débute ça séquence aussi à 0, mais la valeur de __ack__ est à 1 , lors de la présence d'un **SYN** ou **FIN** le numéro de **ACK** est incrémenté.
    3. Client : **Ack** (__seq=1,ack=1__) Le client transmet le **ack** de fin d'établissement de connexion , il prend la valeur du __ACK__ reçu et l'assigne au numéro de séquence.
2. Transfert de donnée du client vers le serveur 
    * Client : **Psh,Ack len(725)** (__seq=1,ack=1__) Le client transfert un paquet d'une longueur de 725 au serveur
3. Réponse du serveur des données reçu
    * Serveur : **ACK** (__seq=1,ack=726__) , le serveur confirme la réception du paquet précédent , lors du __ack__ il incrément la valeur **1** original de son coté et l'incrément de la longueur du dernier paquet reçu soit **725** . Résultat lors de ça réponse la valeur de __ack__ est (1+725=726). C'est comme si le serveur répondais j'ai bien reçu un paquet de 725.
4. Transfert du serveur vers le client
    * Serveur : **ACK len(1448)** (__seq=1,ack=726__), le serveur transmet un paquet __ack__ d'une taille de 1448. 
5. Réponse du client après la réception des données du serveur
    * Client : **ACK** (__seq=726,ack=1449__), donc de la séquence du client à augmenté représentant la quantité de données déjà transmisse. Tous comme le serveur il incrémente la valeur de __ack__ avec la quantité de donnée reçu du serveur
6. Serveur retransmet des données
    * Serveur : **ACK len(1448)** (__seq=1449,ack=726__) le serveur retransmet un paquet de 1448, le numéro de séquence est 1449 car le serveur n'a transmit pour le moment qu'un paquet de 1448 + 1 , le numéro de confirmation (__ack__) correspond à 1 + 725 (quantité de donnée transmise par le client)
7. Le client confirme la réception
    * Client : **ACK** (__seq=726,ack=2897__) , le client à transmit un paquet paquet d'une taille de 1 + 725 donc sont numéro de séquence n'augmente PAS, uniquement le numéro de confirmation __ack__ qui représente (1+1448+1448).
8. Etc jusque la fin de la connexion :P...

Référence : [http://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/](http://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/)

Bon après se long texte quand tous va bien maintenant on revient à notre problème :P :

* #1583 : Le client transmet __ACK__ pour confirmer la réception du transfert (malheureusement la règle de __firewall__ bloque la transmission vers serveur, mais le client ne le sais pas encore) (__seq=5046, Ack=9337176__)
* #1584 : Le client transmet un paquet chiffré au serveur ( mais ce dernier ne le recevra PAS à cause du __firewall__) (__seq=5046, Ack=9337176__)
* #1585 : Le serveur transmet un paquet car lui n'a aucun problème de communication avec le client (__seq=9337176,Ack=5046__)
* #1586 : Le client transmet un paquet chiffré toujours (__seq=5082,ack=9338624__)
* #1587 : Le client transmet un autre paquet chiffré (__seq=5118,ack=9338624__)
* #1588 : Le client retransmet le dernier paquet(__seq=5118,ack=9338624__), pourquoi ? Car il à attendu un certain temps mais le serveur n'a pas continuer à retransmettre des paquets. Si vous regarder la colonne __time__ le chiffre est significativement plus haut que lors du transfert régulier de paquet. Bien entendu ce paquet n'arrivera JAMAIS au serveur
* #1589 : Le client transmet un paquet , car comme nous avons activé le mode __drop__ dans le __firewall__ le client croit que le paquet est arrivé RIEN ne lui indique qu'il y a eu un problème il doit attendre la confirmation de réception du serveur ou l'absence de confirmation pour savoir qu'il y a eu un problème (__seq=5154,ack=9338624__)
* #1590 : Le client transmet un paquet car il croit que les 2 derniers furent reçu (__seq=5190,ack=9338624__)
* #1591 : Le serveur ne recevant pas d'accusé de réception refait l'envoie : (__seq=9261396,ack=5046__)
* #1592 : Le client à reçu la demande du serveur , car la communication n'est pas bloqué dans ce sens il renvoie donc le __ACK__ en fait il dit qu'il a de la disponibilité dans la fenêtre __TCP__ (__seq=5226,ack=9338624__)
* #1593 : Le client retransmet  (__seq=5046,ack=9338624__)
* #1594 : Le serveur retransmet le paquet **#1591** (__seq=9261396,ack=5046__)
* #1595 : Le client retransmet le paquet **#1592** (__seq=5226,ack=9338624__)
* #1596 : Le client retransmet le paquet (__seq=5046,ack=9338624__)
* #1597 : Le serveur retransmet le paquet **#1578** (__seq=9261396,ack=5046__)
* #1598 : Le client retransmet un autre __ACK__ équivalent au paquet **#1595** et **#1592** (__seq=5226,ack=9338624__)
* #1599 : Le client retransmet le paquet **#1596**(__seq=5046,ack=9338624__)
* #1600 : Le serveur renvoie le paquet **#1594** ou **#1591**(__seq=9261396,ack=5046__)

Le jeu va continuer comme ça jusqu'au moment ou le __timeout__ de communication sera atteint et que le serveur coupe la communication, car il ne reçoit plus d'information du client.


## <a name="dns_problem"/> Problème DNS IP  externe VS ip interne

Une problématique que j'ai rencontré de manière récurrente est l'utilisation des adresses IP externe pour l'accès à des service Interne voyons le diagramme suivant :

|[Dia_network_DNS-ip_interne_externe.png](./imgs/Dia_network_DNS-ip_interne_externe.png)

Environnement classique un réseau __LAN__ (192.168.10.0/24) et une __DMZ__ (192.168.66.0/24) , la __DMZ__ permet de fournir des service sur internet tous en limitant l'accès depuis internet vers le réseau local (__LAN__).

Le serveur web à une adresse IP interne 192.168.66.20 et écoute sur le port 80. Le serveur web peut aussi être rejoint depuis internet le __Firewall__ réalise une redirection de port / __port forward__ (__PNAT, port Nat__)  vers l'IP internet.
Donc quand il y a une requête sur l'IP 64.73.4.82:80 ceci est redirigé vers l'IP 192.168.66.20:80. Nous voyons clairement le cheminement avec la flèche **BLEU**.

Si nous prenons la configuration __DNS__ pour le nom __mouton.x3rus.com__ par exemple depuis l'extérieure les __DNS__ retournerons l'IP 64.73.4.82. 

Arrivons maintenant à la situation problématique, quand le client interne désire communiquer avec le serveur web dans la __DMZ__ ? Si le client interne réalise la même requête qu'à l'externe et qu'il récupère l'IP externe . (voir flèche **ROUGE**).

Le client (IP : 192.168.10.30) transmet le paquet __TCP__ au :

1. __firewall__ donc vers l'Internet, car la table de routage, indique que c'est une IP qui n'est pas sur le réseaux donc passerelle par défaut . 
2. Lors de la réception de la requête le __firewall__ analyse le paquet dont la destination est __64.73.4.82:80__ provenant de la carte réseau **LAN**. (Prendre note que l'adresse IP externe est configurer sur la carte **WAN**)  
3. Le __firewall__ **NAT** la requête avec l'adresse IP extérieur car l'IP dans le paquet __TCP__ stipule une destination publique.
    * Résultat :
        * de : **src:** 192.168.10.30:87367 | **dst:** 64.73.4.82:80 
        * à : **src:** 64.73.4.81:87367 | **dst:** 64.73.4.82:80 
4. Le paquet __NAT__ est prêt à sortir de la carte **WAN** , malheureusement la destination est lui même , le paquet ne revient pas dans le __firewall__ car il est sortie de la séquence de traitement.

À l'URL suivant vous aurez le chemin des paquets pour le  __TCP__ : [https://commons.wikimedia.org/wiki/File:Netfilter-packet-flow.svg](https://commons.wikimedia.org/wiki/File:Netfilter-packet-flow.svg) 

Si nous reprenons la même situation lors de la connexion depuis l'externe :

1. __Firewall__ reçoit la requête depuis le client externe (204.73.29.72:9837) pour l'IP __64.73.4.82:80__
2. La requête arrive sur le port **WAN** et le traitement du **PNAT** (redirection de port) est réalisé dans le traitement de __pre-ROUTING__ .
    * Résultat :
        * de : **src** 204.73.29.72:9837 | **dst** 64.73.4.82:80
        * à : **src** 204.73.29.72:9837 | **dst** 192.168.66.20:80
3. Le traitement de routage est fait **après** le __prerouting__ , le paquet est transmis à l'interface __DMZ__
4. Le paquet est transmis à la machine 192.168.66.20 soit le serveur WEB.

La solution au problème est d'avoir un système de __split-DNS__ en d'autre mot lors que le client réalise des requêtes depuis l'interne au lieu d'avoir comme réponse l'IP externe (Internet) il reçoit l'adresse IP interne corrigeant le problème de double __Nating__ problématique. 

**ATTENTION**: Je ne dis pas qu'il est impossible de faire en sorte que le __firewall__ réussisse à faire un tour de passe passe pour que ça fonctionne . Le problème est que ça complexifie **énormément** la configuration et encore plus l'analyse de problème !! De plus certain __firewall__ privatif ne le permette pas !

## <a name="prob_comm_ssl" /> Problème de communication avec un service SSL 

Voyons le cas du déchiffrage d'une communication **SSL** , nous avons 2 produits disponible pour réaliser l'opération :

* [ssldump](http://ssldump.sourceforge.net/) : Personnellement je ne le connais pas , ce qui m'ennuie est que la dernière mise à jour date : 2013-04-17
* [wireshark](http://www.wireshark.org) : Logiciel que nous utilisons déjà pour capturer le trafic réseau de plus il est __multi-platforme__

__Wireshark__ est en mesure de déchiffré plusieurs protocole __SSL__ très bien , si votre service n'est pas présent ce ne veut pas dire que ça marchera pas mais il y a moins de garantie :

* 443 https
* 636 ldaps
* 989 ftps-data
* 990 ftps
* 992 telnets
* 993 imaps
* 994 ircs
* 995 pop3s
* 5061 sips 

Pour les besoins de la démonstration, je vais prendre le plus populaire soit __httpS__, voici un site web disponible :

**https//172.17.0.1/**

![site_demo_https.png](./imgs/site_demo_https.png)

Nous voyons qu'il y a le petit cadenas de présent , bon j'ai pas payé un certificat valide pour la formation , donc c'est un __self signe__

Nous pouvons utiliser la commande **openssl** , qui je crois est aussi disponible sous Windows ... Je vous laisse valider ce dernier point :P. 

Voici le résultat : 

        $ openssl s_client -connect 172.17.0.1:443
        CONNECTED(00000003)
        depth=0 C = CA, ST = Quebec, L = Montreal, O = X3rus, OU = training, CN = www.linux202-sitea.com
        verify error:num=18:self signed certificate
        verify return:1
        depth=0 C = CA, ST = Quebec, L = Montreal, O = X3rus, OU = training, CN = www.linux202-sitea.com
        verify return:1
        ---
        Certificate chain
         0 s:/C=CA/ST=Quebec/L=Montreal/O=X3rus/OU=training/CN=www.linux202-sitea.com
           i:/C=CA/ST=Quebec/L=Montreal/O=X3rus/OU=training/CN=www.linux202-sitea.com
           ---
           Server certificate
           -----BEGIN CERTIFICATE-----
           MIIDvTCCAqWgAwIBAgIJAPeQILfjif9uMA0GCSqGSIb3DQEBCwUAMHUxCzAJBgNV
           BAYTAkNBMQ8wDQYDVQQIDAZRdWViZWMxETAPBgNVBAcMCE1vbnRyZWFsMQ4wDAYD
           VQQKDAVYM3J1czERMA8GA1UECwwIdHJhaW5pbmcxHzAdBgNVBAMMFnd3dy5saW51
           eDIwMi1zaXRlYS5jb20wHhcNMTYwNDIwMTI0MDA4WhcNMTcwNDIwMTI0MDA4WjB1
           MQswCQYDVQQGEwJDQTEPMA0GA1UECAwGUXVlYmVjMREwDwYDVQQHDAhNb250cmVh
           bDEOMAwGA1UECgwFWDNydXMxETAPBgNVBAsMCHRyYWluaW5nMR8wHQYDVQQDDBZ3
           d3cubGludXgyMDItc2l0ZWEuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
           CgKCAQEA6U/3KzAdczpJ/zLWqYHFOkS0QnTY5u402mMvtyyUprSRC1hZbqYJakhn
           tkC/pvOni5BoAxXEPJCI84XQXbYq0mKH67GOq4Qu1VxEOuot+bIQ8qy92Srp/a9O
           uIwYa8cRwi5r/j6BgeXaN6yErtLJ5Ll+M7Aoamxs3gMcf4dZ3dc1t+evS8c5SAWg
           jLFnBNfLJrbKO4cPhwTHVARpwPGzRzBr8o/L1RmSnM3pr5wunsC258FOwJyBTrdk
           LXf7ggq4bd6eew+eW0GhTgykRH9ZgSaLY7/IeFnmggXqyoz3BJI9cMdfCVhUnKom
           wO1DAeVxKqiA++qm7Obbw9gxB2C/gwIDAQABo1AwTjAdBgNVHQ4EFgQUuEPXOcv7
           idBBIVrmexvpELETU78wHwYDVR0jBBgwFoAUuEPXOcv7idBBIVrmexvpELETU78w
           DAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEAN5uY7FQrQNF1j7TyKrLl
           6WPu1+rsOADtNOKLoPANMRUvlhGkObjbVfzIyDOw7yUtEFsmEmTPkZ6jKbbDfS55
           Elf3kOFFICrZaxjQlkPpwEaMlommJCKDOsraDRYNGSLo7aSw2zSCEUZm0QluDtx2
           VnJ82drvlc8YcFVpOJLW89lHzczV3hHmyo6i7H1x/eSryBL/m08OPMar89iQnoHl
           T190I2xduWYFrGMuhYn3xpQVzxWJHhgDpwoK58zE9zaRdapt/P0kS+A8HgMw8qZP
           Wa0QrUtDqtc884lY2UsFKSweiTGoRmWOw0eRHyg1+q0+pPXTT/YvChKwFOsXlmds
           CA==
           -----END CERTIFICATE-----

Ceci me permet de récupérer le certificat (clé publique) du serveur et de confirmer que la communication fonctionne bien :P que le port 443 de l'IP 172.17.0.1 respecte bien le protocole __SSL__ car il m'a répondu avec le certificat :D.

Pour les personnes qui désire comprendre comment fonctionne protocole httpS je vous invite à consulter la vidéo que j'ai réalisé : [Linux 202 ( Cours 17 - Apache SSL - suite 4 )](https://www.youtube.com/watch?v=Hsg3TgG9azM)

Pour les personnes qui veulent uniquement faire fonctionné __wireshark__ sans les explications allé voir l'URL suivante :
[jimshaver:decrypting tls browser traffic with wireshark the easy way](https://jimshaver.net/2015/02/11/decrypting-tls-browser-traffic-with-wireshark-the-easy-way/)

Vous êtes encore là ?? Alors on commence les autres passez à la prochaine section :D, y a pas de malaise :) !


### <a name="prob_comm_ssl_decrypt_firefox" /> Déchiffrement de la communication avec un fureteur

Je vais commencer la démonstration du déchiffrement , c'est le chemin long, mais ce chemin à l'avantage de nous offrir l'ensemble de l'explication et de la connaissance. 
Je vais vous démontré les problèmes que j'ai eu lors de la préparation de cette formation , ceci m'a permit de vraiment mieux comprendre la partie théorique que j'avais réalisé sur le protocole **httpS**.

Premièrement j'ai récupérer la clé **privé** sur serveur web [www\_linux202-siteA\_com.key](https://raw.githubusercontent.com/x3rus/training/master/network/data/www_linux202-siteA_com.key). J'ai bien dit **privé** avec le certificat vous ne pouvez RIEN faire.

#### <a name="premier_prob_decrypt_ssl" /> Tentative de déchiffrement avec uniquement la clé privé du SERVEUR

J'étais partie du principe que si j'avais la clé privé du serveur c'était bon j'étais en business !! Et bien non ! La démonstration suivant est **non fonctionnelle** , mais dans tous problème il y a quelque chose à apprendre .

Voyons comment j'ai réalisé la configuration de __wireshark__ :

* **Edit** __-->__ **preferences** 
* **protocole** __-->__ **HTTP** : j'ai valider que les ports que j'utilise est bien listé pour la section __SSL__
* **protocole** __-->__ **SSL** : 
    * __SSL debug file__ :  __/tmp/wireshark-ssl-debug.log__  (Ceci me permettra de visualiser les logs du traitement de __wireshark__
    * **RSA keys list** : 
    ![setup_wireshark_rsa_key.png](./imgs/setup_wireshark_rsa_key.png)

Voyons le résultat avec cette configuration : 

* Nous voyons le trafic dans __wireshark__ :
    * ![wireshark-tls-prob-cipher-1.png](./imgs/wireshark-tls-prob-cipher-1.png)
* Si nous essayons de déchiffrer le contenu **bouton droit de la souris** __-->__ **Follow SSL stream**:
    * ![wireshark-tls-prob-cipher-2-follow-stream.png](./imgs/wireshark-tls-prob-cipher-2-follow-stream.png) 

Humm mais pourquoi ?? Afin de répondre à cette question nous allons regarder le fichier __log__ de __wireshark__ (__/tmp/wireshark-ssl-debug.log__). Vous trouverez les informations suivante dans le fichier de __log__:

        dissect_ssl3_record: content_type 20 Change Cipher Spec
        ssl_load_keyfile dtls/ssl.keylog_file is not configured!
        ssl_finalize_decryption state = 0x17
        ssl_restore_master_key can't find master secret by Session ID
        ssl_restore_master_key can't find master secret by Session Ticket
        ssl_restore_master_key can't find master secret by Client Random

Cool , mais encore :P ? Effectivement nous avons la clé privé du serveur , mais le [cipher suite](https://fr.wikipedia.org/wiki/Suite_cryptographique) utilisé pour chiffré les données fait en sorte que nous n'avons pas les données . Un petit schéma / rappel du protocole __SSL__ :

![SSLHandshake-v1.png](./imgs/SSLHandshake-v1.png)

Ou nous avons aussi ce schéma :

![SSLHandshake-v2.gif](./imgs/SSLHandshake-v2.gif)

Donc si nous reprenons l'information du diagramme notre problème est que nous avons l'information pour déchiffré ce que le client Transmet au serveur , soit la **pre-master key** malheureusement une fois la négociation de la clé symétrique nous perdons l'information , car nous n'avons pas la **master key** clé symétrique de chiffrement qui fut calculé du coté client et serveur. 


#### <a name="premier_prob_decrypt_ssl_setup_browser" /> Configuration du fureteur pour avoir la master key

Bon nous allons faire une modification de la configuration du fureteur afin d'être en mesure d'extraire la **Master key** qui fut échangé. Pour ce faire nous allons dire au fureteur d'écrire l'information dans un fichier texte qui sera fournit à __wireshake__

Sous GNU/Linux 

        $ export SSLKEYLOGFILE=/tmp/sslkeylog.log
        $ firefox 

Sous Windows et MAC : [https://jimshaver.net/2015/02/11/decrypting-tls-browser-traffic-with-wireshark-the-easy-way/](https://jimshaver.net/2015/02/11/decrypting-tls-browser-traffic-with-wireshark-the-easy-way/)

Je vais sur le site web __SSL__ : https://172.17.0.1

Voici un exemple du contenu du fichier :

        $ cat /tmp/sslkeylog.log
        # SSL/TLS secrets log file, generated by NSS
        CLIENT_RANDOM e643da0cbebfa8553022343817820b55e43efe30629b74bc0fb6f13f0d57668d 89472228100cd3c50140a787a72a618204780052afdc949b6f863a07eac23c68cc039b60239bfead812533e1d715ef5d
        CLIENT_RANDOM ded68bccc179cd17479d72ae7cf426df0e8d770844e21449cf425cb2994dce49 01feff746d34492a64fe06ea0d47d37497af3f06fda4d9df9d66ca93128e8fa0cbec1a456cfbb0ade712c183a2a79e9c
        CLIENT_RANDOM c33da9f992225b5b4e26ed7f017893755bc78d89b2c12e3ba5292a2f5d5dc9ec 89472228100cd3c50140a787a72a618204780052afdc949b6f863a07eac23c68cc039b60239bfead812533e1d715ef5d

Configurerons __wireshark__ pour qu'il lise ce fichier :

* **Edit** __-->__ **preferences** 
* **protocole** __-->__ **SSL** : 
    * __(Pre)master-secret log filename__ : __/tmp/sslkeylog.log__

![wireshark-ajout-master-key-file-pref-ssl.png](./imgs/wireshark-ajout-master-key-file-pref-ssl.png)


Nous referons un teste en accédant au site : __https://172.17.0.1__ 

![wireshark-fureteur-success-decrypt.png](./imgs/wireshark-fureteur-success-decrypt.png)

**WOWWW magic !!!!**


#### <a name="premier_prob_decrypt_ssl_other_than_browser" /> Méthode pour d'autre application

Bon c'est super cool, mais si je veux diagnostiquer avec une autre application que le fureteur je fais comment ?
Effectivement cette méthode est contraignante , voir très contraignante. Pour information la problématique est dans le type de __cipher__ qui est utilisé , [la suite cryptographique](https://fr.wikipedia.org/wiki/Suite_cryptographique) est le nom de la combinaison des algorithmes d'échange de clés, d'authentification, de chiffrement par bloc et génération du code d'authentification de message (MAC) utilisée afin d'établir le paramétrage de sécurité pour une connexion réseau utilisant le protocole de communication __Secure Socket Layer (SSL)__ et __Transport Layer Security (TLS)__. 

Si nous utilisons le **cipher** **Diffie-Hellman Ephemeral (DHE) ou RSA ephemeral cipher** , __wireshark__ n'est pas en mesure de réalisé le déchiffrement. Vous pouvez modifier probablement votre application afin de permettre l'écriture de la **master clé** mais ceci est très contraignant et ne représentera pas la réalité.

Le __cipher__ est négocié entre le client et le serveur, il est donc possible d'indiquer au serveur de ne PAS utiliser les __cipher__ problématique . Voici un exemple pour apache :

        # Configuration SSL
        SSLEngine on
        SSLCertificateFile "/etc/apache2/ssl/www_linux202-siteA_com.crt"
        SSLCertificateKeyFile "/etc/apache2/ssl/www_linux202-siteA_com.key"
        SSLCipherSuite RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!PSK:!SRP:!DSS

L'important ici est de désactiver le support __DHE__ par contre il a beaucoup de cipher qui l'utilise alors je spécifie ceux que je désire uniquement. **SSLCipherSuite**.

        $ sudo apachectl configtest && sudo /etc/init.d/apache2 restart

Maintenant coté client :

        $ unset SSLKEYLOGFILE
        $ echo $SSLKEYLOGFILE
        $ rm /tmp/sslkeylog.log
        $ firefox

Suppression configuration __wireshark__ pour qu'il ne lise plus le fichier :

* **Edit** __-->__ **preferences** 
* **protocole** __-->__ **SSL** : 
    * __(Pre)master-secret log filename__ : 


Donc je reprend avec __wireshark__ et je suis en mesure de déchiffrer le contenu , si ça vous intéresse vous pouvez voir le __cipher__ qui fut négocier dans les paquets :

* Le client propose les __ciphers__ suivant , dans le paquet **Client Hello** :
![cipher-client_hello.png](./imgs/cipher-client_hello.png)

* Le serveur répond avec le __cipher__ qu'il a choisit dans le paquet **Server Hello**:
[!cipher-server_hello.png](./imgs/cipher-server_hello.png)


Bien entendu cette méthode peut être impossible à mettre en place dans le cadre d'un serveur en production !! 
Donc prendre cette méthode avec un grain de sel et évaluer les conséquences de ce changement de configuration !

##### <a name="premier_prob_decrypt_ssl_change_app" /> Configure application avec le bon cipher

Une fois le problème compris sur la source du problème de déchiffrement vous pouvez aussi modifier le comportement de l'application qui communique avec le serveur. Après tous la négociation du __cipher__ ce fait des 2 coté :P, je présente 2 options à vous de trouver le reste pour vos applications :

* __Firefox__ 
    * désactivation des __ciphers__ __DHE__ ET __ECDHE__ , allez dans la configuration **about:config** 
    * recherchez pour __dhe__ et désactivé le tous :
    ![firefox_dhe_disable.png](./imgs/firefox_dhe_disable.png)

    * ATTENTION il ne faut pas oublié une fois les testes réalisé de remettre la configuration convenablement au moins avant votre prochaine visite sur votre site bancaire :D.

* Java
    * la configuration de la __JVM__ est comme suit :  __jdk.TLS.disabledALGORITHMS=DHE, ECDHE__ honnêtement je ne l'ai pas tester :-/ , si une personne désire me fournir l'instruction exacte je suis preneur :D (à vos recherche , c'est l'occasion de participé à la formation ;-) )



#### <a name="premier_prob_decrypt_warrior_part" /> Pour les guerriers  !! Vraiment optionnel !!

Bon petite mise en contexte, j'ai gagné (en savoir) / j'ai perdu (en temps) 5 trajet de train pour comprendre le tous !! Reprenons rapidement le schéma de la communication précédemment montré 

![SSLHandshake-v3-two-way-auth.png](./imgs/SSLHandshake-v3-two-way-auth.png)

Quand j'ai regardé le diagramme je me suis dit , **wowww** si on regarde bien les nombres aléatoire passe dans la communication :

* Le chiffre généré par le client (**RNc**)
* Le chiffre généré par le serveur (**RNs**)
* Ainsi que la **pré-master key** transmit par le client , chiffré avec le certificat du client

Alors je me suis dit , que si j'ai l'ensemble des 3 éléments , je vois pas pourquoi je ne suis pas en mesure de calculé MOI aussi comme un grand la **master key** :P . Après tous si Apache le fait , c'est libre donc il y a bien un bout de code à prendre quelque par pour extraire l'information !! 

Je suis donc partie d'une communication avec __firefox__ et le fichier de clé ou j'ai essayer de récupérer l'information . Si ça vous motive continué , mais je vous avise tous de suite , **ÇA FONCTIONNE PAS** :P . Je crois cependant que la connaissance est intéressante :D. 

Commençons par extraire l'information du fichier __ssllog__ que vous pourrez trouver sur __github__ ici : TODO 

        $ cat sslkeylog_firefox_https_dhe.log
        CLIENT_RANDOM eaba2ab12a4b3312da88a244beab1db493687d7946ff2583e6960d2d4d2ba9b6 04a1b54e353b28afcb64e1380d3c049a9662f53340b1fb91a0734287cd92327a0cb4da8d5bb3148b3873bd2fb00fd7e5
        CLIENT_RANDOM 4800c1d2126559f3e610ae217f0c5fa99a123a9a4f0232a7352f9a315ed6b9d7 a3f2325ff9f8606d33d4fd8ae2bf3e0f63ac7977e0829a494d1f88ed74173aa69455866c8b58ac714c84d950be3a130b
        CLIENT_RANDOM 187ed56c312cab9fce0a3540e06d3e427885ed3ed94b8338ba3ab53a3ffba855 04a1b54e353b28afcb64e1380d3c049a9662f53340b1fb91a0734287cd92327a0cb4da8d5bb3148b3873bd2fb00fd7e5

Vous trouverez aussi le fichier __wireshark__ de la communication sur __github__ ici : TODO 

J'ai d'abord cherché le numéro aléatoire du client contenu dans la communication **client hello**, j'ai extrait les numéros voici la copie d'écran de l'opération :

![wireshark_get_first_random-client-num.png](./imgs/wireshark_get_first_random-client-num.png

Partie de l'heure IMPORTANTE :

![wireshark_get_first_random-client-num_second_part.png](./imgs/wireshark_get_first_random-client-num_second_part.png)

Si nous collons les 2 numéros ensemble ::

        eaba2ab12a4b3312da88a244beab1db493687d7946ff2583e6960d2d4d2ba9b6

**MAGIC** , alors là j'y est vraiment cru :P 

Passons à la partie du serveur , c'est aussi simple : 

![wireshark_get_first_random-server-num.png](./imgs/wireshark_get_first_random-server-num.png)

Bon c'est pas dans le fichier mais j'y croyais encore :P ...

Je suis passé à l'étape de chercher la **pre-master key**, c'est la que le problème commence !
L'échange de la __pre-master key__ est réalisé lors de la séquence **Client Key Exchange** :

![wireshark_get_preshare-key_client.png](./imgs/wireshark_get_preshare-key_client.png)

Si nous regardons nous constatons que ceci est une clé publique :-/ , donc ceci vient avec une clé privé, regardons un schéma  du protocole [Diffie-Hellman](https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman)


* https://ask.wireshark.org/questions/34393/how-to-decrypt-ssl-traffic-using-wireshark
__Be aware of some possible limitations. In particular the choice of cipher suites, PFS cipher suites (the (EC)DHE ones) cannot be decrypted even if you posess the private key. If you have access to the Pre-Master secrets, then you do not have this limitation, but it will require cooperation from the application to get these keys.__

* http://packetpushers.net/using-wireshark-to-decode-ssltls-packets/
__Wireshark can only decrypt SSL/TLS packet data if RSA keys are used to encrypt the data. If a Diffie-Hellman Ephemeral (DHE) or RSA ephemeral cipher suite is used, the RSA keys are only used to secure the DH or RSA exchange, not encrypt the data. Thus, even if you have the correct RSA private key, you will not be able to decrypt the data with Wireshark or any other tool. You can check which cipher suite is being used by examining the Server Hello packet sent by the host that holds the private key, if the cipher suite specified begins TLS_DHE or SSL_DHE, you will not be able to decrypt the data. If the server sends a ServerKeyExchange message, you will not be able to decrypt the data. I’ve no idea how to prevent RSA ephemeral use. For DHE, your only option (if possible) is to modify either the client or server configuration so that DHE cipher suites are not used.__

__For Firefox, enter this URL in the address bar: about:config, click the warning button and then enter this in the filter bar: security.ssl3.dhe. Set each preference displayed to: false and then filter again for security.ssl3.ecdhe and do the same again.__
__Server side (not recommended), if using OpenSSL you could also change any configured cipher strings to include !DHE and !ECDHE__
__With Java something like jdk.TLS.disabledALGORITHMS=DHE, ECDHE in the relevant place should suffice__




### <a name="prob_comm_ssl_decrypt_myapp" /> Déchiffrement de la communication avec une application X

Afin de garder l'intérêt de tous je vais utiliser 2 scripts python :

* __py-connect.py__ : qui fonctionne , lors de la communication avec le serveur

        $ python2 py-connect.py
        Super ca marche
        
* __py-connect-BAD.py__ : qui retourne une erreur mais le Dev (moi :P ) n'a pas fournit un message très claire 

        $ python2 py-connect-BAD.py
        Nope, bonne chance :D

Pour conserver le plaisir nous ne regarderons pas le contenu des scripts et nous ne regarderons pas les logs sur le serveur.
Pour faire l'analyse nous commencerons par le système qui fonctionne bien :D.

Débutons **wireshark** afin de voir le trafic lors de l'exécution de __py-connect.py__ 




* réalisation script python , communication avec le service https normale + un 404 sans msg bien
* Prendre la clef prive du srv https et déchiffrer le contenu de la communication

Référence :

* https://wiki.wireshark.org/SSL
* https://jimshaver.net/2015/02/11/decrypting-tls-browser-traffic-with-wireshark-the-easy-way/
* http://support.citrix.com/article/CTX116557

# Visualisation du cheminement du paquet afin d'identifier les équipements potentiellement problématique

* Comme nous avions vu avec le timeout du TCP keep alive 
* TODO voir comment faire la démo :(.

# Faire attention au netmask 

* Voir que parfois on a l'impression que c le même network mais le netmask est important

# Explication rapide VLAN trunk pour ESX

* Expliquer pourquoi un ESX peut avoir plusieurs réseaux alors qu'il n'a que 2 prises

# Utilisation de TcPdump pour visualiser la communication serveur

* Utilisation de snmp afin de visualiser la communication sur le serveur
* Récupération du fichier de data

# Problème de communication avec un service SSL 

* réalisation script python , communication avec le service https normale + un 404 sans msg bien
* Prendre la clef prive du srv https et déchiffrer le contenu de la communication

https://wiki.wireshark.org/SSL

# Calcule taille de la communication

* Faire une communication normale avec un serveur http, avec calcule size communication
* Activer le mod deflate
* Refaire la meme communication et faire le calcule de la taille des paquet de la communications

# Avec time.php montré le keep-alive lors du tcpdump

* Pour visualisé l'opération du browser lors d'un traitement trop long.
