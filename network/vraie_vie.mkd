<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 


# <a name="Introduction" /> Introduction 

Nous avons vue dans la première partie la théorie des protocoles réseaux __TCP__ , __UDP__ et __IP__. Lors des différentes démonstration tous fonctionnait sans problème. Dans la vie ce n'est pas aussi jolie , quand on vous demande de réaliser une analyse sur un problème, il faut être en mesure d'identifier les problèmes. Nous allons donc maintenant passer à l'étape quand tous ne fonctionne pas afin d'avoir des indices pour identifier les problématiques .
Bien entendu je ne serai jamais en mesure de couvrir l'ensemble des problèmes que vous pouvez rencontrer, cependant j'espère en couvrir assez afin de vous offrir les outils pour diagnostiquer la source du problème . Vous pourrez par la suite identifier l'équipement et la méthode de résolution approprié.

# <a name="couche_IP"/> Communication entre 2 systèmes

Commençons par la couche inférieur donc la couche IP puis nous monterons tranquillement , vers la couche applicative. Nous aurons l'occasion par la suite de voir les protocoles applicatifs telle que __HTTP__**S** avec __wireshark__.

## <a name="ip_probleme_route"/> Problème de routage de paquets

Nous allons maintenant voir un problème de communication entre 2 machines , voici le schéma :

![dia_network_docker_plus_roger.png](./imgs/dia_network_docker_plus_roger.png)

Donc nous avons 2 cartes réseau:

* **wlan0** : la carte sans file avec l'adresse IP 192.168.43.191
* **docker0** : carte virtuelle docker avec l'IP  172.17.0.1

Sous l'interface **docker0** il y a un sous réseau connecté directement sur la carte qui comprend l'ensemble du réseau 172.17.0.0/16 . Dans le réseau 172.17.0.0/16 , nous avons une machine 172.17.0.4 de disponible .

Si j'essaye de réaliser un **PING** de la machine voici le retour : 

        $ ping 172.17.0.4
        PING 172.17.0.4 (172.17.0.4) 56(84) bytes of data.
        From 192.168.142.2 icmp_seq=1 Packet filtered
        From 192.168.142.2 icmp_seq=2 Packet filtered
        From 192.168.142.2 icmp_seq=3 Packet filtered
        ^C
        --- 172.17.0.4 ping statistics ---
        3 packets transmitted, 0 received, +3 errors, 100% packet loss, time 2002ms

Nous avons le message que le paquet fut filtré par le routeur 192.168.142.2 , ce qui est étrange , voyons ce que la commande **traceroute** nous retourne  :

        $ traceroute 172.17.0.4
        traceroute to 172.17.0.4 (172.17.0.4), 30 hops max, 60 byte packets
         1  gateway (192.168.43.1)  3.181 ms  2.724 ms  3.004 ms
         2  * * *
         3  192.168.142.2 (192.168.142.2)  415.969 ms !X 192.168.142.66 (192.168.142.66)  463.790 ms !X  463.809 ms !X

Reprenons le schéma réseau un peu plus haut, ce n'est PAS normale que le paquet soit dirigé var le routeur **192.168.43.1** , selon le schéma ceci devrait être dirigé vers l'interface **docker0** .

Je vais démarrer **wireshark** sur l'interface **wlan0** pour voir le comportement et refaire le __ping__:

![prob_route_wireshark_wlan0_filtered.png](./imgs/prob_route_wireshark_wlan0_filtered.png)

Nous voyons clairement que sur l'interface **wlan0** il y a du trafic et le message est très explicite : __Destination unreachable (Communication administratively filtered)__

Si je réalise le même filtrage sur l'interface **docker0** je n'ai aucun trafic , aucun paquet RIEN !!!

Essayons peut-être un accès SSH après tous juste un problème de __ping__ ce n'est pas la fin du monde :P  :

        $ telnet 172.17.0.4 22
        Trying 172.17.0.4...
        telnet: Unable to connect to remote host: No route to host

Et au niveau du __wireshark__ :

![prob_route_wireshark_wlan0_filtered_telnet_22.png](./imgs/prob_route_wireshark_wlan0_filtered_telnet_22.png)

Humm, c'est pas mieux :p , __nice try__ :)
Visualisons  les routes à présent indiquant le chemin que doit prendre les communications IP 

        $ route -n
        Kernel IP routing table
        Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
        0.0.0.0         192.168.43.1    0.0.0.0         UG    600    0        0 wlan0
        192.168.43.0    0.0.0.0         255.255.255.0   U     600    0        0 wlan0

Effectivement il n'y a aucune instruction pour l'interface **docker0** . Je vais donc faire l'ajout de l'instruction à la table de routage :

        $ sudo route add -net 172.17.0.0 netmask 255.255.0.0 dev docker0
        $ route -n
        Kernel IP routing table
        Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
        0.0.0.0         192.168.43.1    0.0.0.0         UG    600    0        0 wlan0
        172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
        192.168.43.0    0.0.0.0         255.255.255.0   U     600    0        0 wlan0

ENCORE , comme dirait mon fils :D  :

        $  ping 172.17.0.4
        PING 172.17.0.4 (172.17.0.4) 56(84) bytes of data.
        64 bytes from 172.17.0.4: icmp_seq=1 ttl=64 time=0.176 ms
        64 bytes from 172.17.0.4: icmp_seq=2 ttl=64 time=0.114 ms


Et voilà , quand on prend le bon chemin ça va mieux :D 

# <a name="couche_TCP"/> Communication entre 2 systèmes

## <a name="tcp_timeout_drop"/> Analyse d'un problème de communication TCP ou UDP

Un problème classique avec le protocole __TCP__ est un problème de connexion entre le client et le serveur, nous avons un problème et le réflexe est de blâmé le __firewall__ ou le réseau. Ce réflexe est naturel, car souvent cette partie est géré par une autre équipe et nous n'avons pas le contrôle. Nous allons donc voir comment identifier le problème afin de faire la demande approprié pour solutionné le problème . 

Si j'ai un problème de communication entre le client et le serveur il y a 3 possibilités :

* La connectivité est problématique : __Firewall__ bloque les communications ou le paquets n'arrive pas a destination 
* Le serveur ne traite pas la communication adéquatement ne fournissant la de réponse adéquate 
* Le client n'envoie pas la requête au bon serveur ou la requête est mal formé

Je vais partir du principe que vous avez accès au 2 équipements suivant :

* La machine client 
* Le serveur 

Pour les besoins de la démonstration je vais utiliser 2 services __snmpd__ pour __l'UDP__ et __apache__ pour la partie __TCP__ . Nous utiliserons 2 utilitaires __netcat (nc)__ pour simulé un client/serveur __UDP__ et __TCP__ ainsi que __telnet__ car je l'aime bien pour la partie __TCP__

### <a name="tcp_timout"/> Visualisation d'un problème de communication à cause du firewall pour TCP

Pour commencé nous allons voir comment identifier s'il y a un problème de __firewall__ . Voyons le comportement quand il y a une indisponibilité de connexion dû au __firewall__.

J'ai :

* client : 172.17.42.1 
* serveur (apache) : 172.17.0.1 

Pour rappel quand tous va bien lors de l'établissement de connexion entre le client et le serveur je doit avoir :

* Établissement de connexion  ( __3 way handshake__ ) / __SYN__, __SYN-ACK__ , __ACK__
* Transfert de données avec accusé de réception (__ACK__)
* Fermeture de connexion  (__FIN-ACK__, __FIN-ACK__, __ACK__)

Voici un rappel de la copie d'écran de __wireshark__ :

![wireshark_visualisation_fureteur_07.png](./imgs/wireshark_visualisation_fureteur_07.png)

Maintenant, je vais ajouter une règle de __firewall__ qui bloque la communication , je vais utilisé un **DROP** ce qui fait en sorte que le paquet est mis à la poubelle sans avertissement au client .

Je met ici les instructions __iptables__ cependant ceci est en dehors de la formation, je ne veux pas faire de Linux ici. Par contre si vous avez des questions n'hésitez pas à communiquer avec moi en dehors :).

TODO: A completer

# Visualisation du cheminement du paquet afin d'identifier les équipements potentiellement problématique

* Comme nous avions vu avec le timeout du TCP keep alive 
* TODO voir comment faire la démo :(.

# Problème DNS IP  externe VS ip interne

* Visualisation d'une problématique de DNS qui utilise l'IP externe VS l'ip interne pour la communication.

# Visualisation d'une coupure de communication lors d'un transfert de paquet

* Faire l'envoie d'un paquet coupé la comme (iptables)
* Reprendre la communication et visualiser le comportement.

# Faire attention au netmask 

* Voir que parfois on a l'impression que c le même network mais le netmask est important

# Explication rapide VLAN trunk pour ESX

* Expliquer pourquoi un ESX peut avoir plusieurs réseaux alors qu'il n'a que 2 prises

# Utilisation de TcPdump pour visualiser la communication serveur

* Utilisation de snmp afin de visualiser la communication sur le serveur
* Récupération du fichier de data

# Problème de communication avec un service SSL 

* réalisation script python , communication avec le service https normale + un 404 sans msg bien
* Prendre la clef prive du srv https et déchiffrer le contenu de la communication

# Calcule taille de la communication

* Faire une communication normale avec un serveur http, avec calcule size communication
* Activer le mod deflate
* Refaire la meme communication et faire le calcule de la taille des paquet de la communications

# Avec time.php montré le keep-alive lors du tcpdump

* Pour visualisé l'opération du browser lors d'un traitement trop long.
