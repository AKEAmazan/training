<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 


# <a name="Introduction" /> Introduction 

Nous avons vue dans la première partie la théorie des protocoles réseaux __TCP__ , __UDP__ et __IP__. Lors des différentes démonstration tous fonctionnait sans problème. Dans la vie ce n'est pas aussi jolie , quand on vous demande de réaliser une analyse sur un problème, il faut être en mesure d'identifier les problèmes. Nous allons donc maintenant passer à l'étape quand tous ne fonctionne pas afin d'avoir des indices pour identifier les problématiques .
Bien entendu je ne serai jamais en mesure de couvrir l'ensemble des problèmes que vous pouvez rencontrer, cependant j'espère en couvrir assez afin de vous offrir les outils pour diagnostiquer la source du problème . Vous pourrez par la suite identifier l'équipement et la méthode de résolution approprié.

# <a name="couche_IP"/> Communication entre 2 systèmes

Commençons par la couche inférieur donc la couche IP puis nous monterons tranquillement , vers la couche applicative. Nous aurons l'occasion par la suite de voir les protocoles applicatifs telle que __HTTP__**S** avec __wireshark__.

## <a name="ip_probleme_route"/> Problème de routage de paquets

Nous allons maintenant voir un problème de communication entre 2 machines , voici le schéma :

![dia_network_docker_plus_roger.png](./imgs/dia_network_docker_plus_roger.png)

Donc nous avons 2 cartes réseau:

* **wlan0** : la carte sans file avec l'adresse IP 192.168.43.191
* **docker0** : carte virtuelle docker avec l'IP  172.17.0.1

Sous l'interface **docker0** il y a un sous réseau connecté directement sur la carte qui comprend l'ensemble du réseau 172.17.0.0/16 . Dans le réseau 172.17.0.0/16 , nous avons une machine 172.17.0.4 de disponible .

Si j'essaye de réaliser un **PING** de la machine voici le retour : 

        $ ping 172.17.0.4
        PING 172.17.0.4 (172.17.0.4) 56(84) bytes of data.
        From 192.168.142.2 icmp_seq=1 Packet filtered
        From 192.168.142.2 icmp_seq=2 Packet filtered
        From 192.168.142.2 icmp_seq=3 Packet filtered
        ^C
        --- 172.17.0.4 ping statistics ---
        3 packets transmitted, 0 received, +3 errors, 100% packet loss, time 2002ms

Nous avons le message que le paquet fut filtré par le routeur 192.168.142.2 , ce qui est étrange , voyons ce que la commande **traceroute** nous retourne  :

        $ traceroute 172.17.0.4
        traceroute to 172.17.0.4 (172.17.0.4), 30 hops max, 60 byte packets
         1  gateway (192.168.43.1)  3.181 ms  2.724 ms  3.004 ms
         2  * * *
         3  192.168.142.2 (192.168.142.2)  415.969 ms !X 192.168.142.66 (192.168.142.66)  463.790 ms !X  463.809 ms !X

Reprenons le schéma réseau un peu plus haut, ce n'est PAS normale que le paquet soit dirigé var le routeur **192.168.43.1** , selon le schéma ceci devrait être dirigé vers l'interface **docker0** .

Je vais démarrer **wireshark** sur l'interface **wlan0** pour voir le comportement et refaire le __ping__:

![prob_route_wireshark_wlan0_filtered.png](./imgs/prob_route_wireshark_wlan0_filtered.png)

Nous voyons clairement que sur l'interface **wlan0** il y a du trafic et le message est très explicite : __Destination unreachable (Communication administratively filtered)__

Si je réalise le même filtrage sur l'interface **docker0** je n'ai aucun trafic , aucun paquet RIEN !!!

Essayons peut-être un accès SSH après tous juste un problème de __ping__ ce n'est pas la fin du monde :P  :

        $ telnet 172.17.0.4 22
        Trying 172.17.0.4...
        telnet: Unable to connect to remote host: No route to host

Et au niveau du __wireshark__ :

![prob_route_wireshark_wlan0_filtered_telnet_22.png](./imgs/prob_route_wireshark_wlan0_filtered_telnet_22.png)

Humm, c'est pas mieux :p , __nice try__ :)
Visualisons  les routes à présent indiquant le chemin que doit prendre les communications IP 

        $ route -n
        Kernel IP routing table
        Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
        0.0.0.0         192.168.43.1    0.0.0.0         UG    600    0        0 wlan0
        192.168.43.0    0.0.0.0         255.255.255.0   U     600    0        0 wlan0

Effectivement il n'y a aucune instruction pour l'interface **docker0** . Je vais donc faire l'ajout de l'instruction à la table de routage :

        $ sudo route add -net 172.17.0.0 netmask 255.255.0.0 dev docker0
        $ route -n
        Kernel IP routing table
        Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
        0.0.0.0         192.168.43.1    0.0.0.0         UG    600    0        0 wlan0
        172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
        192.168.43.0    0.0.0.0         255.255.255.0   U     600    0        0 wlan0

ENCORE , comme dirait mon fils :D  :

        $  ping 172.17.0.4
        PING 172.17.0.4 (172.17.0.4) 56(84) bytes of data.
        64 bytes from 172.17.0.4: icmp_seq=1 ttl=64 time=0.176 ms
        64 bytes from 172.17.0.4: icmp_seq=2 ttl=64 time=0.114 ms


Et voilà , quand on prend le bon chemin ça va mieux :D 

# <a name="couche_TCP"/> Communication entre 2 systèmes

# Visualisation du cheminement du paquet afin d'identifier les équipements potentiellement problématique

* Comme nous avions vu avec le timeout du TCP keep alive 
* TODO voir comment faire la démo :(.

# Problème DNS IP  externe VS ip interne

* Visualisation d'une problématique de DNS qui utilise l'IP externe VS l'ip interne pour la communication.

# Visualisation d'une coupure de communication lors d'un transfert de paquet

* Faire l'envoie d'un paquet coupé la comme (iptables)
* Reprendre la communication et visualiser le comportement.

# Faire attention au netmask 

* Voir que parfois on a l'impression que c le même network mais le netmask est important

# Explication rapide VLAN trunk pour ESX

* Expliquer pourquoi un ESX peut avoir plusieurs réseaux alors qu'il n'a que 2 prises

# Utilisation de TcPdump pour visualiser la communication serveur

* Utilisation de snmp afin de visualiser la communication sur le serveur
* Récupération du fichier de data

# Problème de communication avec un service SSL 

* réalisation script python , communication avec le service https normale + un 404 sans msg bien
* Prendre la clef prive du srv https et déchiffrer le contenu de la communication

# Calcule taille de la communication

* Faire une communication normale avec un serveur http, avec calcule size communication
* Activer le mod deflate
* Refaire la meme communication et faire le calcule de la taille des paquet de la communications

# TIMEout VS Drop

* Visualisation d'un timeout apache avec un sleep de fou
* Visualisation d'une communication avec un DROP iptables
* Identification c quoi le problème entre timeout application vs drop, grâce à telnet
