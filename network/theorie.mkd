<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>

TODO corriger les \_

# Index 

* [ Clarifications du réseau](#clarification) 
* [ Théorie sur le protocole d'Internet](#clarification_Protocol_internet) 
       * [ Couche Transport (UDP et TCP)](#couche_transport) 
           * [ Transmission Control Protocol (TCP) (protocole de contrôle de transmissions)](#clarification_tcp) 
               * [ TCP établissement de connexion (3 way handshake)](#clarification_tcp_3way_handshake) 
               * [ Structure d'un segment TCP](#clarification_tcp_structure) 
                   * [ Visualisation d'une communication TCP](#visualisation_connexion) 
                       * [ Établissement de la connexion](#visualisation_connexion_conn) 
                       * [ Transferts de données ](#visualisation_transfert_data) 
                       * [ Fin de la connexion.](#visualisation_connexion_fin) 
                   * [ Visualisation d'une communication TCP réalisé par le fureteur](#visualisation_connexion_fureteur) 
                   * [ Visualisation d'une communication TCP réalisé par le fureteur avec site complet](#visualisation_conn_fureteur_ext) 
               * [ Conclusion sur le TCP ](#clarification_tcp_conclusion) 
           * [ User Datagram Protocol (UDP) (protocole de contrôle de transmissions)](#clarification_udp) 
               * [ Structure d'un segment UDP](#clarification_udp_structure) 
                   * [ Visualisation d'une communication UDP](#visualisation_connexion_udp) 
                   * [ Visualisation d'une communication UDP avec l'application snmp](#visualisation_connexion_snmp) 
               * [ Conclusion sur le UDP](#clarification_udp_conclusion) 
       * [ Autre protocole](#clarification_diff_tcp_udp) 
       * [ Couche Internet (IP)](#couche_Internet) 
           * [ Structure du paquet IP](#clarification_IP_structure) 
           * [ Adresses IP et sous-réseau](#clarification_adressage_ip) 
               * [ Netmask et sous-réseau](#clarification_adressage_ip_sous-reseau) 
           * [ Routage des paquets IP](#clarification_routage_IP) 
           * [ Services délivrés / Fiabilité du protocole](#clarification_reliability_ip) 
           * [ Manipulation des adresses IP (NAT)](#clarification_NAT_IP) 
* [ Processus d'établissement de connexion](#clarification_workflow_connection) 

# <a name="clarification" /> Clarifications du réseau

Avant de parler routage ouverture de ports j'aimerai clarifier certain aspect du réseau , pas de panique je ne planifie pas faire 3 jours sur la [couche OSI](https://fr.wikipedia.org/wiki/Mod%C3%A8le_OSI). Nous allons voir un peu cette théorie mais dans un but précis permettre de diagnostiquer un problème. Avoir une meilleur compréhension de l'ensemble du processus et des différentes étapes nous aide a mieux identifier la source des problèmes. De nous jours le réseau est essentiel allumé une machine qui n'est pas connecter et rapidement on ne sait plus quoi faire avec ... 

Pour commencer, j'aimerai vous donner ma vision du réseau au risque de contrarier certain administrateur réseaux :P. Personnellement je perçois le trafic réseaux comme de l'eau. Le trafic coule entre les différents équipement qui soit le laisse passer soit le bloque. Parfois le courant est redirigé vers un autre point , parfois il est légèrement modifier pour ajouter plus d'information ... Mais à la fin c'est aussi simple que ça , je ne suis peut-être pas le plus grand fan du réseau voilà pourquoi j'ai cette vision peut-être simpliste.

# <a name="clarification_Protocol_internet" /> Théorie sur le protocole d'Internet

Nous nous concentrerons sur le protocole le plus utilisé aujourd'hui soit celui d'Internet, pour débuter voici une représentation du __flow__ (courant) sur Internet. 

<img src="https://upload.wikimedia.org/wikipedia/commons/c/c4/IP_stack_connections.svg"  width="700px" />

J'aime beaucoup cette image qui représente très bien chaque étape du processus de communication entre 2 applications. 

* **[Application](https://en.wikipedia.org/wiki/Application_layer)** : L'application peut être n'importe quoi un fureteur communiquant avec un serveur apache. Un client courriel communiquant avec un serveur __imaps__ ou __smtp__ , un jeu communiquant avec un serveur peu importe . L'application génère des données (__data__) qui doit être communiqué à l'autre application. L'application utilisera d'une librairie qui lui permettra de communiquer sur le réseau. En théorie ce pourrait être une librairie pour les réseaux [X.25](https://en.wikipedia.org/wiki/X.25) ou [TCP/IP](https://fr.wikipedia.org/wiki/Transmission_Control_Protocol) ou [UDP/IP](https://fr.wikipedia.org/wiki/User_Datagram_Protocol). Donc l'application génère des données !
* **[Transport](https://en.wikipedia.org/wiki/Transport_layer)** : La couche transport prend les données de l'application et l'encapsule dans un format qui sera utilisé pour transporter les données . À ce stade nous avons 2 protocole actuellement très utilisé [TCP](https://fr.wikipedia.org/wiki/Transmission_Control_Protocol) ou [UDP](https://fr.wikipedia.org/wiki/User_Datagram_Protocol), nous allons voir plus en détail ce principe d'encapsulation et ce qu'il contient. À ce stade du processus les données sont formaté pour être transmis cependant la couche transport ne sait pas comment les transmettre. Est-ce que les paquets  doit être transmit à une passerelle ? Est-ce que la machine est sur le même réseau ? Comment les paquets doit être fragmenté (coupé en morceau) afin de pouvoir passer sur le file ? ...
* **[Internet](https://en.wikipedia.org/wiki/Internet_layer)** : La couche __Internet__ s'occupe de définir le chemin que devra prendre les paquets, à savoir utilisé une passerelle de communication pour accéder au autre réseau. Voilà la partie **IP** de **TCP/IP**, cette couche s'assure de l'ensemble du chemin que devra prendre les données formatées selon le standard définie dans la couche précédente. Si vous regardez le diagramme précédent vous voyez clairement que le chemin pris par les données ne n'utilise que la couche **Internet** et **link** lors de la transition entre l'ensemble des équipements jusqu'au __host__ final.
* **[Link](https://en.wikipedia.org/wiki/Link_layer)** : La couche __Link__ ou de Liaison est utiliser pour convertir les données selon le lien utilisé , cette couche permettra de faire la conversion vers le câble Ethernet ou un port sériel . Grâce à cette abstraction entre la couche **Internet** et la couche **Link** nous pouvons transmettre des données sur différent type de lien (__RJ45__, Fibre Optique, port sériel, ...). Chaque point de traitement , __router__ récupérera l'information transmise sur le câble et analysera la contenu de la couche **Internet** afin de savoir à qui transmettre les données , etc jusqu'à la réception de la machine destinataire.


Voici la même représentation du traitement mais cette fois non plus avec une machine mais lors de l'écriture d'une lettre.

* **Application** : Vous qui écrivait une lettre , vous êtes l'application et vous écrivez sur du papier
* **Transport** : Ceci pourrait être représenter par l'enveloppe , cette dernière contient les données applicatif , dans notre cas la lettre. Nous avons écrit sur l'enveloppe les informations du destinataire , nous avons aussi écrit d'où provient la lettre en cas de problème. Pour finir nous fermons cette dernier, telle que le veut la convention / procédure. À ce stade nous ne savons pas comment la lettre sera transmise, par bateau , par avion ... Est-ce que la lettre sera transmis à un bureau centrale puis redistribué ? Ce que nous savons est que les données sont préparés selon la convention .
* **Internet** : Nous avons les données (application), nous avons le format approprié , la couche internet peut être perçu comme la poste cette dernière sait comment traiter l'adresse que nous lui avons donnés. Car nous avons fournit le bon format , adresse ainsi que le code postal, de vous a moi peut importe le mécanisme utilisé pour transmettre mes données le chemin à peut d'importance nous espérons qu'il soit optimal afin de réduit le délais de livraison. 
* **Link** : La couche de Liaison est l'ensemble des intervenants qui transmettrons ma lettre , le postier , le camion , l'avion , le bateau , ... L'ensemble des intervenants sont en mesure de traiter l'information contenu dans la couche **Internet** afin de connaître le prochain intervenant qui traitera notre enveloppe afin de la livrer. 


Ceci est à haut niveau voyons plus en détail le processus de création de chaque couche afin de mieux visualisé le processus de connexion et d'échange de données. Mon objectif est de voir le processus de création du flux de données nous resterons jusqu'à un certain point à un haut niveau pour encore descendre au fur et a mesure que nous serons confortable avec les concepts.


## <a name="couche_transport" /> Couche Transport (UDP et TCP)

Inutile de prendre du temps pour la couche applicative vous aurez compris que c'est l'ensemble des applications communiquant sur le réseau que ce soit client ou serveur. L'ensemble des exemples à venir clarifierons l'ambiguïté qui peut encore présent. Nous allons nous attaquer à la couche **Transport** nous allons la décortiqué mais avant tous clarifions la différence entre __TCP__ et __UDP__. 

**Port TCP et UDP**

TCP, comme UDP, utilise le numéro de port pour identifier les applications. À chaque extrémité (client/serveur) de la connexion TCP est associé un numéro de port sur 16 bits (de 1 à 65535) assigné à l'application émettrice ou réceptrice. Ces ports sont classés en trois catégories :

* Les __ports bien connus__ sont assignés par l'IANA (Internet Assigned Numbers Authority) dans la plage 0-1023, et sont souvent utilisés par des processus système ou ayant des droits privilégiés. Les applications bien connues qui fonctionnent en tant que serveur et sont en attente de connexions utilisent généralement ces types de ports. Exemples : FTP (21), SSH (22), Telnet (23), SMTP (25), HTTP (80), POP3 (110).
* Les __ports enregistrés__ sont généralement utilisés par des applications utilisateur comme ports sources éphémères pour se connecter à un serveur, mais ils peuvent aussi identifier des services non enregistrés par l'IANA.
* Les __ports dynamiques/privés__ peuvent aussi être utilisés par des applications utilisateur, mais plus rarement. Ils n'ont pas de sens en dehors d'une connexion TCP particulière.


### <a name="clarification_tcp" /> Transmission Control Protocol (TCP) (protocole de contrôle de transmissions)

Une session TCP fonctionne en trois phases :

* l'établissement de la connexion ;
* les transferts de données ;
* la fin de la connexion.

L'établissement de la connexion se fait par un [handshaking en trois temps](https://fr.wikipedia.org/wiki/Three-way_handshake). La rupture de connexion, elle, utilise un [handshaking](https://fr.wikipedia.org/wiki/Handshaking) en quatre temps. Pendant la phase d'établissement de la connexion, des paramètres comme le numéro de séquence sont initialisés afin d'assurer la transmission fiable (sans perte et dans l'ordre) des données.

En d'autre mot lorsque lors que 2 application désire communiquer entre elle avec le protocole __TCP__ :

* Elles se saluent , en ce serrant la main ( établissement de connexion , 3 __way handshake__)
* Elles communiquent, en échangeant des données ( transfert de données )
* Elles se disent au revoir , en ce serrant encore la main ( fin de connexion , 4 __way handshake__)

Dit comme ça on peut pas dire que ce soit compliqué :D.

Voyons à présent comment se réalise chacune des étapes , nous utiliserons un serveur apache et un client __telnet__. Afin de visualiser les communications client serveur nous utiliserons __tcpdump__ et __wireshark__ (disponible sous l'ensemble des OS).


#### <a name="clarification_tcp_3way_handshake" /> TCP établissement de connexion (3 way handshake)

Le côté client de la connexion effectue une ouverture active en 3 temps :

1. Le client envoie un segment SYN au serveur,
2. Le serveur lui répond par un segment SYN/ACK,
3. Le client confirme par un segment ACK.

Maintenant on décrit la même opération en changeant __SYN__ par "salut" et __ACK__ par "ça va "

1. Le client dit **Salut**
2. Le serveur répond **Salut/Ça va ?**
3. Le client confirme **ça va** 

J'aime vulgarisé le processus afin de montrer la simplicité du processus :D.

Durant cet échange initial, les numéros de séquence des deux parties sont synchronisés :

1. Le client utilise son numéro de séquence initial dans le champ "Numéro de séquence" du segment SYN (x par exemple),
2. Le serveur utilise son numéro de séquence initial dans le champ "Numéro de séquence" du segment SYN/ACK (y par exemple) et ajoute le numéro de séquence du client plus un (x+1) dans le champ "Numéro d'acquittement" du segment,
3. Le client confirme en envoyant un ACK avec un numéro de séquence augmenté de un (x+1) et un numéro d'acquittement correspondant au numéro de séquence du serveur plus un (y+1).

Voici une représentation graphique du processus : 

<img src="https://upload.wikimedia.org/wikipedia/commons/6/6c/Tcp_connect.svg" width="700px" />

Par <a href="//commons.wikimedia.org/w/index.php?title=User:Skc&amp;action=edit&amp;redlink=1" class="new" title="User:Skc (page does not exist)">Sébastien Koechlin</a> — <span class="int-own-work" lang="fr">Travail personnel</span>, <a title="Creative Commons Attribution-Share Alike 3.0" href="http://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>, https://commons.wikimedia.org/w/index.php?curid=16887424

Je vais revenir dans quelques instant lors d'un exemple de communication sur l'aspect du numéro de séquence voici rapidement un avant goût : 

* Pendant la phase de transferts de données, certains mécanismes clefs permettent d'assurer la robustesse et la fiabilité de TCP. En particulier, les numéros de séquence sont utilisés afin d'ordonner les segments TCP reçus et de détecter les données perdues, les sommes de contrôle permettent la détection d'erreurs, et les acquittements ainsi que les temporisations permettent la détection des segments perdus ou retardés.

Nous allons voir dans la pratique / sur le terrain ce que ça donne réellement, mais avant j'aimerai présenter un paquet __TCP__ ceci nous aidera pour le lire.

#### <a name="clarification_tcp_structure" /> Structure d'un segment TCP

Référence : [https://fr.wikipedia.org/wiki/Transmission_Control_Protocol#Structure_d.27un_segment_TCP](https://fr.wikipedia.org/wiki/Transmission_Control_Protocol#Structure_d.27un_segment_TCP)


Voici la structure d'un paquet **TCP**

<p><b>En bits</b></p>
<table bgcolor="#AAAAEE" border="1" cellspacing="1" cellpadding="1" style="font-size: 9pt;">
<tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>20</td>
<td>21</td>
<td>22</td>
<td>23</td>
<td>24</td>
<td>25</td>
<td>26</td>
<td>27</td>
<td>28</td>
<td>29</td>
<td>30</td>
<td>31</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="16">
<center>Port Source 2 octets</center>
</td>
<td bgcolor="#F7F8FF" colspan="16">
<center>Port destination 2 octets</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="32">
<center>Numéro de séquence</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="32">
<center>Numéro d'acquittement</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="4">
<center>Taille de l'en-tête</center>
</td>
<td bgcolor="#F7F8FF" colspan="3">
<center>Réservé</center>
</td>
<td bgcolor="#F7F8FF">
<center>ECN / NS</center>
</td>
<td bgcolor="#F7F8FF">
<center>CWR</center>
</td>
<td bgcolor="#F7F8FF">
<center>ECE</center>
</td>
<td bgcolor="#F7F8FF">
<center>URG</center>
</td>
<td bgcolor="#F7F8FF">
<center>ACK</center>
</td>
<td bgcolor="#F7F8FF">
<center>PSH</center>
</td>
<td bgcolor="#F7F8FF">
<center>RST</center>
</td>
<td bgcolor="#F7F8FF">
<center>SYN</center>
</td>
<td bgcolor="#F7F8FF">
<center>FIN</center>
</td>
<td bgcolor="#F7F8FF" colspan="16">
<center>Fenêtre</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="16">
<center>Somme de contrôle</center>
</td>
<td bgcolor="#F7F8FF" colspan="16">
<center>Pointeur de données urgentes</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="22">
<center>Options</center>
</td>
<td bgcolor="#F7F8FF" colspan="10">
<center>Remplissage</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="32">
<center>Données</center>
</td>
</tr>
</table>

Voyons ce que l'ensemble le détail pour chaque champs :

* **Port source** : numéro du port source
* **Port destination** : numéro du port destination
* **Numéro de séquence** : numéro de séquence du premier octet de ce segment
* **Numéro d'acquittement** : numéro de séquence du prochain octet attendu
* **Taille de l'en-tête** : longueur de l'en-tête en mots de 32 bits (les options font partie de l'en-tête)
* __Flags__ :
    * **Réservé** : réservé pour un usage futur
    * **ECN/NS** : signale la présence de congestion, voir RFC 3168 ; ou Nonce Signaling, voir RFC 3540
    * **CWR** : Congestion Window Reduced : indique qu'un paquet avec ECE a été reçu et que la congestion a été traitée
    * **ECE** : ECN-Echo : si SYN=1 indique la capacité de gestion ECN, si SYN=0 indique une congestion signalé par IP (voir RFC 3168)
    * **URG** : Signale la présence de données urgentes
    * **ACK** : signale que le paquet est un accusé de réception (acknowledgement)
    * **PSH** : données à envoyer tout de suite (push)
    * **RST** : rupture anormale de la connexion (reset)
    * **SYN** : demande de synchronisation ou établissement de connexion
    * **FIN** : demande la fin de la connexion
* **Fenêtre** : taille de fenêtre demandée, c'est-à-dire le nombre d'octets que le récepteur souhaite recevoir sans accusé de réception
* **Somme de contrôle/CRC** : somme de contrôle calculée sur l'ensemble de l'en-tête TCP et des données, mais aussi sur un pseudo en-tête (extrait de l'en-tête IP)
* **Pointeur de données urgentes** : position relative des dernières données urgentes
* **Options** : facultatives
* **Remplissage** : zéros ajoutés pour aligner les champs suivants du paquet sur 32 bits, si nécessaire
* **Données** : séquences d'octets transmis par l'application (par exemple : __GET /__)

On voit que c'est pas mal complet en plus des données (à la fin) il y a beaucoup de champs qui peuvent être remplie en plus des __flags__.

**MAIS où sont les adresses ip ?** , très bonne question :D, le protocole __TCP__ n'a aucune idée de l'adresse __IP__ où établir la connexion , ce n'est pas son travail ceci est fait par la couche **Internet** . L'ensemble du trajet pour établir une connexion entre 2 machines est réalisé par la par **IP** dans __TCP__/**IP**. Ceci peut semblé être un détail mais lors de l'analyse de problème de connexion ceci peut être très important. Comme nous (__aka__ moi) avons décidé  de partir de l'application nous verrons ceci plus tard :), gardons en tête pour le moment que la couche __Internet__ fonctionne par magie :D.
Le protocole __TCP__ est donc indépendant du chemin c'est pour ça que l'on peut changé la couche __IP__ pour passé de __IPv4__ à __IPv6__ sans changer le protocole __TCP__. Nous pourrions en théorie avoir un autre protocole pour la couche __Internet__ et avoir une communication __TCP/tboutry__ :D , mais bon c'est pas pour demain que je vais le faire ;-).


##### <a name="visualisation_connexion" /> Visualisation d'une communication TCP

Afin voir le processus nous allons réalisé une connexion avec l'application __telnet__ vers un serveur __Apache__ l'opération sera simplement l'extraction de la page d'accueil. Si nous réalisons l'opération manuellement et regardons le résultat ceci donne : 

        $ telnet 172.17.0.1 80
        Trying 172.17.0.1...
        Connected to 172.17.0.1.
        Escape character is '^]'.
        GET /
        <html>
            <body>
                  <h3> Le site du mouton dessins </h3>
                  <img src=./dessin_mouton.jpg />
            </body>
        </html>

        Connection closed by foreign host.

        # coté serveur , les logs donnent :
        ==> /var/log/apache2/access.log <==
        172.17.42.1 - - [08/Aug/2016:17:17:08 -0400] "GET /" 200 126 "-" "-"

Maintenant nous allons sniffer le trafic réseau afin de voir les paquets __TCP__ qui sont passés, nous utiliserons [wireshark](https://wireshark.org/) et __TCPDUMP__.

Démarrage de __wireshark__, je le démarre comme __root__ afin d'avoir l'ensemble des permissions de lire le trafic sur la carte ceci est évidement réservé à l'administrateur de la machine.

        $ sudo wireshark-gtk 

Je sélectionne l'interface réseau que je désire capturer , dans mon cas je choisie l'interface docker, car mon serveur apache est dans un docker (quelle surprise ;-) ).

![wireshark_select_interface_01.png](./imgs/wireshark_select_interface_01.png)

Maintenant je vais définir un filtre car si vous avez beaucoup de trafic vous serez vite noyé dans la quantité de données reçu. Nous allons donc limité les paquets pour le __host__ 172.17.0.2 et le port 80. 

![wireshark_select_interface_et_define_filter_02.png](./imgs/wireshark_select_interface_et_define_filter_02.png)

Voici le résultat du filtre :

        ip.dst == 172.17.0.2 && tcp.dstport == 80 && ip.proto == TCP

Pour rappel voici le processus d'établissement de connexion :

* l'établissement de la connexion ;
* les transferts de données ;
* la fin de la connexion.

Le serveur à l'IP 172.17.0.2 
Le client à l'IP 172.17.42.1

###### <a name="visualisation_connexion_conn" /> Établissement de la connexion

Nous allons donc établir la connexion vers le serveur avec la commande __telnet__

        $ telnet 172.17.0.2  80
        Trying 172.17.0.1...
        Connected to 172.17.0.1.
        Escape character is '^]'.

**STOP** on ne fait rien d'autre , on regarde maintenant ce que l'application d'analyse du trafic indique :

Nous pouvons voir l'établissement de connexion en trois temps (__3 way handshake__) :

![wireshark_visualisation_3way_handshake_03.png](./imgs/wireshark_visualisation_3way_handshake_03.png)

Si vous regardez dans la section du bas vous pouvez voir le détail du paquet __TCP__:

![wireshark_visualisation_detail_paquet_tcp_04.png](./imgs/wireshark_visualisation_detail_paquet_tcp_04.png)

La connexion est donc établie à cette étape mais aucune donnée n'est transmis , le temps d'écrire ou d'expliquer l'ensemble de la communication j'ai dû couper la communication je vais donc la reprendre mais cette fois en transmettant des données.

###### <a name="visualisation_transfert_data" /> Transferts de données 

La connexion est donc établie , le client __Telnet__ une fois la connexion établie envoyer des données dans notre cas : 

        GET /

Dans le but de récupérer la page d'accueil , le fureteur fait sensiblement la même , mais il transmet plus d'information , cependant l'idée reste la même . Une fois que le serveur va recevoir ces données / cette instruction il va transmettre la page d'accueil.

C'est parti :)

        $ telnet 172.17.0.2 80
        Trying 172.17.0.2...
        Connected to 172.17.0.2.
        Escape character is '^]'.
        GET /
        <html>
            <body>
                <h3> Le site du mouton dessins </h3>
                <img src=./dessin_mouton.jpg />
            </body>
        </html>

        Connection closed by foreign host.


Une fois l'information de la page reçu , le serveur web (__foreign host__) à coupé la communication nous y reviendrons dans la prochaine étape. Visualisons dans __wireshark__ le processus de transfert de données :

![wireshark_visualisation_transfert_data_paquet_tcp_05.png](./imgs/wireshark_visualisation_transfert_data_paquet_tcp_05.png)

J'ai volontairement caché la partie de la coupure de connexion , pour ne pas perdre notre objectif de vue :0.

Donc les 3 premières lignes est l'établissement de connexion entre le client et le serveur.

* ligne 4 : Nous voyons le client (Source) qui envoie au serveur la requête 
* ligne 5 : Le serveur confirme la réception du paquet / de la demande 
* ligne 6 : Le serveur envoie les données de la page __index.html__ conformément à la requête du client 
* ligne 7 : Le client confirme qu'il a bien reçu l'information

Bien entendu ici nous avons des petites communication qui rentre dans 1 paquet __TCP__, lors de l'envoie de fichier il est probable que la communication s'étende sur plusieurs paquet et seront reconstruit par l'application par la suite . Nous réaliserons la même opération avec le fureteur afin de voir le comportement.

###### <a name="visualisation_connexion_fin" /> Fin de la connexion.

Comme nous avons pu le voir lors de la visualisation de l'opération via __telnet__ c'est le serveur apache qui coupe la connexion. Voici le processus de fermeture de connexion :

<img src="https://upload.wikimedia.org/wikipedia/commons/4/42/Tcp_close.svg" width="700px" />

Par <a href="//commons.wikimedia.org/w/index.php?title=User:Skc&amp;action=edit&amp;redlink=1" class="new" title="User:Skc (page does not exist)">Sébastien Koechlin</a> — <span class="int-own-work" lang="fr">Travail personnel</span>, <a title="Creative Commons Attribution-Share Alike 3.0" href="http://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>, https://commons.wikimedia.org/w/index.php?curid=16887424

La phase de terminaison d'une connexion utilise un handshaking en quatre temps, chaque extrémité de la connexion effectuant sa terminaison de manière indépendante. Ainsi, la fin d'une connexion nécessite une paire de segments FIN et ACK pour chaque extrémité.

Regardons maintenant  l'information dans __wiresharke__ :

![wireshark_visualisation_fin_conn_tcp_06.png](./imgs/wireshark_visualisation_fin_conn_tcp_06.png)


* ligne 8 : Le serveur apache transmet un __FIN__ / __ACK__
* ligne 9 : Le client envoie la même information __FIN__ / __ACK__
* ligne 10 : Le serveur confirme la réception est termine la connexion __ACK__

##### <a name="visualisation_connexion_fureteur" /> Visualisation d'une communication TCP réalisé par le fureteur

Ceci est une version très simple nous avons réduit au maximum les intervenants pour bien voir les paquets et pouvoir les étudier facilement. Voyons le même processus avec le fureteur, lors de l'utilisation de la commande __telnet__ nous avons vu uniquement la récupération du __HTML__ cependant nous n'avions pas récupérer le contenu de la page réellement en effet nous n'avions pas extrait l'image du mouton.

Voici ce qui est afficher à l'écran : 

![screenshot_siteweb.png](./imgs/screenshot_siteweb.png)

Lors de la communication voici ce qui est afficher dans __wireshark__ , prendre note que l'IP du serveur web est 172.17.0.1 maintenant :

![wireshark_visualisation_fureteur_07.png](./imgs/wireshark_visualisation_fureteur_07.png)

Donc les explications :

* ligne 1 à 3 : l'établissement de connexion __TCP__ __3 way handshake__
* ligne 4 : Envoie de l'instruction __GET / HTTP/1.1__ qui est relativement la même commande qu'avec __telnet__ cependant il utilise le protocole __http__ 1.1 spécifiquement . Ceci est définie dans la couche applicative par dessus __TCP__ , car c'est les données transmise pour communiquer
* ligne 5 : Le serveur confirme la réception
* ligne 6 : Le serveur selon le protocole __HTTP 1.1__ transmet une confirmation que la requête est bonne. Nous verrons le détail du contenu tous de suite après les explications par ligne . Ceci est purement du protocole __HTTP__ est ne concerne que très peu le __TCP__
* ligne 7 : Le client confirme la réception de l'information 
* ligne 8 : Le client demande l'image du mouton , car ce dernier fut traiter lors de l'interprétation de la page d'index __html__
* ligne 9 et 10 : Le serveur transmet l'image du mouton , comme l'image du mouton ne peut pas être transmise dans 1 paquet, car il est trop gros, il le transmet dans 2 paquets 
* ligne 11 et 12 : Le client confirme la réception des 2 paquets , donc l'ensemble de l'image du mouton
* ligne 13 à 15 : Fermeture par le serveur et le client de la connexion __TCP__

On peut pas dire que ce soit extrêmement compliqué, bien entendu nous voyons un site TRÈS simple. Nous pourrons faire le même exercice avec un site plus complexe la quantité de donnée sera plus impressionnante, mais le processus sera identique.

__WireShark__ nous offre une belle fonctionnalité, comme le protocole __HTTP__ est connu il est possible d'extraire l'information des paquets __TCP__ pour le protocole __HTTP__ afin de voir simplement le contenu . Sélectionné un paquet, cliquez le bouton droit de la souris et sélectionnez **Follow TCP stream**.

![wireshark_visualisation_fureteur_follow_tcpstream_08.png](./imgs/wireshark_visualisation_fureteur_follow_tcpstream_08.png)

Voici le résultat :

![wireshark_visualisation_fureteur_follow_tcpstream_09.png](./imgs/wireshark_visualisation_fureteur_follow_tcpstream_09.png)

Nous voyons plus clairement maintenant l'échange qui fut réalisé à la ligne 4 et à la ligne 6 , j'avais mentionné que le client envoie __GET / HTTP/1.1__ et le serveur l'accusé de validation pour la racine mais c'était pour faire simple :P.
En réalité , le serveur et le client échange les protocoles supporté pour le reste des communications :P , c'est la version compliqué mais au niveau de la touche __Transport__ ça na pas d'importance car c'est uniquement du protocole __HTTP__.
Bien entendu si vous analysez un problème de communication du serveur apache, ceci est très intéressant, mais pour le besoin de la formation ici c'est en dehors de la matière.

##### <a name="visualisation_conn_fureteur_ext" /> Visualisation d'une communication TCP réalisé par le fureteur avec site complet

Prenons quelques minutes pour voir la même opération sur un autre site, pas trop gros pour pouvoir visualiser facilement le résultat, cependant ceci nous montrera clairement les même opérations. 

Je vais utiliser mon fureteur afin de communiquer avec le site : http://x3rus.com/moodle .

Dans cette situation je ne vais pas prendre l'interface __docker__, mais l'interface externe soit __wlan0__ dans mon cas !

![wireshark_configue_all_http_comm_10.png](./imgs/wireshark_configue_all_http_comm_10.png)

Voici le résultat :

![wireshark_visualisation_comm_x3rus_moodle_full_11.png](./imgs/wireshark_visualisation_comm_x3rus_moodle_full_11.png)

Le fichier de données est aussi disponible ICI : 

Comme vous pouvez le voir il y a plus de donnée , premièrement il y a la requête __DNS__ , puis il y a la requête __TCP__ sur le port 80 . 

Nous pouvons suivre la communication __TCP__ en sélectionnant cette communication :

![wireshark_visualisation_comm_x3rus_moodle_12.png](./imgs/wireshark_visualisation_comm_x3rus_moodle_12.png)

Analysons rapidement :

* Paquets 5 , 10 et 11 : représente la connexion __TCP__ __3 way handshake__ sur le port 80
* Paquets 12 à 25 : Les données qui sont transférés entre le client et le serveur
* Paquets 34 , 35 et 36 : La fermeture de la connexion __TCP__

Mais il y a un autre flux __TCP__ un flux vers le port 443 donc le service communique en __SSL__, bon honnêtement j'ai pas tout de suite compris pourquoi :P. J'ai du analyser pourquoi il y avait cette communication, car il n'y a rien dans la page de __moodle__ en __https__. Regardons la communication :

![wireshark_visualisation_comm_x3rus_moodle_comm_ssl_12.png](./imgs/wireshark_visualisation_comm_x3rus_moodle_comm_ssl_12.png)

Je ne vais pas prendre le temps d'analyser le protocole **httpS** , mais je veux vous montrer la partie __TCP__ autant en profiter :D, c'était pas prévue mais autant d'amuser ... 

* Ligne 36, 37 et 38 :  Nous avons la connexion __TCP__ __3 way handshake__ sur le port 443
* Ligne 40 à 47 : Le transfert de données en utilisant le protocole **httpS** , comme l'information est chiffré je ne vois pas la communication clairement comme lors des échanges sur le port 80 :-/
* Ligne 48 , 49 et 50 : Fermeture de la connexion

Comme nous pouvons le voir peut importe la communication réalisé selon le protocole au niveau de la couche __TCP__ il n'y a pas de différence. Bon pour information, maintenant c'est quoi ce trafic :-), j'ai du allé sur le serveur pour voir les logs du serveur apache :P, finalement c'est simplement mon agent __owncloud__ qui communique en __background__ sur mon __laptop__.
Résultat ça à fait du bruit sur le file réseau , je l'avais oublié , mais on a capitalisé sur l'erreur :D.


#### <a name="clarification_tcp_conclusion" /> Conclusion sur le TCP 

Ceci est donc une introduction pour les communications __TCP__ , nous avons couvert la base quand tous va bien :D , lorsque nous allons faire la couche __Internet__ nous allons voir comment le protocole __TCP__ se comporte en cas de problème de communication. Ceci nous permettra d'approfondir le sujet et voir les mécanismes en place pour valider les communications.

L'important de comprendre avec le protocole __TCP__ est que le client et le serveur établisse un lien de communication et échange les données par ce canal. Une fois la communication terminé, il se salut et ferme le canal de communication.

### <a name="clarification_udp" /> User Datagram Protocol (UDP) (protocole de contrôle de transmissions)


Contrairement au protocole __TCP__, il fonctionne sans négociation : il n'existe pas de procédure de connexion préalable à l'envoi des données (le __handshaking__). Donc __UDP__ ne garantit pas la bonne livraison des paquets à destination, ni leur ordre d'arrivée. Il est également possible que des paquets soient reçus en plusieurs exemplaires.

Si nous reprenons une communication __TCP__ , vous vous rappelez à chaque paquet transmit par un __host__ l'autre répondait par une confirmation __ACK__ de réception , ce mécanisme n'est pas présent avec __UDP__. Nous l'avons pas vu nous allons le faire par la suite , mais le protocole __TCP__ renvoie le paquet s'il n'a pas reçu la confirmation de réception. Dans le cas de __UDP__ comme il n'y a pas d'accusé de réception , l'hôte ne peut pas savoir si le paquet est reçu.

Pourquoi utiliser __UDP__ alors si nous avons un risque de perte de paquets ?? La transmission d'accusé de réception à un coup sur le trafic réseau et sur le temps de traitement. Si nous prenons le cas d'un transfert de fichier il est important d'avoir l'ensemble des paquets pour avoir l'intégrité du fichier. Si nous prenons un cas où __l'UDP__  est très utilisé les jeux vidéos en ligne, S'il y a eu un problème sur le lien et que certain paquet ne sont pas passé quelle est la pertinence de les retransmettre ? Si tu joue à __Quake__ , de toute manière t'es déjà mort :P. Sans farce , les jeux sont assez rapide l'état il y a quelques seconde n'est plus pertinente s'il y a renvoie des paquets, de plus s'il y  a un nombre important de joueurs il est important que la communication soit le plus rapidement possible. 

Le service __DNS__ utilise aussi le protocole __UDP__, ceci permet de réduire la charge sur le serveur et le client s'il n'a pas reçu la réponse peut refaire la requête.

#### <a name="clarification_udp_structure" /> Structure d'un segment UDP

Référence : [https://fr.wikipedia.org/wiki/User\_Datagram\_Protocol](https://fr.wikipedia.org/wiki/User_Datagram_Protocol)

Comme vous pouvez le constater , la structure est beaucoup plus simple que le paquet __TCP__, comme il n'y a pas toute la gestion de connexion et de communication, nous nous retrouvons simplement avec le contenu des données. Tous comme pour le protocole __TCP__ il y a la notion de port pour l'envoie de communication.

<table class="wikitable" style="margin: 0 auto; text-align: center;">
<tr>
<td width="35%" bgcolor="#00DDDD">Port Source (<span class="nowrap">16&#160;bits</span>)</td>
<td width="35%" bgcolor="#00DDDD">Port Destination (<span class="nowrap">16&#160;bits</span>)</td>
</tr>
<tr>
<td width="35%" bgcolor="#00DDDD">Longueur (<span class="nowrap">16&#160;bits</span>)</td>
<td width="35%" bgcolor="#00DDDD">Somme de contrôle (<span class="nowrap">16&#160;bits</span>)</td>
</tr>
<tr>
<td width="70%" colspan="2">Données (longueur variable)</td>
</tr>
</table>


* **Port Source** : indique depuis quel port le paquet a été envoyé.
* **Port de Destination** : indique à quel port le paquet doit être envoyé.
* **Longueur** : indique la longueur totale (exprimée en octets) du paquet __UDP__ (en-tête et données). La longueur minimale est donc de 8 octets (taille de l'en-tête).
* **Somme de contrôle** : celle-ci permet de s'assurer de l'intégrité du paquet reçu quand elle est différente de zéro. Elle est calculée sur l'ensemble de l'en-tête __UDP__ et des données, mais aussi sur un pseudo en-tête (extrait de l'en-tête IP)

Tout comme pour la communication __TCP__ il n'y a pas de notion d'__IP__ à ce niveau car ceci est géré par la couche __Internet__! 

##### <a name="visualisation_connexion_udp" /> Visualisation d'une communication UDP

Afin voir le processus nous allons réalisé une requête __DNS__ au serveur google (8.8.8.8) , pour ce faire nous utiliserons la commande **dig**. Voici le résultat à l'écran :

        $ dig lequipe.fr @8.8.8.8

        ; <<>> DiG 9.10.3 <<>> lequipe.fr @8.8.8.8
        ;; global options: +cmd
        ;; Got answer:
        ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 32099
        ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

        ;; OPT PSEUDOSECTION:
        ; EDNS: version: 0, flags:; udp: 512
        ;; QUESTION SECTION:
        ;lequipe.fr.                    IN      A

        ;; ANSWER SECTION:
        lequipe.fr.             222     IN      A       160.92.167.203

        ;; Query time: 71 msec
        ;; SERVER: 8.8.8.8#53(8.8.8.8)
        ;; WHEN: Fri Aug 12 17:30:25 EDT 2016
        ;; MSG SIZE  rcvd: 55

Démarrons **Wireshark** pour sniffé le trafic :

        $ sudo wireshark-gtk

![wireshark_visualisation_requete_dns_14.png](./imgswireshark_visualisation_requete_dns_14.png)

Nous voyons lors de l'utilisation ceci  :

![wireshark_visualisation_requete_dns_lequipe_fr_14.png](./imgs/wireshark_visualisation_requete_dns_lequipe_fr_14.png)

Comme vous pouvez voir il n'y a vraiment pas le __3 way handshake__, nous voyons l'envoie de la requête et la réception. AUCUNE présence d'accusé de réception si le paquet se perd le client ne le sait pas. La communication est petite , une demande , une réponse rien d'autre , voyons maintenant une communication contenant plus d'information .


##### <a name="visualisation_connexion_snmp" /> Visualisation d'une communication UDP avec l'application snmp

Nous allons utiliser le système __snmp__ pour réalisé la démonstration , nous avons un nombre important de donnée qui peut être transférer tout en restant simple. Ceci aura aussi la chance de présenté ce protocole qui n'est pas connu de tous . Bien entendu nous aurions pu faire la démonstration avec un jeu en ligne aussi , mais il y aurait eu beaucoup de bruit sur la communication. 

Description d'__SNMP__ : __SNMP__ est protocole qui permet de collecter des informations d'un système ou d'un équipement , nous retrouvons des informations de monitoring telle que l'utilisation de la mémoire ou du CPU , la liste des packages présent sur le système , les processus qui sont en exécution , des informations sur la carte réseaux ... Il est aussi possible d'exécuter des commandes à distances. Présent aussi bien pour les systèmes d'exploitation ( GNU/Linux, Windows , ...) que pour les __switchs__ et __firewall__ ( __cisco__ , __HP__ , __jenniper__ , ...) . [https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol](https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol)

TODO : Vous pourrez retrouvé la configuration du serveur snmpd que je vais utilisé sur hub.docker.com/x3nejfhe

TODO : ICI ICI completer.

#### <a name="clarification_udp_conclusion" /> Conclusion sur le UDP

Nous venons de voir le comportement du protocole __UDP__ quand tous fonctionne bien nous verrons un peu plus tard le comportement en cas de problème de communication. Comme le client et le serveur n'établisse pas de connexion contrairement au protocole __TCP__ il y a moins de mécanisme de validation. 
Il est important de comprendre que le protocole __UDP__ ne réalise pas de validation de réception de la communication transmise . L'avantage de l'__UDP__ est qu'il est moins gourmand que le protocole __TCP__ justement à cause de validation moins  importante.

## <a name="clarification_diff_tcp_udp" /> Autre protocole

*     [SCTP](https://fr.wikipedia.org/wiki/Stream_Control_Transmission_Protocol) (Stream Control Transmission Protocol), protocole fournissant des services similaires à TCP (fiabilité, remise en ordre des séquences, et contrôle de congestion), tout en offrant la possibilité de communications multi-cibles comme avec UDP.
*     [MPTCP](https://fr.wikipedia.org/wiki/Multipath_TCP) (Multipath TCP) est une surcouche à TCP qui rassemble diverses connexions TCP (à travers différentes interfaces réseau: GSM, Wifi etc.), au sein d'une même méta-connexion (RFC 6824). Ce fonctionnement permet d'exploiter tous les chemins disponibles en parallèle, et donc améliorer significativement les performances et la fiabilité d'une connexion.



## <a name="couche_Internet" /> Couche Internet (IP)

Passons maintenant à la partie **IP** de __TCP__/**IP**, comme nous avons vu lors de la présentation du protocole __TCP__ ou __UDP__ les en-têtes des paquets ne contienne pas d'information sur la source du __host__ ou la destination  du __host__. J'avais mentionné que ceci est normal car cette opération est réalisé par l'autre couche , la couche __Internet__ . Nous allons voir maintenant cette couche, l'objectif de la couche __Internet__ et dans notre cas le protocole IP est de transmettre les paquets d'un point A à B.

Si nous reprenons notre exemple de la lettre que l'on poste la couche **Transport** s'occupe de livrer la livre à son destinataire , du côté de l'application ou même de la couche **Transport** peut importe la méthode. 

Voici une représentation graphique de la structure d'un paquet __TCP__ ici, mais ceci est la même chose pour les paquets __UDP__ ce n'est que les en tête qui change :

![Osi-encapsulation.gif](./imgs/Osi-encapsulation.gif)

Nous voyons clairement qu'à chaque couche, il y a un ajout d'information qui est réalisé, nous partons des données de l'application , le tous enveloppé dans une trame __TCP__ , par la suite , il y a ajout des informations __IP__ pour la destination du __host__ et pour finir les informations de la carte réseau dans notre cas.

### <a name="clarification_IP_structure" /> Structure du paquet IP

Nous avons vu les en-tête des paquets __TCP__ et __UDP__ prenons quelques minutes pour regarder la partie __IP__ de la communication  :

<table class="wikitable" style="width: 750px">
<caption>En-tête IPv4</caption>
<tr>
<td width="3.125%">0</td>
<td width="3.125%">1</td>
<td width="3.125%">2</td>
<td width="3.125%">3</td>
<td width="3.125%">4</td>
<td width="3.125%">5</td>
<td width="3.125%">6</td>
<td width="3.125%">7</td>
<td width="3.125%">8</td>
<td width="3.125%">9</td>
<td width="3.125%">10</td>
<td width="3.125%">11</td>
<td width="3.125%">12</td>
<td width="3.125%">13</td>
<td width="3.125%">14</td>
<td width="3.125%">15</td>
<td width="3.125%">16</td>
<td width="3.125%">17</td>
<td width="3.125%">18</td>
<td width="3.125%">19</td>
<td width="3.125%">20</td>
<td width="3.125%">21</td>
<td width="3.125%">22</td>
<td width="3.125%">23</td>
<td width="3.125%">24</td>
<td width="3.125%">25</td>
<td width="3.125%">26</td>
<td width="3.125%">27</td>
<td width="3.125%">28</td>
<td width="3.125%">29</td>
<td width="3.125%">30</td>
<td width="3.125%">31</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="4">
<center>Version d'IP</center>
</td>
<td bgcolor="#F7F8FF" colspan="4">
<center>Longueur de l'en-tête</center>
</td>
<td bgcolor="#F7F8FF" colspan="8">
<center>Type de service</center>
</td>
<td bgcolor="#F7F8FF" colspan="16">
<center>Longueur totale</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="16">
<center>Identification</center>
</td>
<td bgcolor="#F7F8FF" colspan="3">
<center>Indicateur</center>
</td>
<td bgcolor="#F7F8FF" colspan="13">
<center><span class="lang-en" lang="en">Fragment offset</span></center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="8">
<center>Durée de vie</center>
</td>
<td bgcolor="#F7F8FF" colspan="8">
<center>Protocole</center>
</td>
<td bgcolor="#F7F8FF" colspan="16">
<center>Somme de contrôle de l'en-tête</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="32">
<center>Adresse source</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="32">
<center>Adresse destination</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="32">
<center>Option(s) + remplissage</center>
</td>
</tr>
</table>

Il y a pas mal d'option, nous ne retrouvons pas uniquement l'adresse __ip__ source et la destination , listons le détail :

* **Version** (4 bits) : Version d'IP utilisée (IPv4 , IPv6)
* **Longueur de l'en-tête ou IHL** (pour Internet Header Length) (4 bits) : Nombre de mots de 32 bits, soit 4 octets (ou nombre de lignes du schéma). La valeur est comprise entre 5 et 15, car il y a 20 octets minimum et on ne peut dépasser 40 octets d'option
* **Type de service ou ToS** (pour Type of Service) (8 bits) : Ce champ permet de distinguer différentes qualités de service différenciant la manière dont les paquets sont traités. Composé de 3 bits de priorité (donc 8 niveaux) et trois indicateurs permettant de différencier le débit, le délai ou la fiabilité. Il se décline au fil des RFC. Au départ ([RFC 791](https://tools.ietf.org/html/rfc791)), [RFC 2474](https://tools.ietf.org/html/rfc2474), [RFC 3168](https://tools.ietf.org/html/rfc3168)
* **Longueur totale** en octets ou Total Length (16 bits) : Nombre total d'octets du datagramme, en-tête IP comprise. Donc, la valeur maximale est (216)-1 octets.
* **Identification** (16 bits): Numéro permettant d'identifier les fragments d'un même paquet.
* **Indicateurs** ou Flags (3 bits): 
    * (Premier bit) actuellement inutilisé.
    * (Deuxième bit) DF (Don't Fragment) : lorsque ce bit est positionné à 1, il indique que le paquet ne peut pas être fragmenté. Si le routeur ne peut acheminer ce paquet (taille du paquet supérieure à la MTU), il est alors rejeté.
    * (Troisième bit) MF (More Fragments) : quand ce bit est positionné à 1, on sait que ce paquet est un fragment de données et que d'autres doivent suivre. Quand il est à 0, soit le fragment est le dernier, soit le paquet n'a pas été fragmenté.
* **Fragment offset** (13 bits) :Position du fragment par rapport au paquet de départ, en nombre de mots de 8 octets. 
* **Durée de vie** ou __TTL__ (pour __Time To Live__) (8 bits) : Initialisé par l'émetteur, ce champ est décrémenté d'une unité généralement à chaque saut de routeur. Quand TTL = 0, le paquet est abandonné et un message ICMP est envoyé à l'émetteur pour information. 
* **Protocole** (8 bits) : Numéro du protocole au-dessus de la couche réseau : TCP = 6, UDP = 17, ICMP = 1.
    Ce champ permet d'identifier le protocole utilisé par le niveau supérieur :
    * Internet Control Message Protocol ou ICMP est repéré par les bits 00000001, qu'on écrit souvent en hexadécimal avec 01
    * Transmission Control Protocol ou TCP par les bits 00000110, soit 06
    * User Datagram Protocol ou UDP par les bits 00010001, soit 17 en décimal
* **Somme de contrôle de l'en-tête** ou Header Checksum (16 bits) : Complément à un de la somme complémentée à un de tout le contenu de l'en-tête afin de détecter les erreurs de transfert. Si la somme de contrôle est invalide, le paquet est abandonné sans message d'erreur.
* **Adresse source** (32 bits) : Adresse IP de l'émetteur sur 32 bits.
* **Adresse destination** (32 bits) : Adresse IP du récepteur 32 bits.
* **Options** (0 à 40 octets par mots de 4 octets) : Facultatif. 
* **Remplissage** ou Padding : Champ de taille variable comprise entre 0 et 7 bits. Il permet de combler le champ option afin d'obtenir un en-tête IP multiple de 32 bits. La valeur des bits de bourrage est 0. 


Bon à ce stade de la formation on va pas tous voir , je voulais principalement démontré l'aspect complet du paquet, ce qui nous aidera par la suite afin de comprendre le comportement surtout dans la deuxième partie quand nous causerons des problèmes de communication :D.

À ce stade nous allons nous soucier de :
* Identification
* Durée de vie
* Protocole
* Adresse source
* Adresse destination

### <a name="clarification_adressage_ip" /> Adresses IP et sous-réseau

L'ensemble du protocole IP se base sur les adresses IP, nous ne couvrirons que le protocoles **IPv4**, __l'IPv6__ est disponible mais pas encore répandu sur l'ensemble des réseaux. __L'IPv6__ a un comportement similaire avec quelques particularité et amélioration , je vous invite fortement à en prendre connaissance pour le future. 

Chaque Hôte sur le réseau doit avoir une adresse IP pour que la communication fonctionne , il y a plusieurs classe d'adresse IP, certaines adresses IP sont réservé pour des usages particulier: [Plages d'adresses IP spéciales](https://fr.wikipedia.org/wiki/Adresse_IP#Plages_d.27adresses_IP_sp.C3.A9ciales). 
Je vais faire un raccourci , je ne vais présenter que les adresses IP à utilisé pour un réseau privé / réseau local (**LAN**).


<table class="wikitable">
<tr>
<th>Nom</th>
<th>Fourchettes d'adresses IP</th>
<th>Nombre d'adresses</th>
<th><i><a href="/wiki/Classful_network" title="Classful network">Classe</a></i> description</th>
<th>Large <a href="/wiki/Classless_Inter-Domain_Routing" title="Classless Inter-Domain Routing">CIDR</a> bloque</th>
</tr>
<tr>
<td>24-bit block</td>
<td>10.0.0.0 – 10.255.255.255</td>
<td><span style="white-space:nowrap">16<span style="margin-left:0.2em">777</span><span style="margin-left:0.2em">216</span></span></td>
<td>Classe A simple</td>
<td>10.0.0.0/8</td>
</tr>
<tr>
<td>20-bit block</td>
<td>172.16.0.0 – 172.31.255.255</td>
<td><span style="white-space:nowrap">1<span style="margin-left:0.2em">048</span><span style="margin-left:0.2em">576</span></span></td>
<td>range de classe 16 du  bloque B</td>
<td>172.16.0.0/12</td>
</tr>
<tr>
<td>16-bit block</td>
<td>192.168.0.0 – 192.168.255.255</td>
<td><span style="white-space:nowrap">65<span style="margin-left:0.2em">536</span></span></td>
<td>range de 256 du bloque de classe C</td>
<td>192.168.0.0/16</td>
</tr>
</table>

L'idée de ses adresses IP est que ces dernière ne sont utilisé que pour un réseaux local et peuvent être alloué par n'importe qui pour son propre réseau. Le plus classique reste : 192.168.0.XX ou 192.168.1.XX principalement à cause des routeurs grand publique qui sont vendu dans le commerce pour partager votre connexion internet et permettre l'interconnexion entre vos équipements. 

Voyons un exemple d'un réseau simple ce que nous retrouvons à nos domicile :

![exemple_network_couche_ip.png](./imgs/exemple_network_couche_ip.png)

Le réseau "privé" est 192.168.0.0/24 donc si une machine avec l'adresse IP : 192.168.0.10 veut rejoindre la machine 192.168.0.42 , lors de la communication le paquet va être transmis  au router . Ce dernier va voir grâce à l'adresse IP que c'est pour la communication interne donc il va chercher la machine dans le réseau local. Bien entendu si le client 192.168.0.10 veut rejoindre le site http://x3rus.com/moodle qui correspond à l'IP 199.100.146.119 n'étant pas sur le réseau local et va renvoyer la demande sur internet.

Bon ça c'est la version courte :D et simplifié. Allons un peu plus loin en complexifiant la structure. 

#### <a name="clarification_adressage_ip_sous-reseau" /> Netmask et sous-réseau

Malheureusement nous n'avons pas beaucoup de temps je suis donc dans l'obligation de réduire cette section au minimum, nous pourrions approfondir cette section ultérieurement s'il y a de la demande. 

Si vous avez un peu lu de la littérature réseau vous avez probablement régulièrement vu des annotations dur style :

* 192.168.10.0/24 ou 192.168.10.0 255.255.255.0
* 172.17.0.0/16 ou 172.17.0.0 255.255.0.0
* 192.168.42.8/29 ou 192.168.42.8 255.255.255.248
* 172.30.25.32/27 ou 172.30.25.32 255.255.255.224

Pour beaucoup cette écriture ne veut pas dire grand chose, nous allons la démystifier, bon pour les personnes qui se disent : "Oh non on va calculer des __netmask__ j'ai horreur de ça !!" Pas de panique ! J'ai pas l'intention de passer la prochaine heure sur ce sujet :D , moi aussi j'ai horreur de ça :P. 

Le système de __netmask__ (/24 ou 255.255.255.0) permet de segmenter une plage d'adresse __IP__ , en fait ça permet de regroupé des machines étant dans le même segment réseau. Commençons par comprendre c'est quoi que ceci veut dire et voyons l'utilisation possible. Vous comprendrez peut-être pourquoi votre administrateur réseau vous réponds parfois qu'il n'y a plus d'adresse IP disponible même si vous êtes dans un réseau privé .

On va commencé par le plus simple le **/24** ou **255.255.255.0** , sous GNU/Linux vous avez une jolie ligne de commande pour vous fournir l'information **ipcalc** :
Pour les personnes qui n'ont pas la chance d'être sous Linux vous pouvez utiliser ce site web : [http://jodies.de/ipcalc](http://jodies.de/ipcalc)


        $ ipcalc 192.168.1.0/24 
        Address:   192.168.1.0          11000000.10101000.00000001. 00000000
        Netmask:   255.255.255.0 = 24   11111111.11111111.11111111. 00000000
        Wildcard:  0.0.0.255            00000000.00000000.00000000. 11111111
        =>
        Network:   192.168.1.0/24       11000000.10101000.00000001. 00000000
        HostMin:   192.168.1.1          11000000.10101000.00000001. 00000001
        HostMax:   192.168.1.254        11000000.10101000.00000001. 11111110
        Broadcast: 192.168.1.255        11000000.10101000.00000001. 11111111
        Hosts/Net: 254                   Class C, Private Internet


Bon dans l'exemple ci-dessus, nous analysons le segment réseau : 192.168.1.0/24 , réseau très répandu chez les particuliers, regardons les 2 premières ligne :

* Address:   192.168.1.0          11000000.10101000.00000001. 00000000
* Netmask:   255.255.255.0 = 24   11111111.11111111.11111111. 00000000

Nous avons l'IP 192.168.1.0 affiché en binaire 11000000 == 192, 10101000 == 168 , ...
Nous avons aussi le __NetMask__ 255.255.255.0 affiché en binaire 11111111 == 255 , 00000000 == 0 

Donc si nous y allons **simplement** lorsque que le système doit valider si l'adresse __IP__ fait partie du réseau il appose le __netmask__ définie. Quand nous regardons le __netmask__ nous voyons une série de **1** et **0**. Lorsque je dit que le __netmask__ est apposé partout où il y a des **1** la valeurs ne doit pas changer avec l'IP d'origine quand il y a **0** la valeur peut varier. 
Voilà pourquoi dans la démonstration plus haut , nous pouvons avoir des valeurs différente pour le dernier chiffre et que ceci donne entre 192.168.1.1 à 192.168.1.254. En d'autre mot les derniers 8 binaires peuvent être changé.

Restons dans le simple et regardons un **/16** ou **255.255.0.0** :

        $ ipcalc 172.17.0.0/16
        Address:   172.17.0.0           10101100.00010001. 00000000.00000000
        Netmask:   255.255.0.0 = 16     11111111.11111111. 00000000.00000000
        Wildcard:  0.0.255.255          00000000.00000000. 11111111.11111111
        =>
        Network:   172.17.0.0/16        10101100.00010001. 00000000.00000000
        HostMin:   172.17.0.1           10101100.00010001. 00000000.00000001
        HostMax:   172.17.255.254       10101100.00010001. 11111111.11111110
        Broadcast: 172.17.255.255       10101100.00010001. 11111111.11111111
        Hosts/Net: 65534                 Class B, Private Internet

Dans le cas présent ce n'est plus 8 binaires qui peuvent être changé mais 16 chiffres donc , nous nous retrouvons à avoir une possibilité sur le réseau de 65534 hôtes sur le même segment réseau. Soit dis en passant le __netmask__ peut être utilisé aussi pour la définition de règles de __firewall__ mais nous y reviendrons peut-être...

Telle que mentionné nous ne ferons qu'un survole de cette aspect par manque de temps si vous désirez aller un peu plus loin , je vous invite à lire le livre : [TCP illustrated par Richard Stevens](https://books.google.ca/books/about/TCP_IP_Illustrated_Volume_1.html?id=a23OAn5i8R0C&source=kp_cover&redir_esc=y&hl=en), mais c'est un autre niveau :D.

Bon juste pour s'amuser on va en faire 2 / 3  autres, rapide , car quand on s'amuse le temps passe vite ;-).

Voyons un tous petit réseau peut-être que ceci aidera à la compréhension :

        $ ipcalc 192.168.1.1/29
        Address:   192.168.1.1          11000000.10101000.00000001.00000 001
        Netmask:   255.255.255.248 = 29 11111111.11111111.11111111.11111 000
        Wildcard:  0.0.0.7              00000000.00000000.00000000.00000 111
        =>
        Network:   192.168.1.0/29       11000000.10101000.00000001.00000 000
        HostMin:   192.168.1.1          11000000.10101000.00000001.00000 001
        HostMax:   192.168.1.6          11000000.10101000.00000001.00000 110
        Broadcast: 192.168.1.7          11000000.10101000.00000001.00000 111
        Hosts/Net: 6                     Class C, Private Internet

Dans l'exemple ci-dessus je définie un tout petit réseau car uniquement 3 chiffre (binaire) peuvent être altéré , si nous prenons le dernier chiffre uniquement 192.168.1.  **0** ==  00000000 , comme les 5 premiers chiffre binaire ne peuvent pas changé la valeur maximal pour le segment est : 00000111 soit 7. Nous avons donc un segment réseau comprenant uniquement 6 hôtes !!

        $ ipcalc 192.168.1.8/29
        Address:   192.168.1.8          11000000.10101000.00000001.00001 000
        Netmask:   255.255.255.248 = 29 11111111.11111111.11111111.11111 000
        Wildcard:  0.0.0.7              00000000.00000000.00000000.00000 111
        =>
        Network:   192.168.1.8/29       11000000.10101000.00000001.00001 000
        HostMin:   192.168.1.9          11000000.10101000.00000001.00001 001
        HostMax:   192.168.1.14         11000000.10101000.00000001.00001 110
        Broadcast: 192.168.1.15         11000000.10101000.00000001.00001 111
        Hosts/Net: 6                     Class C, Private Internet

On continue, je définie un réseau 192.168.1.8/29 avec le même __netmask__ 8 == 00001000 comme le 1 est compris dans les 5 chiffres binaire qui ne sont pas modifiable ceci m'offre un nouveau segment réseau qui à pour valeur minimal : 192.168.1.  **9** == 00001**001** et 00001**111**.

J'espère que je suis claire :-/ , la pratique à venir nous permettra de clarifier ce point.

Dernier moins utilisé mais qui peut poser des question lorsqu'on le voit pour la première fois : 192.168.1.10/32 

        $ ipcalc 192.168.1.10/32
        Address:   192.168.1.10         11000000.10101000.00000001.00001010 
        Netmask:   255.255.255.255 = 32 11111111.11111111.11111111.11111111 
        Wildcard:  0.0.0.0              00000000.00000000.00000000.00000000 
        =>
        Hostroute: 192.168.1.10         11000000.10101000.00000001.00001010 
        Hosts/Net: 1                     Class C, Private Internet

Comme vous pouvez le voir le __Netmask__ ne comprend QUE des 1 donc c'est un réseau avec uniquement 1 hôte.

##### <a name="clarification_ip_regroupement" /> Regroupement de réseau

Pour beaucoup l'application et l'utilisation du __Netmask__ reste très ambigüe , le masque réseau est vraiment une méthode pour représenter un ensemble de machine. Si vous êtes confortable avec l'utilisation de plage de port (__port range__), l'utilisation du masque réseau est la même chose. L'utilisation du __Netmask__ est peut-être moins évident au début , mais comme tous on s'habitue. La raison de l'utilisation du __netmask__ est simple l'application d'un masque binaire est beaucoup plus performant de l'interprétation d'une nomenclature "humaine".



### <a name="clarification_routage_IP" /> Routage des paquets IP

### <a name="clarification_reliability_ip" /> Services délivrés / Fiabilité du protocole

### <a name="clarification_NAT_IP" /> Manipulation des adresses IP (NAT)


# <a name="clarification_workflow_connection" /> Processus d'établissement de connexion
