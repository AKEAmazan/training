<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>

TODO corriger les \_

# Index 

# <a name="clarification" /> Clarifications du réseau

Avant de parler routage ouverture de ports j'aimerai clarifier certain aspect du réseau , pas de panique je ne planifie pas faire 3 jours sur la [couche OSI](https://fr.wikipedia.org/wiki/Mod%C3%A8le_OSI). Nous allons voir un peu cette théorie mais dans un but précis permettre de diagnostiquer un problème. Avoir une meilleur compréhension de l'ensemble du processus et des différentes étapes nous aide a mieux identifier la source des problèmes. De nous jours le réseau est essentiel allumé une machine qui n'est pas connecter et rapidement on ne sait plus quoi faire avec ... 

Pour commencer, j'aimerai vous donner ma vision du réseau au risque de contrarier certain administrateur réseaux :P. Personnellement je perçois le trafic réseaux comme de l'eau. Le trafic coule entre les différents équipement qui soit le laisse passer soit le bloque. Parfois le courant est redirigé vers un autre point , parfois il est légèrement modifier pour ajouter plus d'information ... Mais à la fin c'est aussi simple que ça , je ne suis peut-être pas le plus grand fan du réseau voilà pourquoi j'ai cette vision peut-être simpliste.

# <a name="clarification_Protocol_internet" /> Théorie sur le protocole d'Internet

Nous nous concentrerons sur le protocole le plus utilisé aujourd'hui soit celui d'Internet, pour débuter voici une représentation du __flow__ (courant) sur Internet. 

<img src="https://upload.wikimedia.org/wikipedia/commons/c/c4/IP_stack_connections.svg"  width="700px" />

J'aime beaucoup cette image qui représente très bien chaque étape du processus de communication entre 2 applications. 

* **[Application](https://en.wikipedia.org/wiki/Application_layer)** : L'application peut être n'importe quoi un fureteur communiquant avec un serveur apache. Un client courriel communiquant avec un serveur __imaps__ ou __smtp__ , un jeu communiquant avec un serveur peu importe . L'application génère des données (__data__) qui doit être communiqué à l'autre application. L'application utilisera d'une librairie qui lui permettra de communiquer sur le réseau. En théorie ce pourrait être une librairie pour les réseaux [X.25](https://en.wikipedia.org/wiki/X.25) ou [TCP/IP](https://fr.wikipedia.org/wiki/Transmission_Control_Protocol) ou [UDP/IP](https://fr.wikipedia.org/wiki/User_Datagram_Protocol). Donc l'application génère des données !
* **[Transport](https://en.wikipedia.org/wiki/Transport_layer)** : La couche transport prend les données de l'application et l'encapsule dans un format qui sera utilisé pour transporter les données . À ce stade nous avons 2 protocole actuellement très utilisé [TCP](https://fr.wikipedia.org/wiki/Transmission_Control_Protocol) ou [UDP](https://fr.wikipedia.org/wiki/User_Datagram_Protocol), nous allons voir plus en détail ce principe d'encapsulation et ce qu'il contient. À ce stade du processus les données sont formaté pour être transmis cependant la couche transport ne sait pas comment les transmettre. Est-ce que les paquets  doit être transmit à une passerelle ? Est-ce que la machine est sur le même réseau ? Comment les paquets doit être fragmenté (coupé en morceau) afin de pouvoir passer sur le file ? ...
* **[Internet](https://en.wikipedia.org/wiki/Internet_layer)** : La couche __Internet__ s'occupe de définir le chemin que devra prendre les paquets, à savoir utilisé une passerelle de communication pour accéder au autre réseau. Voilà la partie **IP** de **TCP/IP**, cette couche s'assure de l'ensemble du chemin que devra prendre les données formatées selon le standard définie dans la couche précédente. Si vous regardez le diagramme précédent vous voyez clairement que le chemin pris par les données ne n'utilise que la couche **Internet** et **link** lors de la transition entre l'ensemble des équipements jusqu'au __host__ final.
* **[Link](https://en.wikipedia.org/wiki/Link_layer)** : La couche __Link__ ou de Liaison est utiliser pour convertir les données selon le lien utilisé , cette couche permettra de faire la conversion vers le câble Ethernet ou un port sériel . Grâce à cette abstraction entre la couche **Internet** et la couche **Link** nous pouvons transmettre des données sur différent type de lien (__RJ45__, Fibre Optique, port sériel, ...). Chaque point de traitement , __router__ récupérera l'information transmise sur le câble et analysera la contenu de la couche **Internet** afin de savoir à qui transmettre les données , etc jusqu'à la réception de la machine destinataire.


Voici la même représentation du traitement mais cette fois non plus avec une machine mais lors de l'écriture d'une lettre.

* **Application** : Vous qui écrivait une lettre , vous êtes l'application et vous écrivez sur du papier
* **Transport** : Ceci pourrait être représenter par l'enveloppe , cette dernière contient les données applicatif , dans notre cas la lettre. Nous avons écrit sur l'enveloppe les informations du destinataire , nous avons aussi écrit d'où provient la lettre en cas de problème. Pour finir nous fermons cette dernier, telle que le veut la convention / procédure. À ce stade nous ne savons pas comment la lettre sera transmise, par bateau , par avion ... Est-ce que la lettre sera transmis à un bureau centrale puis redistribué ? Ce que nous savons est que les données sont préparés selon la convention .
* **Internet** : Nous avons les données (application), nous avons le format approprié , la couche internet peut être perçu comme la poste cette dernière sait comment traiter l'adresse que nous lui avons donnés. Car nous avons fournit le bon format , adresse ainsi que le code postal, de vous a moi peut importe le mécanisme utilisé pour transmettre mes données le chemin à peut d'importance nous espérons qu'il soit optimal afin de réduit le délais de livraison. 
* **Link** : La couche de Liaison est l'ensemble des intervenants qui transmettrons ma lettre , le postier , le camion , l'avion , le bateau , ... L'ensemble des intervenants sont en mesure de traiter l'information contenu dans la couche **Internet** afin de connaître le prochain intervenant qui traitera notre enveloppe afin de la livrer. 


Ceci est à haut niveau voyons plus en détail le processus de création de chaque couche afin de mieux visualisé le processus de connexion et d'échange de données. Mon objectif est de voir le processus de création du flux de données nous resterons jusqu'à un certain point à un haut niveau pour encore descendre au fur et a mesure que nous serons confortable avec les concepts.


## <a name="clarification_diff_tcp_udp" /> Différence entre TCP et UDP (Transport)

Inutile de prendre du temps pour la couche applicative vous aurez compris que c'est l'ensemble des applications communiquant sur le réseau que ce soit client ou serveur. L'ensemble des exemples à venir clarifierons l'ambiguïté qui peut encore présent. Nous allons nous attaquer à la couche **Transport** nous allons la décortiqué mais avant tous clarifions la différence entre __TCP__ et __UDP__. 

**Port TCP et UDP**

TCP, comme UDP, utilise le numéro de port pour identifier les applications. À chaque extrémité (client/serveur) de la connexion TCP est associé un numéro de port sur 16 bits (de 1 à 65535) assigné à l'application émettrice ou réceptrice. Ces ports sont classés en trois catégories :

* Les __ports bien connus__ sont assignés par l'IANA (Internet Assigned Numbers Authority) dans la plage 0-1023, et sont souvent utilisés par des processus système ou ayant des droits privilégiés. Les applications bien connues qui fonctionnent en tant que serveur et sont en attente de connexions utilisent généralement ces types de ports. Exemples : FTP (21), SSH (22), Telnet (23), SMTP (25), HTTP (80), POP3 (110).
* Les __ports enregistrés__ sont généralement utilisés par des applications utilisateur comme ports sources éphémères pour se connecter à un serveur, mais ils peuvent aussi identifier des services non enregistrés par l'IANA.
* Les __ports dynamiques/privés__ peuvent aussi être utilisés par des applications utilisateur, mais plus rarement. Ils n'ont pas de sens en dehors d'une connexion TCP particulière.


### <a name="clarification_tcp" /> Transmission Control Protocol (TCP) (protocole de contrôle de transmissions)

Une session TCP fonctionne en trois phases :

* l'établissement de la connexion ;
* les transferts de données ;
* la fin de la connexion.

L'établissement de la connexion se fait par un [handshaking en trois temps](https://fr.wikipedia.org/wiki/Three-way_handshake). La rupture de connexion, elle, utilise un [handshaking](https://fr.wikipedia.org/wiki/Handshaking) en quatre temps. Pendant la phase d'établissement de la connexion, des paramètres comme le numéro de séquence sont initialisés afin d'assurer la transmission fiable (sans perte et dans l'ordre) des données.

En d'autre mot lorsque lors que 2 application désire communiquer entre elle avec le protocole __TCP__ :

* Elles se saluent , en ce serrant la main ( établissement de connexion , 3 __way handshake__)
* Elles communiquent, en échangeant des données ( transfert de données )
* Elles se disent au revoir , en ce serrant encore la main ( fin de connexion , 4 __way handshake__)

Dit comme ça on peut pas dire que ce soit compliqué :D.

Voyons à présent comment se réalise chacune des étapes , nous utiliserons un serveur apache et un client __telnet__. Afin de visualiser les communications client serveur nous utiliserons __tcpdump__ et __wireshark__ (disponible sous l'ensemble des OS).


#### <a name="clarification_tcp_3way_handshake" /> TCP établissement de connexion (3 way handshake)

Le côté client de la connexion effectue une ouverture active en 3 temps :

1. Le client envoie un segment SYN au serveur,
2. Le serveur lui répond par un segment SYN/ACK,
3. Le client confirme par un segment ACK.

Maintenant on décrit la même opération en changeant __SYN__ par "salut" et __ACK__ par "ça va "

1. Le client dit **Salut**
2. Le serveur répond **Salut/Ça va ?**
3. Le client confirme **ça va** 

J'aime vulgarisé le processus afin de montrer la simplicité du processus :D.

Durant cet échange initial, les numéros de séquence des deux parties sont synchronisés :

1. Le client utilise son numéro de séquence initial dans le champ "Numéro de séquence" du segment SYN (x par exemple),
2. Le serveur utilise son numéro de séquence initial dans le champ "Numéro de séquence" du segment SYN/ACK (y par exemple) et ajoute le numéro de séquence du client plus un (x+1) dans le champ "Numéro d'acquittement" du segment,
3. Le client confirme en envoyant un ACK avec un numéro de séquence augmenté de un (x+1) et un numéro d'acquittement correspondant au numéro de séquence du serveur plus un (y+1).

Voici une représentation graphique du processus : 

<img src="https://upload.wikimedia.org/wikipedia/commons/6/6c/Tcp_connect.svg" width="700px" />

Par <a href="//commons.wikimedia.org/w/index.php?title=User:Skc&amp;action=edit&amp;redlink=1" class="new" title="User:Skc (page does not exist)">Sébastien Koechlin</a> — <span class="int-own-work" lang="fr">Travail personnel</span>, <a title="Creative Commons Attribution-Share Alike 3.0" href="http://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>, https://commons.wikimedia.org/w/index.php?curid=16887424

Je vais revenir dans quelques instant lors d'un exemple de communication sur l'aspect du numéro de séquence voici rapidement un avant goût : 

* Pendant la phase de transferts de données, certains mécanismes clefs permettent d'assurer la robustesse et la fiabilité de TCP. En particulier, les numéros de séquence sont utilisés afin d'ordonner les segments TCP reçus et de détecter les données perdues, les sommes de contrôle permettent la détection d'erreurs, et les acquittements ainsi que les temporisations permettent la détection des segments perdus ou retardés.

Nous allons voir dans la pratique / sur le terrain ce que ça donne réellement, mais avant j'aimerai présenter un paquet __TCP__ ceci nous aidera pour le lire.

#### <a name="clarification_tcp_structure" /> Structure d'un segment TCP

Référence : [https://fr.wikipedia.org/wiki/Transmission_Control_Protocol#Structure_d.27un_segment_TCP](https://fr.wikipedia.org/wiki/Transmission_Control_Protocol#Structure_d.27un_segment_TCP)


Voici la structure d'un paquet **TCP**

<p><b>En bits</b></p>
<table bgcolor="#AAAAEE" border="1" cellspacing="1" cellpadding="1" style="font-size: 9pt;">
<tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>20</td>
<td>21</td>
<td>22</td>
<td>23</td>
<td>24</td>
<td>25</td>
<td>26</td>
<td>27</td>
<td>28</td>
<td>29</td>
<td>30</td>
<td>31</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="16">
<center>Port Source 2 octets</center>
</td>
<td bgcolor="#F7F8FF" colspan="16">
<center>Port destination 2 octets</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="32">
<center>Numéro de séquence</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="32">
<center>Numéro d'acquittement</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="4">
<center>Taille de l'en-tête</center>
</td>
<td bgcolor="#F7F8FF" colspan="3">
<center>Réservé</center>
</td>
<td bgcolor="#F7F8FF">
<center>ECN / NS</center>
</td>
<td bgcolor="#F7F8FF">
<center>CWR</center>
</td>
<td bgcolor="#F7F8FF">
<center>ECE</center>
</td>
<td bgcolor="#F7F8FF">
<center>URG</center>
</td>
<td bgcolor="#F7F8FF">
<center>ACK</center>
</td>
<td bgcolor="#F7F8FF">
<center>PSH</center>
</td>
<td bgcolor="#F7F8FF">
<center>RST</center>
</td>
<td bgcolor="#F7F8FF">
<center>SYN</center>
</td>
<td bgcolor="#F7F8FF">
<center>FIN</center>
</td>
<td bgcolor="#F7F8FF" colspan="16">
<center>Fenêtre</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="16">
<center>Somme de contrôle</center>
</td>
<td bgcolor="#F7F8FF" colspan="16">
<center>Pointeur de données urgentes</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="22">
<center>Options</center>
</td>
<td bgcolor="#F7F8FF" colspan="10">
<center>Remplissage</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="32">
<center>Données</center>
</td>
</tr>
</table>

Voyons ce que l'ensemble le détail pour chaque champs :

* **Port source** : numéro du port source
* **Port destination** : numéro du port destination
* **Numéro de séquence** : numéro de séquence du premier octet de ce segment
* **Numéro d'acquittement** : numéro de séquence du prochain octet attendu
* **Taille de l'en-tête** : longueur de l'en-tête en mots de 32 bits (les options font partie de l'en-tête)
* __Flags__ :
    * **Réservé** : réservé pour un usage futur
    * **ECN/NS** : signale la présence de congestion, voir RFC 3168 ; ou Nonce Signaling, voir RFC 3540
    * **CWR** : Congestion Window Reduced : indique qu'un paquet avec ECE a été reçu et que la congestion a été traitée
    * **ECE** : ECN-Echo : si SYN=1 indique la capacité de gestion ECN, si SYN=0 indique une congestion signalé par IP (voir RFC 3168)
    * **URG** : Signale la présence de données urgentes
    * **ACK** : signale que le paquet est un accusé de réception (acknowledgement)
    * **PSH** : données à envoyer tout de suite (push)
    * **RST** : rupture anormale de la connexion (reset)
    * **SYN** : demande de synchronisation ou établissement de connexion
    * **FIN** : demande la fin de la connexion
* **Fenêtre** : taille de fenêtre demandée, c'est-à-dire le nombre d'octets que le récepteur souhaite recevoir sans accusé de réception
* **Somme de contrôle/CRC** : somme de contrôle calculée sur l'ensemble de l'en-tête TCP et des données, mais aussi sur un pseudo en-tête (extrait de l'en-tête IP)
* **Pointeur de données urgentes** : position relative des dernières données urgentes
* **Options** : facultatives
* **Remplissage** : zéros ajoutés pour aligner les champs suivants du paquet sur 32 bits, si nécessaire
* **Données** : séquences d'octets transmis par l'application (par exemple : __GET /__)

On voit que c'est pas mal complet en plus des données (à la fin) il y a beaucoup de champs qui peuvent être remplie en plus des __flags__.

**MAIS où sont les adresses ip ?** , très bonne question :D, le protocole __TCP__ n'a aucune idée de l'adresse __IP__ où établir la connexion , ce n'est pas son travail ceci est fait par la couche **Internet** . L'ensemble du trajet pour établir une connexion entre 2 machines est réalisé par la par **IP** dans __TCP__/**IP**. Ceci peut semblé être un détail mais lors de l'analyse de problème de connexion ceci peut être très important. Comme nous (__aka__ moi) avons décidé  de partir de l'application nous verrons ceci plus tard :), gardons en tête pour le moment que la couche __Internet__ fonctionne par magie :D.
Le protocole __TCP__ est donc indépendant du chemin c'est pour ça que l'on peut changé la couche __IP__ pour passé de __IPv4__ à __IPv6__ sans changer le protocole __TCP__. Nous pourrions en théorie avoir un autre protocole pour la couche __Internet__ et avoir une communication __TCP/tboutry__ :D , mais bon c'est pas pour demain que je vais le faire ;-).


##### <a name="visualisation_connexion" /> Visualisation d'une communication TCP

Afin voir le processus nous allons réalisé une connexion avec l'application __telnet__ vers un serveur __Apache__ l'opération sera simplement l'extraction de la page d'accueil. Si nous réalisons l'opération manuellement et regardons le résultat ceci donne : 

        $ telnet 172.17.0.1 80
        Trying 172.17.0.1...
        Connected to 172.17.0.1.
        Escape character is '^]'.
        GET /
        <html>
            <body>
                  <h3> Le site du mouton dessins </h3>
                  <img src=./dessin_mouton.jpg />
            </body>
        </html>

        Connection closed by foreign host.

        # coté serveur , les logs donnent :
        ==> /var/log/apache2/access.log <==
        172.17.42.1 - - [08/Aug/2016:17:17:08 -0400] "GET /" 200 126 "-" "-"

Maintenant nous allons sniffer le trafic réseau afin de voir les paquets __TCP__ qui sont passés, nous utiliserons [wireshark](https://wireshark.org/) et __TCPDUMP__.

Démarrage de __wireshark__, je le démarre comme __root__ afin d'avoir l'ensemble des permissions de lire le trafic sur la carte ceci est évidement réservé à l'administrateur de la machine.

        $ sudo wireshark-gtk 

Je sélectionne l'interface réseau que je désire capturer , dans mon cas je choisie l'interface docker, car mon serveur apache est dans un docker (quelle surprise ;-) ).

![wireshark_select_interface_01.png](./imgs/wireshark_select_interface_01.png)

Maintenant je vais définir un filtre car si vous avez beaucoup de trafic vous serez vite noyé dans la quantité de données reçu. Nous allons donc limité les paquets pour le __host__ 172.17.0.2 et le port 80. 

![wireshark_select_interface_et_define_filter_02.png](./imgs/wireshark_select_interface_et_define_filter_02.png)

Voici le résultat du filtre :

        ip.dst == 172.17.0.2 && tcp.dstport == 80 && ip.proto == TCP

Pour rappel voici le processus d'établissement de connexion :

* l'établissement de la connexion ;
* les transferts de données ;
* la fin de la connexion.

Le serveur à l'IP 172.17.0.2 
Le client à l'IP 172.17.42.1

###### <a name="visualisation_connexion_conn" /> Établissement de la connexion

Nous allons donc établir la connexion vers le serveur avec la commande __telnet__

        $ telnet 172.17.0.2  80
        Trying 172.17.0.1...
        Connected to 172.17.0.1.
        Escape character is '^]'.

**STOP** on ne fait rien d'autre , on regarde maintenant ce que l'application d'analyse du trafic indique :

Nous pouvons voir l'établissement de connexion en trois temps (__3 way handshake__) :

![wireshark_visualisation_3way_handshake_03.png](./imgs/wireshark_visualisation_3way_handshake_03.png)

Si vous regardez dans la section du bas vous pouvez voir le détail du paquet __TCP__:

![wireshark_visualisation_detail_paquet_tcp_04.png](./imgs/wireshark_visualisation_detail_paquet_tcp_04.png)

La connexion est donc établie à cette étape mais aucune donnée n'est transmis , le temps d'écrire ou d'expliquer l'ensemble de la communication j'ai dû couper la communication je vais donc la reprendre mais cette fois en transmettant des données.

###### <a name="visualisation_transfert_data" /> Transferts de données 

La connexion est donc établie , le client __Telnet__ une fois la connexion établie envoyer des données dans notre cas : 

        GET /

Dans le but de récupérer la page d'accueil , le fureteur fait sensiblement la même , mais il transmet plus d'information , cependant l'idée reste la même . Une fois que le serveur va recevoir ces données / cette instruction il va transmettre la page d'accueil.

C'est parti :)

        $ telnet 172.17.0.2 80
        Trying 172.17.0.2...
        Connected to 172.17.0.2.
        Escape character is '^]'.
        GET /
        <html>
            <body>
                <h3> Le site du mouton dessins </h3>
                <img src=./dessin_mouton.jpg />
            </body>
        </html>

        Connection closed by foreign host.


Une fois l'information de la page reçu , le serveur web (__foreign host__) à coupé la communication nous y reviendrons dans la prochaine étape. Visualisons dans __wireshark__ le processus de transfert de données :

![wireshark_visualisation_transfert_data_paquet_tcp_05.png](./imgs/wireshark_visualisation_transfert_data_paquet_tcp_05.png)

J'ai volontairement caché la partie de la coupure de connexion , pour ne pas perdre notre objectif de vue :0.

Donc les 3 premières lignes est l'établissement de connexion entre le client et le serveur.

* ligne 4 : Nous voyons le client (Source) qui envoie au serveur la requête 
* ligne 5 : Le serveur confirme la réception du paquet / de la demande 
* ligne 6 : Le serveur envoie les données de la page __index.html__ conformément à la requête du client 
* ligne 7 : Le client confirme qu'il a bien reçu l'information

Bien entendu ici nous avons des petites communication qui rentre dans 1 paquet __TCP__, lors de l'envoie de fichier il est probable que la communication s'étende sur plusieurs paquet et seront reconstruit par l'application par la suite . Nous réaliserons la même opération avec le fureteur afin de voir le comportement.

###### <a name="visualisation_connexion_fin" /> Fin de la connexion.

Comme nous avons pu le voir lors de la visualisation de l'opération via __telnet__ c'est le serveur apache qui coupe la connexion. Voici le processus de fermeture de connexion :

<img src="https://upload.wikimedia.org/wikipedia/commons/4/42/Tcp_close.svg" width="700px" />

Par <a href="//commons.wikimedia.org/w/index.php?title=User:Skc&amp;action=edit&amp;redlink=1" class="new" title="User:Skc (page does not exist)">Sébastien Koechlin</a> — <span class="int-own-work" lang="fr">Travail personnel</span>, <a title="Creative Commons Attribution-Share Alike 3.0" href="http://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>, https://commons.wikimedia.org/w/index.php?curid=16887424

La phase de terminaison d'une connexion utilise un handshaking en quatre temps, chaque extrémité de la connexion effectuant sa terminaison de manière indépendante. Ainsi, la fin d'une connexion nécessite une paire de segments FIN et ACK pour chaque extrémité.

Regardons maintenant  l'information dans __wiresharke__ :

![wireshark_visualisation_fin_conn_tcp_06.png](./imgs/wireshark_visualisation_fin_conn_tcp_06.png)


* ligne 8 : Le serveur apache transmet un __FIN__ / __ACK__
* ligne 9 : Le client envoie la même information __FIN__ / __ACK__
* ligne 10 : Le serveur confirme la réception est termine la connexion __ACK__

##### <a name="visualisation_connexion_fureteur" /> Visualisation d'une communication TCP réalisé par le fureteur

Ceci est une version très simple nous avons réduit au maximum les intervenants pour bien voir les paquets et pouvoir les étudier facilement. Voyons le même processus avec le fureteur, lors de l'utilisation de la commande __telnet__ nous avons vu uniquement la récupération du __HTML__ cependant nous n'avions pas récupérer le contenu de la page réellement en effet nous n'avions pas extrait l'image du mouton.

Voici ce qui est afficher à l'écran : 

![screenshot_siteweb.png](./imgs/screenshot_siteweb.png)

Lors de la communication voici ce qui est afficher dans __wireshark__ , prendre note que l'IP du serveur web est 172.17.0.1 maintenant :

![wireshark_visualisation_fureteur_07.png](./imgs/wireshark_visualisation_fureteur_07.png)

Donc les explications :

* ligne 1 à 3 : l'établissement de connexion __TCP__ __3 way handshake__
* ligne 4 : Envoie de l'instruction __GET / HTTP/1.1__ qui est relativement la même commande qu'avec __telnet__ cependant il utilise le protocole __http__ 1.1 spécifiquement . Ceci est définie dans la couche applicative par dessus __TCP__ , car c'est les données transmise pour communiquer
* ligne 5 : Le serveur confirme la réception
* ligne 6 : Le serveur selon le protocole __HTTP 1.1__ transmet une confirmation que la requête est bonne. Nous verrons le détail du contenu tous de suite après les explications par ligne . Ceci est purement du protocole __HTTP__ est ne concerne que très peu le __TCP__
* ligne 7 : Le client confirme la réception de l'information 
* ligne 8 : Le client demande l'image du mouton , car ce dernier fut traiter lors de l'interprétation de la page d'index __html__
* ligne 9 et 10 : Le serveur transmet l'image du mouton , comme l'image du mouton ne peut pas être transmise dans 1 paquet, car il est trop gros, il le transmet dans 2 paquets 
* ligne 11 et 12 : Le client confirme la réception des 2 paquets , donc l'ensemble de l'image du mouton
* ligne 13 à 15 : Fermeture par le serveur et le client de la connexion __TCP__

On peut pas dire que ce soit extrêmement compliqué, bien entendu nous voyons un site TRÈS simple. Nous pourrons faire le même exercice avec un site plus complexe la quantité de donnée sera plus impressionnante, mais le processus sera identique.

__WireShark__ nous offre une belle fonctionnalité, comme le protocole __HTTP__ est connu il est possible d'extraire l'information des paquets __TCP__ pour le protocole __HTTP__ afin de voir simplement le contenu . Sélectionné un paquet, cliquez le bouton droit de la souris et sélectionnez **Follow TCP stream**.

![wireshark_visualisation_fureteur_follow_tcpstream_08.png](./imgs/wireshark_visualisation_fureteur_follow_tcpstream_08.png)

Voici le résultat :

![wireshark_visualisation_fureteur_follow_tcpstream_09.png](./imgs/wireshark_visualisation_fureteur_follow_tcpstream_09.png)

Nous voyons plus clairement maintenant l'échange qui fut réalisé à la ligne 4 et à la ligne 6 , j'avais mentionné que le client envoie __GET / HTTP/1.1__ et le serveur l'accusé de validation pour la racine mais c'était pour faire simple :P.
En réalité , le serveur et le client échange les protocoles supporté pour le reste des communications :P , c'est la version compliqué mais au niveau de la touche __Transport__ ça na pas d'importance car c'est uniquement du protocole __HTTP__.

## <a name="clarification_diff_tcp_udp" /> Autre protocole

*     [SCTP](https://fr.wikipedia.org/wiki/Stream_Control_Transmission_Protocol) (Stream Control Transmission Protocol), protocole fournissant des services similaires à TCP (fiabilité, remise en ordre des séquences, et contrôle de congestion), tout en offrant la possibilité de communications multi-cibles comme avec UDP.
*     [MPTCP](https://fr.wikipedia.org/wiki/Multipath_TCP) (Multipath TCP) est une surcouche à TCP qui rassemble diverses connexions TCP (à travers différentes interfaces réseau: GSM, Wifi etc.), au sein d'une même méta-connexion (RFC 6824). Ce fonctionnement permet d'exploiter tous les chemins disponibles en parallèle, et donc améliorer significativement les performances et la fiabilité d'une connexion.
