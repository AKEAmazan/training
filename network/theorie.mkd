<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 

* [ Clarifications du réseau](#clarification)
* [ Théorie sur le protocole d'Internet](#clarification_Protocol_internet)
       * [ Couche Transport (UDP et TCP)](#couche_transport)
           * [ Transmission Control Protocol (TCP) (protocole de contrôle de transmissions)](#clarification_tcp)
               * [ TCP établissement de connexion (3 way handshake)](#clarification_tcp_3way_handshake)
               * [ Structure d'un segment TCP](#clarification_tcp_structure)
                   * [ Visualisation d'une communication TCP](#visualisation_connexion)
                       * [ Établissement de la connexion](#visualisation_connexion_conn)
                       * [ Transferts de données ](#visualisation_transfert_data)
                       * [ Fin de la connexion.](#visualisation_connexion_fin)
                   * [ Visualisation d'une communication TCP réalisé par le fureteur](#visualisation_connexion_fureteur)
                   * [ Visualisation d'une communication TCP réalisé par le fureteur avec site complet](#visualisation_conn_fureteur_ext) 
               * [ Conclusion sur le TCP ](#clarification_tcp_conclusion) 
           * [ User Datagram Protocol (UDP) (protocole de contrôle de transmissions)](#clarification_udp) 
               * [ Structure d'un segment UDP](#clarification_udp_structure) 
                   * [ Visualisation d'une communication UDP](#visualisation_connexion_udp) 
                   * [ Visualisation d'une communication UDP avec l'application snmp](#visualisation_connexion_snmp) 
               * [ Conclusion sur le UDP](#clarification_udp_conclusion) 
       * [ Autre protocole](#clarification_diff_tcp_udp) 
       * [ Couche Internet (IP)](#couche_Internet) 
           * [ Structure du paquet IP](#clarification_IP_structure) 
           * [ Adresses IP et sous-réseau](#clarification_adressage_ip) 
               * [ Netmask et sous-réseau](#clarification_adressage_ip_sous-reseau) 
                   * [ Regroupement de réseau](#clarification_ip_regroupement) 
           * [ Routage des paquets IP](#clarification_routage_IP) 
           * [ Services délivrés / Fiabilité du protocole](#clarification_reliability_ip) 
               * [ Qualité du service IP (Best Effort)](#clarification_ip_best_effort) 
           * [ Manipulation des adresses IP (NAT)](#clarification_NAT_IP) 
       * [ Couche Link (switch , ...)](#couche_Link) 
           * [ Vlan (Virtual LAN)](#couche_Link_vlan) 
           * [ ARP (Address Resolution Protocol)](#couche_Link_arp) 
* [ Conclusion ](#Conclusion) 


# <a name="clarification" /> Clarifications du réseau

Avant de parler routage ouverture de ports j'aimerai clarifier certain aspect du réseau , pas de panique je ne planifie pas faire 3 jours sur la [couche OSI](https://fr.wikipedia.org/wiki/Mod%C3%A8le_OSI). Nous allons voir un peu cette théorie mais dans un but précis permettre de diagnostiquer un problème. Avoir une meilleur compréhension de l'ensemble du processus et des différentes étapes nous aide a mieux identifier la source des problèmes. De nous jours le réseau est essentiel allumé une machine qui n'est pas connecter et rapidement on ne sait plus quoi faire avec ... 

Pour commencer, j'aimerai vous donner ma vision du réseau au risque de contrarier certain administrateur réseaux :P. Personnellement je perçois le trafic réseaux comme de l'eau. Le trafic coule entre les différents équipement qui soit le laisse passer soit le bloque. Parfois le courant est redirigé vers un autre point , parfois il est légèrement modifier pour ajouter plus d'information ... Mais à la fin c'est aussi simple que ça , je ne suis peut-être pas le plus grand fan du réseau voilà pourquoi j'ai cette vision peut-être simpliste.

# <a name="clarification_Protocol_internet" /> Théorie sur le protocole d'Internet

Nous nous concentrerons sur le protocole le plus utilisé aujourd'hui soit celui d'Internet, pour débuter voici une représentation du __flow__ (courant) sur Internet. 

<img src="https://upload.wikimedia.org/wikipedia/commons/c/c4/IP_stack_connections.svg"  width="700px" />

J'aime beaucoup cette image qui représente très bien chaque étape du processus de communication entre 2 applications. 

* **[Application](https://en.wikipedia.org/wiki/Application_layer)** : L'application peut être n'importe quoi un fureteur communiquant avec un serveur apache. Un client courriel communiquant avec un serveur __imaps__ ou __smtp__ , un jeu communiquant avec un serveur peu importe . L'application génère des données (__data__) qui doit être communiqué à l'autre application. L'application utilisera d'une librairie qui lui permettra de communiquer sur le réseau. En théorie ce pourrait être une librairie pour les réseaux [X.25](https://en.wikipedia.org/wiki/X.25) ou [TCP/IP](https://fr.wikipedia.org/wiki/Transmission_Control_Protocol) ou [UDP/IP](https://fr.wikipedia.org/wiki/User_Datagram_Protocol). Donc l'application génère des données !
* **[Transport](https://en.wikipedia.org/wiki/Transport_layer)** : La couche transport prend les données de l'application et l'encapsule dans un format qui sera utilisé pour transporter les données . À ce stade nous avons 2 protocole actuellement très utilisé [TCP](https://fr.wikipedia.org/wiki/Transmission_Control_Protocol) ou [UDP](https://fr.wikipedia.org/wiki/User_Datagram_Protocol), nous allons voir plus en détail ce principe d'encapsulation et ce qu'il contient. À ce stade du processus les données sont formaté pour être transmis cependant la couche transport ne sait pas comment les transmettre. Est-ce que les paquets  doit être transmit à une passerelle ? Est-ce que la machine est sur le même réseau ? Comment les paquets doit être fragmenté (coupé en morceau) afin de pouvoir passer sur le file ? ...
* **[Internet](https://en.wikipedia.org/wiki/Internet_layer)** : La couche __Internet__ s'occupe de définir le chemin que devra prendre les paquets, à savoir utilisé une passerelle de communication pour accéder au autre réseau. Voilà la partie **IP** de **TCP/IP**, cette couche s'assure de l'ensemble du chemin que devra prendre les données formatées selon le standard définie dans la couche précédente. Si vous regardez le diagramme précédent vous voyez clairement que le chemin pris par les données ne n'utilise que la couche **Internet** et **link** lors de la transition entre l'ensemble des équipements jusqu'au __host__ final.
* **[Link](https://en.wikipedia.org/wiki/Link_layer)** : La couche __Link__ ou de Liaison est utiliser pour convertir les données selon le lien utilisé , cette couche permettra de faire la conversion vers le câble Ethernet ou un port sériel . Grâce à cette abstraction entre la couche **Internet** et la couche **Link** nous pouvons transmettre des données sur différent type de lien (__RJ45__, Fibre Optique, port sériel, ...). Chaque point de traitement , __router__ récupérera l'information transmise sur le câble et analysera la contenu de la couche **Internet** afin de savoir à qui transmettre les données , etc jusqu'à la réception de la machine destinataire.


Voici la même représentation du traitement mais cette fois non plus avec une machine mais lors de l'écriture d'une lettre.

* **Application** : Vous qui écrivait une lettre , vous êtes l'application et vous écrivez sur du papier
* **Transport** : Ceci pourrait être représenter par l'enveloppe , cette dernière contient les données applicatif , dans notre cas la lettre. Nous avons écrit sur l'enveloppe les informations du destinataire , nous avons aussi écrit d'où provient la lettre en cas de problème. Pour finir nous fermons cette dernier, telle que le veut la convention / procédure. À ce stade nous ne savons pas comment la lettre sera transmise, par bateau , par avion ... Est-ce que la lettre sera transmis à un bureau centrale puis redistribué ? Ce que nous savons est que les données sont préparés selon la convention .
* **Internet** : Nous avons les données (application), nous avons le format approprié , la couche internet peut être perçu comme la poste cette dernière sait comment traiter l'adresse que nous lui avons donnés. Car nous avons fournit le bon format , adresse ainsi que le code postal, de vous a moi peut importe le mécanisme utilisé pour transmettre mes données le chemin à peut d'importance nous espérons qu'il soit optimal afin de réduit le délais de livraison. 
* **Link** : La couche de Liaison est l'ensemble des intervenants qui transmettrons ma lettre , le postier , le camion , l'avion , le bateau , ... L'ensemble des intervenants sont en mesure de traiter l'information contenu dans la couche **Internet** afin de connaître le prochain intervenant qui traitera notre enveloppe afin de la livrer. 


Ceci est à haut niveau voyons plus en détail le processus de création de chaque couche afin de mieux visualisé le processus de connexion et d'échange de données. Mon objectif est de voir le processus de création du flux de données nous resterons jusqu'à un certain point à un haut niveau pour encore descendre au fur et a mesure que nous serons confortable avec les concepts.


## <a name="couche_transport" /> Couche Transport (UDP et TCP)

Inutile de prendre du temps pour la couche applicative vous aurez compris que c'est l'ensemble des applications communiquant sur le réseau que ce soit client ou serveur. L'ensemble des exemples à venir clarifierons l'ambiguïté qui peut encore présent. Nous allons nous attaquer à la couche **Transport** nous allons la décortiqué mais avant tous clarifions la différence entre __TCP__ et __UDP__. 

**Port TCP et UDP**

TCP, comme UDP, utilise le numéro de port pour identifier les applications. À chaque extrémité (client/serveur) de la connexion TCP est associé un numéro de port sur 16 bits (de 1 à 65535) assigné à l'application émettrice ou réceptrice. Ces ports sont classés en trois catégories :

* Les __ports bien connus__ sont assignés par l'IANA (Internet Assigned Numbers Authority) dans la plage 0-1023, et sont souvent utilisés par des processus système ou ayant des droits privilégiés. Les applications bien connues qui fonctionnent en tant que serveur et sont en attente de connexions utilisent généralement ces types de ports. Exemples : FTP (21), SSH (22), Telnet (23), SMTP (25), HTTP (80), POP3 (110).
* Les __ports enregistrés__ sont généralement utilisés par des applications utilisateur comme ports sources éphémères pour se connecter à un serveur, mais ils peuvent aussi identifier des services non enregistrés par l'IANA.
* Les __ports dynamiques/privés__ peuvent aussi être utilisés par des applications utilisateur, mais plus rarement. Ils n'ont pas de sens en dehors d'une connexion TCP particulière.


### <a name="clarification_tcp" /> Transmission Control Protocol (TCP) (protocole de contrôle de transmissions)

Une session TCP fonctionne en trois phases :

* l'établissement de la connexion ;
* les transferts de données ;
* la fin de la connexion.

L'établissement de la connexion se fait par un [handshaking en trois temps](https://fr.wikipedia.org/wiki/Three-way_handshake). La rupture de connexion, elle, utilise un [handshaking](https://fr.wikipedia.org/wiki/Handshaking) en quatre temps. Pendant la phase d'établissement de la connexion, des paramètres comme le numéro de séquence sont initialisés afin d'assurer la transmission fiable (sans perte et dans l'ordre) des données.

En d'autre mot lorsque lors que 2 application désire communiquer entre elle avec le protocole __TCP__ :

* Elles se saluent , en ce serrant la main ( établissement de connexion , 3 __way handshake__)
* Elles communiquent, en échangeant des données ( transfert de données )
* Elles se disent au revoir , en ce serrant encore la main ( fin de connexion , 4 __way handshake__)

Dit comme ça on peut pas dire que ce soit compliqué :D.

Voyons à présent comment se réalise chacune des étapes , nous utiliserons un serveur apache et un client __telnet__. Afin de visualiser les communications client serveur nous utiliserons __tcpdump__ et __wireshark__ (disponible sous l'ensemble des OS).


#### <a name="clarification_tcp_3way_handshake" /> TCP établissement de connexion (3 way handshake)

Le côté client de la connexion effectue une ouverture active en 3 temps :

1. Le client envoie un segment SYN au serveur,
2. Le serveur lui répond par un segment SYN/ACK,
3. Le client confirme par un segment ACK.

Maintenant on décrit la même opération en changeant __SYN__ par "salut" et __ACK__ par "ça va "

1. Le client dit **Salut**
2. Le serveur répond **Salut/Ça va ?**
3. Le client confirme **ça va** 

J'aime vulgarisé le processus afin de montrer la simplicité du processus :D.

Durant cet échange initial, les numéros de séquence des deux parties sont synchronisés :

1. Le client utilise son numéro de séquence initial dans le champ "Numéro de séquence" du segment SYN (x par exemple),
2. Le serveur utilise son numéro de séquence initial dans le champ "Numéro de séquence" du segment SYN/ACK (y par exemple) et ajoute le numéro de séquence du client plus un (x+1) dans le champ "Numéro d'acquittement" du segment,
3. Le client confirme en envoyant un ACK avec un numéro de séquence augmenté de un (x+1) et un numéro d'acquittement correspondant au numéro de séquence du serveur plus un (y+1).

Voici une représentation graphique du processus : 

<img src="https://upload.wikimedia.org/wikipedia/commons/6/6c/Tcp_connect.svg" width="700px" />

Par <a href="//commons.wikimedia.org/w/index.php?title=User:Skc&amp;action=edit&amp;redlink=1" class="new" title="User:Skc (page does not exist)">Sébastien Koechlin</a> — <span class="int-own-work" lang="fr">Travail personnel</span>, <a title="Creative Commons Attribution-Share Alike 3.0" href="http://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>, https://commons.wikimedia.org/w/index.php?curid=16887424

Je vais revenir dans quelques instant lors d'un exemple de communication sur l'aspect du numéro de séquence voici rapidement un avant goût : 

* Pendant la phase de transferts de données, certains mécanismes clefs permettent d'assurer la robustesse et la fiabilité de TCP. En particulier, les numéros de séquence sont utilisés afin d'ordonner les segments TCP reçus et de détecter les données perdues, les sommes de contrôle permettent la détection d'erreurs, et les acquittements ainsi que les temporisations permettent la détection des segments perdus ou retardés.

Nous allons voir dans la pratique / sur le terrain ce que ça donne réellement, mais avant j'aimerai présenter un paquet __TCP__ ceci nous aidera pour le lire.

#### <a name="clarification_tcp_structure" /> Structure d'un segment TCP

Référence : [https://fr.wikipedia.org/wiki/Transmission_Control_Protocol#Structure_d.27un_segment_TCP](https://fr.wikipedia.org/wiki/Transmission_Control_Protocol#Structure_d.27un_segment_TCP)


Voici la structure d'un paquet **TCP**

<p><b>En bits</b></p>
<table bgcolor="#AAAAEE" border="1" cellspacing="1" cellpadding="1" style="font-size: 9pt;">
<tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
<td>14</td>
<td>15</td>
<td>16</td>
<td>17</td>
<td>18</td>
<td>19</td>
<td>20</td>
<td>21</td>
<td>22</td>
<td>23</td>
<td>24</td>
<td>25</td>
<td>26</td>
<td>27</td>
<td>28</td>
<td>29</td>
<td>30</td>
<td>31</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="16">
<center>Port Source 2 octets</center>
</td>
<td bgcolor="#F7F8FF" colspan="16">
<center>Port destination 2 octets</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="32">
<center>Numéro de séquence</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="32">
<center>Numéro d'acquittement</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="4">
<center>Taille de l'en-tête</center>
</td>
<td bgcolor="#F7F8FF" colspan="3">
<center>Réservé</center>
</td>
<td bgcolor="#F7F8FF">
<center>ECN / NS</center>
</td>
<td bgcolor="#F7F8FF">
<center>CWR</center>
</td>
<td bgcolor="#F7F8FF">
<center>ECE</center>
</td>
<td bgcolor="#F7F8FF">
<center>URG</center>
</td>
<td bgcolor="#F7F8FF">
<center>ACK</center>
</td>
<td bgcolor="#F7F8FF">
<center>PSH</center>
</td>
<td bgcolor="#F7F8FF">
<center>RST</center>
</td>
<td bgcolor="#F7F8FF">
<center>SYN</center>
</td>
<td bgcolor="#F7F8FF">
<center>FIN</center>
</td>
<td bgcolor="#F7F8FF" colspan="16">
<center>Fenêtre</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="16">
<center>Somme de contrôle</center>
</td>
<td bgcolor="#F7F8FF" colspan="16">
<center>Pointeur de données urgentes</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="22">
<center>Options</center>
</td>
<td bgcolor="#F7F8FF" colspan="10">
<center>Remplissage</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="32">
<center>Données</center>
</td>
</tr>
</table>

Voyons ce que l'ensemble le détail pour chaque champs :

* **Port source** : numéro du port source
* **Port destination** : numéro du port destination
* **Numéro de séquence** : numéro de séquence du premier octet de ce segment
* **Numéro d'acquittement** : numéro de séquence du prochain octet attendu
* **Taille de l'en-tête** : longueur de l'en-tête en mots de 32 bits (les options font partie de l'en-tête)
* __Flags__ :
    * **Réservé** : réservé pour un usage futur
    * **ECN/NS** : signale la présence de congestion, voir RFC 3168 ; ou Nonce Signaling, voir RFC 3540
    * **CWR** : Congestion Window Reduced : indique qu'un paquet avec ECE a été reçu et que la congestion a été traitée
    * **ECE** : ECN-Echo : si SYN=1 indique la capacité de gestion ECN, si SYN=0 indique une congestion signalé par IP (voir RFC 3168)
    * **URG** : Signale la présence de données urgentes
    * **ACK** : signale que le paquet est un accusé de réception (acknowledgement)
    * **PSH** : données à envoyer tout de suite (push)
    * **RST** : rupture anormale de la connexion (reset)
    * **SYN** : demande de synchronisation ou établissement de connexion
    * **FIN** : demande la fin de la connexion
* **Fenêtre** : taille de fenêtre demandée, c'est-à-dire le nombre d'octets que le récepteur souhaite recevoir sans accusé de réception
* **Somme de contrôle/CRC** : somme de contrôle calculée sur l'ensemble de l'en-tête TCP et des données, mais aussi sur un pseudo en-tête (extrait de l'en-tête IP)
* **Pointeur de données urgentes** : position relative des dernières données urgentes
* **Options** : facultatives
* **Remplissage** : zéros ajoutés pour aligner les champs suivants du paquet sur 32 bits, si nécessaire
* **Données** : séquences d'octets transmis par l'application (par exemple : __GET /__)

On voit que c'est pas mal complet en plus des données (à la fin) il y a beaucoup de champs qui peuvent être remplie en plus des __flags__.

**MAIS où sont les adresses ip ?** , très bonne question :D, le protocole __TCP__ n'a aucune idée de l'adresse __IP__ où établir la connexion , ce n'est pas son travail ceci est fait par la couche **Internet** . L'ensemble du trajet pour établir une connexion entre 2 machines est réalisé par la par **IP** dans __TCP__/**IP**. Ceci peut semblé être un détail mais lors de l'analyse de problème de connexion ceci peut être très important. Comme nous (__aka__ moi) avons décidé  de partir de l'application nous verrons ceci plus tard :), gardons en tête pour le moment que la couche __Internet__ fonctionne par magie :D.
Le protocole __TCP__ est donc indépendant du chemin c'est pour ça que l'on peut changé la couche __IP__ pour passé de __IPv4__ à __IPv6__ sans changer le protocole __TCP__. Nous pourrions en théorie avoir un autre protocole pour la couche __Internet__ et avoir une communication __TCP/tboutry__ :D , mais bon c'est pas pour demain que je vais le faire ;-).


##### <a name="visualisation_connexion" /> Visualisation d'une communication TCP

Afin voir le processus nous allons réalisé une connexion avec l'application __telnet__ vers un serveur __Apache__ l'opération sera simplement l'extraction de la page d'accueil. Si nous réalisons l'opération manuellement et regardons le résultat ceci donne : 

        $ telnet 172.17.0.1 80
        Trying 172.17.0.1...
        Connected to 172.17.0.1.
        Escape character is '^]'.
        GET /
        <html>
            <body>
                  <h3> Le site du mouton dessins </h3>
                  <img src=./dessin_mouton.jpg />
            </body>
        </html>

        Connection closed by foreign host.

        # coté serveur , les logs donnent :
        ==> /var/log/apache2/access.log <==
        172.17.42.1 - - [08/Aug/2016:17:17:08 -0400] "GET /" 200 126 "-" "-"

Maintenant nous allons sniffer le trafic réseau afin de voir les paquets __TCP__ qui sont passés, nous utiliserons [wireshark](https://wireshark.org/) et __TCPDUMP__.

Démarrage de __wireshark__, je le démarre comme __root__ afin d'avoir l'ensemble des permissions de lire le trafic sur la carte ceci est évidement réservé à l'administrateur de la machine.

        $ sudo wireshark-gtk 

Je sélectionne l'interface réseau que je désire capturer , dans mon cas je choisie l'interface docker, car mon serveur apache est dans un docker (quelle surprise ;-) ).

![wireshark_select_interface_01.png](./imgs/wireshark_select_interface_01.png)

Maintenant je vais définir un filtre car si vous avez beaucoup de trafic vous serez vite noyé dans la quantité de données reçu. Nous allons donc limité les paquets pour le __host__ 172.17.0.2 et le port 80. 

![wireshark_select_interface_et_define_filter_02.png](./imgs/wireshark_select_interface_et_define_filter_02.png)

Voici le résultat du filtre :

        ip.dst == 172.17.0.2 && tcp.dstport == 80 && ip.proto == TCP

Pour rappel voici le processus d'établissement de connexion :

* l'établissement de la connexion ;
* les transferts de données ;
* la fin de la connexion.

Le serveur à l'IP 172.17.0.2 
Le client à l'IP 172.17.42.1

###### <a name="visualisation_connexion_conn" /> Établissement de la connexion

Nous allons donc établir la connexion vers le serveur avec la commande __telnet__

        $ telnet 172.17.0.2  80
        Trying 172.17.0.1...
        Connected to 172.17.0.1.
        Escape character is '^]'.

**STOP** on ne fait rien d'autre , on regarde maintenant ce que l'application d'analyse du trafic indique :

Nous pouvons voir l'établissement de connexion en trois temps (__3 way handshake__) :

![wireshark_visualisation_3way_handshake_03.png](./imgs/wireshark_visualisation_3way_handshake_03.png)

Si vous regardez dans la section du bas vous pouvez voir le détail du paquet __TCP__:

![wireshark_visualisation_detail_paquet_tcp_04.png](./imgs/wireshark_visualisation_detail_paquet_tcp_04.png)

La connexion est donc établie à cette étape mais aucune donnée n'est transmis , le temps d'écrire ou d'expliquer l'ensemble de la communication j'ai dû couper la communication je vais donc la reprendre mais cette fois en transmettant des données.

###### <a name="visualisation_transfert_data" /> Transferts de données 

La connexion est donc établie , le client __Telnet__ une fois la connexion établie envoyer des données dans notre cas : 

        GET /

Dans le but de récupérer la page d'accueil , le fureteur fait sensiblement la même , mais il transmet plus d'information , cependant l'idée reste la même . Une fois que le serveur va recevoir ces données / cette instruction il va transmettre la page d'accueil.

C'est parti :)

        $ telnet 172.17.0.2 80
        Trying 172.17.0.2...
        Connected to 172.17.0.2.
        Escape character is '^]'.
        GET /
        <html>
            <body>
                <h3> Le site du mouton dessins </h3>
                <img src=./dessin_mouton.jpg />
            </body>
        </html>

        Connection closed by foreign host.


Une fois l'information de la page reçu , le serveur web (__foreign host__) à coupé la communication nous y reviendrons dans la prochaine étape. Visualisons dans __wireshark__ le processus de transfert de données :

![wireshark_visualisation_transfert_data_paquet_tcp_05.png](./imgs/wireshark_visualisation_transfert_data_paquet_tcp_05.png)

J'ai volontairement caché la partie de la coupure de connexion , pour ne pas perdre notre objectif de vue :0.

Donc les 3 premières lignes est l'établissement de connexion entre le client et le serveur.

* ligne 4 : Nous voyons le client (Source) qui envoie au serveur la requête 
* ligne 5 : Le serveur confirme la réception du paquet / de la demande 
* ligne 6 : Le serveur envoie les données de la page __index.html__ conformément à la requête du client 
* ligne 7 : Le client confirme qu'il a bien reçu l'information

Bien entendu ici nous avons des petites communication qui rentre dans 1 paquet __TCP__, lors de l'envoie de fichier il est probable que la communication s'étende sur plusieurs paquet et seront reconstruit par l'application par la suite . Nous réaliserons la même opération avec le fureteur afin de voir le comportement.

###### <a name="visualisation_connexion_fin" /> Fin de la connexion.

Comme nous avons pu le voir lors de la visualisation de l'opération via __telnet__ c'est le serveur apache qui coupe la connexion. Voici le processus de fermeture de connexion :

<img src="https://upload.wikimedia.org/wikipedia/commons/4/42/Tcp_close.svg" width="700px" />

Par <a href="//commons.wikimedia.org/w/index.php?title=User:Skc&amp;action=edit&amp;redlink=1" class="new" title="User:Skc (page does not exist)">Sébastien Koechlin</a> — <span class="int-own-work" lang="fr">Travail personnel</span>, <a title="Creative Commons Attribution-Share Alike 3.0" href="http://creativecommons.org/licenses/by-sa/3.0">CC BY-SA 3.0</a>, https://commons.wikimedia.org/w/index.php?curid=16887424

La phase de terminaison d'une connexion utilise un handshaking en quatre temps, chaque extrémité de la connexion effectuant sa terminaison de manière indépendante. Ainsi, la fin d'une connexion nécessite une paire de segments FIN et ACK pour chaque extrémité.

Regardons maintenant  l'information dans __wiresharke__ :

![wireshark_visualisation_fin_conn_tcp_06.png](./imgs/wireshark_visualisation_fin_conn_tcp_06.png)


* ligne 8 : Le serveur apache transmet un __FIN__ / __ACK__
* ligne 9 : Le client envoie la même information __FIN__ / __ACK__
* ligne 10 : Le serveur confirme la réception est termine la connexion __ACK__

##### <a name="visualisation_connexion_fureteur" /> Visualisation d'une communication TCP réalisé par le fureteur

Ceci est une version très simple nous avons réduit au maximum les intervenants pour bien voir les paquets et pouvoir les étudier facilement. Voyons le même processus avec le fureteur, lors de l'utilisation de la commande __telnet__ nous avons vu uniquement la récupération du __HTML__ cependant nous n'avions pas récupérer le contenu de la page réellement en effet nous n'avions pas extrait l'image du mouton.

Voici ce qui est afficher à l'écran : 

![screenshot_siteweb.png](./imgs/screenshot_siteweb.png)

Lors de la communication voici ce qui est afficher dans __wireshark__ , prendre note que l'IP du serveur web est 172.17.0.1 maintenant :

![wireshark_visualisation_fureteur_07.png](./imgs/wireshark_visualisation_fureteur_07.png)

Donc les explications :

* ligne 1 à 3 : l'établissement de connexion __TCP__ __3 way handshake__
* ligne 4 : Envoie de l'instruction __GET / HTTP/1.1__ qui est relativement la même commande qu'avec __telnet__ cependant il utilise le protocole __http__ 1.1 spécifiquement . Ceci est définie dans la couche applicative par dessus __TCP__ , car c'est les données transmise pour communiquer
* ligne 5 : Le serveur confirme la réception
* ligne 6 : Le serveur selon le protocole __HTTP 1.1__ transmet une confirmation que la requête est bonne. Nous verrons le détail du contenu tous de suite après les explications par ligne . Ceci est purement du protocole __HTTP__ est ne concerne que très peu le __TCP__
* ligne 7 : Le client confirme la réception de l'information 
* ligne 8 : Le client demande l'image du mouton , car ce dernier fut traiter lors de l'interprétation de la page d'index __html__
* ligne 9 et 10 : Le serveur transmet l'image du mouton , comme l'image du mouton ne peut pas être transmise dans 1 paquet, car il est trop gros, il le transmet dans 2 paquets 
* ligne 11 et 12 : Le client confirme la réception des 2 paquets , donc l'ensemble de l'image du mouton
* ligne 13 à 15 : Fermeture par le serveur et le client de la connexion __TCP__

On peut pas dire que ce soit extrêmement compliqué, bien entendu nous voyons un site TRÈS simple. Nous pourrons faire le même exercice avec un site plus complexe la quantité de donnée sera plus impressionnante, mais le processus sera identique.

__WireShark__ nous offre une belle fonctionnalité, comme le protocole __HTTP__ est connu il est possible d'extraire l'information des paquets __TCP__ pour le protocole __HTTP__ afin de voir simplement le contenu . Sélectionné un paquet, cliquez le bouton droit de la souris et sélectionnez **Follow TCP stream**.

![wireshark_visualisation_fureteur_follow_tcpstream_08.png](./imgs/wireshark_visualisation_fureteur_follow_tcpstream_08.png)

Voici le résultat :

![wireshark_visualisation_fureteur_follow_tcpstream_09.png](./imgs/wireshark_visualisation_fureteur_follow_tcpstream_09.png)

Nous voyons plus clairement maintenant l'échange qui fut réalisé à la ligne 4 et à la ligne 6 , j'avais mentionné que le client envoie __GET / HTTP/1.1__ et le serveur l'accusé de validation pour la racine mais c'était pour faire simple :P.
En réalité , le serveur et le client échange les protocoles supporté pour le reste des communications :P , c'est la version compliqué mais au niveau de la touche __Transport__ ça na pas d'importance car c'est uniquement du protocole __HTTP__.
Bien entendu si vous analysez un problème de communication du serveur apache, ceci est très intéressant, mais pour le besoin de la formation ici c'est en dehors de la matière.

##### <a name="visualisation_conn_fureteur_ext" /> Visualisation d'une communication TCP réalisé par le fureteur avec site complet

Prenons quelques minutes pour voir la même opération sur un autre site, pas trop gros pour pouvoir visualiser facilement le résultat, cependant ceci nous montrera clairement les même opérations. 

Je vais utiliser mon fureteur afin de communiquer avec le site : http://x3rus.com/moodle .

Dans cette situation je ne vais pas prendre l'interface __docker__, mais l'interface externe soit __wlan0__ dans mon cas !

![wireshark_configue_all_http_comm_10.png](./imgs/wireshark_configue_all_http_comm_10.png)

Voici le résultat :

![wireshark_visualisation_comm_x3rus_moodle_full_11.png](./imgs/wireshark_visualisation_comm_x3rus_moodle_full_11.png)

Le fichier de données est aussi disponible ICI : 

Comme vous pouvez le voir il y a plus de donnée , premièrement il y a la requête __DNS__ , puis il y a la requête __TCP__ sur le port 80 . 

Nous pouvons suivre la communication __TCP__ en sélectionnant cette communication :

![wireshark_visualisation_comm_x3rus_moodle_12.png](./imgs/wireshark_visualisation_comm_x3rus_moodle_12.png)

Analysons rapidement :

* Paquets 5 , 10 et 11 : représente la connexion __TCP__ __3 way handshake__ sur le port 80
* Paquets 12 à 25 : Les données qui sont transférés entre le client et le serveur
* Paquets 34 , 35 et 36 : La fermeture de la connexion __TCP__

Mais il y a un autre flux __TCP__ un flux vers le port 443 donc le service communique en __SSL__, bon honnêtement j'ai pas tout de suite compris pourquoi :P. J'ai du analyser pourquoi il y avait cette communication, car il n'y a rien dans la page de __moodle__ en __https__. Regardons la communication :

![wireshark_visualisation_comm_x3rus_moodle_comm_ssl_12.png](./imgs/wireshark_visualisation_comm_x3rus_moodle_comm_ssl_12.png)

Je ne vais pas prendre le temps d'analyser le protocole **httpS** , mais je veux vous montrer la partie __TCP__ autant en profiter :D, c'était pas prévue mais autant d'amuser ... 

* Ligne 36, 37 et 38 :  Nous avons la connexion __TCP__ __3 way handshake__ sur le port 443
* Ligne 40 à 47 : Le transfert de données en utilisant le protocole **httpS** , comme l'information est chiffré je ne vois pas la communication clairement comme lors des échanges sur le port 80 :-/
* Ligne 48 , 49 et 50 : Fermeture de la connexion

Comme nous pouvons le voir peut importe la communication réalisé selon le protocole au niveau de la couche __TCP__ il n'y a pas de différence. Bon pour information, maintenant c'est quoi ce trafic :-), j'ai du allé sur le serveur pour voir les logs du serveur apache :P, finalement c'est simplement mon agent __owncloud__ qui communique en __background__ sur mon __laptop__.
Résultat ça à fait du bruit sur le file réseau , je l'avais oublié , mais on a capitalisé sur l'erreur :D.


#### <a name="clarification_tcp_conclusion" /> Conclusion sur le TCP 

Ceci est donc une introduction pour les communications __TCP__ , nous avons couvert la base quand tous va bien :D , lorsque nous allons faire la couche __Internet__ nous allons voir comment le protocole __TCP__ se comporte en cas de problème de communication. Ceci nous permettra d'approfondir le sujet et voir les mécanismes en place pour valider les communications.

L'important de comprendre avec le protocole __TCP__ est que le client et le serveur établisse un lien de communication et échange les données par ce canal. Une fois la communication terminé, il se salut et ferme le canal de communication.

### <a name="clarification_udp" /> User Datagram Protocol (UDP) (protocole de contrôle de transmissions)


Contrairement au protocole __TCP__, il fonctionne sans négociation : il n'existe pas de procédure de connexion préalable à l'envoi des données (le __handshaking__). Donc __UDP__ ne garantit pas la bonne livraison des paquets à destination, ni leur ordre d'arrivée. Il est également possible que des paquets soient reçus en plusieurs exemplaires.

Si nous reprenons une communication __TCP__ , vous vous rappelez à chaque paquet transmit par un __host__ l'autre répondait par une confirmation __ACK__ de réception , ce mécanisme n'est pas présent avec __UDP__. Nous l'avons pas vu nous allons le faire par la suite , mais le protocole __TCP__ renvoie le paquet s'il n'a pas reçu la confirmation de réception. Dans le cas de __UDP__ comme il n'y a pas d'accusé de réception , l'hôte ne peut pas savoir si le paquet est reçu.

Pourquoi utiliser __UDP__ alors si nous avons un risque de perte de paquets ?? La transmission d'accusé de réception à un coup sur le trafic réseau et sur le temps de traitement. Si nous prenons le cas d'un transfert de fichier il est important d'avoir l'ensemble des paquets pour avoir l'intégrité du fichier. Si nous prenons un cas où __l'UDP__  est très utilisé les jeux vidéos en ligne, S'il y a eu un problème sur le lien et que certain paquet ne sont pas passé quelle est la pertinence de les retransmettre ? Si tu joue à __Quake__ , de toute manière t'es déjà mort :P. Sans farce , les jeux sont assez rapide l'état il y a quelques seconde n'est plus pertinente s'il y a renvoie des paquets, de plus s'il y  a un nombre important de joueurs il est important que la communication soit le plus rapidement possible. 

Le service __DNS__ utilise aussi le protocole __UDP__, ceci permet de réduire la charge sur le serveur et le client s'il n'a pas reçu la réponse peut refaire la requête.

#### <a name="clarification_udp_structure" /> Structure d'un segment UDP

Référence : [https://fr.wikipedia.org/wiki/User\_Datagram\_Protocol](https://fr.wikipedia.org/wiki/User_Datagram_Protocol)

Comme vous pouvez le constater , la structure est beaucoup plus simple que le paquet __TCP__, comme il n'y a pas toute la gestion de connexion et de communication, nous nous retrouvons simplement avec le contenu des données. Tous comme pour le protocole __TCP__ il y a la notion de port pour l'envoie de communication.

<table class="wikitable" style="margin: 0 auto; text-align: center;">
<tr>
<td width="35%" bgcolor="#00DDDD">Port Source (<span class="nowrap">16&#160;bits</span>)</td>
<td width="35%" bgcolor="#00DDDD">Port Destination (<span class="nowrap">16&#160;bits</span>)</td>
</tr>
<tr>
<td width="35%" bgcolor="#00DDDD">Longueur (<span class="nowrap">16&#160;bits</span>)</td>
<td width="35%" bgcolor="#00DDDD">Somme de contrôle (<span class="nowrap">16&#160;bits</span>)</td>
</tr>
<tr>
<td width="70%" colspan="2">Données (longueur variable)</td>
</tr>
</table>


* **Port Source** : indique depuis quel port le paquet a été envoyé.
* **Port de Destination** : indique à quel port le paquet doit être envoyé.
* **Longueur** : indique la longueur totale (exprimée en octets) du paquet __UDP__ (en-tête et données). La longueur minimale est donc de 8 octets (taille de l'en-tête).
* **Somme de contrôle** : celle-ci permet de s'assurer de l'intégrité du paquet reçu quand elle est différente de zéro. Elle est calculée sur l'ensemble de l'en-tête __UDP__ et des données, mais aussi sur un pseudo en-tête (extrait de l'en-tête IP)

Tout comme pour la communication __TCP__ il n'y a pas de notion d'__IP__ à ce niveau car ceci est géré par la couche __Internet__! 

##### <a name="visualisation_connexion_udp" /> Visualisation d'une communication UDP

Afin voir le processus nous allons réalisé une requête __DNS__ au serveur google (8.8.8.8) , pour ce faire nous utiliserons la commande **dig**. Voici le résultat à l'écran :

        $ dig lequipe.fr @8.8.8.8

        ; <<>> DiG 9.10.3 <<>> lequipe.fr @8.8.8.8
        ;; global options: +cmd
        ;; Got answer:
        ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 32099
        ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

        ;; OPT PSEUDOSECTION:
        ; EDNS: version: 0, flags:; udp: 512
        ;; QUESTION SECTION:
        ;lequipe.fr.                    IN      A

        ;; ANSWER SECTION:
        lequipe.fr.             222     IN      A       160.92.167.203

        ;; Query time: 71 msec
        ;; SERVER: 8.8.8.8#53(8.8.8.8)
        ;; WHEN: Fri Aug 12 17:30:25 EDT 2016
        ;; MSG SIZE  rcvd: 55

Démarrons **Wireshark** pour sniffé le trafic :

        $ sudo wireshark-gtk

![wireshark_visualisation_requete_dns_14.png](./imgswireshark_visualisation_requete_dns_14.png)

Nous voyons lors de l'utilisation ceci  :

![wireshark_visualisation_requete_dns_lequipe_fr_14.png](./imgs/wireshark_visualisation_requete_dns_lequipe_fr_14.png)

Comme vous pouvez voir il n'y a vraiment pas le __3 way handshake__, nous voyons l'envoie de la requête et la réception. AUCUNE présence d'accusé de réception si le paquet se perd le client ne le sait pas. La communication est petite , une demande , une réponse rien d'autre , voyons maintenant une communication contenant plus d'information .


##### <a name="visualisation_connexion_snmp" /> Visualisation d'une communication UDP avec l'application snmp

Nous allons utiliser le système __snmp__ pour réalisé la démonstration , nous avons un nombre important de donnée qui peut être transférer tout en restant simple. Ceci aura aussi la chance de présenté ce protocole qui n'est pas connu de tous . Bien entendu nous aurions pu faire la démonstration avec un jeu en ligne aussi , mais il y aurait eu beaucoup de bruit sur la communication. 

Description d'__SNMP__ : __SNMP__ est protocole qui permet de collecter des informations d'un système ou d'un équipement , nous retrouvons des informations de monitoring telle que l'utilisation de la mémoire ou du CPU , la liste des packages présent sur le système , les processus qui sont en exécution , des informations sur la carte réseaux ... Il est aussi possible d'exécuter des commandes à distances. Présent aussi bien pour les systèmes d'exploitation ( GNU/Linux, Windows , ...) que pour les __switchs__ et __firewall__ ( __cisco__ , __HP__ , __jenniper__ , ...) . [https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol](https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol)

Vous pourrez retrouvé la configuration du serveur snmpd que je vais utilisé sur [https://hub.docker.com/r/x3rus/x3-snmpd/](https://hub.docker.com/r/x3rus/x3-snmpd/)

Récupération du conteneur __snmpd__ et démarrage

        $ docker run x3rus/x3-snmpd

Communication avec le service __snmpd__ grâce à la commande __snmpwalk__

        $ snmpwalk -v 2c -c public 172.17.0.9

TODO: Ajouter une image du résultat du __wireshark__

Visualisation avec __wireshark__ , comme vous pouvez le voir le client réalise la requête et le serveur répond avec plusieurs retour. Si nous reprenons la même requête mais nous réalisons une erreur de configuration en modifiant la communauté .


        $ snmpwalk -v 2c -c publique 172.17.0.9

TODO: Ajouter une image du résultat du __wireshark__

Comme nous pouvons le voir il y a bien l'envoie de communication du client mais AUCUN retour du serveur à cette étape nous nous ne savons pas si le serveur est disponible ou simplement éteint , c'est le problème du protocole __UDP__.

#### <a name="clarification_udp_conclusion" /> Conclusion sur le UDP

Nous venons de voir le comportement du protocole __UDP__ quand tous fonctionne bien nous verrons un peu plus tard le comportement en cas de problème de communication. Comme le client et le serveur n'établisse pas de connexion contrairement au protocole __TCP__ il y a moins de mécanisme de validation. 
Il est important de comprendre que le protocole __UDP__ ne réalise pas de validation de réception de la communication transmise . L'avantage de l'__UDP__ est qu'il est moins gourmand que le protocole __TCP__ justement à cause de validation moins  importante.

## <a name="clarification_diff_tcp_udp" /> Autre protocole

*     [SCTP](https://fr.wikipedia.org/wiki/Stream_Control_Transmission_Protocol) (Stream Control Transmission Protocol), protocole fournissant des services similaires à TCP (fiabilité, remise en ordre des séquences, et contrôle de congestion), tout en offrant la possibilité de communications multi-cibles comme avec UDP.
*     [MPTCP](https://fr.wikipedia.org/wiki/Multipath_TCP) (Multipath TCP) est une surcouche à TCP qui rassemble diverses connexions TCP (à travers différentes interfaces réseau: GSM, Wifi etc.), au sein d'une même méta-connexion (RFC 6824). Ce fonctionnement permet d'exploiter tous les chemins disponibles en parallèle, et donc améliorer significativement les performances et la fiabilité d'une connexion.



## <a name="couche_Internet" /> Couche Internet (IP)

Passons maintenant à la partie **IP** de __TCP__/**IP**, comme nous avons vu lors de la présentation du protocole __TCP__ ou __UDP__ les en-têtes des paquets ne contienne pas d'information sur la source du __host__ ou la destination  du __host__. J'avais mentionné que ceci est normal car cette opération est réalisé par l'autre couche , la couche __Internet__ . Nous allons voir maintenant cette couche, l'objectif de la couche __Internet__ et dans notre cas le protocole IP est de transmettre les paquets d'un point A à B.

Si nous reprenons notre exemple de la lettre que l'on poste la couche **Transport** s'occupe de livrer la livre à son destinataire , du côté de l'application ou même de la couche **Transport** peut importe la méthode. 

Voici une représentation graphique de la structure d'un paquet __TCP__ ici, mais ceci est la même chose pour les paquets __UDP__ ce n'est que les en tête qui change :

![Osi-encapsulation.gif](./imgs/Osi-encapsulation.gif)

Nous voyons clairement qu'à chaque couche, il y a un ajout d'information qui est réalisé, nous partons des données de l'application , le tous enveloppé dans une trame __TCP__ , par la suite , il y a ajout des informations __IP__ pour la destination du __host__ et pour finir les informations de la carte réseau dans notre cas.

### <a name="clarification_IP_structure" /> Structure du paquet IP

Nous avons vu les en-tête des paquets __TCP__ et __UDP__ prenons quelques minutes pour regarder la partie __IP__ de la communication  :

<table class="wikitable" style="width: 750px">
<caption>En-tête IPv4</caption>
<tr>
<td width="3.125%">0</td>
<td width="3.125%">1</td>
<td width="3.125%">2</td>
<td width="3.125%">3</td>
<td width="3.125%">4</td>
<td width="3.125%">5</td>
<td width="3.125%">6</td>
<td width="3.125%">7</td>
<td width="3.125%">8</td>
<td width="3.125%">9</td>
<td width="3.125%">10</td>
<td width="3.125%">11</td>
<td width="3.125%">12</td>
<td width="3.125%">13</td>
<td width="3.125%">14</td>
<td width="3.125%">15</td>
<td width="3.125%">16</td>
<td width="3.125%">17</td>
<td width="3.125%">18</td>
<td width="3.125%">19</td>
<td width="3.125%">20</td>
<td width="3.125%">21</td>
<td width="3.125%">22</td>
<td width="3.125%">23</td>
<td width="3.125%">24</td>
<td width="3.125%">25</td>
<td width="3.125%">26</td>
<td width="3.125%">27</td>
<td width="3.125%">28</td>
<td width="3.125%">29</td>
<td width="3.125%">30</td>
<td width="3.125%">31</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="4">
<center>Version d'IP</center>
</td>
<td bgcolor="#F7F8FF" colspan="4">
<center>Longueur de l'en-tête</center>
</td>
<td bgcolor="#F7F8FF" colspan="8">
<center>Type de service</center>
</td>
<td bgcolor="#F7F8FF" colspan="16">
<center>Longueur totale</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="16">
<center>Identification</center>
</td>
<td bgcolor="#F7F8FF" colspan="3">
<center>Indicateur</center>
</td>
<td bgcolor="#F7F8FF" colspan="13">
<center><span class="lang-en" lang="en">Fragment offset</span></center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="8">
<center>Durée de vie</center>
</td>
<td bgcolor="#F7F8FF" colspan="8">
<center>Protocole</center>
</td>
<td bgcolor="#F7F8FF" colspan="16">
<center>Somme de contrôle de l'en-tête</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="32">
<center>Adresse source</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="32">
<center>Adresse destination</center>
</td>
</tr>
<tr>
<td bgcolor="#F7F8FF" colspan="32">
<center>Option(s) + remplissage</center>
</td>
</tr>
</table>

Il y a pas mal d'option, nous ne retrouvons pas uniquement l'adresse __ip__ source et la destination , listons le détail :

* **Version** (4 bits) : Version d'IP utilisée (IPv4 , IPv6)
* **Longueur de l'en-tête ou IHL** (pour Internet Header Length) (4 bits) : Nombre de mots de 32 bits, soit 4 octets (ou nombre de lignes du schéma). La valeur est comprise entre 5 et 15, car il y a 20 octets minimum et on ne peut dépasser 40 octets d'option
* **Type de service ou ToS** (pour Type of Service) (8 bits) : Ce champ permet de distinguer différentes qualités de service différenciant la manière dont les paquets sont traités. Composé de 3 bits de priorité (donc 8 niveaux) et trois indicateurs permettant de différencier le débit, le délai ou la fiabilité. Il se décline au fil des RFC. Au départ ([RFC 791](https://tools.ietf.org/html/rfc791)), [RFC 2474](https://tools.ietf.org/html/rfc2474), [RFC 3168](https://tools.ietf.org/html/rfc3168)
* **Longueur totale** en octets ou Total Length (16 bits) : Nombre total d'octets du datagramme, en-tête IP comprise. Donc, la valeur maximale est (216)-1 octets.
* **Identification** (16 bits): Numéro permettant d'identifier les fragments d'un même paquet.
* **Indicateurs** ou Flags (3 bits): 
    * (Premier bit) actuellement inutilisé.
    * (Deuxième bit) DF (Don't Fragment) : lorsque ce bit est positionné à 1, il indique que le paquet ne peut pas être fragmenté. Si le routeur ne peut acheminer ce paquet (taille du paquet supérieure à la MTU), il est alors rejeté.
    * (Troisième bit) MF (More Fragments) : quand ce bit est positionné à 1, on sait que ce paquet est un fragment de données et que d'autres doivent suivre. Quand il est à 0, soit le fragment est le dernier, soit le paquet n'a pas été fragmenté.
* **Fragment offset** (13 bits) :Position du fragment par rapport au paquet de départ, en nombre de mots de 8 octets. 
* **Durée de vie** ou __TTL__ (pour __Time To Live__) (8 bits) : Initialisé par l'émetteur, ce champ est décrémenté d'une unité généralement à chaque saut de routeur. Quand TTL = 0, le paquet est abandonné et un message ICMP est envoyé à l'émetteur pour information. 
* **Protocole** (8 bits) : Numéro du protocole au-dessus de la couche réseau : TCP = 6, UDP = 17, ICMP = 1.
    Ce champ permet d'identifier le protocole utilisé par le niveau supérieur :
    * Internet Control Message Protocol ou ICMP est repéré par les bits 00000001, qu'on écrit souvent en hexadécimal avec 01
    * Transmission Control Protocol ou TCP par les bits 00000110, soit 06
    * User Datagram Protocol ou UDP par les bits 00010001, soit 17 en décimal
* **Somme de contrôle de l'en-tête** ou Header Checksum (16 bits) : Complément à un de la somme complémentée à un de tout le contenu de l'en-tête afin de détecter les erreurs de transfert. Si la somme de contrôle est invalide, le paquet est abandonné sans message d'erreur.
* **Adresse source** (32 bits) : Adresse IP de l'émetteur sur 32 bits.
* **Adresse destination** (32 bits) : Adresse IP du récepteur 32 bits.
* **Options** (0 à 40 octets par mots de 4 octets) : Facultatif. 
* **Remplissage** ou Padding : Champ de taille variable comprise entre 0 et 7 bits. Il permet de combler le champ option afin d'obtenir un en-tête IP multiple de 32 bits. La valeur des bits de bourrage est 0. 


Bon à ce stade de la formation on va pas tous voir , je voulais principalement démontré l'aspect complet du paquet, ce qui nous aidera par la suite afin de comprendre le comportement surtout dans la deuxième partie quand nous causerons des problèmes de communication :D.

À ce stade nous allons nous soucier de :
* Identification
* Durée de vie
* Protocole
* Adresse source
* Adresse destination

### <a name="clarification_adressage_ip" /> Adresses IP et sous-réseau

L'ensemble du protocole IP se base sur les adresses IP, nous ne couvrirons que le protocoles **IPv4**, __l'IPv6__ est disponible mais pas encore répandu sur l'ensemble des réseaux. __L'IPv6__ a un comportement similaire avec quelques particularité et amélioration , je vous invite fortement à en prendre connaissance pour le future. 

Chaque Hôte sur le réseau doit avoir une adresse IP pour que la communication fonctionne , il y a plusieurs classe d'adresse IP, certaines adresses IP sont réservé pour des usages particulier: [Plages d'adresses IP spéciales](https://fr.wikipedia.org/wiki/Adresse_IP#Plages_d.27adresses_IP_sp.C3.A9ciales). 
Je vais faire un raccourci , je ne vais présenter que les adresses IP à utilisé pour un réseau privé / réseau local (**LAN**).


<table class="wikitable">
<tr>
<th>Nom</th>
<th>Fourchettes d'adresses IP</th>
<th>Nombre d'adresses</th>
<th><i><a href="/wiki/Classful_network" title="Classful network">Classe</a></i> description</th>
<th>Large <a href="/wiki/Classless_Inter-Domain_Routing" title="Classless Inter-Domain Routing">CIDR</a> bloque</th>
</tr>
<tr>
<td>24-bit block</td>
<td>10.0.0.0 – 10.255.255.255</td>
<td><span style="white-space:nowrap">16<span style="margin-left:0.2em">777</span><span style="margin-left:0.2em">216</span></span></td>
<td>Classe A simple</td>
<td>10.0.0.0/8</td>
</tr>
<tr>
<td>20-bit block</td>
<td>172.16.0.0 – 172.31.255.255</td>
<td><span style="white-space:nowrap">1<span style="margin-left:0.2em">048</span><span style="margin-left:0.2em">576</span></span></td>
<td>range de classe 16 du  bloque B</td>
<td>172.16.0.0/12</td>
</tr>
<tr>
<td>16-bit block</td>
<td>192.168.0.0 – 192.168.255.255</td>
<td><span style="white-space:nowrap">65<span style="margin-left:0.2em">536</span></span></td>
<td>range de 256 du bloque de classe C</td>
<td>192.168.0.0/16</td>
</tr>
</table>

L'idée de ses adresses IP est que ces dernière ne sont utilisé que pour un réseaux local et peuvent être alloué par n'importe qui pour son propre réseau. Le plus classique reste : 192.168.0.XX ou 192.168.1.XX principalement à cause des routeurs grand publique qui sont vendu dans le commerce pour partager votre connexion internet et permettre l'interconnexion entre vos équipements. 

Voyons un exemple d'un réseau simple ce que nous retrouvons à nos domicile :

![exemple_network_couche_ip.png](./imgs/exemple_network_couche_ip.png)

Le réseau "privé" est 192.168.0.0/24 donc si une machine avec l'adresse IP : 192.168.0.10 veut rejoindre la machine 192.168.0.42 , lors de la communication le paquet va être transmis  au router . Ce dernier va voir grâce à l'adresse IP que c'est pour la communication interne donc il va chercher la machine dans le réseau local. Bien entendu si le client 192.168.0.10 veut rejoindre le site http://x3rus.com/moodle qui correspond à l'IP 199.100.146.119 n'étant pas sur le réseau local et va renvoyer la demande sur internet.

Bon ça c'est la version courte :D et simplifié. Allons un peu plus loin en complexifiant la structure. 

#### <a name="clarification_adressage_ip_sous-reseau" /> Netmask et sous-réseau

Malheureusement nous n'avons pas beaucoup de temps je suis donc dans l'obligation de réduire cette section au minimum, nous pourrions approfondir cette section ultérieurement s'il y a de la demande. 

Si vous avez un peu lu de la littérature réseau vous avez probablement régulièrement vu des annotations dur style :

* 192.168.10.0/24 ou 192.168.10.0 255.255.255.0
* 172.17.0.0/16 ou 172.17.0.0 255.255.0.0
* 192.168.42.8/29 ou 192.168.42.8 255.255.255.248
* 172.30.25.32/27 ou 172.30.25.32 255.255.255.224

Pour beaucoup cette écriture ne veut pas dire grand chose, nous allons la démystifier, bon pour les personnes qui se disent : "Oh non on va calculer des __netmask__ j'ai horreur de ça !!" Pas de panique ! J'ai pas l'intention de passer la prochaine heure sur ce sujet :D , moi aussi j'ai horreur de ça :P. 

Le système de __netmask__ (/24 ou 255.255.255.0) permet de segmenter une plage d'adresse __IP__ , en fait ça permet de regroupé des machines étant dans le même segment réseau. Commençons par comprendre c'est quoi que ceci veut dire et voyons l'utilisation possible. Vous comprendrez peut-être pourquoi votre administrateur réseau vous réponds parfois qu'il n'y a plus d'adresse IP disponible même si vous êtes dans un réseau privé .

On va commencé par le plus simple le **/24** ou **255.255.255.0** , sous GNU/Linux vous avez une jolie ligne de commande pour vous fournir l'information **ipcalc** :
Pour les personnes qui n'ont pas la chance d'être sous Linux vous pouvez utiliser ce site web : [http://jodies.de/ipcalc](http://jodies.de/ipcalc)


        $ ipcalc 192.168.1.0/24 
        Address:   192.168.1.0          11000000.10101000.00000001. 00000000
        Netmask:   255.255.255.0 = 24   11111111.11111111.11111111. 00000000
        Wildcard:  0.0.0.255            00000000.00000000.00000000. 11111111
        =>
        Network:   192.168.1.0/24       11000000.10101000.00000001. 00000000
        HostMin:   192.168.1.1          11000000.10101000.00000001. 00000001
        HostMax:   192.168.1.254        11000000.10101000.00000001. 11111110
        Broadcast: 192.168.1.255        11000000.10101000.00000001. 11111111
        Hosts/Net: 254                   Class C, Private Internet


Bon dans l'exemple ci-dessus, nous analysons le segment réseau : 192.168.1.0/24 , réseau très répandu chez les particuliers, regardons les 2 premières ligne :

* Address:   192.168.1.0          11000000.10101000.00000001. 00000000
* Netmask:   255.255.255.0 = 24   11111111.11111111.11111111. 00000000

Nous avons l'IP 192.168.1.0 affiché en binaire 11000000 == 192, 10101000 == 168 , ...
Nous avons aussi le __NetMask__ 255.255.255.0 affiché en binaire 11111111 == 255 , 00000000 == 0 

Donc si nous y allons **simplement** lorsque que le système doit valider si l'adresse __IP__ fait partie du réseau il appose le __netmask__ définie. Quand nous regardons le __netmask__ nous voyons une série de **1** et **0**. Lorsque je dit que le __netmask__ est apposé partout où il y a des **1** la valeurs ne doit pas changer avec l'IP d'origine quand il y a **0** la valeur peut varier. 
Voilà pourquoi dans la démonstration plus haut , nous pouvons avoir des valeurs différente pour le dernier chiffre et que ceci donne entre 192.168.1.1 à 192.168.1.254. En d'autre mot les derniers 8 binaires peuvent être changé.

Restons dans le simple et regardons un **/16** ou **255.255.0.0** :

        $ ipcalc 172.17.0.0/16
        Address:   172.17.0.0           10101100.00010001. 00000000.00000000
        Netmask:   255.255.0.0 = 16     11111111.11111111. 00000000.00000000
        Wildcard:  0.0.255.255          00000000.00000000. 11111111.11111111
        =>
        Network:   172.17.0.0/16        10101100.00010001. 00000000.00000000
        HostMin:   172.17.0.1           10101100.00010001. 00000000.00000001
        HostMax:   172.17.255.254       10101100.00010001. 11111111.11111110
        Broadcast: 172.17.255.255       10101100.00010001. 11111111.11111111
        Hosts/Net: 65534                 Class B, Private Internet

Dans le cas présent ce n'est plus 8 binaires qui peuvent être changé mais 16 chiffres donc , nous nous retrouvons à avoir une possibilité sur le réseau de 65534 hôtes sur le même segment réseau. Soit dis en passant le __netmask__ peut être utilisé aussi pour la définition de règles de __firewall__ mais nous y reviendrons peut-être...

Telle que mentionné nous ne ferons qu'un survole de cette aspect par manque de temps si vous désirez aller un peu plus loin , je vous invite à lire le livre : [TCP illustrated par Richard Stevens](https://books.google.ca/books/about/TCP_IP_Illustrated_Volume_1.html?id=a23OAn5i8R0C&source=kp_cover&redir_esc=y&hl=en), mais c'est un autre niveau :D.

Bon juste pour s'amuser on va en faire 2 / 3  autres, rapide , car quand on s'amuse le temps passe vite ;-).

Voyons un tous petit réseau peut-être que ceci aidera à la compréhension :

        $ ipcalc 192.168.1.1/29
        Address:   192.168.1.1          11000000.10101000.00000001.00000 001
        Netmask:   255.255.255.248 = 29 11111111.11111111.11111111.11111 000
        Wildcard:  0.0.0.7              00000000.00000000.00000000.00000 111
        =>
        Network:   192.168.1.0/29       11000000.10101000.00000001.00000 000
        HostMin:   192.168.1.1          11000000.10101000.00000001.00000 001
        HostMax:   192.168.1.6          11000000.10101000.00000001.00000 110
        Broadcast: 192.168.1.7          11000000.10101000.00000001.00000 111
        Hosts/Net: 6                     Class C, Private Internet

Dans l'exemple ci-dessus je définie un tout petit réseau car uniquement 3 chiffre (binaire) peuvent être altéré , si nous prenons le dernier chiffre uniquement 192.168.1.  **0** ==  00000000 , comme les 5 premiers chiffre binaire ne peuvent pas changé la valeur maximal pour le segment est : 00000111 soit 7. Nous avons donc un segment réseau comprenant uniquement 6 hôtes !!

        $ ipcalc 192.168.1.8/29
        Address:   192.168.1.8          11000000.10101000.00000001.00001 000
        Netmask:   255.255.255.248 = 29 11111111.11111111.11111111.11111 000
        Wildcard:  0.0.0.7              00000000.00000000.00000000.00000 111
        =>
        Network:   192.168.1.8/29       11000000.10101000.00000001.00001 000
        HostMin:   192.168.1.9          11000000.10101000.00000001.00001 001
        HostMax:   192.168.1.14         11000000.10101000.00000001.00001 110
        Broadcast: 192.168.1.15         11000000.10101000.00000001.00001 111
        Hosts/Net: 6                     Class C, Private Internet

On continue, je définie un réseau 192.168.1.8/29 avec le même __netmask__ 8 == 00001000 comme le 1 est compris dans les 5 chiffres binaire qui ne sont pas modifiable ceci m'offre un nouveau segment réseau qui à pour valeur minimal : 192.168.1.  **9** == 00001**001** et 00001**111**.

J'espère que je suis claire :-/ , la pratique à venir nous permettra de clarifier ce point.

Dernier moins utilisé mais qui peut poser des question lorsqu'on le voit pour la première fois : 192.168.1.10/32 

        $ ipcalc 192.168.1.10/32
        Address:   192.168.1.10         11000000.10101000.00000001.00001010 
        Netmask:   255.255.255.255 = 32 11111111.11111111.11111111.11111111 
        Wildcard:  0.0.0.0              00000000.00000000.00000000.00000000 
        =>
        Hostroute: 192.168.1.10         11000000.10101000.00000001.00001010 
        Hosts/Net: 1                     Class C, Private Internet

Comme vous pouvez le voir le __Netmask__ ne comprend QUE des 1 donc c'est un réseau avec uniquement 1 hôte.

##### <a name="clarification_ip_regroupement" /> Regroupement de réseau

Pour beaucoup l'application et l'utilisation du __Netmask__ reste très ambigüe , le masque réseau est vraiment une méthode pour représenter un ensemble de machine. Si vous êtes confortable avec l'utilisation de plage de port (__port range__), l'utilisation du masque réseau est la même chose. L'utilisation du __Netmask__ est peut-être moins évident au début , mais comme tous on s'habitue. La raison de l'utilisation du __netmask__ est simple l'application d'un masque binaire est beaucoup plus performant de l'interprétation d'une nomenclature "humaine".

Voyons un schéma réseau afin d'avoir une représentation d'un organisation d'un réseau fictif:

![netmask_network.png](./imgs/netmask_network.png)

Petite explication textuel , nous avons un réseau à gauche qui comprend 254 hôte possible (192.168.10.0/24) c'est le réseau local. À droite nous avons une machine avec une adresse IP pour le serveur X3rus (198.100.146.119/32) et un réseau de 14 IP publique soit (74.222.97.32/28), avec 3 machines identifiées (74.222.97.40 , 74.222.97.35 et 74.222.97.44 ) .

Donc voyons un peu comment comment les masques réseaux peuvent nous aidée dans la situation présente . Comme vous pouvez le voir dans la section de gauche (192.168.10.0/24), j'ai des machines avec un OS privatif , donc non libre. C'est machines sont sur le même réseau local que l'ensemble de mes machines (192.168.10.0/24) . Cependant ce n'est pas des logiciels libre dessus, donc si je ne leur fait pas confiance si je ne désire pas qu'elle aille sur internet par exemple , comment puis je faire pour les bloquer dans le __firewall__. 

J'ai regrouper l'ensemble des machines avec le système d'exploitation privatif sous le segment réseau "fictif" (192.168.10.248/29 ) , faisons le calcule ... nahh exécutons __ipcalc__ pour faire le calcule :

        $ ipcalc 192.168.10.248/29
        Address:   192.168.10.248       11000000.10101000.00001010.11111 000
        Netmask:   255.255.255.248 = 29 11111111.11111111.11111111.11111 000
        Wildcard:  0.0.0.7              00000000.00000000.00000000.00000 111
        =>
        Network:   192.168.10.248/29    11000000.10101000.00001010.11111 000
        HostMin:   192.168.10.249       11000000.10101000.00001010.11111 001
        HostMax:   192.168.10.254       11000000.10101000.00001010.11111 110
        Broadcast: 192.168.10.255       11000000.10101000.00001010.11111 111
        Hosts/Net: 6                     Class C, Private Internet

Donc je peux avoir 6 hôtes pour ce segment, je vois pas pourquoi j'aurais autant de machine fermé , mais bon :P. 
Résultat si je dis dans le firewall toutes les communications provenant dans 192.168.10.248/29 BLOQUE, n'envoie rien sur Internet. Nous voyons une utilisation pratique du regroupement de machine, ceci m'évite d'avoir une ligne par machine dans le __firewall__ pour bloquer la communication.

Prenons un autre exemple, presque le même réseau mais une petite modification avec un regroupement des machines applicative :

![netmask_network-v2.png](./imgs/netmask_network-v2.png)

Le changement est au niveau de la partie à droite, j'ai regroupé encore "fictivement" les machines applicative sous 74.222.97.32/29 . Donc reprenons une situation fictive, je désire :

Fournir l'accès au Opérateur des services applicatif , donc leur machines est sous 192.168.10.0/24 pour qu'il puisse accéder aux serveurs applicatif (74.222.97.32/29) sur le port 22. 
L'option que j'ai pris est de regrouper les machines des développeurs sous le segment 192.168.10.0/25 , ... heu ça donne quoi ça ?? :P , **ipcalc** me voilà :D 

        $ ipcalc 192.168.10.0/25
        Address:   192.168.10.0         11000000.10101000.00001010.0 0000000
        Netmask:   255.255.255.128 = 25 11111111.11111111.11111111.1 0000000
        Wildcard:  0.0.0.127            00000000.00000000.00000000.0 1111111
        =>
        Network:   192.168.10.0/25      11000000.10101000.00001010.0 0000000
        HostMin:   192.168.10.1         11000000.10101000.00001010.0 0000001
        HostMax:   192.168.10.126       11000000.10101000.00001010.0 1111110
        Broadcast: 192.168.10.127       11000000.10101000.00001010.0 1111111
        Hosts/Net: 126                   Class C, Private Internet

Donc avec cette segmentation je peux avoir disons 125 hôtes pour les développeurs, en d'autre mot , j'ai segmenté la première partie de mon réseau pour le dédier aux développeurs. Résultat dans les règles de __firewall__  je pourrais mentionné ceci :

__Devs__ (192.168.10.0/25) peuvent accéder sur le port 22 vers le réseau 74.222.97.32/29 , donc les uniquement les serveurs applicatif. 

Prendre note que je fais mes exemples en parlant de __firewall__ , cependant cette nomenclature est aussi applicable dans les fichiers de configuration d'apache pour limiter l'accès à une section d'administration, le service de base de donnée telle que __Postgress__ pour l'accès , ... Donc ceci ne s'applique pas uniquement pour les équipements réseaux.

### <a name="clarification_routage_IP" /> Routage des paquets IP

Le protocole IP est sans connexion établie (__connexion less__), en d'autre mot chaque paquet est traité indépendamment pour la livraison. En d'autre mot même si nous reprenons le concept du protocole __TCP__ qui établie une connexion entre les 2 hôtes au niveau __IP__ les paquets qui sont transmis entre les 2 machines peuvent prendre des chemins différents à chaque transmission de paquet.

Si nous prenons au haut niveau l'algorithme de livraison des paquets voici ce que ça donne :

1. Si le **réseau de destination** est directement connecté sur la machine 
    * Livraison à l'**hôte de destination** direction sur l'interface .
2. Sinon si la table de routage comprend une entré pour le **réseau de destination** 
    * Envoie du paquet au router de destination (__next-hop__) pour que lui réalise la redirection vers l'**hôte de destination**
3. Sinon validation qu'il y a une route par défaut
    * Envoie du paquet vers la route par défaut
4. Sinon pas de route par défaut
    * Retour d'un message d'erreur à l'expéditeur

Ce n'est pas très compliquer , bien entendu plus nous avons de réseaux disponible plus ce simple algorithme peut être très complexe , par contre j'aimerai surtout souligner un point. 
**Le protocole IP ne réalise le routage QUE sur la destination , la source du paquet n'est pas pris en considération !!!**
Cette phrase est importante pour bien comprendre le chemin des paquets !

Regardons les routes définie sur ma machine actuellement :

        $ route -n
        Kernel IP routing table
        Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
        0.0.0.0         192.168.43.1    0.0.0.0         UG    600    0        0 wlan0
        172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
        192.168.43.0    0.0.0.0         255.255.255.0   U     600    0        0 wlan0

Sous Windows si je ne me trompe pas la commande __dos__ est :

        > netstat -r -n
        [ PAS DE OUTPUT PAS TESTE ]

Ici j'ai 2 interface (carte réseau) :

* **wlan0** : carte réseau sans fil 
* **docker0** : carte virtuel pour mes (conteneurs docker)[Explication de docker disponible en vidéo](https://www.youtube.com/playlist?list=PLrspRZ5MjONxxp4gr_6I3otYOlKkSFunL)

Voici les adresses __IP__ :

* **wlan0** : 192.168.43.191/24
* **docker0** : 172.17.42.1/16

Si nous regardons la table de routage :

* Ligne 3 :
    * La ligne indique que si la destination est contenu dans le réseau 192.168.43.0/24 envoie la requête à l'interface **wlan0**

            Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
            192.168.43.0    0.0.0.0         255.255.255.0   U     600    0        0 wlan0
* Ligne 2 :
    * La ligne indique que si la destination est contenu dans le réseau 172.17.0.0/16 envoie la requête sur l'interface **docker0**

            Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
            172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
* Ligne 1 :
    * Sinon transmet la requête à la route par défaut ici **192.168.42.1** sur l'interface **wlan0**

            Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
            0.0.0.0         192.168.43.1    0.0.0.0         UG    600    0        0 wlan0

Le système est aussi simple que ça à la base !! Après les administrateurs ont compliqué tous ça pour assurer leur emploie :P, non je rigole. En mettant un système de base simple et compréhensible, un ensemble de mécanisme furent mis en place afin d'assurer une disponibilité constante du réseau, malgré le fait de perdre des nœuds dans l'infrastructure.


L'ensemble des propagations des informations des routes sur internet , la mise à jour des routes automatique , ... 

* [BGP](https://fr.wikipedia.org/wiki/Border_Gateway_Protocol) **Border Gateway Protocol**  est un protocole d'échange de route utilisé notamment sur le réseau Internet. Son objectif est d'échanger des informations de routage et d'accessibilité de réseaux (appelés préfixes) entre Autonomous Systems (AS).)
* [OSPF](https://fr.wikipedia.org/wiki/Open_Shortest_Path_First) **Open Shortest Path First** est un protocole de routage interne IP de type « à état de liens ». Il a été développé au sein de l'Internet Engineering Task Force (IETF) à partir de 1987

### <a name="clarification_reliability_ip" /> Services délivrés / Fiabilité du protocole

Le réseau IP est basé sur le [principe de bout-à-bout](https://fr.wikipedia.org/wiki/Principe_de_bout-%C3%A0-bout) (en anglais : [end-to-end principle](https://en.wikipedia.org/wiki/End-to-end_principle) : Il énonce que « plutôt que d’installer l’intelligence au cœur du réseau, il faut la situer aux extrémités : les ordinateurs au sein du réseau n’ont à exécuter que les fonctions très simples qui sont nécessaires pour les applications les plus diverses, alors que les fonctions qui sont requises par certaines applications spécifiques seulement doivent être exécutées en bordure de réseau. Ainsi, la complexité et l’intelligence du réseau sont repoussées vers ses lisières. Des réseaux simples pour des applications intelligentes. »

L'infrastructure de réseau est considéré comme intrinsèquement peu fiable à tout le niveau du réseau ou d'une transmission , ceci suppose que le réseau est dynamique en termes de disponibilité de liens et de nœuds. Aucune installation de surveillance ou de mesure de la performance centrale existe que les pistes ou maintient l'état du réseau.

Afin d'avoir la flexibilité d'avoir une gestion dynamique du trajet des communications , le protocole IP est __stateless__ sans connexion forte , chaque paquet est géré indépendamment. Ceci peut semblé en contradiction avec la couche supérieur __TCP__ qui lui est __statefull__ (orienté connexion) entre deux hôtes, ceci mérite une petite explication. Le canal entre 2 hôtes est établie par le protocole __TCP__ pour s'assurer qu'il y est un lien , cependant le chemin parcouru par un paquet par varié d'une transmission à l'autre. J'ai sauté volontairement un aspect du protocole __TCP__ , je vais rajouter l'information maintenant .Le protocole __TCP__ ne s'attend pas à recevoir les paquets dans le bonne ordre en effet comme chaque transmission peut prendre un chemin différent il est possible que parfois la transmission d'un paquet soit plus rapide ou plus lent.
Si nous reprenons allons voir l'en tête du paquet __TCP__ le numéro de séquence est utilisé à cette effet.

Voici une représentation graphique du routage :

![Routing_schema.png](./imgs/Routing_schema.png)

Voyons un exemple avec l'application **traceroute** qui nous permet de visualiser le chemin parcouru par un paquet afin de voir son cheminement. Je vais faire 2 requête pour le service __www.google.com__ :

        $ date && traceroute www.google.com
        Fri Aug 19 08:46:20 EDT 2016
        traceroute to www.google.com (172.217.4.196), 30 hops max, 60 byte packets
         1  gateway (192.168.43.1)  1.594 ms  1.732 ms  2.680 ms
         2  * * *  
         3  192.168.142.66 (192.168.142.66)  77.497 ms  249.147 ms 192.168.142.2 (192.168.142.2)  77.465 ms
         4  10.118.50.165 (10.118.50.165)  45.352 ms 10.118.50.173 (10.118.50.173)  45.205 ms 10.118.50.165 (10.118.50.165)  45.297 ms
         5  10.118.48.61 (10.118.48.61)  45.363 ms  45.551 ms 10.118.48.57 (10.118.48.57)  45.401 ms
         6  24.156.157.157 (24.156.157.157)  48.882 ms  26.435 ms 24.156.157.153 (24.156.157.153)  37.600 ms
         7  gw03.strfrd.phub.net.cable.rogers.com (66.185.82.38)  33.332 ms  37.719 ms 24.156.146.42 (24.156.146.42)  36.887 ms
         8  24.156.146.42 (24.156.146.42)  37.205 ms  37.701 ms 24.156.157.133 (24.156.157.133)  44.984 ms
         9  24.156.157.133 (24.156.157.133)  45.072 ms van58-9-231-85.dynamic.rogerstelecom.net (209.148.231.85)  44.711 ms 24.156.157.133 (24.156.157.133)  36.733 ms
         10  van58-9-231-85.dynamic.rogerstelecom.net (209.148.231.85)  47.896 ms  50.824 ms  43.826 ms
         11  van58-9-230-10.dynamic.rogerstelecom.net (209.148.230.10)  44.126 ms  44.013 ms  44.030 ms
         12  72.14.222.87 (72.14.222.87)  43.151 ms  43.605 ms  36.525 ms
         13  216.239.47.114 (216.239.47.114)  47.308 ms 72.14.222.87 (72.14.222.87)  51.792 ms  54.456 ms
         14  72.14.236.224 (72.14.236.224)  55.834 ms 72.14.236.226 (72.14.236.226)  56.012 ms 72.14.236.224 (72.14.236.224)  56.054 ms
         15  216.239.49.236 (216.239.49.236)  55.969 ms 72.14.236.226 (72.14.236.226)  60.465 ms 216.239.49.236 (216.239.49.236)  60.116 ms
         16  72.14.236.209 (72.14.236.209)  63.569 ms 72.14.252.27 (72.14.252.27)  63.689 ms  63.841 ms
         17  lga15s48-in-f4.1e100.net (172.217.4.196)  61.269 ms 72.14.252.27 (72.14.252.27)  56.460 ms *

16 secondes plus tard on relance la requête :

        $ date && traceroute www.google.com
        Fri Aug 19 08:46:36 EDT 2016
        traceroute to www.google.com (172.217.4.196), 30 hops max, 60 byte packets
         1  gateway (192.168.43.1)  2.177 ms  2.394 ms  2.617 ms
         2  * * *
         3  192.168.142.2 (192.168.142.2)  241.469 ms  93.143 ms  93.188 ms
         4  10.118.50.165 (10.118.50.165)  41.892 ms 10.118.50.173 (10.118.50.173)  41.902 ms 10.118.50.165 (10.118.50.165)  78.194 ms
         5  10.118.48.61 (10.118.48.61)  41.916 ms 10.118.48.57 (10.118.48.57)  42.654 ms 10.118.48.61 (10.118.48.61)  41.951 ms
         6  24.156.157.153 (24.156.157.153)  44.796 ms  31.740 ms  42.273 ms
         7  24.156.146.42 (24.156.146.42)  33.924 ms  26.713 ms  38.678 ms
         8  24.156.146.42 (24.156.146.42)  38.714 ms 24.156.157.133 (24.156.157.133)  42.379 ms  42.017 ms
         9  van58-9-231-85.dynamic.rogerstelecom.net (209.148.231.85)  44.496 ms 24.156.157.133 (24.156.157.133)  34.496 ms  31.558 ms
         10  van58-9-231-85.dynamic.rogerstelecom.net (209.148.231.85)  57.536 ms  59.568 ms van58-9-229-229.dynamic.rogerstelecom.net (209.148.229.229)  62.109 ms
         11  van58-9-229-229.dynamic.rogerstelecom.net (209.148.229.229)  60.080 ms van58-9-230-10.dynamic.rogerstelecom.net (209.148.230.10)  56.135 ms *
         12  van58-9-230-10.dynamic.rogerstelecom.net (209.148.230.10)  55.680 ms  51.846 ms  51.602 ms
         13  * 216.239.47.114 (216.239.47.114)  47.791 ms 72.14.222.87 (72.14.222.87)  43.863 ms
         14  216.239.47.114 (216.239.47.114)  45.678 ms 72.14.236.224 (72.14.236.224)  92.370 ms  56.359 ms
         15  72.14.236.226 (72.14.236.226)  59.623 ms 216.239.49.236 (216.239.49.236)  52.860 ms 72.14.236.224 (72.14.236.224)  56.581 ms
         16  72.14.252.27 (72.14.252.27)  56.370 ms 209.85.252.243 (209.85.252.243)  55.958 ms 216.239.48.210 (216.239.48.210)  76.785 ms
         17  lga15s48-in-f4.1e100.net (172.217.4.196)  55.954 ms  58.893 ms *

Analysons le résultat à l'écran , lors que ma machine 192.168.43.191 essaye de rejoindre 172.217.4.196 (__google__): 

* Ligne 1 : Comme je sort de ma machine vers Internet , le système transmet la requête à ma passerelle par défaut __192.168.43.1__  les trois chiffre qui suive l'adresse __IP__ correspond au __TTL__ (__Time To Leave__) que __traceroute__ à reçu lors du transfert des paquets __ICMP__ (un __ping__ :P )
* Ligne 2 : **\* \* \*** , la passerelle  qui suit la passerelle par défaut refuse les requêtes __ICMP__ , __traceroute__ en a transmis 3, les 3 furent sans réponse, donc pas d'information .
* Ligne 3 : Première différence lors de la première requête nous avons une réponse lors du premier teste de 2 __routeurs__ 192.168.142.66 et 192.168.142.2 , l'IP 66 à répondu au 2 premières requêtes __ICMP__ et l'IP .2 à répondu à la dernière.
* Ligne 4 : Ce n'est pas 2 __routeurs__ mais 3 routes différentes 10.118.50.165 45.352ms ,10.118.50.173 45.205ms, 10.118.50.165 45.297ms . Nous voyons déjà clairement le côté dynamique des route , nous voyons que plusieurs chemin s'offre au paquet selon le moment de la demande et la disponibilité des infrastructures. Ceci permet en d'autre d'assurer la disponibilité des service mais aussi de distribué la charge entre plusieurs équipement.
* Ligne suivante : Si vous regardez attentivement vous constaterez que le chemin n'est pas exactement identique lors des 2 requêtes qui furent réalisé avec 10 secondes d'écart.

Pour les personnes qui veulent avoir un résultat pour un film de __IT__ avec plein d'effet visuel :P , car la ligne de commande c'est pas très sexy pour __Hollywood__ vous avez :
* [https://sourceforge.net/projects/openvisualtrace/](https://sourceforge.net/projects/openvisualtrace/)

#### <a name="clarification_ip_best_effort" /> Qualité du service IP (Best Effort)

Nous disons toujours que l'Internet à une vitesse variable, nous le voyons régulièrement parfois un service répond très bien et parfois il est plus lent car il y a plus de congestion. Comme l'ensemble de l'infrastructure d'Internet repose sur la configuration en périphérie il est important de réaliser une configuration adéquat, mais nous pouvons toujours être affecté.

Avec la démocratisation de la voix sur IP , nous sommes confronté à un problème de taille, si vous avez un service de voix sur IP il est important que votre communication ne soit pas impacté . En d'autre mot si vous parlez au téléphone et que vous téléchargez la dernière distribution avec le protocole de __torrent__ il ne faut pas que la voix soit coupé ou hachuré.
Le système de [QOS](https://fr.wikipedia.org/wiki/Qualit%C3%A9_de_service) vient répondre à ce besoin, il garantie une quantité de bande passante disponible et réservé pour la voix , ceci assurant qu'aucune autre communication impacte les transferts.

L'identification des paquets prioritaire peut être réalisé par l'application mais plus souvent par les équipements réseau en ajoutant des __flags__ aux paquets, afin de les identifier.

### <a name="clarification_NAT_IP" /> Manipulation des adresses IP (NAT)

Nous avons parlé de routage des paquets qui transige d'une machine à l'autre, mais j'ai volontaire omis une information importante, j'ai uniquement indiquer le cheminement d'un paquet vers la machine extérieur et non le retour. Lors de la présentation des couches Transport __TCP__ ou __UDP__ nous avons vu que la réponses doit revenir :0. 

Regardons le schéma suivant qui représente une topologie très classique :

![network_schema_nat.png](./imgs/network_schema_nat.png)

Ceci ressemble énormément à un réseau domestique , un réseau local **192.168.10.0/24** avec une connexion Internet dont l'IP est : **64.154.19.124/32** . 

Prenons l'exemple de la machine **dark** avec l'IP __192.168.10.44/32__ qui tente de communiquer avec la machine **kazak** qui a une adresse IP publique sur internet __140.99.45.130/32__.

Lors de la transmission du paquet , peut importe le protocole (__TCP__ , __UDP__, ...) nous nous concentrons uniquement sur le chemin parcouru par le paquet donc la couche **Internet**.
Voici à quoi ressemble l'en-tête IP lors de l'envoie de paquet ainsi que le retour :

![network_schema_nat-with-header-IP.png](./imgs/network_schema_nat-with-header-IP.png)

1. **Dark** construit son paquet IP en définissant son adresse IP source ainsi que l'IP du serveur distance , jusqu'ici tous va bien
2. En théorie , le serveur **Kazak** va recevoir la communication , et va répondre peut importe le protocole utilisé
3. Il utilisera l'IP **source** du paquet reçu soit __192.168.10.44__ pour répondre.
4. Malheureusement l'IP __192.168.10.44__ fait partie des adresses IP dédié pour les réseaux privées , voir explication [ Adresses IP et sous-réseau](#clarification_adressage_ip). 
5. **Kazak** n'a donc pas l'information pour rejoindre la machine **Dark** 

Pour corriger ce problème nous avons besoin d'un **NAT** (__Network Address Translation__) en d'autre mot quand le paquet va transiger par le routeur Internet (64.154.19.124) ce dernier va modifier le paquet IP afin de modifier l'adresse IP source.

Voici une représentation visuelle de l'opération :

![network_schema_nat-with-header-IP-et-NAT.png](./imgs/network_schema_nat-with-header-IP-et-NAT.png)

Comme vous pouvez le voir le routeur à mis l'adresse IP externe d'Internet lors de l'envoie du paquet , quand **Kazar** voudra répondre à la machine **Dark** il utilisera l'adresse IP publique **routable** sur Internet pour répondre. Le routeur Internet réalisera la même opération de changement d'adresse IP mais au lieu de changer la source, il changera l'IP de destination afin de mettre l'IP Interne de **Dark** soit : 192.168.10.44.

Le routeur Internet qui réalise du **NAT** conserve une table de conversion pour savoir quelles machine interne à communiquer avec l'externe lui permettant de refaire les conversions lors que les paquets reviennent.

Pourquoi le __NATting__: 

* Afin de permettre à plusieurs machines d'avoir internet avec une seul adresse IP publique
* Permet de protéger le réseau internet en limitant les paquets , car sinon toutes les machines auraient une adresses publique directement sur internet.
* Réduit le nombre d'adresse IP publique requise , comme le nombre d'adresse __IPv4__ sont limité


## <a name="couche_Link" /> Couche Link (switch , ...)

Je n'avais pas prévue couvrir cette couche cependant il y a au moins 2 sujets que je désire adresser donc je vais encore étendre un peu plus la formation :P . Comme toujours mon gros défis est de ne pas trop en faire mais c'est plus fort que moi :P.

Nous allons voir "rapidement" la couche **Link** , cette couche comprend le traitement qui est réalisé au niveau des __switchs__ , point d'accès sans-fil , ... En d'autre mot ce sont les équipements qui permettent l'interconnexion des équipements, contrairement à la couche physique qui est la carte réseau de la machine (__wifi__ ou filaire )

Voyons quelques point de configuration possible au niveau des équipements qui est très répandu dans l'industrie et que je pense mérite d'être mentionné, car parfois ceci cause des problèmes :P.

### <a name="couche_Link_vlan" /> Vlan (Virtual LAN)

Lors de la présentation de la segmentation des réseaux j'ai fait mention qu'il est possible de définir des règles d'accès selon l'adresse IP et le __netmask__. Pour les petits malin peut-être vous vous êtes dis , cool j'ai juste à prendre l'adresse IP d'un administrateur de la compagnie et BINGO j'aurais l'ensemble de leur droit !!!

En théorie oui , ceci est vraie cependant dans la réalité vous ne pouvez pas vous connecter sur n'importe quelle sous réseaux, il y a des mécanismes de "protection" qui limite les prises réseaux. 
Si vous aviez accès à la configuration de la __switch__ de votre entreprise, vous pourriez constater que chaque port est associé à un __VLAN__. 

Un __VLAN__ possède un numéro et est associé à un segment réseau définie , ceci permet: 
* à une __switch__ de fournir plusieurs  réseaux tous en limitant les communications entre les ports
* Optimiser la bande passante
* Séparer virtuellement les flux
* Ajouter de la sécurité afin de ne dédié un port qu'à un ou plusieurs __VLAN__ / réseaux

Voici une représentation du paquet incluant un __VLAN__ :

![VLAN_-_Trama_802.1Q.jpg](./imgs/VLAN_-_Trama_802.1Q.jpg)

Si vous utilisez une autre adresse IP qui est associé au __VLAN__ ce dernier ne routera tous simplement pas vos paquets, car le segment réseau ne sera pas convenable !!

### <a name="couche_Link_arp" /> ARP (Address Resolution Protocol)

Dernier point rapide pour terminer la théorie du réseau , pour les plus vieux ils vont probablement ce rappeler du bon vieux temps des __HUB__ avant que les __switchs__ fassent leur apparition .
Le __HUB__ quand il recevait un paquet IP, il le __broadcasté__ à l'ensemble des ordinateurs branchés sur le __HUB__ , en d'autre mot si la machine **Dark** recevait un paquet l'ensemble des machines (__yoda__,__r2d2__,__C-3PO__) recevait le paquet . L'idée était que uniquement la machine qui avait la bonne IP traitait la communication.
Je vous dis pas comme c'était génial quand tu voulais sniffer ce qui se passé sur l'ensemble du réseau ou au moins les machines à coté de toi.

Ce bon temps est révolue :P, afin de limité le __noise__ sur le réseau les __switchs__ conserve une table des mac adresses des machines branché dans les ports. Nous ne l'avons pas bien vu mais si nous reprenons la représentation suivante vous pouvez voir que dans la couche **data Link** il y a une en-tête pour la MAC.

![Osi-encapsulation.gif](./imgs/Osi-encapsulation.gif)

Donc de nos jours la __switch__ n'envoie les paquets que pour la bonne machine :-(. Ceci peut avoir un effet de bord lors de vos testes par exemple .

1. J'ai une machine **A** avec l'IP 192.168.10.44 , qui est branché et communique sur le réseau. Je désire changer cette dernière cependant je veux valider avant que mon "serveur" ou que les applications fonctionne .
2. Je débranche uniquement le fil réseaux de la machine **A** et le branche dans la machine **B** , je lui assigne l'IP 192.168.10.44.
3. Il est à parier que vous n'aurez pas de réseau , pourquoi ? Car l'adresse MAC physique de la carte réseau à changé et la __switch__ a conservé, dans sa table de MAC la correspondance IP (192.168.10.44) et la MAC de la machine **A**. Il faut enlever l'entrée de la l'IP et MAC.

Si nous avions éteint la machine **A** avant de brancher le câble dans **B** , **A** aurait envoyer un signal à la __switch__ lui signalant que le système va s'éteindre et que la __MAC__ va peut-être changer.


# <a name="Conclusion"/> Conclusion 

1. L'application définie le data / requête qui sera transmise au serveur selon un protocole établie ( HTTP, __FTP__, __DNS__, ...)
2. Cette requête est encapsulé selon un protocole
    1. __TCP__ (ex. HTTP): réalisation d'un lien entre le client et le serveur , connexion "forte" pour le transfert des communications. Le tous ce fini avec une fermeture de connexion.
    2. __UDP__ (ex. __DNS__) : Aucune connexion entre le client et le serveur , le client envoie la requête et attend le retour du serveur
3. Le cheminement sur le réseau est réaliser avec le protocole IP , qui s'assure de rejoindre la machine **B** depuis le point **A**. Chaque paquet peuvent prendre un chemin différent pour rejoindre la destination selon la disponibilité de l'infrastructure. Certaine adresse IP sont réservé pour un usage "interne" (__LAN__)  il est possible de réaliser de la manipulation de paquet exemple __NAT__
4. La segmentation du réseau peut être réaliser aussi au niveau des équipements de connexion telle que __switchs__ via le système de __VLAN__


Référence : [http://www.tcpipguide.com/free/t\_toc.htm](http://www.tcpipguide.com/free/t_toc.htm)
