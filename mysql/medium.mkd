<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 

# <a name="storage_engine" /> Stockage des informations

__MySQL__ a un système de stockage des informations modulaire (__pluggable__) , ceci permet d'utiliser le système adéquat selon vos besoins. Dans les faits ceci est principalement lors de l'optimisation que l'on modifie le système de stockage. Le gros avantage est que le système de stockage est complètement transparent pour les applications ! Ceci permet aussi d'accroitre les possibilités de __MySQL__.

Voici une liste non exhaustive des raisons de choisir un type de stockage particulier :

* **Concurrence** : Certain système de stockage offre un système de verrou (__LOCK__) plus granulaire (par exemple : uniquement verrou par enregistrement / ligne) . Choisir le bon système de stockage peut permettre de réduire le temps de traitement (__overhead__) requis pour le verrou, améliorant la performance générale.
* **Support des Transactions** : Support des transactions ( couvert dans le chapitre précédent __COMMIT__ et __ROLLBACK__ ) bien que toutes les applications n'en n'ont pas besoin ceci peut être pratique. 
* **Intégrité** : Selon le système de stockage que vous utilisez vous pouvez avoir ou non le système référentiel fort avec les clés étrangère , bien entendu cette ajout ayant un coût si vous désirez réduire la charge sur le serveur de BD opté pour un système sans référentiel fort vous aurez un gain de performance.
* **Stockage physique** : Les modules choisie vous permet d'avoir un système de stockage approprié pour vos besoin ( __csv__, mémoire, ...)
* **Indexation** : Les systèmes de stockage offre une indexation propre, optimisé selon la situation. Vous retrouverez l'indexation __B-tree__ pour l'ensemble des systèmes de stockage.
* **Cache mémoire** : L'ensemble des systèmes de stockage offre une fonctionnalité minimal de mise en mémoire des requêtes, mais certain système offre une optimisation pour ce besoin. (exemple __MySQL's high-speed Query Cache__)
* **Assistant de performance** : De manière général , l'engin peut être optimal pour la lecture ou l'écriture , offrir des utilitaires d'analyse de performance ...
* **Fonctionnalité particulière** : Le système de stockage peut offrir des fonctionnalités particulière telle que le support des données __GéoSpacial__, ou une gestion plus granulaire des accès de sécurité.

* Référence 
    * [Caractéristique stockage](http://dev.mysql.com/doc/refman/5.5/en/pluggable-storage-common-layer.html)
    * [Module de stockage](http://dev.mysql.com/doc/refman/5.5/en/pluggable-storage-overview.html)

## <a name="engine_available" /> Engins disponible

Documentation __MySQL__ de référence : [Storage engines](http://dev.mysql.com/doc/refman/5.5/en/storage-engines.html)

Premièrement voyons ce qui est disponible sur notre environnements, vous n'avez pas besoin d'être l'administrateur pour visualiser les engins disponibles 

        $ mysql -u bob -p
        Enter password:
        mysql> SHOW ENGINES ;
        +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
        | Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
        +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
        | PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
        | MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
        | CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
        | BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
        | MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
        | InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
        | ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
        | MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
        | FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
        +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
        9 rows in set (0.00 sec)

Nous pouvons donc voir l'ensemble des engins offert sur notre base de données prenons quelque minutes pour identifier les options disponibles :

* **InnoDB** __défaut__ : Depuis la version 5.5.5 **InnoDB** est le système de stockage par défaut originalement c'était **MyISAM** qui était privilégié. __InnoDB__ support le système de transaction (__commit__, __rollback__, ...) , il a aussi la fonctionnalité de __crash-recovery__ afin de protéger les données en cas de problème du système. **InnoDB** a la caractéristique de réalisé des verrous par enregistrement et non sur l'ensemble de la table , les données sont stocké dans un index de type __cluster__ afin de réduire __l'I/O__ (accès disque) pour les requêtes courantes particulièrement sur les clés primaires. Plus d'information disponible sur la documentation de __MySQL__ [Innodb storage](dev.mysql.com/doc/refman/5.5/en/innodb-storage-engine.html)
* **MyISAM** : Avant la version 5.5.5 c'était le système de stockage par défaut, ce système de stockage n'offre pas la possibilité d'utiliser le système de transaction. Il n'offre pas non plus la possibilité d'utiliser les clés étrangère pour l'intégrité des données. Le système de verrou est sur l'ensemble de la table et non pour l'enregistrement, bon à ce point vous vous dites mais pourquoi j'utiliserai ce système il fait moins de chose **qu'innoDB**. **MyISAM** support un plus grand nombre de données que **InnoDB** 256TB pour être exacte :D. Il support la cherche indexé dans l'ensemble des champs teste , non disponible dans **innoDB** avant la version 5.6.4. L'absence de mécanisme de validation en a fait un système plus performant pour les accès en **Lecture** et fut très populaire pour l'indexation des champs **TEXT** principalement pour les applications web . Documentation sur __MySQL__ [MyISAM storage](http://dev.mysql.com/doc/refman/5.5/en/myisam-storage-engine.html)
* **Memory** : Permet d'utiliser la **RAM** du système pour stocké les informations, bien entendu ce mécanisme est très très performant, cependant les informations sont éphémère. Il n'y a aucun mécanisme en cas de crash du système, le système ressemble à **MyISAM** pas de clé étrangère, pas de transaction , ... Documentation sur __MySQL__ [Memory storage](http://dev.mysql.com/doc/refman/5.5/en/memory-storage-engine.html).
* **Archive** : Comme son nom l'indique ce type de stockage est utilisé pour l'archivage de donnée, la particularité est d'offrir la possibilité de stockage SANS limite. Bien entendu il ne faut pas s'attendre à avoir de la performance pour ce type de stockage , il n'y a pas d'indexation des données ceci à donc un gros impact sur la performance. Il y a tout de même une mise en cache des requêtes. Documentation sur __MySQL__ [Archive storage](http://dev.mysql.com/doc/refman/5.5/en/archive-storage-engine.html).
* **Federated** : Vous avez la possibilité de créer un serveur __MySQL__ logique qui regroupe un grand nombre de serveur __MySQL__. Quand nous utilisons les système de stockage classique (__MyISAM__, __InnoDB__, ...) la définition de la table ET les données sont sur la même machine, avec le mode **fédéré** les donnés sont sur un serveur distant .Documentation __MySQL__ [Federated storage](http://dev.mysql.com/doc/refman/5.5/en/federated-storage-engine.html)
    ![se-federated-structure.png](./imgs/se-federated-structure.png)
* **CSV** : __Comma Separated Values__ soit Valeur Séparés par des Virgules , ceci permet d'avoir un fichier avec une virgule qui sépare les champs. La performance est très limité cependant ceci peut être pratique pour extraire de l'information de la base de données. Documentation __MySQL__ [csv storage](http://dev.mysql.com/doc/refman/5.5/en/csv-storage-engine.html)
* **BlackHole** : Alors celui la j'essaye encore de voir l'utilité , la documentation parle d'utilité lors de la réplication pour ne pas répliquer certain données, mais bon personnellement j'exclus les tables que je ne veux pas ... Bon j'oublie de donner l'explication, normale **blackhole** c'est le trou noir. Le système vous permet de créer un table d'insérer des donnes mais tous est envoyé à la poubelle. Donc lors d'un **SELECT** le système ne renvoie AUCUNE information. Je trouve ça bien même si je ne vois pas l'utilité :D . Documentation __MySQL__  [Blackhole storage](http://dev.mysql.com/doc/refman/5.5/en/blackhole-storage-engine.html)

Voici un résumé des fonctionnalités et du supports selon l'engin :

![summary_storage_engine.png](./imgs/summary_storage_engine.png)


## <a name="engine_use" /> Utilisation des systèmes de stockage

Pour une même base de données plusieurs engins peuvent être utilisé, selon vos besoins , voici un petit exemple d'utilisation :

Vous avez un site de jeu , l'ensemble des informations utilisateurs ( nom, mot de passe, contact , ... ) sont stocké dans une base de données de type **InnoDB** ou **MyISAM** , quand les utilisateurs débutes une partie (éphémère) et jugé non-critique :P vous pourriez créer une table : partie\_2764 (partie\_#de-la-partie) cette table serait définie avec l'engin **Memory** pour être optimisé au maximum en cas de crash ce n'est pas critique. 

Voyons un peu l'utilisation des **engin** je vais me concentrer sur les 2 types les plus utiliser **MyISAM** et **InnoDB** , car je veux que l'on voit le stockage sur le disque en plus de l'utilisation dans __MySQL__ . Les tables que nous allons créer seront aussi utilisé afin de voir la récupération de donnée lors de crash :).

Donc création des tables puis insertion de données :

        mysql> CREATE TABLE app_article ( id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY , texte TEXT NOT NULL, text_status ENUM('brouillon','evaluation','final') NOT NULL , info VARCHAR(20) ) ENGINE=MYISAM ;
        mysql> CREATE TABLE app_inno_article ( id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY , texte TEXT NOT NULL, text_status ENUM('brouillon','evaluation','final') NOT NULL , info VARCHAR(20) ) ENGINE=INNODB ;

Donc nous avons 2 tables complètement identique au niveau de la définition **SAUF** pour l'engin de stockage :
* __app\_article__ utilise **MyIsam**
* __app\_inno\_article__ utilise **InnoDB**

Je vais faire quelques ajout dans les tables toujours des données identique , pour des fin de données bidon je vais prendre chaque ligne du logs **dmegs** et faire l'ajout dans la tables. 

        # dmesg | tail 
        [  112.040722] device vethfc5261a entered promiscuous mode
        [  112.040819] IPv6: ADDRCONF(NETDEV_UP): vethfc5261a: link is not ready
        [  112.040822] br-9f2bdd9fbdd2: port 1(vethfc5261a) entered blocking state
        [  112.040824] br-9f2bdd9fbdd2: port 1(vethfc5261a) entered forwarding state
        [  112.042343] br-9f2bdd9fbdd2: port 1(vethfc5261a) entered disabled state
        # dmesg | wc -l
        809

Voici le petit script pas trop jolie :D , mais bon j'ai pas 4 heures à mettre ça beau :D.

        $ cat insert.sh
        #!/bin/bash
        #
        #############################

        # Variables
        USER_BD=bob
        USER_PASS=marley
        DB=ma_super_BD

        export IFS=$'\n'

        for line in $(dmesg) ; do
                TIMESTAMP=$(echo $line | cut -d ']' -f 1 | tr -d "[" | tr -s " " )
                TEXT=$(echo $line | cut -d ']' -f 2- | tr -s " ")
                STATUS=$(shuf -i 1-3 -n 1)

                # insertion dans mysql
                mysql -u $USER_BD --password=$USER_PASS $DB -e "insert into app_article (texte,text_status,info) values (\"$TEXT\",$STATUS,\"$TIMESTAMP\");"
                mysql -u $USER_BD --password=$USER_PASS $DB -e "insert into app_inno_article (texte,text_status,info) values (\"$TEXT\",$STATUS,\"$TIMESTAMP\");"

         done

Donc on lance l'insertion :

        $ ./insert.sh

Résultat :

        $ mysql -u bob -p
        mysql> select * from app_article;
        [ ... OUTPUT COUPÉ ... ]
        | 807 |  br-9f2bdd9fbdd2: port 1(vethfc5261a) entered forwarding state
        | brouillon   |  112.230810 |
        | 808 |  IPv6: ADDRCONF(NETDEV_CHANGE): br-9f2bdd9fbdd2: link becomes ready
        | final       |  112.230891 |
        +-----+----------------------------------------------------------------------
        808 rows in set (0.00 sec)

        mysql> select * from app_inno_article;
        | 804 |  IPv6: ADDRCONF(NETDEV_CHANGE): vethfc5261a: link becomes ready                                                                                                                                 | final       |  112.230731 |
        | 805 |  br-9f2bdd9fbdd2: port 1(vethfc5261a) entered blocking state                                                                                                                                    | evaluation  |  112.230807 |
        | 806 |  br-9f2bdd9fbdd2: port 1(vethfc5261a) entered forwarding state                                                                                                                                  | final       |  112.230810 |
        | 807 |  IPv6: ADDRCONF(NETDEV_CHANGE): br-9f2bdd9fbdd2: link becomes ready                                                                                                                             | final       |  112.230891 |
        +-----+----------------------------------------------------------------
        807 rows in set (0.00 sec)


Regardons le résultat sur le système de fichiers nous allons voir dans le répertoires **data** de mysql : **/var/lib/mysql/**.

        ls -l /var/lib/mysql/ma_super_BD/app_*
        -rw-rw---- 1 mysql mysql 62792 Oct 25 21:21 /var/lib/mysql/ma_super_BD/app_article.MYD
        -rw-rw---- 1 mysql mysql 10240 Oct 25 21:27 /var/lib/mysql/ma_super_BD/app_article.MYI
        -rw-rw---- 1 mysql mysql  8691 Oct 25 20:49 /var/lib/mysql/ma_super_BD/app_article.frm
        -rw-rw---- 1 mysql mysql  8691 Oct 25 20:50 /var/lib/mysql/ma_super_BD/app_inno_article.frm

Regardons les fichiers présente :

* **app\_article.frm** et **app\_inno\_article.frm** : Ce fichier contient la définition des tables vous pouvez constater que ce fichier est présent pour l'engin **MyISAM** et **innoDB**. Avec la commande **strings** vous pourrez extraire l'information de la tables , car le fichier est binaire :

        $ strings app_inno_article.frm
        PRIMARY
        InnoDB
        )
        texte
        text_status

* **app\_article.MYI** : Fichier contenant les index de la table **app\_article**
* **app\_article.MYD** : Le fichier contient les données de la tables **app\_article** , si nous utilisons **strings** sur le fichiers vous aurez les données.

        $ strings app_article.MYD
        [ ... OUTPUT COUPÉ ... ]
         br-9f2bdd9fbdd2: port 1(vethfc5261a) entered blocking state
         112.230807
         br-9f2bdd9fbdd2: port 1(vethfc5261a) entered forwarding state
         112.230810
         IPv6: ADDRCONF(NETDEV_CHANGE): br-9f2bdd9fbdd2: link becomes ready
         112.230891

Mais où sont les __Index__ et les données pour la tables __app\_inno\_article__ ? Dans le __cloud__ tous est dans le __cloud__ de nos jours ... Non c'est une farce , l'ensemble des données sont stocké dans le fichier : **ibdata1**
La particularité de **innoDB** est de stocké l'ensemble des données de l'engin dans un même fichier peut importe la table , mais un petit coup de **strings** nous montrera que je ne dis pas QUE des conneries :D.

        $ strings ibdata1  | tail
         eth0: renamed from veth2e94dd9
         112.207424
         IPv6: ADDRCONF(NETDEV_CHANGE): vethfc5261a: link becomes ready
         112.230731
         br-9f2bdd9fbdd2: port 1(vethfc5261a) entered blocking state
         112.230807
         br-9f2bdd9fbdd2: port 1(vethfc5261a) entered forwarding state
         112.230810
         IPv6: ADDRCONF(NETDEV_CHANGE): br-9f2bdd9fbdd2: link becomes ready
         112.230891


### <a name="engine_innodb" /> Système de stockage InnoDB

Comme **innoDB** est maintenant le système de stockage par défaut, je vais couvrir ce dernier uniquement. J'aurais bien voulu couvrir aussi **MyISAM**, mais j'ai plus envie de couvrir d'autre matière que le système de base de données (faut être honnête :D ). 

Telle que mentionné précédemment le système **innoDB** enregistre l'ensemble des données dans un ou plusieurs fichiers **ibdata** contenu dans le répertoire de donnée de __MySQL__. Comme nous allons le voir les informations sont stocké par défaut par __tablespace__ dans un gros fichier par défaut.

Bon il existe une méthode pour avoir un fichier par table l'option **innodb_file_per_table** vous permet d'avoir un fichier de donnée par table à ce moment vous aurez des fichiers par table avec l'extension __.ibd__.

Pour les personnes qui sont familier avec __Oracle__ vous allez apprécier :D , après tous __MySQL__ est propriété d'Oracle faut s'attendre à y voir des similitude. 

#### <a name="engine_innodb_tablespace" /> Tablespace d'InnoDB

**InnoDB** utilise le système d'espace de table , woww en Français ça sonne étrange , ou en anglais **TABLESPACE** , Un __tablespace__ est un espace de stockage dans lequel des données composant les bases de données peuvent être enregistrées. Il fournit une couche d'abstraction entre les données logiques et les données physiques, et sert d'espace d'allocation pour tous les segments pris en charge par le système de gestion de bases de données (un segment de base de données est un objet de base de données qui occupe un espace physique, comme les données d'une table ou d'un index). Une fois créé, le __tablespace__ peut être référencé par son nom lors de la création des segments de base de données.
Le __tablespace__ spécifie uniquement l'espace de stockage de la base de données, non la structure logique de celle-ci ou le modèle de données. 

La logique **d'innoDB** va comme suit, le système n'a pas envie d'écrire de chargé le fichier en mémoire mais préfère travaillé sur un espace contenant les tables et les index. Afin d'optimiser le traitement d'écriture au lieu d'ajouter des données dans le fichier de donnée il pré alloue une quantité pré définie de donnée et joue dedans pour l'insertion d'information.

Reprenons rapidement notre base de données __ma\_super\_BD__ au niveau du système de fichier :

        $ du -hs /var/lib/mysql/ibdata1
        18M     /var/lib/mysql/ibdata1
        $ du -hs /var/lib/mysql/ma_super_BD/
        204K    /var/lib/mysql/ma_super_BD/

18 __Megs__ pour les données dans le __tablespace__ d'**innodb** comparativement à 204k pour l'ensemble de la base de donnée de __ma\_super\_BD__ , vous me direz que oui mais l'ensemble des tables créer originalement sont des tables __innodb__ . Effectivement mais 18 __Megs__ tous de même c beaucoup , pour les données insérées.

Bon je voulais montré l'utilisation de [show variables](http://dev.mysql.com/doc/refman/5.5/en/show-variables.html) , mais j'en ai besoin maintenant :D.
Nous allons regarder la configuration assigné à **innoDB** pour cette opération je vous suggère d'être **root**, car je ne sais pas si un simple utilisateur peut tous voir.

Pour faire vite [show variables](http://dev.mysql.com/doc/refman/5.5/en/show-variables.html), permet de visualisé les configurations du serveur __MySQL__ que ces configurations soit définies par l'administrateur dans le fichier de configuration du serveur __MySQL__ ou celle par défaut (comme c'est le cas pour nous).

        $ mysql -u root -p
        mysql> show variables where Variable_name='innodb_data_file_path';
        +-----------------------+------------------------+
        | Variable_name         | Value                  |
        +-----------------------+------------------------+
        | innodb_data_file_path | ibdata1:10M:autoextend |
        +-----------------------+------------------------+
        1 row in set (0.00 sec)

L'instruction **innodb\_data\_file\_path** permet de définir le nom du fichier qui sera utilisé pour stocker les informations du __tablespace__ par défaut. Prenons l'exemple ici :

* **ibdata1:10M:autoextend** :
    * **ibdata1** : Le nom du fichier , nous l'avons déjà vu
    * **10M** : Définie la taille du __tablespace__ créer initialement 
    * **autoextend** : Que ce passe t'il quand les 10 __Megs__ sont remplie , dans le cas présent le système va automatiquement étendre le __tablespace__ pour permettre l'ajout de données.

Prenons une autre variable pour savoir de combien sera augmenté le __tablespace__ l'idée est d'ajouter une quantité significatif de donnée  dans le __tablespace__ pour ne pas être obligé d'étendre le __tablespace__ à chaque minutes ... 

        mysql> show variables where Variable_name='innodb_autoextend_increment';
        +-----------------------------+-------+
        | Variable_name               | Value |
        +-----------------------------+-------+
        | innodb_autoextend_increment | 8     |
        +-----------------------------+-------+

* **innodb_autoextend_increment** : ici nous avons la valeur 8 qui indique que 8 __Megs__ sera ajouté au __tablespace__ à chaque fois qu'il y aura extension de ce dernier...

__HO__! 10 + 8 == 18M , je pense que la valeur de 18M du fichier __ibdata__ est claire maintenant :D. 

#### <a name="engine_innodb_filesize" /> Taille des fichiers de données

Un problème avec cette ajustement de l'espace automatiquement incrémenté est dans l'optimisation de l'espace disque dur , regardons la taille du __tablespace__ en octet pour avoir une vision plus précise de l'espace utilisé.

        $ du -s /var/lib/mysql/ibdata1
        18432   /var/lib/mysql/ibdata1 

Regardons maintenant l'espace utilisé par l'engin __MyIsam__, je fais l'addition des données ET des indexs : 

        $ du -sc app_article.MYD app_article.MYI
        64      app_article.MYD
        12      app_article.MYI
        76      total


Donc nous avons bien les 18 __megs__  pour **innoDB** et 76K pour **MyISAM** .
Je vais ajouter des données dans la tables __innodb__ toujours avec le script d'insertion des données provenant de la commande __dmegs__

        $  ./insert.sh
        $ du -s /var/lib/mysql/ibdata1
        18432   /var/lib/mysql/ibdata1
        $ du -sc /var/lib/mysql/ma_super_BD/app_article.MYD /var/lib/mysql/ma_super_BD/app_article.MYI 
        124     /var/lib/mysql/ma_super_BD/app_article.MYD
        20      /var/lib/mysql/ma_super_BD/app_article.MYI
        144     total


Rien n'a changé pour le fichier **innoDB** car il ne va augmenté que lors que le __tablespace__ sera presque plein et allouera un bloque de 8M.
Réalisons de l'ajout de donnée , de manière plus significatif.

Je vais exécuter 10000 fois le scripts d'insertion  :

        $ for i in $(seq 1 10000) ; do ./insert.sh ;done

Comme ma base de données n'est utilisé QUE pour cette formation les données ajouter dans la base de données n'est QUE et UNIQUEMENT réalisé dans les 2 tables __app\_articles__ et __app\_inno\_article__


Bon finalement c'était un peu trop long 10000 , je l'ai arrêté :P , regardons l'espace disque utilisé :

         $ du -s /var/lib/mysql/ibdata1 
         26628   /var/lib/mysql/ibdata1
         $ du -hs /var/lib/mysql/ibdata1
         27M     /var/lib/mysql/ibdata1

         $ du -hsc /var/lib/mysql/ma_super_BD/app_article.MYD /var/lib/mysql/ma_super_BD/app_article.MYI    
         4.8M    /var/lib/mysql/ma_super_BD/app_article.MYD
         656K    /var/lib/mysql/ma_super_BD/app_article.MYI
         5.5M    total

Il y a augmentation du __tablespaces__ voyons dans la tables le nombre d'entré :

        mysql> select count(*) from app_inno_article;
        +----------+
        | count(*) |
        +----------+
        |    64569 |
        +----------+
        1 row in set (0.02 sec)

        mysql> select count(*) from app_article;     
        +----------+
        | count(*) |
        +----------+
        |    64570 |
        +----------+
        1 row in set (0.00 sec)

Parfait donc nous avons l'espace utilisé dans le __tablespace__ que ce passe t'il si nous supprimons la tables __app\_article__ , donc celle avec l'engin **MyISAM** ?

        $ du -sh /var/lib/mysql/ 
        49M     /var/lib/mysql/


        mysql> drop table app_article;
        Query OK, 0 rows affected (0.01 sec)

        $ du -hs /var/lib/mysql/
        43M     /var/lib/mysql/

        $ ls /var/lib/mysql/ma_super_BD/app_article*            
        ls: cannot access /var/lib/mysql/ma_super_BD/app_article*: No such file or directory

Donc nous voyons clairement que nous avons récupéré l'espace disque dur alloué à la table __app\_article__ !

Réalisons la même opération avec la table utilisant l'engin **InnoDB** soit __app\_inno\_article__ :

         $ du -hs /var/lib/mysql/                    
         43M     /var/lib/mysql/

         $ du -h /var/lib/mysql/ibdata1 
         27M     /var/lib/mysql/ibdata1

         mysql> drop table app_inno_article;
         Query OK, 0 rows affected (0.01 sec)

         $ du -hs /var/lib/mysql/                    
         43M     /var/lib/mysql/

         $ du -h /var/lib/mysql/ibdata1 
         27M     /var/lib/mysql/ibdata1

Aucune économie d'espace réalisé !! Peut-être faut redémarrer le service ... Allez pourquoi pas , si ça peut faire plaisir :D .

        $ sudo /etc/init.d/mysql restart

        $ du -sh /var/lib/mysql/    
        43M     /var/lib/mysql/
        $ du -h  /var/lib/mysql/ibdata1               
        27M     /var/lib/mysql/ibdata1

Et bien non ... L'espace alloué reste alloué peut importe la suppression réalisée par la suite , il n'y a pas de réduction du fichier de __tablespace__, en fait les bloques à l'intérieur sont identifiés comme disponible. Il y a donc plus d'espace disponible dans le __tablespace__ il n'aura pas besoin d'étendre le fichier la prochaine fois il comblera l'espace libéré par la table __app\_inno\_article__. 
Ceci est un détail cependant il est important de le comprendre, surtout si vous avez un ajout de donnée dans votre base de données. Exemple vous réalisez des testes de performance sur votre système , si vous vous dites que vous supprimerez uniquement les tables après le teste ceci ne libérera pas l'espace sur le disque !

Bon la solution maintenant, je présume que c'est ce que tout le monde attend. Il n'y en a pas, je peux parlé pour la version 5.5 et 5.7 pas de méthode intégré dans __MySQL__ pour récupéré l'espace sans **downtime**. __WTF__ vous vous dites , __yep__ moi aussi !!

La solution suggérer est de faire un backup complet de la base de données de supprimé les fichiers de  __tablespaces__ et de réimporter la BD.

Heu ... Heu ...

Bon __ok__  il y a une autre solution :) , mais faut y pensé lors de la configuration de votre serveur __MySQL__ , si vous activez la fonctionnalité **innodb_file_per_table**, __MySQL__ réalisera un fichier par table même si le format est **innoDB**. Résultat lors de la __suppression__ d'une table l'espace sera de nouveau disponible. Par défaut **AVANT** la version 5.7 cette option était à __OFF__ , avec la version 5.7 par défaut ceci est à **TRUE**. Vous pouvez voir la valeur sur votre système :


        mysql> show variables where Variable_name='innodb_file_per_table';                            
        +-----------------------+-------+
        | Variable_name         | Value |
        +-----------------------+-------+
        | innodb_file_per_table | OFF   |
        +-----------------------+-------+
        1 row in set (0.00 sec)

Bien que le système utilise un fichier **innoDB** par table le mécanisme reste le même , un fichier d'une taille X sera prédéfinie et il utilisera une valeur définie pour automatiquement agrandir le fichier. Donc si l'on supprimer uniquement des entrés dans la tables il n'y aura pas libération de l'espace disque dur au niveau du système d'exploitation. Pour réduire l'espace vous devrez utiliser l'instruction [OPTIMIZE TABLE](http://dev.mysql.com/doc/refman/5.7/en/optimize-table.html)

Vous pourrez trouver les avantages et inconvénients de cette configuration sur la page de __MySQL 5.7__ : [InnoDB par table](http://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-tablespaces.html)

Voyons rapidement quelques points :

* Pour 
    * Récupération de l'espace disque dur "direct" lors de la suppression des tables
    * Vous pouvez utilisez l'instruction [OPTIMIZE TABLE](http://dev.mysql.com/doc/refman/5.7/en/optimize-table.html) pour compacter un fichier de table. **innodb** dans la pratique va lui même refaire la création du fichier pour éliminer les bloques __libre__.
    * Il est possible de copier un simple table d'une base de données à l'autre lors que ces dernières sont éteintes.
    * La segmentation des fichiers permet d'avoir un impacte moins grand s'il y a corruption du disque dur.
    * Vous pouvez voir la taille des tables SANS communiquer avec __MySQL__ , donc uniquement avec le système d'exploitation.
* Contre
    * Comme nous l'avons dis précédemment comme l'ajout d'espace est fait par bloque ainsi que la création initial du fichier est possible si la taille initiale est trop grande qu'une grande quantité d'espace soit perdu.
    * L'opération de synchronisation entre la mémoire est les fichiers (**[fsync](https://linux.die.net/man/2/fsync)**) sera plus demandant sur le système, car cette fois ci __MySQL__ devra communiquer avec un plus grand nombre de fichiers pour la synchronisation comparativement à 1 originalement.
    * __MySQL__ devra avoir plusieurs fichier d'ouvert pour les opérations , si votre base de données contient beaucoup de tables il est possible que la valeur du nombre de fichier ouvert ne soit pas convenablement configurer.
    * Lors de la suppression d'un table le __Buffer Pool__ est scanné , cette opération peut être ralentie si le __Buffer pool__ a une taille de __10gig__


Comme toujours il n'y a pas de recette qui s'applique à tous le monde , personnellement je pense que si vous avez une base de données pour vos sites web (__cms__, __moodle__ , ...) avec une charge petite l'utilisation de **InnoDB\_par\_table** est une bonne idée . Si vous êtes une entreprise avec à haut volume de transaction , vous avez probablement un __DBA__ de disponible, parlez sans évalué , faite des __benchmark__ avec votre application et la Base de données c'est le meilleur moyen de planifier à court et moyen terme.

#### <a name="engine_innodb_fileformat" /> Format de fichier d'innoDB (clin d'œil)

Je ne pourrais malheureusement approfondir sur ce sujet, car avant de préparer la formation je ne savais pas qu'il y avait plusieurs format de fichier possible pour **innodb** :P. Donc au lieu de dire bêtise que j'aurais copié / collé d'Internet sans ajouter de valeur ajouter sur le sujet je vais simplement vous pointé l'existence des formats et vous laissez faire vos recherches. 

Il existe 2 type de format de fichier supporté par **InnoDB**:

* **Antelope** (format par défaut pour __MySQL__  avant 5.5) :  offre le supports **REDUNDANT** et **COMPACT** des enregistrements (ligne)
* **Barracuda** (format par défaut pour __MySQL__  après 5.5)  : offre le supports **COMPRESSED** pour la compression des données et **DYNAMIC** pour une meilleur gestion du stockage pour les entrés variables (__VARCHAR__, __TEXT__, ... ) des enregistrements (ligne)

Pour visualiser le format actuellement en cours d'utilisation :

        mysql> show variables where Variable_name='innodb_file_format';   
        +--------------------+----------+
        | Variable_name      | Value    |
        +--------------------+----------+
        | innodb_file_format | Antelope |
        +--------------------+----------+
        1 row in set (0.00 sec)

Et voilà j'en dirai pas plus :D, désolé 

* Référence :
    * [File Space Management](http://dev.mysql.com/doc/refman/5.5/en/innodb-file-space.html) 
    * [SHOW TABLES STATUS](http://dev.mysql.com/doc/refman/5.5/en/show-table-status.html)
    * [Configuration innodb](http://dev.mysql.com/doc/refman/5.5/en/innodb-init-startup-configuration.html#innodb-startup-data-file-configuration)
    * [InnoDB par table](http://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-tablespaces.html)
    * [InnoDB file_format](http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html#sysvar_innodb_file_format)



# <a name="crash_healt_recovery" /> Validation de la santé et prise en charge

Cette section est je pense important, est-ce que vous l'appliquerez **cash** je ne pense pas, cependant ceci vous offrira un base un point de référence si ceci arrive. Vous transpirerez peut-être un peu moins et / ou vous aurez l'air plus en contrôle devant les autres qui sont en panique totale :).


## <a name="check_status" /> Analyse de l'état de santé des tables

Avant de corriger les problèmes il faut être en mesure d'identifier s'il y a un problème :D donc commençons par la validation des tables.

Comme j'avais fait mention je vais utiliser les 2 tables __app\_article__ et __app\_inno\_article__ pour faire la démonstration avec les 2 systèmes de stockage **MyISAM** et **innoDB**. Bon quand j'avais dis ça j'avais pas prévu de supprimer les tables pour faire la démonstration de l'utilisation de l'espace :P.
Pas grave, on va les recréer :D.

        $ mysql -u bob -p 
        mysql> use ma_super_BD
        mysql> CREATE TABLE app_inno_article ( id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY , texte TEXT NOT NULL, text_status ENUM('brouillon','evaluation','final') NOT NULL , info VARCHAR(20) ) ENGINE=INNODB ;
        Query OK, 0 rows affected (0.00 sec)

        mysql> CREATE TABLE app_article ( id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY , texte TEXT NOT NULL, text_status ENUM('brouillon','evaluation','final') NOT NULL , info VARCHAR(20) ) ENGINE=MYISAM ;
        Query OK, 0 rows affected (0.01 sec)

Un petit coup de script d'insertion pour mettre un peu de contenu  :

        $ ./insert.sh

        mysql> select count(*) from app_article;
        +----------+
        | count(*) |
        +----------+
        |      803 |
        +----------+
        1 row in set (0.00 sec)

        mysql> select count(*) from app_inno_article;
        +----------+
        | count(*) |
        +----------+
        |      803 |
        +----------+
        1 row in set (0.00 sec)

Validons l'état des tables maintenant, à l'aide de l'instruction [check table](http://dev.mysql.com/doc/refman/5.5/en/check-table.html#check-table-innodb) :


        mysql> check table app_article;
        +-------------------------+-------+----------+----------+
        | Table                   | Op    | Msg_type | Msg_text |
        +-------------------------+-------+----------+----------+
        | ma_super_BD.app_article | check | status   | OK       |
        +-------------------------+-------+----------+----------+
        1 row in set (0.00 sec)

        mysql> check table app_inno_article;
        +------------------------------+-------+----------+----------+
        | Table                        | Op    | Msg_type | Msg_text |
        +------------------------------+-------+----------+----------+
        | ma_super_BD.app_inno_article | check | status   | OK       |
        +------------------------------+-------+----------+----------+
        1 row in set (0.01 sec)

L'instruction [check table](http://dev.mysql.com/doc/refman/5.5/en/check-table.html#check-table-innodb) fonctionne aussi bien pour **MyISAM** et **innoDB**.
Ceci ne validera **QUE** l'état générale de la table si cette dernier à un problème d'index ou de clé , le problème ne sera pas remonté ! Vous devez utiliser une autre instruction [CHECK ANALYZE](http://dev.mysql.com/doc/refman/5.5/en/analyze-table.html):

        mysql> analyze table app_article;     
        +-------------------------+---------+----------+-----------------------------+
        | Table                   | Op      | Msg_type | Msg_text                    |
        +-------------------------+---------+----------+-----------------------------+
        | ma_super_BD.app_article | analyze | status   | Table is already up to date |
        +-------------------------+---------+----------+-----------------------------+
        1 row in set (0.00 sec)

        mysql> analyze table app_inno_article;
        +------------------------------+---------+----------+----------+
        | Table                        | Op      | Msg_type | Msg_text |
        +------------------------------+---------+----------+----------+
        | ma_super_BD.app_inno_article | analyze | status   | OK       |
        +------------------------------+---------+----------+----------+
        1 row in set (0.00 sec)

La différence est que [CHECK ANALYZE](http://dev.mysql.com/doc/refman/5.5/en/analyze-table.html) valide les index et les clé 

Moins pertinent selon dans le sujet de la validation de la santé des tables mais pertinent pour valider s'il y a modification d'un table il existe l'instruction [CHECKSUM TABLE](http://dev.mysql.com/doc/refman/5.5/en/innochecksum.html), qui permet d'avoir un __checksum__ d'un table :

        mysql> CHECKSUM TABLE app_article;
        +-------------------------+------------+
        | Table                   | Checksum   |
        +-------------------------+------------+
        | ma_super_BD.app_article | 3408470473 |
        +-------------------------+------------+
        1 row in set (0.01 sec)

        mysql> CHECKSUM TABLE app_inno_article;
        +------------------------------+------------+
        | Table                        | Checksum   |
        +------------------------------+------------+
        | ma_super_BD.app_inno_article | 3408470473 |
        +------------------------------+------------+
        1 row in set (0.00 sec)


Comme nous avons exactement la même quantité et même donnée dans les 2 table nous pouvons constater que le résultat est identique :D, c'est bien fait tous de même :D.

Référence :

* [check table](http://dev.mysql.com/doc/refman/5.5/en/check-table.html#check-table-innodb)
* [CHECK ANALYZE](http://dev.mysql.com/doc/refman/5.5/en/analyze-table.html)
* [CHECKSUM TABLE](http://dev.mysql.com/doc/refman/5.5/en/innochecksum.html)

http://dev.mysql.com/doc/refman/5.5/en/myisam-table-maintenance.html
http://dev.mysql.com/doc/refman/5.5/en/innodb-statistics-estimation.html
https://twindb.com/repair-corrupted-innodb-table-with-corruption-in-secondary-index/

SHOW ENGINE INNODB STATUS\G

## <a name="view_vars_change_it"/> Visualisation et modification des variables

* max_connexion ...

# <a name="perms_mysql_tables" /> Manipulation des permissions avec mysql sans le grant

Bon voyons à l'étape **brutale** :D , car bon c'est ça qui est cool avec le libre, il y a la bonne méthode jolie avec les commandes :) , puis y a la méthode ou tu modifies le fichier en arrière puis ça marche :D. Je ne vous dis pas d'utiliser cette méthode !!! Mon objectif avec la démonstration est de démontré comment __Mysql__ stock l'information des permissions , le savoir est bien !

Telle mentionné, le système __MySQL__ à besoin de la base de données __mysql__ pour fonctionné afin de conserver les informations du système dont les permissions utilisateur. Nous allons créer une nouvelle base de donnée et refaire la même opération de création d'utilisateur mais sans **create user** et **sans les grant** . 
Pour les personnes qui disent **POURQUOI ?** vous pouvez passer au prochaine chapitre, car **la question n'est pas pourquoi mais COMMENT ?** .

Allez on crée la base de donnée : **zer\_bd**

        mysql> create database ze_bd ;
            Query OK, 1 row affected (0.00 sec)

        mysql> show databases;
        +--------------------+
        | Database           |
        +--------------------+
        | information_schema |
        | ma_super_BD        |
        | mysql              |
        | performance_schema |
        | ze_bd              |
        +--------------------+
        5 rows in set (0.00 sec)

Nous sommes avec l'utilisateur **root** nous allons basculer sous la base de donnée __mysql__

        mysql> use mysql;
        Database changed


# <a name="reference" /> Références

* Stockage des informations
    * [Caractéristique stockage](http://dev.mysql.com/doc/refman/5.5/en/pluggable-storage-common-layer.html)
    * [Module de stockage](http://dev.mysql.com/doc/refman/5.5/en/pluggable-storage-overview.html)
    * [Storage engines](http://dev.mysql.com/doc/refman/5.5/en/storage-engines.html)
    * Type de stocakge :
        * [Innodb storage](dev.mysql.com/doc/refman/5.5/en/innodb-storage-engine.html)
        * [MyISAM storage](http://dev.mysql.com/doc/refman/5.5/en/myisam-storage-engine.html)
        * [Memory storage](http://dev.mysql.com/doc/refman/5.5/en/memory-storage-engine.html)
        * [Federated storage](http://dev.mysql.com/doc/refman/5.5/en/federated-storage-engine.html)
        * [csv storage](http://dev.mysql.com/doc/refman/5.5/en/csv-storage-engine.html)
        * [Blackhole storage](http://dev.mysql.com/doc/refman/5.5/en/blackhole-storage-engine.html)
    * InnoDB
        * [File Space Management](http://dev.mysql.com/doc/refman/5.5/en/innodb-file-space.html) 
        * [SHOW TABLES STATUS](http://dev.mysql.com/doc/refman/5.5/en/show-table-status.html)
        * [Configuration innodb](http://dev.mysql.com/doc/refman/5.5/en/innodb-init-startup-configuration.html#innodb-startup-data-file-configuration)
        * [InnoDB par table](http://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-tablespaces.html)
        * [InnoDB file_format](http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html#sysvar_innodb_file_format)

# <a name="configue" /> Configuration de mysql (mysql.cnf +  ~/.my.cnf)

# <a name="performance" /> Configuration de performance

* définition du data sur un autre HD
* voir option de configue pour innoDB p-e myISAM (share mémory , ... )

http://dev.mysql.com/doc/refman/5.5/en/innodb-best-practices.html

# <a name="crash_recovery" /> Système de recupération et validation de la santé des tables

# <a name="mysql_replication" /> Mise en place d'une replication Mysql
# <a name="mysql_backup" /> Réalisation d'un backup de(s) base(s) de données

 
