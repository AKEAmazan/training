<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 

# <a name="storage_engine" /> Stockage des informations

__MySQL__ a un système de stockage des informations modulaire (__pluggable__) , ceci permet d'utiliser le système adéquat selon vos besoins. Dans les faits ceci est principalement lors de l'optimisation que l'on modifie le système de stockage. Le gros avantage est que le système de stockage est complètement transparent pour les applications ! Ceci permet aussi d'accroitre les possibilités de __MySQL__.

Voici une liste non exhaustive des raisons de choisir un type de stockage particulier :

* **Concurrence** : Certain système de stockage offre un système de verrou (__LOCK__) plus granulaire (par exemple : uniquement verrou par enregistrement / ligne) . Choisir le bon système de stockage peut permettre de réduire le temps de traitement (__overhead__) requis pour le verrou, améliorant la performance générale.
* **Support des Transactions** : Support des transactions ( couvert dans le chapitre précédent __COMMIT__ et __ROLLBACK__ ) bien que toutes les applications n'en n'ont pas besoin ceci peut être pratique. 
* **Intégrité** : Selon le système de stockage que vous utilisez vous pouvez avoir ou non le système référentiel fort avec les clés étrangère , bien entendu cette ajout ayant un coût si vous désirez réduire la charge sur le serveur de BD opté pour un système sans référentiel fort vous aurez un gain de performance.
* **Stockage physique** : Les modules choisie vous permet d'avoir un système de stockage approprié pour vos besoin ( __csv__, mémoire, ...)
* **Indexation** : Les systèmes de stockage offre une indexation propre, optimisé selon la situation. Vous retrouverez l'indexation __B-tree__ pour l'ensemble des systèmes de stockage.
* **Cache mémoire** : L'ensemble des systèmes de stockage offre une fonctionnalité minimal de mise en mémoire des requêtes, mais certain système offre une optimisation pour ce besoin. (exemple __MySQL's high-speed Query Cache__)
* **Assistant de performance** : De manière général , l'engin peut être optimal pour la lecture ou l'écriture , offrir des utilitaires d'analyse de performance ...
* **Fonctionnalité particulière** : Le système de stockage peut offrir des fonctionnalités particulière telle que le support des données __GéoSpacial__, ou une gestion plus granulaire des accès de sécurité.

* Référence 
    * [Caractéristique stockage](http://dev.mysql.com/doc/refman/5.5/en/pluggable-storage-common-layer.html)
    * [Module de stockage](http://dev.mysql.com/doc/refman/5.5/en/pluggable-storage-overview.html)

## <a name="engine_available" /> Engins disponible

Documentation __MySQL__ de référence : [Storage engines](http://dev.mysql.com/doc/refman/5.5/en/storage-engines.html)

Premièrement voyons ce qui est disponible sur notre environnements, vous n'avez pas besoin d'être l'administrateur pour visualiser les engins disponibles 

        $ mysql -u bob -p
        Enter password:
        mysql> SHOW ENGINES ;
        +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
        | Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
        +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
        | PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
        | MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
        | CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
        | BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
        | MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
        | InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
        | ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
        | MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
        | FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
        +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
        9 rows in set (0.00 sec)

Nous pouvons donc voir l'ensemble des engins offert sur notre base de données prenons quelque minutes pour identifier les options disponibles :

* **InnoDB** __défaut__ : Depuis la version 5.5.5 **InnoDB** est le système de stockage par défaut originalement c'était **MyISAM** qui était privilégié. __InnoDB__ support le système de transaction (__commit__, __rollback__, ...) , il a aussi la fonctionnalité de __crash-recovery__ afin de protéger les données en cas de problème du système. **InnoDB** a la caractéristique de réalisé des verrous par enregistrement et non sur l'ensemble de la table , les données sont stocké dans un index de type __cluster__ afin de réduire __l'I/O__ (accès disque) pour les requêtes courantes particulièrement sur les clés primaires. Plus d'information disponible sur la documentation de __MySQL__ [Innodb storage](dev.mysql.com/doc/refman/5.5/en/innodb-storage-engine.html)
* **MyISAM** : Avant la version 5.5.5 c'était le système de stockage par défaut, ce système de stockage n'offre pas la possibilité d'utiliser le système de transaction. Il n'offre pas non plus la possibilité d'utiliser les clés étrangère pour l'intégrité des données. Le système de verrou est sur l'ensemble de la table et non pour l'enregistrement, bon à ce point vous vous dites mais pourquoi j'utiliserai ce système il fait moins de chose **qu'innoDB**. **MyISAM** support un plus grand nombre de données que **InnoDB** 256TB pour être exacte :D. Il support la cherche indexé dans l'ensemble des champs teste , non disponible dans **innoDB** avant la version 5.6.4. L'absence de mécanisme de validation en a fait un système plus performant pour les accès en **Lecture** et fut très populaire pour l'indexation des champs **TEXT** principalement pour les applications web . Documentation sur __MySQL__ [MyISAM storage](http://dev.mysql.com/doc/refman/5.5/en/myisam-storage-engine.html)
* **Memory** : Permet d'utiliser la **RAM** du système pour stocké les informations, bien entendu ce mécanisme est très très performant, cependant les informations sont éphémère. Il n'y a aucun mécanisme en cas de crash du système, le système ressemble à **MyISAM** pas de clé étrangère, pas de transaction , ... Documentation sur __MySQL__ [Memory storage](http://dev.mysql.com/doc/refman/5.5/en/memory-storage-engine.html).
* **Archive** : Comme son nom l'indique ce type de stockage est utilisé pour l'archivage de donnée, la particularité est d'offrir la possibilité de stockage SANS limite. Bien entendu il ne faut pas s'attendre à avoir de la performance pour ce type de stockage , il n'y a pas d'indexation des données ceci à donc un gros impact sur la performance. Il y a tout de même une mise en cache des requêtes. Documentation sur __MySQL__ [Archive storage](http://dev.mysql.com/doc/refman/5.5/en/archive-storage-engine.html).
* **Federated** : Vous avez la possibilité de créer un serveur __MySQL__ logique qui regroupe un grand nombre de serveur __MySQL__. Quand nous utilisons les système de stockage classique (__MyISAM__, __InnoDB__, ...) la définition de la table ET les données sont sur la même machine, avec le mode **fédéré** les donnés sont sur un serveur distant .Documentation __MySQL__ [Federated storage](http://dev.mysql.com/doc/refman/5.5/en/federated-storage-engine.html)
    ![se-federated-structure.png](./imgs/se-federated-structure.png)
* **CSV** : __Comma Separated Values__ soit Valeur Séparés par des Virgules , ceci permet d'avoir un fichier avec une virgule qui sépare les champs. La performance est très limité cependant ceci peut être pratique pour extraire de l'information de la base de données. Documentation __MySQL__ [csv storage](http://dev.mysql.com/doc/refman/5.5/en/csv-storage-engine.html)
* **BlackHole** : Alors celui la j'essaye encore de voir l'utilité , la documentation parle d'utilité lors de la réplication pour ne pas répliquer certain données, mais bon personnellement j'exclus les tables que je ne veux pas ... Bon j'oublie de donner l'explication, normale **blackhole** c'est le trou noir. Le système vous permet de créer un table d'insérer des donnes mais tous est envoyé à la poubelle. Donc lors d'un **SELECT** le système ne renvoie AUCUNE information. Je trouve ça bien même si je ne vois pas l'utilité :D . Documentation __MySQL__  [Blackhole storage](http://dev.mysql.com/doc/refman/5.5/en/blackhole-storage-engine.html)

Voici un résumé des fonctionnalités et du supports selon l'engin :

![summary_storage_engine.png](./imgs/summary_storage_engine.png)


## <a name="engine_use" /> Utilisation des systèmes de stockage

Pour une même base de données plusieurs engins peuvent être utilisé, selon vos besoins , voici un petit exemple d'utilisation :

Vous avez un site de jeu , l'ensemble des informations utilisateurs ( nom, mot de passe, contact , ... ) sont stocké dans une base de données de type **InnoDB** ou **MyISAM** , quand les utilisateurs débutes une partie (éphémère) et jugé non-critique :P vous pourriez créer une table : partie\_2764 (partie\_#de-la-partie) cette table serait définie avec l'engin **Memory** pour être optimisé au maximum en cas de crash ce n'est pas critique. 

Voyons un peu l'utilisation des **engin** je vais me concentrer sur les 2 types les plus utiliser **MyISAM** et **InnoDB** , car je veux que l'on voit le stockage sur le disque en plus de l'utilisation dans __MySQL__ . Les tables que nous allons créer seront aussi utilisé afin de voir la récupération de donnée lors de crash :).

Donc création des tables puis insertion de données :

        mysql> CREATE TABLE app_article ( id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY , texte TEXT NOT NULL, text_status ENUM('brouillon','evaluation','final') NOT NULL , info VARCHAR(20) ) ENGINE=MYISAM ;
        mysql> CREATE TABLE app_inno_article ( id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY , texte TEXT NOT NULL, text_status ENUM('brouillon','evaluation','final') NOT NULL , info VARCHAR(20) ) ENGINE=INNODB ;

Donc nous avons 2 tables complètement identique au niveau de la définition **SAUF** pour l'engin de stockage :
* __app\_article__ utilise **MyIsam**
* __app\_inno\_article__ utilise **InnoDB**

Je vais faire quelques ajout dans les tables toujours des données identique , pour des fin de données bidon je vais prendre chaque ligne du logs **dmegs** et faire l'ajout dans la tables. 

        # dmesg | tail 
        [  112.040722] device vethfc5261a entered promiscuous mode
        [  112.040819] IPv6: ADDRCONF(NETDEV_UP): vethfc5261a: link is not ready
        [  112.040822] br-9f2bdd9fbdd2: port 1(vethfc5261a) entered blocking state
        [  112.040824] br-9f2bdd9fbdd2: port 1(vethfc5261a) entered forwarding state
        [  112.042343] br-9f2bdd9fbdd2: port 1(vethfc5261a) entered disabled state
        # dmesg | wc -l
        809

Voici le petit script pas trop jolie :D , mais bon j'ai pas 4 heures à mettre ça beau :D.

        $ cat insert.sh
        #!/bin/bash
        #
        #############################

        # Variables
        USER_BD=bob
        USER_PASS=marley
        DB=ma_super_BD

        export IFS=$'\n'

        for line in $(dmesg) ; do
                TIMESTAMP=$(echo $line | cut -d ']' -f 1 | tr -d "[" | tr -s " " )
                TEXT=$(echo $line | cut -d ']' -f 2- | tr -s " ")
                STATUS=$(shuf -i 1-3 -n 1)

                # insertion dans mysql
                mysql -u $USER_BD --password=$USER_PASS $DB -e "insert into app_article (texte,text_status,info) values (\"$TEXT\",$STATUS,\"$TIMESTAMP\");"
                mysql -u $USER_BD --password=$USER_PASS $DB -e "insert into app_inno_article (texte,text_status,info) values (\"$TEXT\",$STATUS,\"$TIMESTAMP\");"

         done

Donc on lance l'insertion :

        $ ./insert.sh

Résultat :

        $ mysql -u bob -p
        mysql> select * from app_article;
        [ ... OUTPUT COUPÉ ... ]
        | 807 |  br-9f2bdd9fbdd2: port 1(vethfc5261a) entered forwarding state
        | brouillon   |  112.230810 |
        | 808 |  IPv6: ADDRCONF(NETDEV_CHANGE): br-9f2bdd9fbdd2: link becomes ready
        | final       |  112.230891 |
        +-----+----------------------------------------------------------------------
        808 rows in set (0.00 sec)

        mysql> select * from app_inno_article;
        | 804 |  IPv6: ADDRCONF(NETDEV_CHANGE): vethfc5261a: link becomes ready                                                                                                                                 | final       |  112.230731 |
        | 805 |  br-9f2bdd9fbdd2: port 1(vethfc5261a) entered blocking state                                                                                                                                    | evaluation  |  112.230807 |
        | 806 |  br-9f2bdd9fbdd2: port 1(vethfc5261a) entered forwarding state                                                                                                                                  | final       |  112.230810 |
        | 807 |  IPv6: ADDRCONF(NETDEV_CHANGE): br-9f2bdd9fbdd2: link becomes ready                                                                                                                             | final       |  112.230891 |
        +-----+----------------------------------------------------------------
        807 rows in set (0.00 sec)


Regardons le résultat sur le système de fichiers nous allons voir dans le répertoires **data** de mysql : **/var/lib/mysql/**.

        ls -l /var/lib/mysql/ma_super_BD/app_*
        -rw-rw---- 1 mysql mysql 62792 Oct 25 21:21 /var/lib/mysql/ma_super_BD/app_article.MYD
        -rw-rw---- 1 mysql mysql 10240 Oct 25 21:27 /var/lib/mysql/ma_super_BD/app_article.MYI
        -rw-rw---- 1 mysql mysql  8691 Oct 25 20:49 /var/lib/mysql/ma_super_BD/app_article.frm
        -rw-rw---- 1 mysql mysql  8691 Oct 25 20:50 /var/lib/mysql/ma_super_BD/app_inno_article.frm

Regardons les fichiers présente :

* **app\_article.frm** et **app\_inno\_article.frm** : Ce fichier contient la définition des tables vous pouvez constater que ce fichier est présent pour l'engin **MyISAM** et **innoDB**. Avec la commande **strings** vous pourrez extraire l'information de la tables , car le fichier est binaire :

        $ strings app_inno_article.frm
        PRIMARY
        InnoDB
        )
        texte
        text_status

* **app\_article.MYI** : Fichier contenant les index de la table **app\_article**
* **app\_article.MYD** : Le fichier contient les données de la tables **app\_article** , si nous utilisons **strings** sur le fichiers vous aurez les données.

        $ strings app_article.MYD
        [ ... OUTPUT COUPÉ ... ]
         br-9f2bdd9fbdd2: port 1(vethfc5261a) entered blocking state
         112.230807
         br-9f2bdd9fbdd2: port 1(vethfc5261a) entered forwarding state
         112.230810
         IPv6: ADDRCONF(NETDEV_CHANGE): br-9f2bdd9fbdd2: link becomes ready
         112.230891

Mais où sont les __Index__ et les données pour la tables __app\_inno\_article__ ? Dans le __cloud__ tous est dans le __cloud__ de nos jours ... Non c'est une farce , l'ensemble des données sont stocké dans le fichier : **ibdata1**
La particularité de **innoDB** est de stocké l'ensemble des données de l'engin dans un même fichier peut importe la table , mais un petit coup de **strings** nous montrera que je ne dis pas QUE des conneries :D.

        $ strings ibdata1  | tail
         eth0: renamed from veth2e94dd9
         112.207424
         IPv6: ADDRCONF(NETDEV_CHANGE): vethfc5261a: link becomes ready
         112.230731
         br-9f2bdd9fbdd2: port 1(vethfc5261a) entered blocking state
         112.230807
         br-9f2bdd9fbdd2: port 1(vethfc5261a) entered forwarding state
         112.230810
         IPv6: ADDRCONF(NETDEV_CHANGE): br-9f2bdd9fbdd2: link becomes ready
         112.230891


### <a name="engine_innodb" /> Système de stockage InnoDB

Comme **innoDB** est maintenant le système de stockage par défaut, je vais couvrir ce dernier uniquement. J'aurais bien voulu couvrir aussi **MyISAM**, mais j'ai plus envie de couvrir d'autre matière que le système de base de données (faut être honnête :D ). 

Telle que mentionné précédemment le système **innoDB** enregistre l'ensemble des données dans un ou plusieurs fichiers **ibdata** contenu dans le répertoire de donnée de __MySQL__. Comme nous allons le voir les informations sont stocké par défaut par __tablespace__ dans un gros fichier par défaut.

Bon il existe une méthode pour avoir un fichier par table l'option **innodb_file_per_table** vous permet d'avoir un fichier de donnée par table à ce moment vous aurez des fichiers par table avec l'extension __.ibd__.

Pour les personnes qui sont familier avec __Oracle__ vous allez apprécier :D , après tous __MySQL__ est propriété d'Oracle faut s'attendre à y voir des similitude. 

#### <a name="engine_innodb_tablespace" /> Tablespace d'InnoDB

**InnoDB** utilise le système d'espace de table , woww en Français ça sonne étrange , ou en anglais **TABLESPACE** , Un __tablespace__ est un espace de stockage dans lequel des données composant les bases de données peuvent être enregistrées. Il fournit une couche d'abstraction entre les données logiques et les données physiques, et sert d'espace d'allocation pour tous les segments pris en charge par le système de gestion de bases de données (un segment de base de données est un objet de base de données qui occupe un espace physique, comme les données d'une table ou d'un index). Une fois créé, le __tablespace__ peut être référencé par son nom lors de la création des segments de base de données.
Le __tablespace__ spécifie uniquement l'espace de stockage de la base de données, non la structure logique de celle-ci ou le modèle de données. 

La logique **d'innoDB** va comme suit, le système n'a pas envie d'écrire de chargé le fichier en mémoire mais préfère travaillé sur un espace contenant les tables et les index. Afin d'optimiser le traitement d'écriture au lieu d'ajouter des données dans le fichier de donnée il pré alloue une quantité pré définie de donnée et joue dedans pour l'insertion d'information.

Reprenons rapidement notre base de données __ma\_super\_BD__ au niveau du système de fichier :

        $ du -hs /var/lib/mysql/ibdata1
        18M     /var/lib/mysql/ibdata1
        $ du -hs /var/lib/mysql/ma_super_BD/
        204K    /var/lib/mysql/ma_super_BD/

18 __Megs__ pour les données dans le __tablespace__ d'**innodb** comparativement à 204k pour l'ensemble de la base de donnée de __ma\_super\_BD__ , vous me direz que oui mais l'ensemble des tables créer originalement sont des tables __innodb__ . Effectivement mais 18 __Megs__ tous de même c beaucoup , pour les données insérées.

Bon je voulais montré l'utilisation de [show variables](http://dev.mysql.com/doc/refman/5.5/en/show-variables.html) , mais j'en ai besoin maintenant :D.
Nous allons regarder la configuration assigné à **innoDB** pour cette opération je vous suggère d'être **root**, car je ne sais pas si un simple utilisateur peut tous voir.

Pour faire vite [show variables](http://dev.mysql.com/doc/refman/5.5/en/show-variables.html), permet de visualisé les configurations du serveur __MySQL__ que ces configurations soit définies par l'administrateur dans le fichier de configuration du serveur __MySQL__ ou celle par défaut (comme c'est le cas pour nous).

        $ mysql -u root -p
        mysql> show variables where Variable_name='innodb_data_file_path';
        +-----------------------+------------------------+
        | Variable_name         | Value                  |
        +-----------------------+------------------------+
        | innodb_data_file_path | ibdata1:10M:autoextend |
        +-----------------------+------------------------+
        1 row in set (0.00 sec)

L'instruction **innodb\_data\_file\_path** permet de définir le nom du fichier qui sera utilisé pour stocker les informations du __tablespace__ par défaut. Prenons l'exemple ici :

* **ibdata1:10M:autoextend** :
    * **ibdata1** : Le nom du fichier , nous l'avons déjà vu
    * **10M** : Définie la taille du __tablespace__ créer initialement 
    * **autoextend** : Que ce passe t'il quand les 10 __Megs__ sont remplie , dans le cas présent le système va automatiquement étendre le __tablespace__ pour permettre l'ajout de données.

Prenons une autre variable pour savoir de combien sera augmenté le __tablespace__ l'idée est d'ajouter une quantité significatif de donnée  dans le __tablespace__ pour ne pas être obligé d'étendre le __tablespace__ à chaque minutes ... 

        mysql> show variables where Variable_name='innodb_autoextend_increment';
        +-----------------------------+-------+
        | Variable_name               | Value |
        +-----------------------------+-------+
        | innodb_autoextend_increment | 8     |
        +-----------------------------+-------+

* **innodb_autoextend_increment** : ici nous avons la valeur 8 qui indique que 8 __Megs__ sera ajouté au __tablespace__ à chaque fois qu'il y aura extension de ce dernier...

__HO__! 10 + 8 == 18M , je pense que la valeur de 18M du fichier __ibdata__ est claire maintenant :D. 

#### <a name="engine_innodb_filesize" /> Taille des fichiers de données

Un problème avec cette ajustement de l'espace automatiquement incrémenté est dans l'optimisation de l'espace disque dur , regardons la taille du __tablespace__ en octet pour avoir une vision plus précise de l'espace utilisé.

        $ du -s /var/lib/mysql/ibdata1
        18432   /var/lib/mysql/ibdata1 

Regardons maintenant l'espace utilisé par l'engin __MyIsam__, je fais l'addition des données ET des indexs : 

        $ du -sc app_article.MYD app_article.MYI
        64      app_article.MYD
        12      app_article.MYI
        76      total


Donc nous avons bien les 18 __megs__  pour **innoDB** et 76K pour **MyISAM** .
Je vais ajouter des données dans la tables __innodb__ toujours avec le script d'insertion des données provenant de la commande __dmegs__

        $  ./insert.sh
        $ du -s /var/lib/mysql/ibdata1
        18432   /var/lib/mysql/ibdata1
        $ du -sc /var/lib/mysql/ma_super_BD/app_article.MYD /var/lib/mysql/ma_super_BD/app_article.MYI 
        124     /var/lib/mysql/ma_super_BD/app_article.MYD
        20      /var/lib/mysql/ma_super_BD/app_article.MYI
        144     total


Rien n'a changé pour le fichier **innoDB** car il ne va augmenté que lors que le __tablespace__ sera presque plein et allouera un bloque de 8M.
Réalisons de l'ajout de donnée , de manière plus significatif.

Je vais exécuter 10000 fois le scripts d'insertion  :

        $ for i in $(seq 1 10000) ; do ./insert.sh ;done

Comme ma base de données n'est utilisé QUE pour cette formation les données ajouter dans la base de données n'est QUE et UNIQUEMENT réalisé dans les 2 tables __app\_articles__ et __app\_inno\_article__


Bon finalement c'était un peu trop long 10000 , je l'ai arrêté :P , regardons l'espace disque utilisé :

         $ du -s /var/lib/mysql/ibdata1 
         26628   /var/lib/mysql/ibdata1
         $ du -hs /var/lib/mysql/ibdata1
         27M     /var/lib/mysql/ibdata1

         $ du -hsc /var/lib/mysql/ma_super_BD/app_article.MYD /var/lib/mysql/ma_super_BD/app_article.MYI    
         4.8M    /var/lib/mysql/ma_super_BD/app_article.MYD
         656K    /var/lib/mysql/ma_super_BD/app_article.MYI
         5.5M    total

Il y a augmentation du __tablespaces__ voyons dans la tables le nombre d'entré :

        mysql> select count(*) from app_inno_article;
        +----------+
        | count(*) |
        +----------+
        |    64569 |
        +----------+
        1 row in set (0.02 sec)

        mysql> select count(*) from app_article;     
        +----------+
        | count(*) |
        +----------+
        |    64570 |
        +----------+
        1 row in set (0.00 sec)

Parfait donc nous avons l'espace utilisé dans le __tablespace__ que ce passe t'il si nous supprimons la tables __app\_article__ , donc celle avec l'engin **MyISAM** ?

        $ du -sh /var/lib/mysql/ 
        49M     /var/lib/mysql/


        mysql> drop table app_article;
        Query OK, 0 rows affected (0.01 sec)

        $ du -hs /var/lib/mysql/
        43M     /var/lib/mysql/

        $ ls /var/lib/mysql/ma_super_BD/app_article*            
        ls: cannot access /var/lib/mysql/ma_super_BD/app_article*: No such file or directory

Donc nous voyons clairement que nous avons récupéré l'espace disque dur alloué à la table __app\_article__ !

Réalisons la même opération avec la table utilisant l'engin **InnoDB** soit __app\_inno\_article__ :

         $ du -hs /var/lib/mysql/                    
         43M     /var/lib/mysql/

         $ du -h /var/lib/mysql/ibdata1 
         27M     /var/lib/mysql/ibdata1

         mysql> drop table app_inno_article;
         Query OK, 0 rows affected (0.01 sec)

         $ du -hs /var/lib/mysql/                    
         43M     /var/lib/mysql/

         $ du -h /var/lib/mysql/ibdata1 
         27M     /var/lib/mysql/ibdata1

Aucune économie d'espace réalisé !! Peut-être faut redémarrer le service ... Allez pourquoi pas , si ça peut faire plaisir :D .

        $ sudo /etc/init.d/mysql restart

        $ du -sh /var/lib/mysql/    
        43M     /var/lib/mysql/
        $ du -h  /var/lib/mysql/ibdata1               
        27M     /var/lib/mysql/ibdata1

Et bien non ... L'espace alloué reste alloué peut importe la suppression réalisée par la suite , il n'y a pas de réduction du fichier de __tablespace__, en fait les bloques à l'intérieur sont identifiés comme disponible. Il y a donc plus d'espace disponible dans le __tablespace__ il n'aura pas besoin d'étendre le fichier la prochaine fois il comblera l'espace libéré par la table __app\_inno\_article__. 
Ceci est un détail cependant il est important de le comprendre, surtout si vous avez un ajout de donnée dans votre base de données. Exemple vous réalisez des testes de performance sur votre système , si vous vous dites que vous supprimerez uniquement les tables après le teste ceci ne libérera pas l'espace sur le disque !

Bon la solution maintenant, je présume que c'est ce que tout le monde attend. Il n'y en a pas, je peux parlé pour la version 5.5 et 5.7 pas de méthode intégré dans __MySQL__ pour récupéré l'espace sans **downtime**. __WTF__ vous vous dites , __yep__ moi aussi !!

La solution suggérer est de faire un backup complet de la base de données de supprimé les fichiers de  __tablespaces__ et de réimporter la BD.

Heu ... Heu ...

Bon __ok__  il y a une autre solution :) , mais faut y pensé lors de la configuration de votre serveur __MySQL__ , si vous activez la fonctionnalité **innodb_file_per_table**, __MySQL__ réalisera un fichier par table même si le format est **innoDB**. Résultat lors de la __suppression__ d'une table l'espace sera de nouveau disponible. Par défaut **AVANT** la version 5.7 cette option était à __OFF__ , avec la version 5.7 par défaut ceci est à **TRUE**. Vous pouvez voir la valeur sur votre système :


        mysql> show variables where Variable_name='innodb_file_per_table';                            
        +-----------------------+-------+
        | Variable_name         | Value |
        +-----------------------+-------+
        | innodb_file_per_table | OFF   |
        +-----------------------+-------+
        1 row in set (0.00 sec)

Bien que le système utilise un fichier **innoDB** par table le mécanisme reste le même , un fichier d'une taille X sera prédéfinie et il utilisera une valeur définie pour automatiquement agrandir le fichier. Donc si l'on supprimer uniquement des entrés dans la tables il n'y aura pas libération de l'espace disque dur au niveau du système d'exploitation. Pour réduire l'espace vous devrez utiliser l'instruction [OPTIMIZE TABLE](http://dev.mysql.com/doc/refman/5.7/en/optimize-table.html)

Vous pourrez trouver les avantages et inconvénients de cette configuration sur la page de __MySQL 5.7__ : [InnoDB par table](http://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-tablespaces.html)

Voyons rapidement quelques points :

* Pour 
    * Récupération de l'espace disque dur "direct" lors de la suppression des tables
    * Vous pouvez utilisez l'instruction [OPTIMIZE TABLE](http://dev.mysql.com/doc/refman/5.7/en/optimize-table.html) pour compacter un fichier de table. **innodb** dans la pratique va lui même refaire la création du fichier pour éliminer les bloques __libre__.
    * Il est possible de copier un simple table d'une base de données à l'autre lors que ces dernières sont éteintes.
    * La segmentation des fichiers permet d'avoir un impacte moins grand s'il y a corruption du disque dur.
    * Vous pouvez voir la taille des tables SANS communiquer avec __MySQL__ , donc uniquement avec le système d'exploitation.
* Contre
    * Comme nous l'avons dis précédemment comme l'ajout d'espace est fait par bloque ainsi que la création initial du fichier est possible si la taille initiale est trop grande qu'une grande quantité d'espace soit perdu.
    * L'opération de synchronisation entre la mémoire est les fichiers (**[fsync](https://linux.die.net/man/2/fsync)**) sera plus demandant sur le système, car cette fois ci __MySQL__ devra communiquer avec un plus grand nombre de fichiers pour la synchronisation comparativement à 1 originalement.
    * __MySQL__ devra avoir plusieurs fichier d'ouvert pour les opérations , si votre base de données contient beaucoup de tables il est possible que la valeur du nombre de fichier ouvert ne soit pas convenablement configurer.
    * Lors de la suppression d'un table le __Buffer Pool__ est scanné , cette opération peut être ralentie si le __Buffer pool__ a une taille de __10gig__


Comme toujours il n'y a pas de recette qui s'applique à tous le monde , personnellement je pense que si vous avez une base de données pour vos sites web (__cms__, __moodle__ , ...) avec une charge petite l'utilisation de **InnoDB\_par\_table** est une bonne idée . Si vous êtes une entreprise avec à haut volume de transaction , vous avez probablement un __DBA__ de disponible, parlez sans évalué , faite des __benchmark__ avec votre application et la Base de données c'est le meilleur moyen de planifier à court et moyen terme.

#### <a name="engine_innodb_fileformat" /> Format de fichier d'innoDB (clin d'œil)

Je ne pourrais malheureusement approfondir sur ce sujet, car avant de préparer la formation je ne savais pas qu'il y avait plusieurs format de fichier possible pour **innodb** :P. Donc au lieu de dire bêtise que j'aurais copié / collé d'Internet sans ajouter de valeur ajouter sur le sujet je vais simplement vous pointé l'existence des formats et vous laissez faire vos recherches. 

Il existe 2 type de format de fichier supporté par **InnoDB**:

* **Antelope** (format par défaut pour __MySQL__  avant 5.5) :  offre le supports **REDUNDANT** et **COMPACT** des enregistrements (ligne)
* **Barracuda** (format par défaut pour __MySQL__  après 5.5)  : offre le supports **COMPRESSED** pour la compression des données et **DYNAMIC** pour une meilleur gestion du stockage pour les entrés variables (__VARCHAR__, __TEXT__, ... ) des enregistrements (ligne)

Pour visualiser le format actuellement en cours d'utilisation :

        mysql> show variables where Variable_name='innodb_file_format';   
        +--------------------+----------+
        | Variable_name      | Value    |
        +--------------------+----------+
        | innodb_file_format | Antelope |
        +--------------------+----------+
        1 row in set (0.00 sec)

Et voilà j'en dirai pas plus :D, désolé 

* Référence :
    * [File Space Management](http://dev.mysql.com/doc/refman/5.5/en/innodb-file-space.html) 
    * [SHOW TABLES STATUS](http://dev.mysql.com/doc/refman/5.5/en/show-table-status.html)
    * [Configuration innodb](http://dev.mysql.com/doc/refman/5.5/en/innodb-init-startup-configuration.html#innodb-startup-data-file-configuration)
    * [InnoDB par table](http://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-tablespaces.html)
    * [InnoDB file_format](http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html#sysvar_innodb_file_format)



# <a name="crash_healt_recovery" /> Validation de la santé et prise en charge

Cette section est je pense important, est-ce que vous l'appliquerez **cash** je ne pense pas, cependant ceci vous offrira un base un point de référence si ceci arrive. Vous transpirerez peut-être un peu moins et / ou vous aurez l'air plus en contrôle devant les autres qui sont en panique totale :).


## <a name="check_status" /> Analyse de l'état de santé des tables

Avant de corriger les problèmes il faut être en mesure d'identifier s'il y a un problème :D donc commençons par la validation des tables.

Comme j'avais fait mention je vais utiliser les 2 tables __app\_article__ et __app\_inno\_article__ pour faire la démonstration avec les 2 systèmes de stockage **MyISAM** et **innoDB**. Bon quand j'avais dis ça j'avais pas prévu de supprimer les tables pour faire la démonstration de l'utilisation de l'espace :P.
Pas grave, on va les recréer :D.

        $ mysql -u bob -p 
        mysql> use ma_super_BD
        mysql> CREATE TABLE app_inno_article ( id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY , texte TEXT NOT NULL, text_status ENUM('brouillon','evaluation','final') NOT NULL , info VARCHAR(20) ) ENGINE=INNODB ;
        Query OK, 0 rows affected (0.00 sec)

        mysql> CREATE TABLE app_article ( id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY , texte TEXT NOT NULL, text_status ENUM('brouillon','evaluation','final') NOT NULL , info VARCHAR(20) ) ENGINE=MYISAM ;
        Query OK, 0 rows affected (0.01 sec)

Un petit coup de script d'insertion pour mettre un peu de contenu  :

        $ ./insert.sh

        mysql> select count(*) from app_article;
        +----------+
        | count(*) |
        +----------+
        |      803 |
        +----------+
        1 row in set (0.00 sec)

        mysql> select count(*) from app_inno_article;
        +----------+
        | count(*) |
        +----------+
        |      803 |
        +----------+
        1 row in set (0.00 sec)

Validons l'état des tables maintenant, à l'aide de l'instruction [check table](http://dev.mysql.com/doc/refman/5.5/en/check-table.html#check-table-innodb) :


        mysql> check table app_article;
        +-------------------------+-------+----------+----------+
        | Table                   | Op    | Msg_type | Msg_text |
        +-------------------------+-------+----------+----------+
        | ma_super_BD.app_article | check | status   | OK       |
        +-------------------------+-------+----------+----------+
        1 row in set (0.00 sec)

        mysql> check table app_inno_article;
        +------------------------------+-------+----------+----------+
        | Table                        | Op    | Msg_type | Msg_text |
        +------------------------------+-------+----------+----------+
        | ma_super_BD.app_inno_article | check | status   | OK       |
        +------------------------------+-------+----------+----------+
        1 row in set (0.01 sec)

L'instruction [check table](http://dev.mysql.com/doc/refman/5.5/en/check-table.html#check-table-innodb) fonctionne aussi bien pour **MyISAM** et **innoDB**.
Ceci ne validera **QUE** l'état générale de la table si cette dernier à un problème d'index ou de clé , le problème ne sera pas remonté ! Vous devez utiliser une autre instruction [CHECK ANALYZE](http://dev.mysql.com/doc/refman/5.5/en/analyze-table.html):

        mysql> analyze table app_article;     
        +-------------------------+---------+----------+-----------------------------+
        | Table                   | Op      | Msg_type | Msg_text                    |
        +-------------------------+---------+----------+-----------------------------+
        | ma_super_BD.app_article | analyze | status   | Table is already up to date |
        +-------------------------+---------+----------+-----------------------------+
        1 row in set (0.00 sec)

        mysql> analyze table app_inno_article;
        +------------------------------+---------+----------+----------+
        | Table                        | Op      | Msg_type | Msg_text |
        +------------------------------+---------+----------+----------+
        | ma_super_BD.app_inno_article | analyze | status   | OK       |
        +------------------------------+---------+----------+----------+
        1 row in set (0.00 sec)

La différence est que [CHECK ANALYZE](http://dev.mysql.com/doc/refman/5.5/en/analyze-table.html) valide les index et les clé 

Moins pertinent selon dans le sujet de la validation de la santé des tables mais pertinent pour valider s'il y a modification d'un table il existe l'instruction [CHECKSUM TABLE](http://dev.mysql.com/doc/refman/5.5/en/innochecksum.html), qui permet d'avoir un __checksum__ d'un table :

        mysql> CHECKSUM TABLE app_article;
        +-------------------------+------------+
        | Table                   | Checksum   |
        +-------------------------+------------+
        | ma_super_BD.app_article | 3408470473 |
        +-------------------------+------------+
        1 row in set (0.01 sec)

        mysql> CHECKSUM TABLE app_inno_article;
        +------------------------------+------------+
        | Table                        | Checksum   |
        +------------------------------+------------+
        | ma_super_BD.app_inno_article | 3408470473 |
        +------------------------------+------------+
        1 row in set (0.00 sec)


Comme nous avons exactement la même quantité et même donnée dans les 2 table nous pouvons constater que le résultat est identique :D, c'est bien fait tous de même :D.

Comme nous l'avions vu aussi précédemment il est aussi possible d'utiliser l'instruction [SHOW TABLE STATUS](http://dev.mysql.com/doc/refman/5.5/en/show-table-status.html): 

        mysql> SHOW TABLE STATUS WHERE NAME="app_inno_article" \G
        *************************** 1. row ***************************
        Name: app_inno_article
        Engine: InnoDB
        Version: 10
        Row_format: Compact
        Rows: 950
        Avg_row_length: 120
        Data_length: 114688
        Max_data_length: 0
        Index_length: 0
        Data_free: 15728640
        Auto_increment: 810
        Create_time: 2016-10-31 12:02:38
        Update_time: NULL
        Check_time: NULL
        Collation: latin1_swedish_ci
        Checksum: NULL
        Create_options:
        Comment:
        1 row in set (0.00 sec)

### <a name="monitoring_innodb" /> Monitoring des tables avec innoDB

Documentation chez __MySQL__ : [Monitoring InnoDB](http://dev.mysql.com/doc/refman/5.5/en/innodb-enabling-monitors.html) 

Vous pouvez voir la santé du système de stockage __innoDB__ avec l'instruction  : **SHOW ENGINE INNODB STATUS\G**

        mysql> SHOW ENGINE INNODB STATUS\G
        *************************** 1. row ***************************
        Type: InnoDB
            Name:
            Status:
            =====================================
            161031 12:14:12 INNODB MONITOR OUTPUT
            =====================================
            Per second averages calculated from the last 48 seconds
            -----------------
            BACKGROUND THREAD
            -----------------
            srv_master_thread loops: 1 1_second, 1 sleeps, 0 10_second, 1 background, 1 flush
            srv_master_thread log flush and writes: 1
       [... OUTPUT COUPÉ ...]


En théorie, oui je dis en théorie car avec ma version de __MySQL__ 5.5 je n'ai pas réussie à avoir le output du monitoring par table :-/.
Selon la documentation il faut simplement créer une table : 

        mysql> CREATE TABLE innodb_table_monitor (a INT) ENGINE=INNODB;

Pour avoir l'information sur les tables après plusieurs tentative je n'ai pas eu de succès , j'ai du oublier quelque chose, mais quoi ... Je vous laisserai faire vos recherches nous essayerons ensemble lors de la formation :D.


Référence :

* [check table](http://dev.mysql.com/doc/refman/5.5/en/check-table.html#check-table-innodb)
* [CHECK ANALYZE](http://dev.mysql.com/doc/refman/5.5/en/analyze-table.html)
* [CHECKSUM TABLE](http://dev.mysql.com/doc/refman/5.5/en/innochecksum.html)
* [Monitoring InnoDB](http://dev.mysql.com/doc/refman/5.5/en/innodb-enabling-monitors.html)


## <a name="repair_tables" /> Réparation des tables

Bon avant de pouvoir  réparer une table faut que cette dernière est un problème ... Donc on va générer un problème :D.
Un petit backup avant , attention le backup que je réalise est TRÈS mauvais :P , mais comme il n'y a pas d'activité ce n'est pas critique mais cette méthode ne fonctionnera pas dans un vraie environnement avec de l'activité.

        $ mkdir ~/bk-bd
        $ cp app_* ~/bk-bd

Un petit **VIM** avec de la suppression et de l'ajout d'information sur la table **app\_article**

        $ sudo vim app_article.MYD

Après avec erroné le fichier refaisons une validation de la table 

        mysql> check table app_article;                              
        +-------------------------+-------+----------+-----------------------------------------------------+
        | Table                   | Op    | Msg_type | Msg_text                                            |
        +-------------------------+-------+----------+-----------------------------------------------------+
        | ma_super_BD.app_article | check | error    | Size of datafile is: 62848         Should be: 62856 |
        | ma_super_BD.app_article | check | error    | Corrupt                                             |
        +-------------------------+-------+----------+-----------------------------------------------------+
        2 rows in set (0.00 sec)

**COOL** un problème contrôler :D , vous pouvez aussi utilisé la ligne de commande avec **mysqlcheck**

        $ /usr/local/mysql/bin/mysqlcheck -u bob -p ma_super_BD app_article
        Enter password:
        ma_super_BD.app_article
        warning  : Table is marked as crashed
        error    : Size of datafile is: 62848         Should be: 62856
        error    : Corrupt

        $ /usr/local/mysql/bin/mysqlcheck -u bob -p ma_super_BD app_inno_article
        Enter password:
        ma_super_BD.app_inno_article                       OK

Passons à l'étape de la réparation de la table [REPAIR TABLE](http://dev.mysql.com/doc/refman/5.5/en/repair-table.html).
**ATTENTION** : **repair table** ne fonctionne QUE pour **MyISAM**

        mysql> repair table app_article;
        +-------------------------+--------+----------+----------------------------------------------------+
        | Table                   | Op     | Msg_type | Msg_text                                           |
        +-------------------------+--------+----------+----------------------------------------------------+
        | ma_super_BD.app_article | repair | info     | Wrong bytesec:   0-  0-120 at 60380; Skipped       |
        | ma_super_BD.app_article | repair | info     | Found block that points outside data file at 60552 |
        | ma_super_BD.app_article | repair | info     | Found block that points outside data file at 60660 |
        | ma_super_BD.app_article | repair | info     | Found block that points outside data file at 60720 |
        | ma_super_BD.app_article | repair | info     | Found block that points outside data file at 61028 |
        | ma_super_BD.app_article | repair | info     | Found block that points outside data file at 61224 |
        | ma_super_BD.app_article | repair | warning  | Number of rows changed from 809 to 778             |
        | ma_super_BD.app_article | repair | status   | OK                                                 |
        +-------------------------+--------+----------+----------------------------------------------------+
        8 rows in set (0.00 sec)

        mysql> check table app_article; 
        +-------------------------+-------+----------+----------+
        | Table                   | Op    | Msg_type | Msg_text |
        +-------------------------+-------+----------+----------+
        | ma_super_BD.app_article | check | status   | OK       |
        +-------------------------+-------+----------+----------+
        1 row in set (0.01 sec)


Regardons à présent le __checksum__ entre nos 2 tables identique :

        mysql> CHECKSUM TABLE app_article;
        | Table                   | Checksum   |
        +-------------------------+------------+
        | ma_super_BD.app_article | 1217375564 |
        +-------------------------+------------+

        mysql> CHECKSUM TABLE app_inno_article; 
        | Table                        | Checksum   |
        +------------------------------+------------+
        | ma_super_BD.app_inno_article | 3766155580 |
        +------------------------------+------------+

Lors de l'opération de réparation nous avons pu voir le message : **Number of rows changed from 809 to 778** , validons le :

        mysql> select count(*) from app_article;
        | count(*) |
        +----------+
        |      778 |
        +----------+

        mysql> select count(*) from app_inno_article;
        | count(*) |
        +----------+
        |      809 |
        +----------+


Passons à **InnoDB** c'est plus compliqué :D, le principe est que **innodb** se répare tous seul, ouin ... Par expérience si votre système de fichier à un problème ou votre **RAID** il n'y a PAS de réparation automatique qui fonctionne ... Bon créons le problème :D.

Copie du backup , je sais pas pourquoi je fais ça , réflex :

         $ sudo cp ibdata1 ~/bk-bd 

         $ sudo vim /var/lib/mysql/ibdata1 
         [ Modification aléatoire du contenue ]

Je vais maintenant valider la table : 

         mysql> check table app_inno_article;
        +------------------------------+-------+----------+----------+
        | Table                        | Op    | Msg_type | Msg_text |
        +------------------------------+-------+----------+----------+
        | ma_super_BD.app_inno_article | check | status   | OK       |
        +------------------------------+-------+----------+----------+
        1 row in set (0.01 sec)

Pas de problème, __humm__ là t'as vraiment envie de dire que **innoDB** c'est fort , mais attendons un peu on va arrêter la BD et redémarrer le système ,
vaut mieux le faire ici qu'en production . Voici le résultat :

        161031 21:11:01 [Note] mysqld (mysqld 5.5.52) starting as process 19 ...
        161031 21:11:01 [Note] Plugin 'FEDERATED' is disabled.
        161031 21:11:01 InnoDB: The InnoDB memory heap is disabled
        161031 21:11:01 InnoDB: Mutexes and rw_locks use GCC atomic builtins
        161031 21:11:01 InnoDB: Compressed tables use zlib 1.2.3
        161031 21:11:01 InnoDB: Using Linux native AIO
        161031 21:11:01 InnoDB: Initializing buffer pool, size = 128.0M
        161031 21:11:01 InnoDB: Completed initialization of buffer pool
        161031 21:11:01 InnoDB: highest supported file format is Barracuda.
        161031 21:11:01  InnoDB: Waiting for the background threads to start
        161031 21:11:02 InnoDB: Error: tablespace size stored in header is 1664 pages, but
        161031 21:11:02 InnoDB: the sum of data file sizes is only 1600 pages
        161031 21:11:02 InnoDB: Cannot start InnoDB. The tail of the system tablespace is
        161031 21:11:02 InnoDB: missing. Have you edited innodb_data_file_path in my.cnf in an
        161031 21:11:02 InnoDB: inappropriate way, removing ibdata files from there?
        161031 21:11:02 InnoDB: You can set innodb_force_recovery=1 in my.cnf to force
        161031 21:11:02 InnoDB: a startup if you are trying to recover a badly corrupt database.
        161031 21:11:02 [ERROR] Plugin 'InnoDB' init function returned error.
        161031 21:11:02 [ERROR] Plugin 'InnoDB' registration as a STORAGE ENGINE failed.
        161031 21:11:02 [ERROR] Unknown/unsupported storage engine: InnoDB
        161031 21:11:02 [ERROR] Aborting

        161031 21:11:02 [Note] mysqld: Shutdown complete

C'est sympa **innoDB** ça te laisse même pas démarrer ta BD !! C'est le problème d'un fichier pour l'ensemble du __tablespace__. 

Le **PIRE** si vous utilisez __MySQL__ dans un docker vous corrigez comment le problème ?!?!?! Il mentionne de mettre **innodb_force_recovery=1** mais si vous n'avez pas fait de volume votre conteneur démarre pas ! Bon pour les personnes comme moi :D , qui préparez tranquillement leur formation dans le train dans un conteneur voici comment vous sauver . Bien entendu c'est **HORS SUJET** pour mysql [Docker changement du start](#docker_start_change)

Nous allons donc définir dans le fichier **my.cnf** l'option **innodb_force_recovery=1** , nous reviendrons bientôt sur ce fichier de configuration :

        $ cat /etc/mysql/my.cnf
        [mysqld]
        skip-host-cache
        skip-name-resolve
        datadir = /var/lib/mysql
        innodb_force_recovery=1
        !includedir /etc/mysql/conf.d/


Bon il semble qu'il a réussie :

         # /usr/local/bin/docker-entrypoint.sh mysqld
         21:35:50 InnoDB: Using Linux native AIO
         161031 21:35:50 InnoDB: Initializing buffer pool, size = 128.0M
         161031 21:35:50 InnoDB: Completed initialization of buffer pool
         161031 21:35:50 InnoDB: highest supported file format is Barracuda.
         161031 21:35:50  InnoDB: Waiting for the background threads to start
         161031 21:35:51 InnoDB: Error: tablespace size stored in header is 1664 pages, but
         161031 21:35:51 InnoDB: the sum of data file sizes is only 1600 pages
         161031 21:35:51 InnoDB: 5.5.52 started; log sequence number 13537750
         161031 21:35:51 InnoDB: !!! innodb_force_recovery is set to 1 !!!


Il la même super bien fait :D 

        mysql> select count(*) from app_inno_article;                   
        +----------+
        | count(*) |
        +----------+
        |      809 |
        +----------+
        1 row in set (0.00 sec)

        mysql> CHECKSUM TABLE app_inno_article;                  
        +------------------------------+------------+
        | Table                        | Checksum   |
        +------------------------------+------------+
        | ma_super_BD.app_inno_article | 3766155580 |
        +------------------------------+------------+
        1 row in set (0.00 sec)

Même le __checksum__ est bon :-| .

Le problème par contre est qu'avec l'option **innodb_force_recovery=1** vous ne pouvez plus faire d'insertion , dans le __tablespace__ :-/ , oui la base de données est en **lecture-seule** si vous essayer de créer un table ceci fonctionnera mais pas l'insertion . Vous aurez l'erreur suivante dans de __MySQL__ :

        Got error -1 from storage engine

Dans les logs vous aurez un message claire :

        InnoDB: A new raw disk partition was initialized or
        InnoDB: innodb_force_recovery is on: we do not allow
        InnoDB: database modifications by the user. Shut down
        InnoDB: mysqld and edit my.cnf so that newraw is replaced
        InnoDB: with raw, and innodb_force_... is removed.

Mais c'est le moment de réalisé une sauvegarde de la base de donnée.  Vous pouvez utilisez la commande **mysqlcheck**:

        $ mysqlcheck -u root -p --all-databases
        Enter password:
        ma_super_BD.album                                  OK
        ma_super_BD.album2                                 OK
        ma_super_BD.app_article                            OK
        ma_super_BD.app_inno_article                       OK
        ma_super_BD.artiste                                OK
        ma_super_BD.employe                                OK
        ma_super_BD.employe2                               OK
        ma_super_BD.employe3                               OK
        ma_super_BD.innodb_monitor                         OK
        ma_super_BD.innodb_table_monitor                   OK
        ma_super_BD.innodb_tablespace_monitor              OK
        [ ... OUTPUT COUPÉ ... ]

S'il y a indication d'une table problématique vous pouvez la supprimer et reprendre les données depuis la sauvegarde pour recréer proprement la table et le __tablespace__ . Dans le pire des cas faire une sauvegarde complète du système et recréer l'ensemble.

Bon malheureusement je vais être un peu limité dans mes possibilités de __crash__ , donc je vais vous faire par de mon expérience, de mon dernier __crash__ de base de données __MySQL__ avec **innoDB** . 
Comme vous avez pu le constater quand il y a un problème avec le système de stockage **innoDB** l'ensemble de la base de données __crash__ le processus **mysqld** s'arrête et essaye de redémarrer selon votre système. Même si j'avais l'option **innodb_force_recovery=1** dans ma configuration comme c'était un problème de disque dur, il n'a pas pu faire grand chose. Le plus gros problème est que comme le processus **mysqld** s'arrête même les services qui utilisaient __MyISAMM__ été affecté :(. La solution fut de reprendre le backup et de réimporter les données afin de recréer les tables __innoDB__ convenablement, bien entendu ceci sera équivalent pour __MyISAMM__ cependant ce dernier n'affecte pas l'ensemble du processus __mysqld__. Nous verrons lors de la formation si le problème est équivalent pour __MySQL__ **5.7**.

Donc peut importe le mécanisme de **crash recovery** un backup reste votre meilleur filet :D. 

Passons donc au backup :D

* Référence :
    * [REPAIR TABLE](http://dev.mysql.com/doc/refman/5.5/en/repair-table.html)
    * [REPAIR INNODB](https://twindb.com/repair-corrupted-innodb-table-with-corruption-in-secondary-index/)
 
# <a name="mysql_backup" /> Réalisation d'un backup de(s) base(s) de données

Le système de backup de __Mysql__ est bien fait car il prend en charge peut importe le système de stockage utilisé, pas besoin de ce prendre la tête.
L'application pour réaliser un backup se nomme [Mysqldump](http://dev.mysql.com/doc/refman/5.5/en/mysqldump.html) , bien entendu vous devrez fournir des informations d'authentification pour l'utiliser. Je vous suggère d'utiliser un utilisateur dédier au backup , voici les droits requis : [SELECT](http://dev.mysql.com/doc/refman/5.5/en/privileges-provided.html#priv_select) , [SHOW VIEW](http://dev.mysql.com/doc/refman/5.5/en/privileges-provided.html#priv_show-view), [TRIGGER](http://dev.mysql.com/doc/refman/5.5/en/privileges-provided.html#priv_trigger), [LOCK TABLE](http://dev.mysql.com/doc/refman/5.5/en/privileges-provided.html#priv_lock-tables). Bien entendu l'utilisateur n'a pas besoin d'avoir accès en écriture , sauf si vous désirez __restorer__ une base de données mais honnêtement à ce stade j'utilise l'administrateur (__root__). 


Nous allons voir 2 type de backup , personnellement j'utilise toujours les 2 , car j'aime avoir un BON filet en cas de problème après tous c'est mes données !!

1. Sauvegarde complet dans 1 fichiers : L'avantage de cette solution s'il y a un problème avec votre BD que vous devez la réinstaller et la remettre en place 1 fichier et voilà l'ensemble est présent pas de soucis 
2. Sauvegarde des base de données 1 fichier par BD : L'avantage est que si vous avez besoin de récupéré juste une BD qui à eu un problème (erreur de manipulation , suppression , contenu erroné ) vous avez uniquement besoin de traiter cette base de données pas de manipulation à réaliser pour récupérer juste une BD

L'avantage d'utiliser ces 2 méthodes est que vous avez 2 sauvegarde presque identique (presque car il est possible qu'il y est quelques secondes / minutes entre les sauvegardes ) donc un filet double :D.

Bon fini le __blabla let's GO__ les commandes.

## <a name="mysql_backup_full" /> Sauvegarde complet de la base de donnée

Allez direct la commande :

        mysqldump --all-databases -u root -p > full.sql

Et voilà , l'ensemble de la BD __MySQL__ est contenu dans le fichier __full.sql__ !!

Vous pouvez voir le contenu :

        head -45 full.sql
        -- MySQL dump 10.13  Distrib 5.5.52, for linux2.6 (x86_64)
        --
        -- Host: localhost    Database: 
        -- ------------------------------------------------------
        -- Server version       5.5.52

        /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
        /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
        /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
        /*!40101 SET NAMES utf8 */;
        /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
        /*!40103 SET TIME_ZONE='+00:00' */;
        /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
        /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
        /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
        /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

        --
        -- Current Database: `ma_super_BD`
        --

        CREATE DATABASE /*!32312 IF NOT EXISTS*/ `ma_super_BD` /*!40100 DEFAULT CHARACTER SET latin1 */;

        USE `ma_super_BD`;

        --
        -- Table structure for table `album`
        --

        DROP TABLE IF EXISTS `album`;
        /*!40101 SET @saved_cs_client     = @@character_set_client */;
        /*!40101 SET character_set_client = utf8 */;
        CREATE TABLE `album` (
          `id` tinyint(3) unsigned NOT NULL AUTO_INCREMENT,
          `nom` varchar(20) NOT NULL,
          `annee` year(4) NOT NULL,
          `artiste` tinyint(3) unsigned DEFAULT NULL,
          PRIMARY KEY (`id`),
          KEY `artiste` (`artiste`),
          CONSTRAINT `album_ibfk_1` FOREIGN KEY (`artiste`) REFERENCES `artiste` (`id`)
        ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=latin1;
        /*!40101 SET character_set_client = @saved_cs_client */;
        --

Bien entendu tous comme pour l'établissement de connexion avec le client __mysql__ il est possible de fournir le mot de passe sur la ligne de commande afin de pouvoir mettre cette commande dans un **cron** ou un script.

        $ mysqldump --all-databases -u root --password=superPatate > full.sql

Bon c'est du texte simple donc ça se compresse bien , bien entendu vous pouvez toujours utiliser la commande **gzip** post-exécution.

        $ du -hs full.sql
        3.2M    full.sql
        $ gzip full.sql
        $ du -hs full.sql.gz
        788K    full.sql.gz

Ou directement le mettre sur la commande en mettant la date du jour :D, c'est plus jolie  :

        $ mysqldump --all-databases -u root --password=superPatate | gzip > full-$(date +%F).sql.gz 
        $ du -hs full-$(date +%F).sql.gz                                                           
        788K    full-2016-11-01.sql.gz


Quelques arguments COOL :

* **-xml** (__mysqldump --xml --all-databases -u root -p > bk.xml__) : permet d'avoir le résultat en format __xml__ pour les amoureux du __xml__ :P
* **--no-data, -d**  : Permet de réaliser une sauvegarde uniquement des schémas sans le contenu des tables, pas très pratique pour un backup mais idéal pour répliquer une structure .
* **--extended-insert, -e** : ceci permet de définie le backup avec le système d'insertion étendu , ça augmente la rapidité de __restore__
* **--dump-date** : Ajoute en commentaire la date de la sauvegarde dans le fichier
* **--complete-insert, -c** : les instructions d'insertion seront complète incluant les colonnes, principalement intéressant lorsque vous migré de base de donnée de __MySQL__ vers une autre BD.
* **--compatible=name** : Dans la même idée si vous réalisez une sauvegarde pour la rechargé dans une autre BD vous pouvez définir un mode de compatibilité voici la liste des options possible : __ansi, mysql323, mysql40, postgresql, oracle, mssql, db2, maxdb, no_key_options, no_table_options, or no_field_options__
* **--replace** : Au lieu de réalisé la sauvegarde avec des __insert__ le système utilisera l'instruction __replace__ , pratique pour rafraichir un environnement.
* **where** : Réalise la sauvegarde unique pour les lignes qui concorde au critère inclut dans l'instruction __where__.

L'ensemble des instructions / options sont disponible à l'adresse de __Mysql__ : [http://dev.mysql.com/doc/refman/5.5/en/mysqldump.html](http://dev.mysql.com/doc/refman/5.5/en/mysqldump.html)
 
## <a name="mysql_backup_database" /> Sauvegarde des base de donnée individuelle 

Telle que mentionné , moi j'aime bien avoir une sauvegarde par base de donnée au lieu d'avoir un **GROS** fichier avec l'ensemble. Pourquoi simplement que si j'ai une base de donnée de 200__Megs__ et 2 autres base de données de 5 __Gig__ , si je dois faire une récupération de la petite base de données faut que je manipule un fichier de 10.2 __gig__ . Si je dois faire une restauration d'urgence, je transpire déjà assez pour pas vouloir me battre à trier un gros fichier !

Donc voici l'instruction pour faire une sauvegarde d'une base de donnée :

        $ mysqldump -u root --password=superPatate  --databases ma_super_BD > dump-ma_super_BD-$(date +%F).sql
        $  ls -l dump-ma_super_BD-$(date +%F).sql
        -rw-r--r-- 1 root root 148701 Nov  1 21:05 dump-ma_super_BD-2016-11-01.sql

Comme vous pouvez voir la commande est la même [mysqldump](http://dev.mysql.com/doc/refman/5.5/en/mysqldump.html) , donc l'ensemble des arguments mentionné dans la précédente section sont valide. 

Bon une petite astuce maintenant :D , pour ceux qui se disent super je vais faire un script comme suit :

        #!/bin/bash
        #
        ###########################################

        LST_BD_TO_BACKUP="ma_super_BD wordpress pyrocms"
        USER_BD=root
        PASSWORD_BD=superPatate
        REP_BK=/dump/bd/

        for bd in $LST_BD_TO_BACKUP ; do
            mysqldump -u $USER_BD --password=$PASSWORD_BD --databases $bd | gzip > $REP_BK/$bd-$(date +%F).sql.gz
        done

Oui , c'est pas mal ... __Ok__ non c'est à chier !! Pas que je vous fais pas confiance , mais si vous êtes plusieurs administrateur sur la machine ou qu'un développeur peut aussi créer des base de données que va t'il arriver ?? Quand vous aurez un __crash__ vous vous rendrez compte que vous avez oublié d'ajouter la nouvelle base de données dans la variable **$LST_BD_TO_BACKUP** , résultat pas de backup . Si vous en supprimé une vous aurez une erreur, mince consolation car c'est pas le plus critique. 

Voici ce que je vous suggère, de procéder à l'inverse de prendre TOUTES les base de données et d'exclure celle que vous ne désirez pas. Voici la commande pour avoir l'ensemble des bases de données présent dans la bd.

        $ mysql -u root --password=superPatate --skip-column-names -s -e 'show databases '
        information_schema
        ma_super_BD
        mysql
        performance_schema
        ze_bd

Avec les options **--skip-column-names** , pour supprimer le nom de la colonne et **-s** pour silence pour ne pas avoir le formatage du résultat j'ai l'ensemble des base de données disponible. Nous savons que **information\_schema**  et **performance\_schema** sont dynamique nous pouvons donc les exclure de la sauvegarde.
On reprend :D 

        #!/bin/bash
        #
        ############################################
        LST_EXCLU_BD_TO_BACKUP="information_schema performance_schema"
        USER_BD=root
        PASSWORD_BD=superPatate
        REP_BK=/dump/bd/

        LST_BD=$(mysql -u $USER_BD --password=$PASSWORD_BD --skip-column-names -s -e 'show databases ')
        for bd in $LST_BD ; do
            if echo $LST_EXCLU_BD_TO_BACKUP | grep -v -q $bd ; then
                mysqldump -u $USER_BD --password=$PASSWORD_BD --databases $bd | gzip > $REP_BK/$bd-$(date +%F).sql.gz
            fi
        done


**HAaaa** je me sens plus en sécurité tous d'un coup :D. Je vous suggère d'utiliser le même principe pour l'ensemble de vos BD que ce soit __MySQL__ ou autre , les sauvegardes sont trop importante pour que l'on oublie une base de données :-/.

Il vous  reste à ajouter un système de rotation pour ne pas remplir le disque dur de backup de base de données.


* Référence :
    * [Mysqldump](http://dev.mysql.com/doc/refman/5.5/en/mysqldump.html)

## <a name="mysql_backup_restore" /> Réalisation d'une restauration

Un peu plus et j'oubliais de couvrir la restauration d'un backup :P .

Pour les besoins de l'opération je vais prendre la sauvegarde de la base de donnée **ma\_super\_bd** et créer la base de donnée , **restored\_bd**. 

Comme vous pouvez le constater je désire changer le nom de la base de donnée lors de l'import, pour ce faire j'ai plusieurs options.

Regardons le fichier de sauvegarde, principalement les premières ligne :

        $ cat -n dump-ma_super_BD-2016-11-01.sql | head -30
            1  -- MySQL dump 10.13  Distrib 5.5.52, for linux2.6 (x86_64)
            2  --
            3  -- Host: localhost    Database: ma_super_BD
            4  -- ------------------------------------------------------
            5  -- Server version       5.5.52
            6
            7  /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
            8  /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
            9  /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
           10  /*!40101 SET NAMES utf8 */;
           11  /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
           12  /*!40103 SET TIME_ZONE='+00:00' */;
           13  /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
           14  /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
           15  /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
           16  /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
           17
           18  --
           19  -- Current Database: `ma_super_BD`
           20  --
           21
           22  CREATE DATABASE /*!32312 IF NOT EXISTS*/ `ma_super_BD` /*!40100 DEFAULT CHARACTER SET latin1 */;
           23
           24  USE `ma_super_BD`;
           25
           26  --

Bon Il y a pas mal de commentaire :-/ , mais j'ai voulu les laissé , en gros si je veux importer cette sauvegarde dans une autre base de données j'ai simplement à modifier la ligne **22** et **24** :D soit  :

           22  CREATE DATABASE /*!32312 IF NOT EXISTS*/ `ma_super_BD` /*!40100 DEFAULT CHARACTER SET latin1 */;
           23
           24  USE `ma_super_BD`;

Allez un petit __VI__ sur le fichier et voilà on en parle plus , __Yeahhh__ ça marche bien jusqu'à ce que votre BD soit de plusieurs __GIG__. Dans cette situation même si __VI__ est super merveilleux avec 25 ans d'ingénierie en arrière , il aura de la difficultés :-/. 

Donc l'objectif est de ne pas avoir l'instruction __CREATE__ et surtout ne pas avoir l'instruction __USE__. Pour le __CREATE__ vous pouvez utiliser l'option **--no-create-db** lors du __dump__ , c'est bien mais bon ça reste pas l'idéal de plus il n'y a pas de paramètre pour supprimer l'instruction __USE__ dans **mysqldump** . De plus si vous désirez restauré la __BD__ original vous ne serez pas plus avancé de devoir rajouter ces instructions si la sauvegarde est volumineuse. 

Voici ma suggestion, laissez l'instruction de création (__CREATE__) et d'utilisation (__USE__), après nous se que l'on veut c'est simplement faire une recherche et remplacé la définition de l'ancienne BD. Ça tombe bien **sed** le fait SUPER BIEN :D, on sait et on peut le valider avec **hear** que l'instruction de création et d'utilisation est présent uniquement dans les premières lignes . 
Voici l'exemple de validation

         head -30 ma_super_BD-2016-11-01.sql | cat -n
              1  -- MySQL dump 10.13  Distrib 5.5.52, for linux2.6 (x86_64)
              2  --
              3  -- Host: localhost    Database: ma_super_BD
              4  -- ------------------------------------------------------
              5  -- Server version       5.5.52
              6
              7  /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
              8  /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
              9  /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
             10  /*!40101 SET NAMES utf8 */;
             11  /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
             12  /*!40103 SET TIME_ZONE='+00:00' */;
             13  /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
             14  /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
             15  /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
             16  /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
             17
             18  --
             19  -- Current Database: `ma_super_BD`
             20  --
             21
             22  CREATE DATABASE /*!32312 IF NOT EXISTS*/ `ma_super_BD` /*!40100 DEFAULT CHARACTER SET latin1 */;
             23
             24  USE `ma_super_BD`;
             25
             26  --
             27  -- Table structure for table `album`
             28  --
             29
             30  DROP TABLE IF EXISTS `album`;

Le reste on s'en fou :D , donc on peut le dire il n'y a que les 30 premières lignes à modifier peut importe la taille de la sauvegarde. Nous allons utiliser **sed** pour modifier les 30 premières lignes du fichier.

         $ sed -i '1,30s/ma_super_BD/restored_bd/' ma_super_BD-2016-11-01.sql

**MAGIE** :D 

Nous sommes près à charger le fichier :

        $  mysql -u root -p
        mysql> \. ma_super_BD-2016-11-01.sql


Voilà c'est pas plus compliquer que ça :D.

# <a name="configue" /> Configuration de mysql (mysql.cnf +  ~/.my.cnf)

Nous allons voir comment modifier les fichiers de configuration de __MySQL__ pour le serveur et pour le client. 
On va commencé par le client c'est la partie moins longue puis nous couvrirons le serveur .

## Configuration du client ( USER_HOME/.my.cnf)

Si vous manipulez souvent votre base de donnée avec le client __mysql__ vous devez à chaque fois entrer le mot de passe et utilisateur , ce n'est pas la fin du monde, mais on est tous paresseux . Pour un Sysadmin c'est une qualité :D !

Donc éditez votre fichier __$HOME/.my.cnf__ avec les informations suivant :

        [client]
        user=root
        password=superPatate
        # host=localhost
        # database = ma_super_BD

Bien entendu il y a le mot de passe en claire donc il faut ajuster les permissions pour protéger le contenu :

        $ chmod 600 .my.cnf

Suite à l'ajout de l'instruction maintenant si je tape uniquement , il établera une avec l'utilisateur __root__.

        $ mysql
        mysql> 

Comme vous pouvez le constater il est aussi possible de définir un serveur __SQL__ et une base de donnée de connexion.

Vous pourrez voir d'autre option disponible sur la page de [Mysql cnf option](http://dev.mysql.com/doc/refman/5.5/en/option-files.html)
Je pense que l'on à fait le tour , très rapidement vous verrez le reste sur le site de __MySQL__
Passons à la section serveur :D :D.

## Configuration du serveur ou globale (/etc/mysql/my.cnf)

Le fichier de configuration par défaut de __MySQL__ se trouve dans le répertoire __/etc/mysql/__ et porte le nom __my.cnf__ . Regardons celui actuellement en utilisation  : 

        $ cat /etc/mysql/my.cnf
        [mysqld]
        skip-host-cache
        skip-name-resolve
        datadir = /var/lib/mysql
        !includedir /etc/mysql/conf.d/
        $ ls /etc/mysql/conf.d/

Comme vous pouvez le voir il n'y a pas grand chose, surtout que je suis dans un docker actuellement, si vous avez installé __MySQL__ sous Ubuntu ou Debian vous aurez beaucoup plus de paramètre. Regardons la liste des paramètres possible , à la page [Mysql Option available](http://dev.mysql.com/doc/refman/5.5/en/mysqld-option-tables.html)

Heu, effectivement on les fera pas tous :P , par contre vous aimeriez bien savoir ce que votre système utilise, imaginons que vous avez une problématique avec le serveur. Vous postez sur un forum pour avoir un peu d'aide puis on vous demande qu'elle est la valeur de **innodb_buffer_pool_size** , dans notre cas si on regarde , heu heu heu. On peut difficilement répondre . 

Regardons comment extraire l'information depuis le serveur , avec l'instruction [SHOW VARIABLES](http://dev.mysql.com/doc/refman/5.5/en/show-variables.html) nous serrons en mesure d'avoir notre informations

        mysql> show variables;
        +-------------------------------+------------------------------------------------------
        | Variable_name                 | Value                                               |
        +-------------------------------+-----------------------------------------------------+
        | auto_increment_increment      | 1                                                   |
        | auto_increment_offset         | 1                                                   |
        | autocommit                    | ON                                                  |
        | automatic_sp_privileges       | ON                                                  |
        [ ... OUTPUT COUPÉ ...]


Bon reprenons notre problème pour la valeur de **innodb_buffer_pool_size** , quelle est la valeur en place :

        mysql> show variables where Variable_name = 'innodb_buffer_pool_size';     
        +-------------------------+-----------+
        | Variable_name           | Value     |
        +-------------------------+-----------+
        | innodb_buffer_pool_size | 134217728 |
        +-------------------------+-----------+

Allons plus loin pour l'ensemble des instructions **innodb\_buffer**

        mysql> show variables where Variable_name like '%innodb_buffer%';          
        +------------------------------+-----------+
        | Variable_name                | Value     |
        +------------------------------+-----------+
        | innodb_buffer_pool_instances | 1         |
        | innodb_buffer_pool_size      | 134217728 |
        +------------------------------+-----------+

C'est vraiment le plus important de la formation , être en mesure d'extraire l'information de notre configuration existante :D.

Avant de débuter les configurations pour l'optimisation de la base de données  voyons les configurations primaire importante .

* **[datadir](http://dev.mysql.com/doc/refman/5.5/en/server-options.html#option_mysqld_datadir)** : Permet de définir où est le répertoire de données de __MySQL__ , on n'y touche rarement sauf quand la partition **/var** est pleine :P . Si cette situation arrive vous arrêtez __MySQL__ déplacé le répertoire __/var/lib/mysql__ vers un autre répertoire exemple __/data/mysql/__ modifiez cette variable et redémarrer __MySQL__. Aussi simple que ça , attention tous de même au permissions :P, vous assurez que l'utilisateur __mysql__ pourra lire et écrire !
* **[bind-address](http://dev.mysql.com/doc/refman/5.5/en/server-options.html#option_mysqld_bind-address)** : Définie sur quelle __IP__ le service écoutera , cette option est souvent par défaut à 127.0.0.1 . Si votre service __SQL__ doit pouvoir écouter sur le réseau soit vous définissez l'IP ici ou 0.0.0.0 pour indiquer TOUTES les IP.
* **[port](http://dev.mysql.com/doc/refman/5.5/en/server-options.html#option_mysqld_port)** : assez claire mais je voulais le mentionné si vous désirez modifier le port 3306 par défaut par un autre.
* **[log](http://dev.mysql.com/doc/refman/5.5/en/server-options.html#option_mysqld_log)**: Permet de loguer  l'ensemble des opérations de __MySQL__ attention ceci ne doit être activé QUE pour réalisé de l'analyse de __debug__, car tous est contenu dans le logs ( Les requêtes, les erreurs , les connexions, TOUS)
* **[log-error](http://dev.mysql.com/doc/refman/5.5/en/server-options.html#option_mysqld_log-error)**: Cette instruction est mieux car elle ne conserve log que les erreurs de __MySQL__ donc ceci est plus minimal.
* **[max\_connections]http://dev.mysql.com/doc/refman/5.5/en/server-system-variables.html#sysvar_max_connections)**: Définie le nombre de connexion maximal que __MySQL__ accepte, par défaut la valeur est à **151** . Pour un environnement interne pas de problème, si vous avez un gros trafic il est fort probable que vous soyez obligé d'augmenter cette valeur.
* **[old\_password](http://dev.mysql.com/doc/refman/5.5/en/server-system-variables.html#sysvar_old_passwords)**: Je nomme cette option uniquement si vous êtes vraiment mal pris et que vous devez importer une VEILLE ( avant 4.1 ) sur votre base de données. Le système de chiffrement de mot de passe a changé vous serez donc dans l'obligation d'indiquer la fonctionnalité du vieux chiffrement. Conseil réinitialisé les mot de passe !! Ce sera plus propre.
* **[log-slow-query](http://dev.mysql.com/doc/refman/5.5/en/server-options.html#option_mysqld_log-slow-queries)**: Permet de loguer les requêtes qui ont pris beaucoup de temps. C'est quoi beaucoup ? C'est ce que la valeur de la variable [long\_query\_time](http://dev.mysql.com/doc/refman/5.5/en/server-system-variables.html#sysvar_long_query_time) soit 10 secondes par défaut.
* **[user](http://dev.mysql.com/doc/refman/5.5/en/server-options.html#option_mysqld_user)**: Indique le nom de l'utilisateur système qui sera utilisé pour exécuter le service / __deamon__ de __MySQL__. Bien entendu s'il y a modification de cette valeur, modifier aussi les permissions du répertoire __datadir__.

Pour le reste ceci varie selon vos besoin je redonne l'URL de la page de __Mysql__: [Mysql Option available](http://dev.mysql.com/doc/refman/5.5/en/mysqld-option-tables.html)

Vous verrez il y a l'option pour définir le système de __storage__ par défaut de présent ...

* Référence 
    * http://dev.mysql.com/doc/refman/5.5/en/server-configuration.html
 
# <a name="perf_conf" /> Configuration d'optimisation de performance

Nous allons maintenant voir quelques paramètres disponible pour améliorer les performances de __MySQL__. 
Avant tous je tiens à préciser une chose, d'expérience passé la majorité des problèmes sont reliés à 2 choses :

* Des **requêtes SQL** mal écrites , résultant à un nombre énorme de requêtes avec des liens non utilisé.
* Un oublis  de création **INDEX** , sur les champs qui sont régulièrement interrogé.
* Le dernier et non le moindre l'accès disque, qui peut se révéler un vraie problème, merci l'inventeur des **SSD**. Pour ce point je vous suggère de regarder la commande **iostat** qui vous permettra d'analyser quelle partition qui cause problème.

Et pas de bol c'est pas couvert ici :P, car ceci est relié à votre application et que je ne suis pas particulièrement bon pour la rédaction de requête __SQL__. Bon ceci étant dis si votre __DBA__ ou expert __SQL__ vient vous parler et dis j'ai tous regardé c'est un problème avec __l'OS__. Si vous n'êtes pas l'administrateur réseau vous pouvez toujours répondre non c'est un problème de __network__ ;-).
Sans farce nous allons voir comment nous allons pouvoir faire notre part pour résoudre le problème. 
Après tous nous sommes des super héros :

![supertux.gif](./imgs/supertux.gif)

## <a name="metric_mysql_perf" /> Récupération de métriques

Avant toutes chose nous devons avoir des métriques sur l'utilisation de notre système __MySQL__ , car malgré toute notre bonne volonté il est possible qu'il y est de effet de bord négatif nous devons être en mesure de l'identifier rapidement.
J'aimerai vous dire que vous devez d'abord réaliser les opérations sur un environnement de __QA__ , __Perf__, ... Mais nous connaissons tous la réalité soit vous en avez pas (malheureusement) soit cette dernière n'est pas représentatif de la production et même si les 2 premiers affirmations sont vraie une fois en production c'est possible qu'il y est des différences. 
La seule solution est d'avoir des métriques pour comprendre et prendre action.

Voici quelques outils  disponible 

### MyTOP

Une bonne documentation disponible par nos amis de __DigitalOcean__ [how-to-use-mytop-to-monitor-mysql-performance](https://www.digitalocean.com/community/tutorials/how-to-use-mytop-to-monitor-mysql-performance).

Rapidement installation : 

        $ sudo apt-get install mytop 

Et pour visualiser l'ensemble en live :

        $ mytop -u root -h 127.0.0.1

        MySQL on 127.0.0.1 (5.5.52)                             load 0.68 0.40 0.28 7/395 19043 up 0+00:22:57 [12:31:06]
         Queries: 7.0k     qps:    5 Slow:     0.0         Se/In/Up/De(%):    33/33/00/00
         Sorts:      0 qps now:  469 Slow qps: 0.0  Threads:    2 (   1/   0) 33/33/00/00
         Key Efficiency: 99.8%  Bps in/out: 468.3/565.0   Now in/out: 39.9k/53.1k

         Id      User         Host/IP         DB       Time    Cmd    State Query       
         --      ----         -------         --       ----    ---    ----- ----------
         1619      root       127.0.0.1                     0  Query          show full processlist
         2359       bob       localhost ma_super_B          0  Query query en insert into app_inno_article (texte,text_status,info) values (" clocksource: Switche


Ceci est vraiment très pratique pour visualiser les requêtes en cours et potentiellement identifier une requête problématique .


### innotop

Dans la même idée de visualisation en direct des problèmes il y a aussi **innotop** qui vous permet de visualiser la santé de vos table **innoDB**. Nous voyons que __MySQL__ pousse de plus en plus pour ce système de stockage. 

Sous __Debian__ la commande est directement disponible dans le packaque de __mysql-client__ 

Voici un exemple d'utilisation :

        When   Load  QPS     Slow  QCacheHit  KCacheHit  BpsIn   BpsOut
        Now    0.02  499.68     0      0.00%    100.00%  47.87k  84.26k
        Total  0.00   25.86     0      0.00%     99.96%   2.28k   2.82k

        Cmd    ID      State   User   Host           DB           Time   Query                                                                                        
        Query    4709  update  bob    localhost      ma_super_BD  00:00  insert into app_article (texte,text_status,info) values (" lpc_ich: Resource conflict(s) foun


Vous avez un très bon article disponible sur les possibilité __d'innotop__ [innotop real time](https://www.percona.com/blog/2013/10/14/innotop-real-time-advanced-investigation-tool-mysql/)

Une fois démarré, vous pouvez faire **?** afin de voir les vu disponible , voici le résultat :

![option-innotop.png](./imgs/option-innotop.png)

Je manque d'activité pour que ce soit représentatif , l'idée est qu'avec les touches :

* **B** :  vous visualisez les __buffers__ de __innoDB__
* **I** : les accès disque de __innoDB__ 
* etc :D

### Percona-monitoring-plugins

L'avantage et l'inconvénient des solutions présenté préalablement est que vous n'avez pas une vision de la santé dans le temps. Le système __Percona Monitoring Plugins__ vous permettra à l'aide de graphique de visualisé la santé de vos base de données sur une longue période . Vous pourrez ainsi voir une dégradation des performances si ceci est minimal dans le temps tranquillement , jusqu'à atteindre un point critique.
Bien entendu le désavantage est qu'il y a un délais dans la collecte d'information donc en combinaisons avec les 2 solutions présenté préalablement vous aurez l'ensemble des informations requis.

Voici un exemple du résultat : 

![percona-perf-cacti.png](./imgs/percona-perf-cacti.png)


Voici la documentation officiel du produit : [Percona monitoring plugins](https://www.percona.com/doc/percona-monitoring-plugins/1.1/cacti/installing-templates.html)

TODO : faire un test



## <a name="change_seting" /> Changement de configuration pour la performance.


Nous allons donc voir quelques options disponible , voici la marche à suivre que je vous suggère :

* Ne changez pas trop de valeur à la fois afin d'être en mesure d'identifier celle qui est la meilleur dans votre situation 
* Aillez des métriques d'utilisation de la base de donnée, afin de bien voir les impactes dans le temps et de voir s'il y a eu un effet de bord

Car c'est bien de réussir à identifier les problèmes mais faut bien les corriger un jour :D.

Nous allons voir les configurations selon que ce soit de type **innoDB** , **MyISAM** ou de manière général .

### <a name="optimize_innodb" /> Optimisation d'innoDB

Voici des options de configuration disponible :

        #INNODB
        innodb_buffer_pool_size = 378M
        innodb_log_file_size = 64M
        innodb_file_per_table=1

        innodb_thread_concurrency = 128
        innodb_flush_method = O_DIRECT

Alors là si vous copiez / collez cette configuration cash , ça risque de faire crash :P ou du moins de ne pas avoir le résultat désiré, il est important de comprendre ce que fait ces options ... C'est partie.

* **[innodb_buffer_pool_size](http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size)** (valeur par défaut 128M): Cette valeur doit être élevé surtout si votre serveur est dédié au service de base de donnée __MySQL__. Le système __innoDB__ utilise cette espace mémoire (**buffer**) pour mettre en cache les données ainsi que l'indexation. Plus la taille du __buffer__ grand plus le système de stockage réalisera les opérations en mémoire. Cette option vous permettra de réduire l'accès disque améliorant ainsi les performances de la base de données. Lors d'opération de modification __insert__, __update__, l'information sera mise à jour dans ce __buffer__ et écrit régulièrement. Bien entendu il est important de laisser de la mémoire pour les autres processus sur le système, nous ne voudrions pas que les autres applications __swap__, car __Mysql__ prend l'ensemble de la mémoire. Voici un exemple de valeur possible selon la mémoire disponible sur votre système , prendre en note que ceci est pour un serveur dédié à __MySQL__ :
    *  Mémoire total : __8GB__ RAM __=>__  valeur 5-6__GB__ 
    *  Mémoire total : __32GB__ RAM __=>__ valeur 20-25__GB__ 
    *  Mémoire total : __128GB__ RAM __=>__ valeur 100-120__GB__
Documentation disponible sur le sujet :
    * Plus d'information sur le système de **buffer d'innodb** disponible sur le site de __MySQL__ [innodb-buffer-pool](http://dev.mysql.com/doc/refman/5.5/en/innodb-buffer-pool.html). 
    * Un peu vieux mais les concepts reste les mêmes [percona - choosing-innodb-buffer](https://www.percona.com/blog/2007/11/03/choosing-innodb_buffer_pool_size/)
* **[innodb_log_file_size](http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html#sysvar_innodb_log_file_size)** (valeur par défaut 5M): Alors là attention choix difficile, le système **innodb** réalise des fichiers de logs qui sont utilisés lors des __crash recovery__  pour reconstruire les tables. Ils sont aussi nommé __redo log__ sur d'autre système de base de données. Donc il permette de rejoué les transactions qui non pas pu être écrit sur disques dans le __tablespace__, bien entendu la réalisation d'écriture prend du jus et surtout de l'accès disque qui est lent par nature. L'objectif ici est de réduire le nombre de fichiers écrit en aillant des fichiers plus gros au lieu d'avoir une gestion de plusieurs petit fichier. En d'autre mot en réduisant le nombre de __checkpoint__ par fichier nous améliorons les performances d'accès disque, cependant en cas de restauration des données après un crash le système devra parcourir des plus gros fichier ceci prendra plus de temps.
* **[innodb_file_per_table](http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html#sysvar_innodb_file_per_table)** : J'ai décidé de le remettre ici , nous ne parlons pas d'optimisation de performance ici, mais plutôt d'utilisation de l'espace disque dur. Car si nous voulons de la performance je vous suggère de ne pas mettre cette option cependant dans la réalité la récupération d'espace disque est importante.
* **[innodb_flush_method](http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html#sysvar_innodb_flush_method)** (valeur par défaut __NULL__) : L'objectif de cette configuration est de supprimé le double **buffering**, si vous avez configurer de manière approprié la valeur **[innodb_buffer_pool_size](http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size)** , vous avez mis en cache les opérations. Si nous laissons la valeur **innodb_flush_method** telle quel que va t'il se passer quand __l'OS__ va recevoir l'instruction d'écriture sur le disque il va le caché aussi (__bufferiser__) résultat nous avons un double __buffer__ . Bien entendu si vous n'avez confiant en votre système d'exploitation, si vous n'avez pas de RAID, vous pouvez laisser le double __caching__ , mais c'est inutile , pas optimal ;-). Regardez les options disponible sur le site de __MySQL__.
    * L'article ici revient sur le sujet [percona - choosing-innodb-buffer](https://www.percona.com/blog/2007/11/03/choosing-innodb_buffer_pool_size/)
* **[innodb_flush_log_at_trx_commit](http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit)** (valeur par défaut 1) : Un choix encore plus difficile :D, et oui ça se complique . Par défaut le système **innodb** est **[ACID compliant](https://fr.wikipedia.org/wiki/Propri%C3%A9t%C3%A9s_ACID)**, (atomicité, cohérence, isolation et durabilité) sont un ensemble de propriétés qui garantissent qu'une transaction informatique est exécutée de façon fiable.  Ceci est l'idéal pour l'intégrité des données , cette valeur peut être idéale sur un serveur **master** , par contre ceci peut être intense si les disques dur sont plus lent. 
    * Valeur **1** : le système écrit dans les __redo log__ à chaque __commit__, garantissant les données.
    * Valeur **2** : le système va écrire chaque transaction , après le commit , dans le __log file__ qui sera __flushé__ sur le disque approximativement à chaque seconde. Ceci n'est cependant pas garantie selon le planificateur de tâche interne à __MySQL__. Par le fait même il y a un risque de perte de donnée advenant un crash du système.
    * Valeur **0** : avec cette configuration il n'y a pas d'écriture dans le __log file__ mémoire le système attendra l'opération de __flush__ pour enregistrer la transaction sur disque. Est-ce un problème **OUI** pour un serveur maître , peut-être pas pour un __slave__ dont l'ensemble des transactions fut déjà valider et qui est présent en backup uniquement !
* **[innodb\_thread\_concurrency](http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html#sysvar_innodb_thread_concurrency)** (valeur par défaut 0) : La configuration suivant n'est pertinente QUE si vous partagez le service __MySQL__ avec d'autre application !! Par défaut le système __MySQL__ ne limite pas le nombre de __thread__ pour **innoDB** , la limitation est celle du système d'exploitation. Comme nous l'avions vu lors de la formation sur apache et les performances parfois il vaut mieux limiter l'utilisation du système pour qu'il réponde bien plutôt que de le laisser prendre toute les ressources et s'écraser tous seul. Voici un exemple fournit par le site __MySQL__ de configuration possible :

         If your workload is consistently heavy or occasionally spikes, start by setting innodb_thread_concurrency=128, and lowering the value to 96, 80, 64, and so on, until you find the number of threads that provides the best performance. For example, suppose your system typically has 40 to 50 users, but periodically the number increases to 60, 70, or even 200. You find that performance is stable at 80 concurrent users but starts to show a regression above this number. In this case, you would set innodb_thread_concurrency=80 to avoid impacting performance. 

### <a name="optimize_MyISAM" /> Optimisation de MyISAM

Voici des options de configuration disponible :

        #MyISAM
        key_buffer_size = 128M

Bon je suis un peu emmerdé, car j'ai pas trouvé grand chose sur le sujet, la majorité des optimisations que j'ai trouvé s'applique autant pour __MyISAM qu'innoDB__ très peu de paramètre pour ce type de stockage. Ceci démontre clairement la tendance vers __innoDB__.

* **[key_buffer_size](http://dev.mysql.com/doc/refman/5.5/en/server-system-variables.html#sysvar_key_buffer_size)** (valeur par défaut 8M) : Nous retrouvons le même concepts de conserver les index en mémoire afin d'optimiser la recherche au lieu de parcourir le disque. Il est important de noter que ceci n'inclut QUE les **index** aucun donnée , donc pas besoin de mettre un valeur énorme . La documentation de __MySQL__ suggère de définir cette valeur de 25% de la mémoire , j'aime pas trop les pourcentages du genre car quand on a un serveur de 8G et de 128G ce n'est pas tous à fait la même chose. Le site offre une technique pour calculer / valider votre configuration .

            You can check the performance of the key buffer by issuing a SHOW STATUS statement and examining the Key_read_requests, Key_reads, Key_write_requests, and Key_writes status variables. (See Section 13.7.5, “SHOW Syntax”.) The Key_reads/Key_read_requests ratio should normally be less than 0.01. The Key_writes/Key_write_requests ratio is usually near 1 if you are using mostly updates and deletes, but might be much smaller if you tend to do updates that affect many rows at the same time or if you are using the DELAY_KEY_WRITE table option. 

 
### <a name="optimize_global" /> Optimisation applicable à l'ensemble 

Voici des options disponibles :

        tmp_table_size = 32M
        max_heap_table_size = 32M
        thread_cache_size = 50
        table_open_cache = 800
        open_files_limit = 65535

        skip_name_resolve = ON
        max_connections = 500

* **[tmp\_table\_size](http://dev.mysql.com/doc/refman/5.5/en/server-system-variables.html#sysvar_tmp_table_size) et [max\_heap\_table\_size](http://dev.mysql.com/doc/refman/5.5/en/server-system-variables.html#sysvar_max_heap_table_size)** (valeur par défaut : 16M): Ceci permet d'indiquer à __MySQL__ la quantité de mémoire qui sera utilisé pour les tables temporaire, ceci est particulièrement  intéressant si vous avez plusieurs **GROUP BY** dans vos requêtes __SQL__. Le fonctionnement est le suivant lors de la requête __MySQL__ met en mémoire une table temporaire, si cette dernière dépasse la valeur donné (exemple 32M) il réalisera une table sur disque pour faire le traitement. Bien entendu une table sur disque sera plus couteux en terme de ressource, les 2 valeurs sont conjointe vous devez donc ajuster les 2 valeurs.

* **[thread\_cache\_size](http://dev.mysql.com/doc/refman/5.5/en/server-system-variables.html#sysvar_thread_cache_size)** (valeur par défaut 0): Cette configuration permet d'indiquer à __MySQL__ de réutiliser les __thread__ utilisé lors des connexions. Par défaut le fonctionnement est le suivant quand une nouvelle connexion est établie un __thread__ est démarrer quand la connexion est terminé le __thread__ est détruit. Le changement de valeur , selon la documentation à peu d'impact sur la performance, sauf si vous avez un nombre important de connexion par second. Bon important c'est quoi , le point de référence qui est donnée est 100 par seconde. Si vous centralisez votre base de donnée pour plusieurs application vous constaterez que ceci peut arrivé vite. Si vous modifiez la valeur vous serez en mesure de valider l'impacte de la configuration en analysant le nombre connexion (__SHOW GLOBAL STATUS LIKE 'Connections';__) en comparaison au nombre de __thread__ créés (__SHOW GLOBAL STATUS LIKE 'Threads_created';__). 
* **[table\_open\_cache](http://dev.mysql.com/doc/refman/5.5/en/server-system-variables.html#sysvar_table_open_cache)** (valeur par défaut 400): Cette valeur indique le nombre de table qui pourra être ouvert par chaque __thread__. Si vous augmentez cette valeur vous devrez aussi modifier la valeur de la configuration **[open\_files\_limit](http://dev.mysql.com/doc/refman/5.5/en/server-system-variables.html#sysvar_open_files_limit)**. Pour connaître la valeur à définir consultez le résultat de la commande __SHOW GLOBAL STATUS LIKE 'open_tables';__.


* **[max\_connections](http://dev.mysql.com/doc/refman/5.5/en/server-system-variables.html#sysvar_max_connections)** (valeur par défaut 151): Permet de définir le nombre maximal de connexion accepté par __MySQL__ , si vous avez une valeur trop basse vous aurez le message suivant lors d'un tentative de connexion : __“Too many connections”__.
* **[skip\_name\_resolve](http://dev.mysql.com/doc/refman/5.5/en/server-system-variables.html#sysvar_skip_name_resolve)** (valeur par défaut OFF): Avec cette instruction lorsque le client établera une connexion au système __MySQL__ ne réalisera PAS de reverse __DNS__ sur l'adresse IP. Je vous conseille d'activer cette option si vous avez un grand nombre de connexion provenant de plusieurs machines. Par contre ceci aura un impacte sur votre configuration surtout pour l'attribution d'accès, lors de l'instruction **GRANT** vous ne pourrez plus utilise le nom de domaine pour l'attribution d'accès, mais uniquement l'adresse IP. Est-ce que ceci peut avoir un __GROS__ gain de performance je ne le crois pas , mais parfois une combinaison d'opération donne un bon résultat.

### <a name="ref_optimisation" /> Référence 

* http://dev.mysql.com/doc/refman/5.5/en/server-configuration.html
* http://www.codingpedia.org/ama/optimizing-mysql-server-settings/
* https://www.percona.com/blog/2007/11/03/choosing-innodb_buffer_pool_size/
* https://www.percona.com/blog/2014/01/28/10-mysql-performance-tuning-settings-after-installation/
* https://support.rackspace.com/how-to/configuring-mysql-server-on-ubuntu/
* https://www.percona.com/doc/percona-monitoring-plugins/1.1/cacti/installing-templates.html


# <a name="perms_mysql_tables" /> Manipulation des permissions avec mysql sans le grant

Bon voyons l'étape **brutale** :D , car bon c'est ça qui est cool avec le libre, il y a la bonne méthode jolie avec les commandes :) , puis y a la méthode ou tu modifies le fichier en arrière puis ça marche :D. Je ne vous dis pas d'utiliser cette méthode !!! Mon objectif avec la démonstration est de démontré comment __Mysql__ stock l'information des permissions , le savoir est bien !

Telle mentionné, le système __MySQL__ à besoin de la base de données __mysql__ pour fonctionné afin de conserver les informations du système dont les permissions utilisateur. Nous allons créer une nouvelle base de donnée et refaire la même opération de création d'utilisateur mais sans **create user** et **sans les grant** . 
Pour les personnes qui disent **POURQUOI ?** vous pouvez passer au prochaine chapitre, car **la question n'est pas pourquoi mais COMMENT ?** .

Allez on crée la base de donnée : **zer\_bd**

        mysql> create database ze_bd ;
            Query OK, 1 row affected (0.00 sec)

        mysql> show databases;
        +--------------------+
        | Database           |
        +--------------------+
        | information_schema |
        | ma_super_BD        |
        | mysql              |
        | performance_schema |
        | ze_bd              |
        +--------------------+
        5 rows in set (0.00 sec)

Nous sommes avec l'utilisateur **root** nous allons basculer sous la base de donnée __mysql__

        mysql> use mysql;
        Database changed


# <a name="forgot_root_password" /> Instruction si vous avez perdu votre mot de passe root

# <a name="reference" /> Références

* Stockage des informations
    * [Caractéristique stockage](http://dev.mysql.com/doc/refman/5.5/en/pluggable-storage-common-layer.html)
    * [Module de stockage](http://dev.mysql.com/doc/refman/5.5/en/pluggable-storage-overview.html)
    * [Storage engines](http://dev.mysql.com/doc/refman/5.5/en/storage-engines.html)
    * Type de stocakge :
        * [Innodb storage](dev.mysql.com/doc/refman/5.5/en/innodb-storage-engine.html)
        * [MyISAM storage](http://dev.mysql.com/doc/refman/5.5/en/myisam-storage-engine.html)
        * [Memory storage](http://dev.mysql.com/doc/refman/5.5/en/memory-storage-engine.html)
        * [Federated storage](http://dev.mysql.com/doc/refman/5.5/en/federated-storage-engine.html)
        * [csv storage](http://dev.mysql.com/doc/refman/5.5/en/csv-storage-engine.html)
        * [Blackhole storage](http://dev.mysql.com/doc/refman/5.5/en/blackhole-storage-engine.html)
    * InnoDB
        * [File Space Management](http://dev.mysql.com/doc/refman/5.5/en/innodb-file-space.html) 
        * [SHOW TABLES STATUS](http://dev.mysql.com/doc/refman/5.5/en/show-table-status.html)
        * [Configuration innodb](http://dev.mysql.com/doc/refman/5.5/en/innodb-init-startup-configuration.html#innodb-startup-data-file-configuration)
        * [InnoDB par table](http://dev.mysql.com/doc/refman/5.7/en/innodb-multiple-tablespaces.html)
        * [InnoDB file_format](http://dev.mysql.com/doc/refman/5.5/en/innodb-parameters.html#sysvar_innodb_file_format)
    * Santé des tables
        * [check table](http://dev.mysql.com/doc/refman/5.5/en/check-table.html#check-table-innodb)
        * [CHECK ANALYZE](http://dev.mysql.com/doc/refman/5.5/en/analyze-table.html)
        * [CHECKSUM TABLE](http://dev.mysql.com/doc/refman/5.5/en/innochecksum.html)
        * [REPAIR TABLE](http://dev.mysql.com/doc/refman/5.5/en/repair-table.html)
        * [REPAIR INNODB](https://twindb.com/repair-corrupted-innodb-table-with-corruption-in-secondary-index/)
        * [REPAIR INNODB blog](http://blackbird.si/mysql-corrupted-innodb-tables-recovery-step-by-step-guide/)
    * Fichier de configuration
        * [Mysql cnf option](http://dev.mysql.com/doc/refman/5.5/en/option-files.html)   
    * Configuration de __Mysql__ serveur
        * [http://dev.mysql.com/doc/refman/5.5/en/server-configuration.html](http://dev.mysql.com/doc/refman/5.5/en/server-configuration.html)
        * [http://www.codingpedia.org/ama/optimizing-mysql-server-settings/](http://www.codingpedia.org/ama/optimizing-mysql-server-settings/)
        * [https://www.percona.com/blog/2014/01/28/10-mysql-performance-tuning-settings-after-installation/](https://www.percona.com/blog/2014/01/28/10-mysql-performance-tuning-settings-after-installation/)
        * [https://support.rackspace.com/how-to/configuring-mysql-server-on-ubuntu/](https://support.rackspace.com/how-to/configuring-mysql-server-on-ubuntu/)
        * [percona - choosing innodb buffer](https://www.percona.com/blog/2007/11/03/choosing-innodb_buffer_pool_size/)
        * [innodb-best-practices](http://dev.mysql.com/doc/refman/5.5/en/innodb-best-practices.html)
    * Optimisation de __Mysql__ :
        * http://dev.mysql.com/doc/refman/5.5/en/server-configuration.html
        * http://www.codingpedia.org/ama/optimizing-mysql-server-settings/
        * https://www.percona.com/blog/2007/11/03/choosing-innodb_buffer_pool_size/
        * https://www.percona.com/blog/2014/01/28/10-mysql-performance-tuning-settings-after-installation/
        * https://support.rackspace.com/how-to/configuring-mysql-server-on-ubuntu/
        * https://www.percona.com/doc/percona-monitoring-plugins/1.1/cacti/installing-templates.html




# <a name="docker_start_change" /> Changement de la commande start d'un docker

Premièrement récupérer le ID du conteneur :

        $ docker ps -a 
        [ ... OUTPUT COUPÉ ...] 
        286a58149acd    mysql:5.5    "docker-entrypoint.sh"    3 weeks ago    Exited (1) 2 seconds ago         x3-mysql-p
        [ ... OUTPUT COUPÉ ...] 
 
Inspection du conteneur :

    	$ docker inspect 286a58149acd
    	[
    	    {
            	"Id": "286a58149acd3d333b808764ee053b389b394a06a792483150df0e7b30dd9a78",
            	"Created": "2016-10-05T23:45:55.899578983Z",
    	        "Path": "docker-entrypoint.sh",
    	        "Args": [
    	            "mysqld"
    	        ],
                "State": {
                    "Status": "exited",
                    "Running": false,
                    "Paused": false,
                    "Restarting": false,
                    "OOMKilled": false,
                    "Dead": false,
                    "Pid": 0,
                    "ExitCode": 1,
                    "Error": "",
                    "StartedAt": "2016-10-31T20:45:47.097872323Z",
                    "FinishedAt": "2016-10-31T20:45:48.286121255Z"
                },
                "Image": "sha256:402df65b897ec438b848525dc5812bb4b435aef153f9da617748afcd34c79664",
                "ResolvConfPath": "/var/lib/docker/containers/286a58149acd3d333b808764ee053b389b394a06a792483150df0e7b30dd9a78/resolv.conf",
                "HostnamePath": "/var/lib/docker/containers/286a58149acd3d333b808764ee053b389b394a06a792483150df0e7b30dd9a78/hostname",
                "HostsPath": "/var/lib/docker/containers/286a58149acd3d333b808764ee053b389b394a06a792483150df0e7b30dd9a78/hosts",
                "LogPath": "/var/lib/docker/containers/286a58149acd3d333b808764ee053b389b394a06a792483150df0e7b30dd9a78/286a58149acd3d333b808764ee053b389b394a06a792483150df0e7b30dd9a78-json.log",


Nous allons éditer le fichier de configuration du conteneur :D , car on est des **H4x0r** !! 
Normalement le fichier est contenu dans /var/lib/docker/containers/ et l'ID , si vous le trouvez pas **Grep** est ton ami :D , j'espère que le répertoire est pas trop gros :D 

**IMPORTANT** avant d'éditer le fichier il faut arrêter le service de docker :-( , ouin ,car docker est plus **H4x0r** que nous il va réécrire le fichier :-/.

          $ sudo systemctl stop docker.service
          $ sudo vim /var/lib/docker/containers/286a58149acd3d333b808764ee053b389b394a06a792483150df0e7b30dd9a78/config.v2.json

Nous devons modifier les arguments suivant  : 

            "Path":"docker-entrypoint.sh","Args":["mysqld"],

Pour :

            "Path":"/usr/bin/tail","Args":["-f","/dev/null"],

On redémarre le service docker 

        $ sudo systemctl start  docker.service

On valide la nouvelle configuration :

        $ docker ps -a | grep 286a58149acd
        286a58149acd     mysql:5.5      "/usr/bin/tail -f /de"    3 weeks ago    Exited (0) 54 seconds ago             x3-mysql-p

On peut maintenant démarrer le conteneur  :

        $ docker start -i -a x3-mysql-p
        [ ... La console restera comme ça ...]

Sur un autre terminal :

        $ docker exec -it x3-mysql-p bash
        root@x3-sql:/#
        
**ET VOILÀ**

Maintenant on peut même roulé le démarrage SQL tranquille

        root@x3-sql:/# /usr/local/bin/docker-entrypoint.sh mysqld
        161031 21:32:51 [Note] mysqld (mysqld 5.5.52) starting as process 62 ...
        161031 21:32:51 [Note] Plugin 'FEDERATED' is disabled.
        161031 21:32:51 InnoDB: The InnoDB memory heap is disabled
        161031 21:32:51 InnoDB: Mutexes and rw_locks use GCC atomic builtins
        161031 21:32:51 InnoDB: Compressed tables use zlib 1.2.3
        161031 21:32:51 InnoDB: Using Linux native AIO
        161031 21:32:51 InnoDB: Initializing buffer pool, size = 128.0M
        161031 21:32:51 InnoDB: Completed initialization of buffer pool
        161031 21:32:51 InnoDB: highest supported file format is Barracuda.
        161031 21:32:51  InnoDB: Waiting for the background threads to start
        161031 21:32:52 InnoDB: Error: tablespace size stored in header is 1664 pages, but
        161031 21:32:52 InnoDB: the sum of data file sizes is only 1600 pages
        161031 21:32:52 InnoDB: Cannot start InnoDB. The tail of the system tablespace is
        161031 21:32:52 InnoDB: missing. Have you edited innodb_data_file_path in my.cnf in an
        161031 21:32:52 InnoDB: inappropriate way, removing ibdata files from there?
        161031 21:32:52 InnoDB: You can set innodb_force_recovery=1 in my.cnf to force
        161031 21:32:52 InnoDB: a startup if you are trying to recover a badly corrupt database.
        161031 21:32:52 [ERROR] Plugin 'InnoDB' init function returned error.
        161031 21:32:52 [ERROR] Plugin 'InnoDB' registration as a STORAGE ENGINE failed.
        161031 21:32:52 [ERROR] Unknown/unsupported storage engine: InnoDB
        161031 21:32:52 [ERROR] Aborting

        161031 21:32:52 [Note] mysqld: Shutdown complete

        root@x3-sql/#

Il y a un Issue sur __github__ pour le faire en lui passant un argument , en attendant ça MARCHE :D 
