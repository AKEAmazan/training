<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 

# <a name="storage_engine" /> Stockage des informations

__MySQL__ a un système de stockage des informations modulaire (__pluggable__) , ceci permet d'utiliser le système adéquat selon vos besoins. Dans les faits ceci est principalement lors de l'optimisation que l'on modifie le système de stockage. Le gros avantage est que le système de stockage est complètement transparent pour les applications ! Ceci permet aussi d'accroitre les possibilités de __MySQL__.

Voici une liste non exhaustive des raisons de choisir un type de stockage particulier :

* **Concurrence** : Certain système de stockage offre un système de verrou (__LOCK__) plus granulaire (par exemple : uniquement verrou par enregistrement / ligne) . Choisir le bon système de stockage peut permettre de réduire le temps de traitement (__overhead__) requis pour le verrou, améliorant la performance générale.
* **Support des Transactions** : Support des transactions ( couvert dans le chapitre précédent __COMMIT__ et __ROLLBACK__ ) bien que toutes les applications n'en n'ont pas besoin ceci peut être pratique. 
* **Intégrité** : Selon le système de stockage que vous utilisez vous pouvez avoir ou non le système référentiel fort avec les clés étrangère , bien entendu cette ajout ayant un coût si vous désirez réduire la charge sur le serveur de BD opté pour un système sans référentiel fort vous aurez un gain de performance.
* **Stockage physique** : Les modules choisie vous permet d'avoir un système de stockage approprié pour vos besoin ( __csv__, mémoire, ...)
* **Indexation** : Les systèmes de stockage offre une indexation propre, optimisé selon la situation. Vous retrouverez l'indexation __B-tree__ pour l'ensemble des systèmes de stockage.
* **Cache mémoire** : L'ensemble des systèmes de stockage offre une fonctionnalité minimal de mise en mémoire des requêtes, mais certain système offre une optimisation pour ce besoin. (exemple __MySQL's high-speed Query Cache__)
* **Assistant de performance** : De manière général , l'engin peut être optimal pour la lecture ou l'écriture , offrir des utilitaires d'analyse de performance ...
* **Fonctionnalité particulière** : Le système de stockage peut offrir des fonctionnalités particulière telle que le support des données __GéoSpacial__, ou une gestion plus granulaire des accès de sécurité.

* Référence 
    * [Caractéristique stockage](http://dev.mysql.com/doc/refman/5.5/en/pluggable-storage-common-layer.html)
    * [Module de stockage](http://dev.mysql.com/doc/refman/5.5/en/pluggable-storage-overview.html)

## <a name="engine_available" /> Engins disponible

Documentation __MySQL__ de référence : [Storage engines](http://dev.mysql.com/doc/refman/5.5/en/storage-engines.html)

Premièrement voyons ce qui est disponible sur notre environnements, vous n'avez pas besoin d'être l'administrateur pour visualiser les engins disponibles 

        $ mysql -u bob -p
        Enter password:
        mysql> SHOW ENGINES ;
        +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
        | Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
        +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
        | PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
        | MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
        | CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
        | BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
        | MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
        | InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
        | ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
        | MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
        | FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
        +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
        9 rows in set (0.00 sec)

Nous pouvons donc voir l'ensemble des engins offert sur notre base de données prenons quelque minutes pour identifier les options disponibles :

* **InnoDB** __défaut__ : Depuis la version 5.5.5 **InnoDB** est le système de stockage par défaut originalement c'était **MyISAM** qui était privilégié. __InnoDB__ support le système de transaction (__commit__, __rollback__, ...) , il a aussi la fonctionnalité de __crash-recovery__ afin de protéger les données en cas de problème du système. **InnoDB** a la caractéristique de réalisé des verrous par enregistrement et non sur l'ensemble de la table , les données sont stocké dans un index de type __cluster__ afin de réduire __l'I/O__ (accès disque) pour les requêtes courantes particulièrement sur les clés primaires. Plus d'information disponible sur la documentation de __MySQL__ [Innodb storage](dev.mysql.com/doc/refman/5.5/en/innodb-storage-engine.html)
* **MyISAM** : Avant la version 5.5.5 c'était le système de stockage par défaut, ce système de stockage n'offre pas la possibilité d'utiliser le système de transaction. Il n'offre pas non plus la possibilité d'utiliser les clés étrangère pour l'intégrité des données. Le système de verrou est sur l'ensemble de la table et non pour l'enregistrement, bon à ce point vous vous dites mais pourquoi j'utiliserai ce système il fait moins de chose **qu'innoDB**. **MyISAM** support un plus grand nombre de données que **InnoDB** 256TB pour être exacte :D. Il support la cherche indexé dans l'ensemble des champs teste , non disponible dans **innoDB** avant la version 5.6.4. L'absence de mécanisme de validation en a fait un système plus performant pour les accès en **Lecture** et fut très populaire pour l'indexation des champs **TEXT** principalement pour les applications web . Documentation sur __MySQL__ [MyISAM storage](http://dev.mysql.com/doc/refman/5.5/en/myisam-storage-engine.html)
* **Memory** : Permet d'utiliser la **RAM** du système pour stocké les informations, bien entendu ce mécanisme est très très performant, cependant les informations sont éphémère. Il n'y a aucun mécanisme en cas de crash du système, le système ressemble à **MyISAM** pas de clé étrangère, pas de transaction , ... Documentation sur __MySQL__ [Memory storage](http://dev.mysql.com/doc/refman/5.5/en/memory-storage-engine.html).
* **Archive** : Comme son nom l'indique ce type de stockage est utilisé pour l'archivage de donnée, la particularité est d'offrir la possibilité de stockage SANS limite. Bien entendu il ne faut pas s'attendre à avoir de la performance pour ce type de stockage , il n'y a pas d'indexation des données ceci à donc un gros impact sur la performance. Il y a tout de même une mise en cache des requêtes. Documentation sur __MySQL__ [Archive storage](http://dev.mysql.com/doc/refman/5.5/en/archive-storage-engine.html).
* **Federated** : Vous avez la possibilité de créer un serveur __MySQL__ logique qui regroupe un grand nombre de serveur __MySQL__. Quand nous utilisons les système de stockage classique (__MyISAM__, __InnoDB__, ...) la définition de la table ET les données sont sur la même machine, avec le mode **fédéré** les donnés sont sur un serveur distant .Documentation __MySQL__ [Federated storage](http://dev.mysql.com/doc/refman/5.5/en/federated-storage-engine.html)
    ![se-federated-structure.png](./imgs/se-federated-structure.png)
* **CSV** : __Comma Separated Values__ soit Valeur Séparés par des Virgules , ceci permet d'avoir un fichier avec une virgule qui sépare les champs. La performance est très limité cependant ceci peut être pratique pour extraire de l'information de la base de données. Documentation __MySQL__ [csv storage](http://dev.mysql.com/doc/refman/5.5/en/csv-storage-engine.html)
* **BlackHole** : Alors celui la j'essaye encore de voir l'utilité , la documentation parle d'utilité lors de la réplication pour ne pas répliquer certain données, mais bon personnellement j'exclus les tables que je ne veux pas ... Bon j'oublie de donner l'explication, normale **blackhole** c'est le trou noir. Le système vous permet de créer un table d'insérer des donnes mais tous est envoyé à la poubelle. Donc lors d'un **SELECT** le système ne renvoie AUCUNE information. Je trouve ça bien même si je ne vois pas l'utilité :D . Documentation __MySQL__  [Blackhole storage](http://dev.mysql.com/doc/refman/5.5/en/blackhole-storage-engine.html)

Voici un résumé des fonctionnalités et du supports selon l'engin :

![summary_storage_engine.png](./imgs/summary_storage_engine.png)


## <a name="engine_use" /> Utilisation des systèmes de stockage

Pour une même base de données plusieurs engins peuvent être utilisé, selon vos besoins , voici un petit exemple d'utilisation :

Vous avez un site de jeu , l'ensemble des informations utilisateurs ( nom, mot de passe, contact , ... ) sont stocké dans une base de données de type **InnoDB** ou **MyISAM** , quand les utilisateurs débutes une partie (éphémère) et jugé non-critique :P vous pourriez créer une table : partie\_2764 (partie\_#de-la-partie) cette table serait définie avec l'engin **Memory** pour être optimisé au maximum en cas de crash ce n'est pas critique. 

## <a name="view_vars_change_it"/> Visualisation et modification des variables

* max_connexion ...

# <a name="perms_mysql_tables" /> Manipulation des permissions avec mysql sans le grant

Bon voyons à l'étape **brutale** :D , car bon c'est ça qui est cool avec le libre, il y a la bonne méthode jolie avec les commandes :) , puis y a la méthode ou tu modifies le fichier en arrière puis ça marche :D. Je ne vous dis pas d'utiliser cette méthode !!! Mon objectif avec la démonstration est de démontré comment __Mysql__ stock l'information des permissions , le savoir est bien !

Telle mentionné, le système __MySQL__ à besoin de la base de données __mysql__ pour fonctionné afin de conserver les informations du système dont les permissions utilisateur. Nous allons créer une nouvelle base de donnée et refaire la même opération de création d'utilisateur mais sans **create user** et **sans les grant** . 
Pour les personnes qui disent **POURQUOI ?** vous pouvez passer au prochaine chapitre, car **la question n'est pas pourquoi mais COMMENT ?** .

Allez on crée la base de donnée : **zer\_bd**

        mysql> create database ze_bd ;
            Query OK, 1 row affected (0.00 sec)

        mysql> show databases;
        +--------------------+
        | Database           |
        +--------------------+
        | information_schema |
        | ma_super_BD        |
        | mysql              |
        | performance_schema |
        | ze_bd              |
        +--------------------+
        5 rows in set (0.00 sec)

Nous sommes avec l'utilisateur **root** nous allons basculer sous la base de donnée __mysql__

        mysql> use mysql;
        Database changed


# <a name="reference" /> Références

* Stockage des informations
    * [Caractéristique stockage](http://dev.mysql.com/doc/refman/5.5/en/pluggable-storage-common-layer.html)
    * [Module de stockage](http://dev.mysql.com/doc/refman/5.5/en/pluggable-storage-overview.html)
    * [Storage engines](http://dev.mysql.com/doc/refman/5.5/en/storage-engines.html)
    * Type de stocakge :
        * [Innodb storage](dev.mysql.com/doc/refman/5.5/en/innodb-storage-engine.html)
        * [MyISAM storage](http://dev.mysql.com/doc/refman/5.5/en/myisam-storage-engine.html)
        * [Memory storage](http://dev.mysql.com/doc/refman/5.5/en/memory-storage-engine.html)
        * [Federated storage](http://dev.mysql.com/doc/refman/5.5/en/federated-storage-engine.html)
        * [csv storage](http://dev.mysql.com/doc/refman/5.5/en/csv-storage-engine.html)
        * [Blackhole storage](http://dev.mysql.com/doc/refman/5.5/en/blackhole-storage-engine.html)

# <a name="configue" /> Configuration de mysql (mysql.cnf +  ~/.my.cnf)

# <a name="performance" /> Configuration de performance

# <a name="crash_recovery" /> Système de recupération et validation de la santé des tables

# <a name="mysql_replication" /> Mise en place d'une replication Mysql
# <a name="mysql_backup" /> Réalisation d'un backup de(s) base(s) de données

 
