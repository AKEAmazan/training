# Puppet ( Système de gestion de configuration ) 

**Puppet** est un système de gestion de configuration de système qui permet de gérer les systèmes d'exploitations :

* GNU/Linux 
* Mac OS X 
* Ms Windows

Il est existe version de puppet :

* **Version libre** qui permet de gérer les déploiements système et applicatif, et accepte les machines virtuelles type Amazon EC2.
* **Version commercial** permet en plus, de gérer les machines virtuelles VMware, d'avoir une interface graphique de gestion, d'automatiser et d'orchestrer les déploiements, d'avoir une plateforme de développement pour tous les environnements, de gérer individuellement les droits utilisateurs.

Puppet est principalement écrit en __Ruby__ un point fort pour certain , une contrainte pour d'autre :). Je vous laisserai faire votre choix, avec l'expérience.


## C'est quoi un système de gestion de configuration ?

Avant de parler de __puppet__ proprement dit , voyons c'est quoi un [système de gestion de configuration](https://fr.wikipedia.org/wiki/Gestion_de_configuration). L'objectif d'un gestionnaire de configuration est de permettre de gérer la configuration du système, j'espère que vous étiez assis en lisant cette phrase pleine de vérité :P. Au delà de cette tautologie , voyons des cas concrètes .

* **Permettre rapidement de mettre en place la configuration d'un système** ( système d'exploitation , logiciel , composante , ...) : Si vous avez quelques serveurs à mettre en place , combien de temps devez vous mettre sur le système pour qu'il soit opérationnel ? 4 heures , 2 heures ... ? Il est probable que le temps varie, selon le rôle du système. Avec un système de gestion de configuration, vous serez en mesure de définir des règles , des instructions qui décriront le processus de configuration qui sera réalisé sur le système. En d'autre mot l'idée est de délégué la tâches de l'ensemble du processus de configuration à une application.
* **Erreur de configuration** :  La plus grosse perte de temps,  lors de la mise en place d'un système est lorsqu'une erreur se glisse dans la configuration , que nous parlions d'une faute de frappe , d'une erreur d'inattention et on saute une section , ... Au mieux ça ne marche pas du tous alors on cherche , on cherche longtemps la virgule , le paramètre fautif. Autre situation, ça fonctionne mais pas dans une circonstance , donc ça fonctionne presque. Le signalement peut venir plusieurs semaine plus tard , donc pas planifié dans le projet , résultat difficile à gérer dans son temps . Le système de gestion de configuration applique bêtement , sans émotion , sans gueule de bois, même si l'OM à gagné la Ligue des Champions :P.
* **Uniformisation de la configuration** : Comme il n'y a pas d'opération manuelle réalisées la configuration est toujours intègre d'un système à l'autre , je ne dis pas toujours bonne :P , mais au moins si vous appliquez une configuration dans l'environnement de développement vous aurez la même configuration en production ! Vous serez donc en mesure d'identifier un problème de configuration dès l'environnement de développement. Bien entendu nous verrons comment paramétrer la configuration, car nous allouerons pas la même quantité de mémoire en développement qu'en production ...
* **Centralisation de la configuration** : Comme nous définirons la configuration à un endroit il est simple d'extraire la configuration du système rapidement sans établir de connexion sur le serveur et analyser la situation. 
* **Audit de conformité (exemple : PCI, ISO27001 , ... ) , conservation de la configuration** : En utilisant un système de gestion de configuration lors des audit de sécurité ou de conformité se sera beaucoup plus simple en démontrant l'utilisation du système plutôt que d'avoir 1 à 3 mois de préparation afin de valider et corriger manuellement chaque serveur avant l'audit. De plus selon le type de gestion de configuration, il est possible de conserver un état de la configuration , en d'autre mot s'il y a un changement réalisé sur le système par une opération manuel ce dernier sera réinitialisé afin d'être conforme à celle définie sur le système centrale. 
* **Changement et évolution de la configuration** : Vous avez peut-être déjà un système de création automatique de vos serveurs que nous parlions d'un Kickstart (RedHat) , Preseed (Debian) ou un système de template de création de VM , voir AIM pour amazon. Ceci fonctionne a merveille pour la création initiale de vos instances , cependant ceci est très limitatif pour l'évolution de vos configurations. Voici un exemple concret "problématique" , vous avez 40 serveurs qui furent créer avec le template / Kickstart ,... Vous constatez qu'il y a un problème avec la configuration SSH , vous désirez par exemple bloquer la fonctionnalité de __Port Forwarding__ , sans système de gestion vous devrez établir une connexion sur chaque système pour faire le changement en espérant que vous n'en n'oubliez pas UN !!
* **Conservation de l'évolution de la configuration** (en bonus ) : En utilisant un contrôleur de révision, en plus de l'ensemble des avantages mentionné plus haut, vous aurez aussi l'historique de l'évolution de vos configurations dans le temps , ainsi que l'intervenant ayant réalisé l'opération !

Mais comment faisions nous avant ? Les systèmes de gestion de configuration existe depuis LONGTEMPS que ce soit des solutions payante ou libre , un exemple est [CFEngine](https://en.wikipedia.org/wiki/CFEngine) ça version 1 est sortie en 1993 , mais honnêtement ce n'était pas très populaire. Résultat nous réalisions une panoplie de script (bash , ou autre) pour faire l'ensemble des opérations. Le gros inconvénient était que la gestion de ces scripts étaient très couteuse en temps et surtout nous n'avions pas une communauté afin d'améliorer la solution.

Les défis d'un gestion de configuration : 

1. **Gestion des particularités** : Le système de gestion de configuration permet d'unifier notre déploiement, si nous avions la même configuration partout ce serait très simple, la réalité est tout autre. Si nous prenons le cas d'une application , dans l'environnement de développement nous avons 4 Gigs de RAM alors que l'environnement de production en a 16 Gigs . Bien entendu si nous avons une application __java__ la configuration de la jvm ne sera pas identiques. Dans le même esprit, si nous prenons l'authentification au serveur via le service __ssh__, si nous définissons des limites d'accès par groupe nous n'aurons pas les mêmes permissions dans l'environnement de développement et l'environnement de validation (QA). Ceci est un défis autant technique que d'organisation de votre configuration centralisé.
2. **Sensibilisation des administrateurs et des power utilisateurs (sudo)** : Le système de gestion de configuration est très puissant, mais bien entendu il ajoute une couche de gestion additionnel. Si vous n'avez qu'une partie de votre équipe qui adhère à l'idée et que le reste continue à gérer manuellement les serveurs, il y aura un **clash**. Vous n'aurez pas de configuration intègre et la personne qui réalise la configuration manuellement verra, ça configuration écrasé. Il mentionnera que ça ne fonctionne pas à CAUSE du système automatisé ! Pour cette partie je vous conseille FORTEMENT d'identifier les fichiers gérer par le système de gestion centralisé (Nous y reviendrons). Le cas est identique pour les power utilisateurs , c'est utilisateur qui sont administrateurs sur le système s'il désactive votre système de configuration centralisé. Vous aurez un problème ,car vous partirez du principe que la configuration va s'appliquer mais non :P, puis le jeu du chat et de la souris va débuter si vous n'arrivez pas à avoir l'adhésion du Devs :D.
3. **Temps et Documentation** : Bien entendu nous avons tous réalisé des configurations manuellement sur le système ceci va "vite", car c'est un reflex . La monté en compétence prendra un peu de temps et donc ça prendra un plus de temps. Vous aurez un gain sur le long terme. La documentation de vos modules / playbook, classe, ... devra être aussi réalisé , sinon vous risquez d'avoir un duplicata des configurations ceci mélangera une personne qui cherche quelle configuration appliquer. Encore une fois la configuration prend du temps.
4. **Visibilité** : Dans le concept de DevOps, mais c'était déjà le cas dans le passé , assurez vous d'avoir une visibilité sur les clients géré par le système de gestion de configuration. Vous devez au moins avoir l'information suivante : Quand fut la dernière fois que le client fut synchronisé ? Est-ce qu'il y a eu des erreurs , si oui combien ?

# NOTE :

* __Puppet IDE__ : https://puppet.com/blog/geppetto-a-puppet-ide 


