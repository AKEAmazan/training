<meta http-equiv='Content-Type' content='text/html; charset=utf-8' />

<style>
pre {
      background:#f1edc6;
      border:black dashed 1px;
      font-style: italic;
      font-family: monospace;
      white-space: pre;
      margin: 1em 0;
      font-size: 14px;
      padding: 10px 10px;
     }
</style>

![docker Logo](https://docs.docker.com/dist/assets/images/logo.png "Optional title").

* [ Docker Introduction ](#docker_intro) 
       * [Un container n'est pas une VM](#docker_not_vm) 
       * [Pourquoi Docker](#why_docker) 
       * [Architecture de Docker](#architecture) 
           * [Creation d'un container](#creation) 
               * [Récupération d'une images depuis [dockerhub](https://hub.docker.com/)](#recup_img") 
               * [Visualisation des dockers présent ](#visualisation_docker) 
               * [Executer ce container](#run_docker) 
               * [Creation d'une image personnalisé](#create_custom) 
       * [Utilisation des dockers](#use_docker) 
           * [Réseau ](#network) 
           * [Utilisation des données dans un container ](#utilisation_donnee) 
               * [MountBind](#mountbind) 
               * [Assigner un nom au docker == un layer ](#name_docker) 
               * [Bruler un layer ( ajout d'une couche )](#burn_layer) 
               * [Definition de service au bootup](#bootup) 
       * [Le cycle de vie avec Docker](#lifecycle)

# <a name="docker_intro" /> Docker Introduction 

L'objectif de Docker est d'offire des conteneurs applicatif facile a déployer afin d'encapsulé l'application , incluant l'ensemble de ces dépendances et les versions de ces dernières.

* **With Docker you can separate your applications from your infrastructure AND treat your infrastructure like a managed application**
* Docker provides a way to run almost any application securely isolated in a container.
* The isolation and security allow you to run many containers simultaneously on your host. 
* The lightweight nature of containers, which run without the extra load of a hypervisor, means you can get more out of your hardware.
* distributing and shipping those containers to your teams for further development and testing

## <a name="docker_not_vm" />Un container n'est pas une VM

* Machine Virtuel (Vmware , KVM , ...)
  * Installation d'un système d'exploitation complet 
  * Emulation de l'ensemble du matériel ( CPU , mémoire , ... ) 
  * Installation des applications + librairie

* Container 
  * contient uniquement l'application et les librairies lié


<img src="https://serversideup.net/wp-content/uploads/2014/10/ContainerVsVM.png"  width="600px" />

Le système hôte est ainsi géré directement par le Docker Engine . On a ainsi une mutualisation qui permet de lancer les conteneurs de manière très rapide: le temps de lancement d'un conteneur est presque le même que le temps de lancement des applications qu'il contient. En effet, le système d'exploitation est déjà lancé. Donc pas de phase de démarrage ni d'initialisation de cette couche.

* Il est plus approprié de voir les contenaires comme une ou plusieurs applications chrooté (limité dans un espace du système) 
* Avantage est que chaque container à son stack ip , il est possible de les faire communiquer sans problème (pratique lors de connexion VPN.)
* Chaque container a sont accès root dédié 

Quelle sont les avantages de **docker** comparativement au jail sous BSD qui existe depuis 15 ans ?

* L'administration des containers simplifier avec l'utilisation de DockerFiles pour contruire l'image du container
* Possibilité de gérer les version des containers
* Possibilité de stocker , pull, push des containers ( registry , hub.docker.com )
* API Rest 
* Utilisation de unionFS pour réutiliser l'espace disque pour les bloques disque équivalent.



## <a name="why_docker" />Pourquoi Docker

* Faster delivery of your applications
  * We want your environment to work better. Docker containers, and the work flow that comes with them, help your developers, sysadmins, QA folks, and release engineers work together to get your code into production and make it useful. We've created a standard container format that lets developers care about their applications inside containers while sysadmins and operators can work on running the container in your deployment.
  * We make it easy to build new containers, enable rapid iteration of your applications, and increase the visibility of changes.
  * Docker containers are lightweight and fast! Containers have sub-second launch times, reducing the cycle time of development, testing, and deployment.

* Deploy and scale more easily
  * Docker containers run (almost) everywhere. You can deploy containers on desktops, physical servers, virtual machines ...
  * Since Docker runs on so many platforms, it's easy to move your applications around. You can easily move an application from a testing environment into the cloud and back whenever you need.
  * Docker's lightweight containers also make scaling up and down fast and easy.

* Get higher density and run more workloads
  * Docker containers don't need a hypervisor, so you can pack more of them onto your hosts. This means you get more value out of every server and can potentially reduce what you spend on equipment and licenses.

* Faster deployment makes for easier management
  * As Docker speeds up your work flow, it gets easier to make lots of small changes instead of huge, big bang updates

[Source : About Docker](https://docs.docker.com/engine/misc/ "Ref Sources")

## <a name="architecture" />Architecture de Docker


Les composantes de docker :

* Le logiciel **docker** : installé sur le serveur GNU/Linux obligatoirement, (distribué sous licence Apache 2.0)
* [Docker Hub](https://hub.docker.com/ "docker hub") : Fournit une platforme de partage de containers 


Docker uses a client-server architecture. The Docker client talks to the Docker daemon, which does the heavy lifting of building, running, and distributing your Docker containers. Both the Docker client and the daemon can run on the same system, or you can connect a Docker client to a remote Docker daemon. The Docker client and daemon communicate via sockets or through a RESTful API.


<img src="https://docs.docker.com/engine/article-img/architecture.svg"  width="700px" />

* Client : représente l'ensemble des instructions réalisé avec le binaire **docker** 
* Daemon : Le processus sur le service qui réalise le heavy lifting avec l'OS et le registry
* Registry : Site ou serveur offrant des images de container 

Voyons les détails avec la création d'une container ceci nous offrira la théorie et la pratique 

### <a name="creation" />Creation d'un container

#### <a name="recup_img"" />Récupération d'une images depuis [dockerhub](https://hub.docker.com/)
  Ceci est un peu destabilisant car il y a un grand nombre de docker présent qui sont bien souvent uploadé par n'importe qui ! Les distributions grand public (ubuntu, centos) sont identifier comme officiel !

    $ docker pull centos 
    $ docker pull ubuntu:14.04
    $ docker pull debian:jessie

#### <a name="visualisation_docker" />Visualisation des dockers présent 
  Vous pouvez utiliser la commande docker images pour voir les images présent sur votre hôtes

    $ docker images 
    TODO ajouter output

#### <a name="run_docker" />Executer ce container
Execution du container simplement suite a son extraction depuis le depo , dans notre cas [dockerhub](https://hub.docker.com/). Nous allons utiliser la commande **docker run** avec les arguments:

* -i : interactif
* -t : avec un tty.

Commande :

    $ docker -it debian:jessie
    root@d5dcc5392fd2:/# ps auuf
    USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root         1  0.0  0.1   3592  2512 ?        Ss   22:00   0:00 /bin/bash
    root         7  0.0  0.0   2928  1756 ?        R+   22:03   0:00 ps auuf

Nous avons donc un hostname généré qui est en fait l'id du container , si nous utilisons une autre console et que nous listons les dockers en execution avec **docker ps** , nous retrouverons le dockers 

    $ docker ps 
    CONTAINER ID    IMAGE                      COMMAND      CREATED         STATUS              PORTS NAMES
    d5dcc5392fd2    debian:jessie   "/bin/bash"  6 minutes ago    Up 6 minutes       reverent_albattani

Lors de l'introduction j'ai insisté sur 1 point majeur que le container n'est pas une machine virtuel nous voyons ici clairement une différence. Quand je list les processus en cours d'execution **ps aux** nous ne voyons que le **bash** et la commande ps dans le container. Le premier processus qui a démarrer le **PID 1** est bash.

Alors que si je fais la même commande sur ma machine hôte en plus d'avoir un nombre de processus significativement plus grand nous retrouvons le **PID 1** qui est le processus d'initialisation du système (**/sbin/init**).
De plus nous voyons l'ensemble des processus du kernel **[nom_process]**.

    Hote $ ps aux | head
    USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root         1  0.1  0.2   5560  4304 ?        Ss   16:51   0:01 /sbin/init
    root         2  0.0  0.0      0     0 ?        S    16:51   0:00 [kthreadd]
    root         3  0.0  0.0      0     0 ?        S    16:51   0:00 [ksoftirqd/0]
    root         5  0.0  0.0      0     0 ?        S<   16:51   0:00 [kworker/0:0H]
    root         6  0.0  0.0      0     0 ?        S    16:51   0:00 [kworker/u4:0]
    root         7  0.1  0.0      0     0 ?        S    16:51   0:01 [rcu_preempt]
    root         8  0.0  0.0      0     0 ?        S    16:51   0:00 [rcu_sched]

Nous verrons un peu plus loin comment démarrer un docker en background ... (TODO : fixer ce paragraphe)

**ATTENTION** Les données du container sont effémaire (TODO: valider orthographe), en effet toute modification sur le container en l'etat seront perdu une fois la session bash terminé. Démo :P !

    $ docker run -it debian:jessie
    root@085ad9165f9e:/# vi /tmp/toto
    root@085ad9165f9e:/# echo "un petit bonjour" > /root/mon_fichier
    root@085ad9165f9e:/# ls -l /root/mon_fichier
    -rw-r--r-- 1 root root 17 Nov 18 22:18 /root/mon_fichier
    root@085ad9165f9e:/# cat /root/mon_fichier
    un petit bonjour
    root@085ad9165f9e:/# 
    root@085ad9165f9e:/# exit
    $ docker run -it debian:jessie
    root@c0bc5fd81328:/# ls -l  /root/
    total 0
    root@c0bc5fd81328:/# 

Comme vous pouvez le constater entre le numéro du container a aussi changé de 085ad9165f9e à c0bc5fd81328, c'est donc une nouvelle instance de l'image originel qui fut chargé ! Bien entendu il y a moyen de solutioner ce problème nous allons le voir dans quelques minutes :D.

Mais en soit la solution est-elle vraiment importante si on ne comprend pas pourquoi ... voyons donc comment est structuré une image en créant notre propre image.

#### <a name="create_custom" />Creation d'une image personnalisé

Un container a pour objectif de fournir une application avec son éco système complet, le concept de docker n'est pas de 
fournir une machine virtuel. Lors images que j'ai télécharger avec la commande **docker pull** sont des containers minimal
sur lequelle nous batissons notre container pour fournir notre application. 

Pour la demontration nous allons mettre en place un serveur web qui fournit un page web simple. Nous allons donc
contruire un container avec un Dockerfile. 

Voici le fichier DockerFile  utiliser , nous allons partir de l'image original **debian:jessie** et ajouter 
le service apache. Voici le contenu du fichier

    $ mkdir websrv
    $ vim Dockerfile
    FROM debian:jessie
    MAINTAINER Boutry Thomas "thomas.boutry@acceo.com"
     
    # install apps 
    RUN apt-get update && \
    apt-get install -y apache2 
     
    # Clean up apt-get
    RUN apt-get clean all
     
    EXPOSE 80

Pout Builder le docker comme suit nous donnons le nom **srvweb-demo** a l'image

    $ docker build -t srvweb-demo .
    Sending build context to Docker daemon 2.048 kB
    Sending build context to Docker daemon 
    Step 0 : FROM debian:jessie
     ---> 7dcc01931e09
     Step 1 : MAINTAINER Boutry Thomas "thomas.boutry@acceo.com"
      ---> Using cache
       ---> 0b1b643b256f
       Step 2 : RUN apt-get update &&     apt-get install -y apache2
        ---> Running in 1e08ac6aa215
        Ign http://http.debian.net jessie InRelease
        Get:1 http://http.debian.net jessie Release.gpg [2373 B]
        Hit http://http.debian.net jessie Release
        [....]
        [....]
        Building dependency tree...
        The following extra packages will be installed:
          apache2-bin apache2-data apache2-utils file libalgorithm-c3-perl
        [....]
        [....]
          perl-modules rename sgml-base ssl-cert xml-core
          0 upgraded, 53 newly installed, 0 to remove and 0 not upgraded.
          Need to get 11.1 MB of archives.
          After this operation, 46.5 MB of additional disk space will be used.
          Get:1 http://http.debian.net/debian/ jessie/main libsasl2-modules-db i386 2.1.26.dfsg1-13 [67.8 kB]
        [....]
        [....]
        Setting up liblua5.1-0:i386 (5.1.5-7.1) ...
        Setting up apache2-bin (2.4.10-10+deb8u3) ...
        Setting up apache2-utils (2.4.10-10+deb8u3) ...
        Setting up apache2-data (2.4.10-10+deb8u3) ...
        Setting up apache2 (2.4.10-10+deb8u3) ...
        Processing triggers for sgml-base (1.26+nmu4) ...
        [....]
        [....]
        ---> 2bda374cb60b
        Removing intermediate container 1e08ac6aa215
        Step 3 : RUN apt-get clean all
         ---> Running in e9e6529e84ef
         ---> 7a3126a11212
        Removing intermediate container e9e6529e84ef
        Step 4 : EXPOSE 80
         ---> Running in 37942989b3d5
         ---> 91d0eef1225d
        Removing intermediate container 37942989b3d5
        Successfully built 91d0eef1225d


Visualisation des images disponibles :

    $ docker images 
    REPOSITORY               TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
    srvweb-demo              latest              91d0eef1225d        4 minutes ago       433 MB
    debian        jessie              7dcc01931e09        3 weeks ago         275.6 MB

Maintenant si nous demarrons le docker et regardons la presence d'apache et le port

    $ docker run -it srvweb-demo
    root@4a9646057695:/#
    root@4a9646057695:/# dpkg -l |grep apache
    ii  apache2                       2.4.10-10+deb8u3         i386         Apache HTTP Server
    ii  apache2-bin                   2.4.10-10+deb8u3         i386         Apache HTTP Server (modules and other binary)
    ii  apache2-data                  2.4.10-10+deb8u3         all          Apache HTTP Server (common files)
    ii  apache2-utils                 2.4.10-10+deb8u3         i386         Apache HTTP Server (utility programs )
    root@4a9646057695:/# ps aux
    USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root         1  0.5  0.1   3592  2680 ?        Ss   22:40   0:00 /bin/bash
    root         8  0.0  0.0   2932  1792 ?        R+   22:40   0:00 ps aux
    root@4a9646057695:/# netstat -lntp
    Active Internet connections (only servers)
    Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
    root@4a9646057695:/# 
    root@4a9646057695:/#  /etc/init.d/apache2 start
    root@4a9646057695:/#  netstat -lntp
    Active Internet connections (only servers)
    Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
    tcp6       0      0 :::80                   :::*                    LISTEN      25/apache2


Sur la machine Hôte je ne vois pas le port ouvert car , la machine Hôte et le container on chacun leur stack IP

    HOTE $ sudo netstat -lntp
    Active Internet connections (only servers)
    Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
    tcp        0      0 127.0.0.1:34120         0.0.0.0:*               LISTEN      2007/python2 


Nous verrons sous peut le stack ip !!! restons concentré sur la question du filesystème.
Le système de container fonctionne par couche layer voici une représentation graphique d'une container :

<img src="http://docs.master.dockerproject.org/terms/images/docker-filesystems-multilayer.png"  width="600px" />

Comme nous pouvons le voir dans la representation ici le container utilise un système Debian et a ajouter l'application
Apache et emacs. Par dessus il y a le layer Writable qui permet au container d'exister pendant l'utilisation , car comme vous
le savez surement un système GNU/Linux ne peux pas fonctionner en Read-Only cette couche permet au bon fonctionnement.

Si nous reprenons notre container **srvweb-demo** il est possible de visualiser les layers utilisés, avec la commande
**docker history**

    HOTE $ docker history srvweb-demo
    IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
    91d0eef1225d        14 hours ago        /bin/sh -c #(nop) EXPOSE 80/tcp                 0 B
    7a3126a11212        14 hours ago        /bin/sh -c apt-get clean all                    0 B
    2bda374cb60b        14 hours ago        /bin/sh -c apt-get update &&     apt-get inst   157.5 MB
    0b1b643b256f        15 hours ago        /bin/sh -c #(nop) MAINTAINER Boutry Thomas "t   0 B
    7dcc01931e09        3 weeks ago         /bin/sh -c #(nop) CMD ["/bin/bash"]             0 B
    0fd558da9b52        3 weeks ago         /bin/sh -c #(nop) LABEL License=GPLv2           0 B
    7f08c6429b05        3 weeks ago         /bin/sh -c #(nop) LABEL Vendor=Debian           0 B
    ccade716b98f        3 weeks ago         /bin/sh -c #(nop) ADD file:5222370b044ddd1aef   275.6 MB
    6f8878132e44        3 weeks ago         /bin/sh -c #(nop) MAINTAINER Nickcis <ncis20@   0 B


Ce systeme de layer est un gros avantage du systeme docker , car les layers peuvent être reutiliser pour la creation
d'une autre images / container. Si je creer une autre  image mais cette fois j'installe en plus openssh.

Creation de l'image , fichier DockerFile

    FROM debian:jessie
    MAINTAINER Boutry Thomas "thomas.boutry@acceo.com"

    # install apps 
    RUN apt-get update && \
        apt-get install -y apache2 

    RUN apt-get install -y openssh-server

    # Clean up apt-get
    RUN apt-get clean all

    EXPOSE 80

Creation de l'image

    $ docker build -t websrv-with-ssh .
    Sending build context to Docker daemon 2.048 kB
    Sending build context to Docker daemon
    Step 0 : FROM debian:jessie
     ---> 7dcc01931e09
    Step 1 : MAINTAINER Boutry Thomas "thomas.boutry@acceo.com"
      ---> Using cache
      ---> 0b1b643b256f
     Step 2 : RUN apt-get update &&     apt-get install -y apache2
      ---> Using cache
      ---> 2bda374cb60b
     Step 3 : RUN apt-get install -y openssh-server
      ---> Running in 6b39a8b60d36
     Reading package lists...
     Building dependency tree...
     Reading state information...

Visualisation des layers :

    $ docker history websrv-with-ssh
    IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
    6c0125964a07        20 seconds ago      /bin/sh -c #(nop) EXPOSE 80/tcp                 0 B
    dacc0b7a474c        28 seconds ago      /bin/sh -c apt-get clean all                    0 B
    9cf1f9b10602        42 seconds ago      /bin/sh -c apt-get install -y openssh-server    46.69 MB
    2bda374cb60b        15 hours ago        /bin/sh -c apt-get update &&     apt-get inst   157.5 MB
    0b1b643b256f        15 hours ago        /bin/sh -c #(nop) MAINTAINER Boutry Thomas "t   0 B
    7dcc01931e09        3 weeks ago         /bin/sh -c #(nop) CMD ["/bin/bash"]             0 B
    0fd558da9b52        3 weeks ago         /bin/sh -c #(nop) LABEL License=GPLv2           0 B
    7f08c6429b05        3 weeks ago         /bin/sh -c #(nop) LABEL Vendor=Debian           0 B
    ccade716b98f        3 weeks ago         /bin/sh -c #(nop) ADD file:5222370b044ddd1aef   275.6 MB
    6f8878132e44        3 weeks ago         /bin/sh -c #(nop) MAINTAINER Nickcis <ncis20@   0 B


Il est possible de realiser la difference des layers pour visualiser ce qui a changer

    $ docker history websrv-with-ssh > /tmp/layer-websrv-with-ssh
    $ docker history srvweb-demo > tmp/layer-srvweb-demo
    $ diff /tmp/layer-srvweb-demo /tmp/layer-websrv-with-ssh
    < 91d0eef1225d        15 hours ago        /bin/sh -c #(nop) EXPOSE 80/tcp                 0 B
    < 7a3126a11212        15 hours ago        /bin/sh -c apt-get clean all                    0 B
    ---
    > 6c0125964a07        2 minutes ago       /bin/sh -c #(nop) EXPOSE 80/tcp                 0 B
    > > dacc0b7a474c        2 minutes ago       /bin/sh -c apt-get clean all                    0 B
    > > 9cf1f9b10602        2 minutes ago       /bin/sh -c apt-get install -y openssh-server    46.69 MB


Comme nous pouvons le constater les couches :

* L'image d'origine est identique pour les 2 containers (debian)
* La mise à jour de l'OS et l'installation de apache

Ce qui change c'est :

* La couche additionnel d'installation du serveur openssh
* Le clean up du repo apt (apt-get clean all)

**Wow** le clean up (apt-get clean all) est present dans les 2 container pourquoi il reutilise pas le même layer !!
La réutilisation des couches (layers) n'est effectué que si elles sont déclarer dans le même ordre !!! en effet le système
ne peut garantir que l'opération n'est identique au niveau du file système UNIQUEMENT si les opérations précédente sont 
les mêmes. 

Si nous prenons le cas présent du clean up des packques , l'opération n'est pas la même :

* la couche 7a3126a11212 (srvweb-demo) : supprimer les fichiers de mise à jour télécharger dans /var/cache/.../*.deb
* la couche dacc0b7a474c (websrv-with-ssh) : supprimer les même fichiers + ceux d'openssh ce n'est donc pas la même opération !

Ce système de couche est en fait le système [unionfs](https://en.wikipedia.org/wiki/UnionFS) qui permet de définir le filesystème en couche.

Il est parfois utiliser le terme **bruler** les layers d'un containers car ces derniers sont gravé mais modifiable lors de l'utilisation, grace à la couche writeable sur le dessus.
Il existe un grand nombre d'instruction pour faire la création d'un docker . Voir le lien suivant sur le [site de référence](https://docs.docker.com/v1.8/reference/builder/).

Voici une courte liste:

* Execution d'une commande ( **RUN** , exemple apt-get install ....)
* Ajout de fichier ou répertoire ( **ADD** )
* Définition des variables d'environnement (**ENV**)


Source :

  * [docker layer](http://docs.master.dockerproject.org/terms/layer/#union-file-system)
  * [Understanding Docker](https://docs.docker.com/engine/introduction/understanding-docker/)
  * [layering of docker images](http://tuhrig.de/layering-of-docker-images/)
 

## <a name="use_docker" />Utilisation des dockers

### <a name="network" />Réseau 


Cette section est encore en cours d'amélioration , l'ensemble des perspectives possible avec docker ne furent pas annalysé. 

Réalisation d'un port forward de la machine Hôte vers le container :

    $ docker run -it -p 8080:80 srvweb-demo
    root@1385d905ecf8:/# /etc/init.d/apache2 start
    [....] Starting web server: apache2AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message
    . ok 
    root@1385d905ecf8:/# netstat -lntp
    Active Internet connections (only servers)
    Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
    tcp6       0      0 :::80                   :::*                    LISTEN      -
    root@1385d905ecf8:/#


    HOTE $ sudo netstat -lntp | grep 8080
    tcp6       0      0 :::8080                 :::*                    LISTEN      12207/docker-proxy


La page est donc disponible si nous prenons un navigateur : http://127.0.0.1:8080

![port_8080_webpage](./img-web-page.png)


Il est possible de démarrer la même image mais de réaliser une redirection de port différent nous avons donc le même container/application disponible sur 2 port distint . S'il y avait des mutex ou autre limitation propre à l'application il vive dans un éco-système différent.

    $ docker run -it -p 8082:80 srvweb-demo
    root@c5a07205dcc5:/# /etc/init.d/apache2 start
    [....] Starting web server: apache2AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.3. Set the 'ServerName' directive globally to suppress this message
    . ok 
    root@c5a07205dcc5:/# netstat -lntp
    Active Internet connections (only servers)
    Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
    tcp6       0      0 :::80                   :::*                    LISTEN      -               


    HOTE $ sudo netstat -lntp | egrep '8080|8082'
    tcp6       0      0 :::8080                 :::*                    LISTEN      12207/docker-proxy
    tcp6       0      0 :::8082                 :::*                    LISTEN      14668/docker-proxy


### <a name="utilisation_donnee" />Utilisation des données dans un container 

L'ensemble des systèmes de couches c'est bien mais comment mon système vie dans un container ? Est-ce possible d'avoir un container qui conservé les données ? <br>
Avec l'information présente il n'est pas imaginable d'avoir une base de donnée ou une page web qui conserve de l'information via l'upload de fichiers ou autre ... 

Effectivement avec l'information fournit jusque maintenant l'utilisation de docker en dehors de test one shot ne semble pas vraiment possible. Pour la question de base de donnée
bien entendu il pensable de brulé un layer avec les données de la BD et imaginé qu'au prochain reboot les données seront réinitialisé.

#### <a name="mountbind" />MountBind

Afin de solutionner ce problème il est possible de réaliser des **mount bind** d'un répertoire hote sur de container.  Tout comme pour la définition du port foward ceci est un paramètre lors de l'initialisation de container.

    $ docker run -it -p 8082:80 -v /data/html:/var/www/html/  srvweb-demo
    root@e52e7386a2c6:/# ls -l /var/www/html/
    total 0

    HOTE # echo "super page de ouff" > /data/html/index.html
    HOTE $ echo "fichier creer par un user" > /data/html/userfile.html
    HOTE $ sudo chown userName /data/html/userfile.html

    root@e52e7386a2c6:/# ls -l /var/www/html/
    total 8
    -rw-r--r-- 1 root root 19 Nov 19 15:20 index.html
    -rw-r--r-- 1 1000 root 21 Nov 19 15:20 userfile.html


Comme le UID 1000 n'est pas définie dans le container **/etc/passwd** le container ne peut pas faire l'association , ceci est important surtout s'il y a manipulation des fichiers sur l'hote ET dans le container ! Dans cette situation si j'arrète et reprend le container les données reste :

    root@e52e7386a2c6:/# exit

    HOTE $ docker run -it -p 8080:80 -v /data/html:/var/www/html/  srvweb-demo
    root@c19bb2526dd2:/# ls -l /var/www/html/
    total 8
    -rw-r--r-- 1 root root 19 Nov 19 15:20 index.html
    -rw-r--r-- 1 1000 root 21 Nov 19 15:20 userfile.html

#### <a name="name_docker" />Assigner un nom au docker == un layer 

Lorsque que j'ai démarrer mes container depuis le début nous avons vue le "hostname" changer constament :

* root@085ad9165f9e:/#
* root@1385d905ecf8:/#
* root@4a9646057695:/#

Ce numéro correspond à la layer Writable du docker 

<img src="http://docs.master.dockerproject.org/terms/images/docker-filesystems-multilayer.png"  width="600px" />

Il est possible d'assigner à l'execution un layer pour que ce soit toujours la même couche writeable qui soit utilisé . Voyons dans la réalité :D .
je vais faire 2 operation définir un hostname à la machine avec l'option **-h** et définir un nom de layer avec **--name**.

    HOTE $ docker run -it -p 8080:80 -h site_web_corpo -v /data/html:/var/www/html/ --name site_web_corpo  srvweb-demo
    root@site_web_corpo:/# ls /var/www/html/
    index.html  userfile.html
    root@site_web_corpo:/# vi /root/avec_le_layer_namer
    root@site_web_corpo:/# exit

    $ docker run -it -p 8080:80 -h site_web_corpo -v /data/html:/var/www/html/ --name site_web_corpo  srvweb-demo
    Error response from daemon: Conflict. The name "site_web_corpo" is already in use by container cf82d7eb0233. You have to remove (or rename) that container to be able to reuse that name.

J'ai une erreur ... car par default quand on utilise la commande **docker run** il creer une nouvelle instance , dans notre cas nous avons dejà la couche supérieur il faut donc redémarrer l'instance. 

Avec la commande **docker ps** et **docker ps -l** nous pouvons visualiser les dockers avec les etats

    HOTE $ docker ps -a
    CONTAINER ID        IMAGE                                      COMMAND                  CREATED             STATUS                      PORTS                    NAMES
    cf82d7eb0233        srvweb-demo                                "/bin/bash"              3 minutes ago       Exited (0) 2 minutes ago                             site_web_corpo
    c19bb2526dd2        srvweb-demo                                "/bin/bash"              25 minutes ago      Exited (0) 6 minutes ago                             fervent_leakey
    [....]
    
    HOTE $ docker ps -a -l
    CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES
    cf82d7eb0233        srvweb-demo         "/bin/bash"         3 minutes ago       Exited (0) 2 minutes ago                       site_web_corpo


Donc je redemarre le container et je m'y rattache

    HOTE $ $ docker start site_web_corpo
    site_web_corpo
    HOTE $ docker attach site_web_corpo
    root@site_web_corpo:/# ls /root/
    total 4
    -rw-r--r-- 1 root root 23 Nov 19 15:46 avec_le_layer_namer
    root@site_web_corpo:/# ls -l /var/www/html/
    total 8
    -rw-r--r-- 1 root root 19 Nov 19 15:20 index.html
    -rw-r--r-- 1 1000 root 21 Nov 19 15:20 userfile.html

Nous constatons que mon fichier est toujours présent , il est donc possible de démarrer plusieurs container avec la même image cependant il faut que le layer writable soit unique par container , ceci est du au système Linux qui dispose des fichiers temporaire / lock , ... Si nous avions deux container avec le même layer suppérieur le comportement serait étrange.

#### <a name="burn_layer" />Bruler un layer ( ajout d'une couche )

Si nous avons plusieurs container , donc plusieurs instance et que nous constatons un problème qu'il faut modifier l'image de base , bien entendu l'idéal est de modifier le fichier DockerFile et de reconstruire l'image afin que toute personne utilisant ce container puisse profiter de ce changement . Dans la réalité il est parfois important d'appliquer une modification "rapidement" ou tout simplement de pouvoir manipuler les layers car on peut le faire :D .

Visualisons l'état des layers de l'image **srvweb-demo** 

    HOTE $ docker history srvweb-demo
    IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
    542b4dd368a0        About an hour ago   /bin/sh -c #(nop) EXPOSE 80/tcp                 0 B
    936cceddf353        About an hour ago   /bin/sh -c apt-get clean all                    0 B
    e659a06a5110        About an hour ago   /bin/sh -c apt-get update &&     apt-get inst   157.6 MB
    6101357e0af2        About an hour ago   /bin/sh -c #(nop) MAINTAINER Boutry Thomas "t   0 B
    140e18016122        3 weeks ago         /bin/sh -c #(nop) CMD ["/bin/bash"]             0 B
    e1d661133e76        3 weeks ago         /bin/sh -c #(nop) LABEL License=GPLv2           0 B
    eb36000ea36d        3 weeks ago         /bin/sh -c #(nop) LABEL Vendor=Debian           0 B
    8ba1bb348f85        3 weeks ago         /bin/sh -c #(nop) ADD file:5222370b044ddd1aef   275.6 MB
    ad97cee03005        3 weeks ago         /bin/sh -c #(nop) MAINTAINER Nickcis <ncis20@   0 B

Nous avons une instance du container en execution 

     HOTE $ docker ps
     CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
     cf82d7eb0233        srvweb-demo         "/bin/bash"         31 minutes ago      Up 25 minutes       0.0.0.0:8080->80/tcp     site_web_corpo


Ajout d'un certificat ssl : 

    root@site_web_corpo:/etc/apache2# mkdir ssl
    root@site_web_corpo:/etc/apache2# cd
    root@site_web_corpo:~# openssl req -new -newkey rsa:2048 -x509 -out cert.crt -keyout cert.key -nodes -days 365
    root@site_web_corpo:~# ls -ltr
    total 12
    -rw-r--r-- 1 root root   23 Nov 19 15:46 avec_le_layer_namer
    -rw-r--r-- 1 root root 1704 Nov 19 16:09 cert.key
    -rw-r--r-- 1 root root 1342 Nov 19 16:09 cert.crt
    root@site_web_corpo:~# cp cert.crt cert.key /etc/apache2/ssl/


A présent je brule le nouveau layer avec un message significatif :

* -m : le message (comme svn)
* site_web_corpo : le container actuel
* srvweb-demo : ici j'overwrite celui en court d'utilisation mais j'aurais aussi pu en créer un nouveau

commande :

    HOTE $ docker commit -m "Ajout des certificat SSL " site_web_corpo srvweb-demo

Si nous regardons les layers en utilisation :

    $ docker history srvweb-demo
    IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
    47503d9436b0        7 seconds ago       /bin/bash                                       8.031 kB            Ajout des certificat SSL
    542b4dd368a0        About an hour ago   /bin/sh -c #(nop) EXPOSE 80/tcp                 0 B
    936cceddf353        About an hour ago   /bin/sh -c apt-get clean all                    0 B
    e659a06a5110        About an hour ago   /bin/sh -c apt-get update &&     apt-get inst   157.6 MB
    6101357e0af2        About an hour ago   /bin/sh -c #(nop) MAINTAINER Boutry Thomas "t   0 B
    140e18016122        3 weeks ago         /bin/sh -c #(nop) CMD ["/bin/bash"]             0 B
    e1d661133e76        3 weeks ago         /bin/sh -c #(nop) LABEL License=GPLv2           0 B
    eb36000ea36d        3 weeks ago         /bin/sh -c #(nop) LABEL Vendor=Debian           0 B
    8ba1bb348f85        3 weeks ago         /bin/sh -c #(nop) ADD file:5222370b044ddd1aef   275.6 MB
    ad97cee03005        3 weeks ago         /bin/sh -c #(nop) MAINTAINER Nickcis <ncis20@   0 B


La couche incluant l'ajout du certificat est bien présent , donc si je démarre une nouvelle instance de srvweb-demo , sans utilisé le layer site_web_corpo , je vois toujours mes fichiers 

    HOTE $ docker run -it -p 8080:80 -v /data/html:/var/www/html/   srvweb-demo
    root@696ac9f60763:/# ls /etc/apache2/ssl/
    cert.crt  cert.key


Le concept est très super surtout combiner avec **docker diff** qui me permet de visualiser avant le commit les différences voici un exemple:

    root@696ac9f60763:/# touch /tmp/toto
    root@696ac9f60763:/# rm /etc/apache2/ssl/cert.key

    HOTE $ docker ps
    CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
    696ac9f60763        srvweb-demo         "/bin/bash"         18 minutes ago      Up 17 minutes       0.0.0.0:8080->80/tcp     dreamy_hugle

    HOTE $ docker diff dreamy_hugle
    C /etc
    C /etc/apache2
    C /etc/apache2/ssl
    D /etc/apache2/ssl/cert.key
    C /tmp
    A /tmp/toto
     
    $ docker commit -m "Mise a jour certificat  " dreamy_hugle srvweb-demo

    $ docker history srvweb-demo
    IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
    87f410c60922        4 seconds ago       /bin/bash                                       0 B                 Mise a jour certificat
    47503d9436b0        24 minutes ago      /bin/bash                                       8.031 kB            Ajout des certificat SSL
    542b4dd368a0        About an hour ago   /bin/sh -c #(nop) EXPOSE 80/tcp                 0 B

Si comme dans le cas présent il y a un problème que l'opération planifier ne correspond pas a ce qui doit être en place ... il est possible de faire un revert.  je vais revenir au layer de l'installation du certificat original .

    root@696ac9f60763:/# exit
    HOTE $ docker history srvweb-demo
    IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
    87f410c60922        3 minutes ago       /bin/bash                                       0 B                 Mise a jour certificat
    47503d9436b0        28 minutes ago      /bin/bash                                       8.031 kB            Ajout des certificat SSL
    542b4dd368a0        2 hours ago         /bin/sh -c #(nop) EXPOSE 80/tcp                 0 B
    936cceddf353        2 hours ago         /bin/sh -c apt-get clean all                    0 B

    HOTE $ docker tag 47503d9436b0 srvweb-demo
    Error response from daemon: Conflict: Tag srvweb-demo:latest is already set to image 87f410c60922, if you want to replace it, please use -f option
    HOTE $ docker tag -f 47503d9436b0 srvweb-demo

    HOTE $ docker history srvweb-demo
    IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
    47503d9436b0        29 minutes ago      /bin/bash                                       8.031 kB            Ajout des certificat SSL
    542b4dd368a0        2 hours ago         /bin/sh -c #(nop) EXPOSE 80/tcp                 0 B
    936cceddf353        2 hours ago         /bin/sh -c apt-get clean all                    0 B

    HOTE $ docker run -it -p 8080:80 -v /data/html:/var/www/html/   srvweb-demo
    root@4c5d65cde366:/# ls /etc/apache2/ssl/
    cert.crt  cert.key


Nous ne sommes pas obligé d'overwrite l'image original nous pouvons aussi utilisé le système de **TAG**, en ajouter **:Nom_du_tag**, l'exemple ci-dessous créer l'image srvweb-demo avec le tag v2

    HOTE $ docker ps
    CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
    4c5d65cde366        srvweb-demo         "/bin/bash"         4 minutes ago       Up 4 minutes        0.0.0.0:8080->80/tcp     focused_chandrasekhar

    HOTE $ docker commit -m "update version configue " focused_chandrasekhar srvweb-demo:v2
    ad7710c059e99fcaf4b99c235f58ee8b8d6ce31c605d900ab9b9422086c20522

    HOTE $ docker images | grep  srvweb
    srvweb-demo                     v2                  ad7710c059e9        13 seconds ago      433.2 MB
    srvweb-demo                     latest              47503d9436b0        34 minutes ago      433.2 MB


On peut voir ça comme des snapshots ... L'utilisation des layers donne beaucoup de possibilité , il faut bien l'utiliser.

[Source: layering-of-docker-images](http://tuhrig.de/layering-of-docker-images/)

#### <a name="bootup" />Definition de service au bootup

Depuis le debut de l'exercice à chaque fois que j'ai démarrer un container il a utilisé la command par defautl soit **/bin/bash**.

Voyons a present comment démarrer les services , comme nous avons pu le voir l'ensemble du contenaire n'est pas initialiser de la même manière qu'un système complet Linux, nous avions vu que le **PID 1**, n'est pas **/bin/init** mais le process voulu. Il serait donc possible de démarrer uniquement apache par exemple ou uniquement ssh. Ce que j'ai vu souvant les personnes utilise **supervisor** pour faire le démarrage de service . Voici un exemple des instructions :


    # use Supervisor  to start services 
    RUN apt-get install -y  supervisor
    COPY conf/supervisord.conf /etc/supervisor/conf.d/supervisord.conf

    EXPOSE 22
    CMD ["/usr/bin/supervisord"]

Et le contenu du fichier de configuration  **/etc/supervisor/conf.d/supervisord.conf**

    [supervisord]
    nodaemon=true
    
    [program:sshd]
    command=/usr/sbin/sshd -D

    [program:apache2]
    command=/bin/bash -c "source /etc/apache2/envvars && exec /usr/sbin/apache2 -DFOREGROUND"


Pourquoi mettre en forground car c'est le process supervisord qui va gerer la mise en arrière plan, le système permet plusieurs instruction telle que le redémarrage automatique si ça plante , .... Pour le moment le manque d'expérience pratique avec ce système ne me permet pas de me prononcé sur les avantages est problème.

## <a name="lifecycle" />Le cycle de vie avec Docker

TODO: A completer avec l'experience.

![Infrastructure docker](http://image.slidesharecdn.com/introductiondocker-140912032700-phpapp02/95/introduction-dockerio-16-638.jpg?cb=1410492483 )


[Source : Understanding docker](https://docs.docker.com/engine/introduction/understanding-docker/ "Architecture Docker")


