<meta http-equiv='Content-Type' content='text/html; charset=utf-8' />
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>

![docker_logo](./imgs/Docker_logo.png)

# Index

# <a name="Intro" /> Introduction

**Docker** est un logiciel libre qui automatise le déploiement d'applications dans des conteneurs logiciels. Selon la firme de recherche sur l'industrie __451 Research__, « Docker est un outil qui peut empaqueter une application et ses dépendances dans un conteneur isolé, qui pourra être exécuté sur n'importe quel serveur Linux ». Ceci permet d'étendre la flexibilité et la portabilité d’exécution d'une application, que ce soit sur la machine locale, un __cloud__ privé ou public, une machine nue, etc. 

Ceci est une description très générale nous allons voir les détails sous peu de ce qu'est réellement __docker__.

## <a name="whatIsDocker" /> Qu'est ce que Docker ?

Docker vous offre la possibilité d'isoler votre application du reste du système, cette isolation est réalisé grâce au fonctionnalité du noyaux (kernel) du système d'exploitation (pour GNU/Linux : __cgroup__ et __namespace__). Nous parlons d'isolation au niveau :

* **Couche réseau** : Chaque conteneur à son propre __stack IP__, chaque conteneur à son propre adresse IP.
* **Couche applicative** : Les applications dans un conteneur ne voit que ce qui est contenu dans ce dernier, tous ce qui est à l'extérieure est inexistant.

Vous avez la possibilité de limité l'utilisation des ressources (CPU, I/O, réseaux , ...) grâce au fonctionnalité du noyau. 

Pourquoi l'arrivée de Docker ? À la lecture de l'énoncé ci-dessus ceci ressemble à une Machine Virtuel, les solutions de visualisation ne manque pas !
Ceci est souvent l'analogie réalisée, mais un conteneur n'est PAS une machine virtuel, voyons les problématiques 

### <a name="Objectif" /> Objectif de Docker


L'objectif de Docker est d'offrir des conteneurs applicatif facile à déployer afin d'encapsulé l'application , incluant l'ensemble de ces dépendances et les versions de ces dernières.

* **Avec Docker vous pouvez séparer votre application de l'infrastructure et traiter cette dernier comme une application**
* Docker vous permet d'exécuter n'importe quelle application de manière sécuritaire dans un conteneur.
* L'isolation et la sécurité vous offre la possibilité d'exécuter plusieurs conteneur sur la même machine.
* L'absence __d'Hypervisor__ vous permet de tiré une plus grande partie du matériel, car il n'y a pas de charge additionnel pour la visualisation.
* La distribution et les options de transfert de conteneurs vous permet d'avoir le même environnement pour l'ensemble des équipes (__Dev__, __QA__, ...)


### <a name="docker_vs_vm" /> La différence entre une Machine Virtuel (VM) et docker

On dit souvent une image vos mille mot donc commençons par la représentation graphique des 2 configurations. 

![ContainerVsVM.png](./imgs/ContainerVsVM.png)

* Les partie commune 
    * Composante matériel , en d'autre mot la machine physique
    * Un système d'exploitation (Linux, Windows , ...)
* Une Machine Virtuel
    * Un système __d'hypervisor__ , __ESX__, __KVM__, __Xen__ , ... Cette couche permettra l'émulation d'une __CPU__, mémoire, carte réseau , ...
    * Un système d'exploitation potentiellement différent du système d'exploitation native sur la machine
    * Installation des librairies et de l'application contenu dans la machine virtuel
* Un Conteneur
    * contient uniquement les librairies et l'application 

Vous êtes tous familiarisé avec le système de machine virtuel, nous nous concentrerons donc sur la partie conteneur.

Dans le cas d'un conteneur il n'y a pas __d'hyperviseur__, le système d'exploitation dans le cas présent GNU/Linux peut gérer nativement les systèmes docker via l'applicatif installé. Il n'y a donc pas d'émulation de matériels réalisé comme pour une machine virtuel, il n'y a pas de système d'exploitation d'installer qui réalisera le même travail que le système hôte. 
Un conteneur utilisera le même **noyaux** que le système hôte pour fonctionner, à l'avantage de réduire considérablement le temps d'initialisation d'un conteneur , car le conteneur n'a pas de **noyaux** à charger , de matériel à détecter ou d'initialisation du système , il ne démarre que l'application spécifié. L'inconvénient avec cette solution est que le conteneur initialisé doit être de même type de le docker __host__. En d'autre mot il n'est pas possible d'avoir un conteneur de type __Windows__ sur une machine GNU/Linux, conceptuellement ceci n'est pas possible.

* Il est plus approprié de voir un conteneur comme environnement [chrooté](https://fr.wikipedia.org/wiki/Chroot) en anglais [Chroot](https://en.wikipedia.org/wiki/Chroot). (Limité dans un espace disque dur du système **Ch**ange **root** , changement de racine / )
* Un des avantages est que chaque conteneur à sa couche réseau (__stack ip__) , donc en plus d'une isolation des fichiers nous avons aussi une isolation des communication réseau. 
* Chaque conteneur à son administrateur **root** ainsi que les utilisateurs dans le conteneur, assurant encore une fois une isolation complète.

Pour les plus vieux d'entre vous, vous vous direz peut-être : Quelle sont les avantages de **docker** comparativement au __jail__ sous __BSD__ qui existe depuis 15 ans ou encore les zones de __solaris__ ?

* L'administration des conteneurs simplifier avec l'utilisation de __DockerFiles__ pour construire l'image des conteneurs.
* L'administration de l'orchestration des conteneurs à l'aide de __docker-compose__ ou de système de __cluster__ telle que __Kibernet__ ou __swarm__.
* La possibilité de gérer les version des containers
* La possibilité de stocker , manipuler , récupérer des conteneurs depuis un __registry__, ceci nous donne la possibilité d'avoir des images de conteneur comme artefact.
* L'API __Rest__ pour manipuler nos docker __host__.
* L'utilisation __d'unionFS__ pour réutiliser l'espace disque pour les bloques disques équivalent.

## <a name="Architecture" /> Architecture de Docker 

Nous parlons de __docker__ et de conteneur , nous avons vue que le docker __host__ est l'applicatif installer sur le système d'exploitation qui permet d'exécuter / isoler un conteneur. Avant d'aller plus loin sur l'applicatif __docker__ nous allons nous arrêter sur le conteneur. 

### <a name="ContainerAndImage" /> Conteneur est au commencement une images

Nous allons clarifier l'utilisation des termes ceci simplifiera le dialogue pour le reste de la présentation.

* Une **image** est l'artefact d'un conteneur , l'image est un __conteneur__ à l'état non initialisé, c'est la coquille contenant l'ensemble requis. Nous allons déplacé cette image sur le docker __host__ afin de l'exécuter. Une autre manière de le voir une image est un conteneur vierge, pas encore exécuté.
* Un **conteneur** est une image qui fut exécuter au moins une fois, donc initialiser sur un docker __host__, avec des configurations (Variable d'environnement, assignation réseau , partage d'espace disque , ...) .

Vous pouvez trouver un **GRAND** d'image sur le site [hub.docker.com](https://hub.docker.com/). 

Prenons quelques minutes pour regarder le contenu, [hub.docker.com/explore](https://hub.docker.com/explore/), juste pour vous donner une idée du contenu.
Il y a 2 type d'image disponible :

* **OFFICIEL** : C'est images sont valider par le fournisseur est considérer comme officiel par le "manufacturé" , comme vous pouvez le voir vous retrouvez :
    * [Ubuntu](https://hub.docker.com/_/ubuntu/)
    * [Mysql](https://hub.docker.com/_/mysql/)
    * [Apache](https://hub.docker.com/_/httpd/)
    * [Wordpress](https://hub.docker.com/_/wordpress/)
* **PUBLIQUE** : C'est images sont créer par des internautes, ils sont donc non valider par un tierce, il est donc important de les utiliser avec parcimonie, lors de teste ou de valider le contenu !
    * [le miens :D](https://hub.docker.com/u/x3rus/)
    * [nexus](https://hub.docker.com/r/sonatype/nexus/)
    * [Mysql mais non officiel](https://hub.docker.com/r/tozd/mysql/)


## <a name="whyUseDocker" /> Pourquoi utiliser Docker ?



