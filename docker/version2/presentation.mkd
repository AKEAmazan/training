<meta http-equiv='Content-Type' content='text/html; charset=utf-8' />
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>

![docker_logo](./imgs/Docker_logo.png)

# Index

# <a name="Intro" /> Introduction

**Docker** est un logiciel libre qui automatise le déploiement d'applications dans des conteneurs logiciels. Selon la firme de recherche sur l'industrie __451 Research__, « Docker est un outil qui peut empaqueter une application et ses dépendances dans un conteneur isolé, qui pourra être exécuté sur n'importe quel serveur Linux ». Ceci permet d'étendre la flexibilité et la portabilité d’exécution d'une application, que ce soit sur la machine locale, un __cloud__ privé ou public, une machine nue, etc. 

Ceci est une description très générale nous allons voir les détails sous peu de ce qu'est réellement __docker__.

## <a name="whatIsDocker" /> Qu'est ce que Docker ?

Docker vous offre la possibilité d'isoler votre application du reste du système, cette isolation est réalisé grâce au fonctionnalité du noyaux (kernel) du système d'exploitation (pour GNU/Linux : __cgroup__ et __namespace__). Nous parlons d'isolation au niveau :

* **Couche réseau** : Chaque conteneur à son propre __stack IP__, chaque conteneur à son propre adresse IP.
* **Couche applicative** : Les applications dans un conteneur ne voit que ce qui est contenu dans ce dernier, tous ce qui est à l'extérieure est inexistant.

Vous avez la possibilité de limité l'utilisation des ressources (CPU, I/O, réseaux , ...) grâce au fonctionnalité du noyau. 

Pourquoi l'arrivée de Docker ? À la lecture de l'énoncé ci-dessus ceci ressemble à une Machine Virtuel, les solutions de visualisation ne manque pas !
Ceci est souvent l'analogie réalisée, mais un conteneur n'est PAS une machine virtuel, voyons les problématiques 

### <a name="Objectif" /> Objectif de Docker


L'objectif de Docker est d'offrir des conteneurs applicatif facile à déployer afin d'encapsulé l'application , incluant l'ensemble de ces dépendances et les versions de ces dernières.

* **Avec Docker vous pouvez séparer votre application de l'infrastructure et traiter cette dernier comme une application**
* Docker vous permet d'exécuter n'importe quelle application de manière sécuritaire dans un conteneur.
* L'isolation et la sécurité vous offre la possibilité d'exécuter plusieurs conteneur sur la même machine.
* L'absence __d'Hypervisor__ vous permet de tiré une plus grande partie du matériel, car il n'y a pas de charge additionnel pour la visualisation.
* La distribution et les options de transfert de conteneurs vous permet d'avoir le même environnement pour l'ensemble des équipes (__Dev__, __QA__, ...)


### <a name="docker_vs_vm" /> La différence entre une Machine Virtuel (VM) et docker

On dit souvent une image vos mille mot donc commençons par la représentation graphique des 2 configurations. 

![ContainerVsVM.png](./imgs/ContainerVsVM.png)

* Les partie commune 
    * Composante matériel , en d'autre mot la machine physique
    * Un système d'exploitation (Linux, Windows , ...)
* Une Machine Virtuel
    * Un système __d'hypervisor__ , __ESX__, __KVM__, __Xen__ , ... Cette couche permettra l'émulation d'une __CPU__, mémoire, carte réseau , ...
    * Un système d'exploitation potentiellement différent du système d'exploitation native sur la machine
    * Installation des librairies et de l'application contenu dans la machine virtuel
* Un Conteneur
    * contient uniquement les librairies et l'application 

Vous êtes tous familiarisé avec le système de machine virtuel, nous nous concentrerons donc sur la partie conteneur.

Dans le cas d'un conteneur il n'y a pas __d'hyperviseur__, le système d'exploitation dans le cas présent GNU/Linux peut gérer nativement les systèmes docker via l'applicatif installé. Il n'y a donc pas d'émulation de matériels réalisé comme pour une machine virtuel, il n'y a pas de système d'exploitation d'installer qui réalisera le même travail que le système hôte. 
Un conteneur utilisera le même **noyaux** que le système hôte pour fonctionner, à l'avantage de réduire considérablement le temps d'initialisation d'un conteneur , car le conteneur n'a pas de **noyaux** à charger , de matériel à détecter ou d'initialisation du système , il ne démarre que l'application spécifié. L'inconvénient avec cette solution est que le conteneur initialisé doit être de même type de le docker __host__. En d'autre mot il n'est pas possible d'avoir un conteneur de type __Windows__ sur une machine GNU/Linux, conceptuellement ceci n'est pas possible.

* Il est plus approprié de voir un conteneur comme environnement [chrooté](https://fr.wikipedia.org/wiki/Chroot) en anglais [Chroot](https://en.wikipedia.org/wiki/Chroot). (Limité dans un espace disque dur du système **Ch**ange **root** , changement de racine / )
* Un des avantages est que chaque conteneur à sa couche réseau (__stack ip__) , donc en plus d'une isolation des fichiers nous avons aussi une isolation des communication réseau. 
* Chaque conteneur à son administrateur **root** ainsi que les utilisateurs dans le conteneur, assurant encore une fois une isolation complète.

Pour les plus vieux d'entre vous, vous vous direz peut-être : Quelle sont les avantages de **docker** comparativement au __jail__ sous __BSD__ qui existe depuis 15 ans ou encore les zones de __solaris__ ?

* L'administration des conteneurs simplifier avec l'utilisation de __DockerFiles__ pour construire l'image des conteneurs.
* L'administration de l'orchestration des conteneurs à l'aide de __docker-compose__ ou de système de __cluster__ telle que __Kibernet__ ou __swarm__.
* La possibilité de gérer les version des containers
* La possibilité de stocker , manipuler , récupérer des conteneurs depuis un __registry__, ceci nous donne la possibilité d'avoir des images de conteneur comme artefact.
* L'API __Rest__ pour manipuler nos docker __host__.
* L'utilisation __d'unionFS__ pour réutiliser l'espace disque pour les bloques disques équivalent.

## <a name="Architecture" /> Architecture de Docker 

Nous parlons de __docker__ et de conteneur , nous avons vue que le docker __host__ est l'applicatif installer sur le système d'exploitation qui permet d'exécuter / isoler un conteneur. Avant d'aller plus loin sur l'applicatif __docker__ nous allons nous arrêter sur le conteneur. 

### <a name="ContainerAndImage" /> Conteneur est au commencement une images

Nous allons clarifier l'utilisation des termes ceci simplifiera le dialogue pour le reste de la présentation.

* Une **image** est l'artefact d'un conteneur , l'image est un __conteneur__ à l'état non initialisé, c'est la coquille contenant l'ensemble requis. Nous allons déplacé cette image sur le docker __host__ afin de l'exécuter. Une autre manière de le voir une image est un conteneur vierge, pas encore exécuté.
* Un **conteneur** est une image qui fut exécuter au moins une fois, donc initialiser sur un docker __host__, avec des configurations (Variable d'environnement, assignation réseau , partage d'espace disque , ...) .

Vous pouvez trouver un **GRAND nombre** d'image sur le site [hub.docker.com](https://hub.docker.com/). 

Prenons quelques minutes pour regarder le contenu, [hub.docker.com/explore](https://hub.docker.com/explore/), juste pour vous donner une idée du contenu.
Il y a 2 type d'image disponible :

* **OFFICIEL** : C'est images sont valider par le fournisseur est considérer comme officiel par le "manufacturé" , comme vous pouvez le voir vous retrouvez :
    * [Ubuntu](https://hub.docker.com/_/ubuntu/)
    * [Mysql](https://hub.docker.com/_/mysql/)
    * [Apache](https://hub.docker.com/_/httpd/)
    * [Wordpress](https://hub.docker.com/_/wordpress/)
* **PUBLIQUE** : C'est images sont créer par des internautes, ils sont donc non valider par un tierce, par le fait même il important de les utiliser avec parcimonie, lors de teste ou de valider le contenu !
    * [le miens :D](https://hub.docker.com/u/x3rus/)
    * [nexus](https://hub.docker.com/r/sonatype/nexus/)
    * [Mysql mais non officiel](https://hub.docker.com/r/tozd/mysql/)

### <a name="Composante" /> Composante de l'architecture 

Voici une représentation graphique de l'architecture dans son état la plus simple :

![architecture.svg](./imgs/architecture.svg)


Docker utilise une architecture **client-server** :

* Le **client docker** communique avec le **Docker daemon (serveur)**.
* Le **Docker daemon (serveur)** réalise l'ensemble des opérations sur les images, les conteneurs , l'assignation des ressources , ...
* Le **client** et le **serveur** peuvent être sur la même machine ou sur 2 systèmes distinct.
* 2 mode de communication sont possible **API REST** et **socket**.
* Le **registry** est un lieu de stockage des images , ce **registry** peut être publique ([hub.docker.com](http://hub.docker.com)) ou privé à l'aide d'application libre ou privative (ex: [Nexus](https://www.sonatype.com/docker), [Docker registry](https://docs.docker.com/registry/) ).


Regardons rapidement le __workflow__ de l'utilisation de docker afin de voir l'interaction des composantes !

* Pré requis (voir documentation sur le site officiel : [Installation pour MacOS](https://docs.docker.com/engine/installation/mac/) , [Installation pour Windows](https://docs.docker.com/engine/installation/windows/), [Installation sous GNU/Linux](https://docs.docker.com/engine/installation/linux/ubuntulinux/) )
    * Installation du client docker
    * Installation du serveur docker 

1. Le client récupère une image depuis un **registry**, pour les besoins de la formation je vais récupérer l'image du conteneur de __Ubuntu 16.04 (LST)__ disponible sur le __registry__ publique de docker : [https://hub.docker.com/\_/ubuntu/](https://hub.docker.com/_/ubuntu/).

        $ docker pull ubuntu:16.04

    * L'image est récupérer depuis le __registry__ est copié localement sur le serveur __Docker\_Host__

    Bien entendu j'aurais pu utiliser d'autre distribution telle que :

    * [Centos](https://hub.docker.com/_/centos/)
    * [debian](https://hub.docker.com/_/debian/)
    * [opensuse](https://hub.docker.com/_/opensuse/)

2. Le client crée un conteneur avec comme source l'images , préalablement récupéré.

        $ docker run --interactive --tty ubuntu:16.04 bash
        root@866d8d61534a:/# 
        root@866d8d61534a:/# cat /etc/lsb-release
        DISTRIB_ID=Ubuntu
        DISTRIB_RELEASE=16.04
        DISTRIB_CODENAME=xenial
        DISTRIB_DESCRIPTION="Ubuntu 16.04.1 LTS"

3. Visualisation des conteneurs en exécution :

        $ docker ps
        CONTAINER ID    IMAGE           COMMAND      CREATED             STATUS              PORTS    NAMES
        866d8d61534a    ubuntu:16.04    "bash"       2 minutes ago       Up 2 minutes                 tender_borg

Les images sont conceptuellement minimal , si nous essayons quelques commandes considérées comme de base , nous serons surpris , voici quelques exemple :

        root@866d8d61534a:/# wget
        bash: wget: command not found
        root@866d8d61534a:/# vim
        bash: vim: command not found
        root@866d8d61534a:/# vi
        bash: vi: command not found
        root@866d8d61534a:/# less
        bash: less: command not found
        root@866d8d61534a:/# sed --version
        sed (GNU sed) 4.2.2
        Copyright (C) 2012 Free Software Foundation, Inc.
        [... OUTPUT COUPÉ ...]

4. Si nous listons les processus en utilisation, nous allons constater l'isolation en place :

        root@866d8d61534a:/# ps aux
        USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
        root         1  2.0  0.0  18248  3136 ?        Ss   22:03   0:00 bash
        root        11  0.0  0.0  34424  2664 ?        R+   22:03   0:00 ps aux


Bien entendu dans le cas présent j'ai démarrer un système Ubuntu de version 16:04, mais ceci est une image vide sans application spécifique , nous verrons lors de la création d'image que nous utiliserons l'image Ubuntu:16.04 pour créer nos propres images. Prenons un autre exemple par exemple nous désirons avoir un serveur __MySQL__ de version 5.5 ou un serveur web __Apache (httpd)__ de version 2.4.

1. Récupération des images depuis le [hub de docker](https://hub.docker.com).
    * httpd : [https://hub.docker.com/\_/httpd/](https://hub.docker.com/_/httpd/)
    * mysql : [https://hub.docker.com/\_/mysql/](https://hub.docker.com/_/mysql/)

            $ docker pull mysql:5.5
            [... OUTPUT COUPÉ ...]
            $ docker pull httpd:2.4
            2.4: Pulling from library/httpd
    
            386a066cd84a: Downloading [====>                                              ] 4.718 MB/51.36 MB
            a11d6b8e2fac: Download complete
            c1fdc7beec37: Downloading [=====================>                             ]  4.98 MB/11.74 MB
            bd14a67deca2: Downloading [====================================>              ] 5.504 MB/7.557 MB
            92b34ad02810: Waiting

2. Exécution du conteneur __Mysql__ version 5.5 , à l'aide de la variable **MYSQL\_ROOT\_PASSWORD** je donne en paramètre le mot de passe administrateur **root** à utiliser lors de l'initialisation de la base de donnée dans le conteneur.

            $ docker run -e MYSQL_ROOT_PASSWORD=super   mysql:5.5
            Initializing database
            161115 21:55:39 [Note] /usr/local/mysql/bin/mysqld (mysqld 5.5.52) starting as process 60 ...
            161115 21:55:39 [Note] /usr/local/mysql/bin/mysqld (mysqld 5.5.52) starting as process 66 ...
            [... OUTPUT COUPÉ ...]
            161115 21:55:45 [Warning] 'proxies_priv' entry '@ root@c78d6c624c23' ignored in --skip-name-resolve mode.
            161115 21:55:45 [Note] Event Scheduler: Loaded 0 events
            161115 21:55:45 [Note] mysqld: ready for connections.
            Version: '5.5.52'  socket: '/tmp/mysql.sock'  port: 3306  MySQL Community Server (GPL)

3. Nous avons donc une serveur __Mysql__ disponible initialiser avec le mot de passe fournit en paramètre. Nous voyons donc clairement la relation image , environnement dormant et le conteneur qui réalise l'initialisation de l'environnement au démarrage !

4. Comme les conteneurs sont isolés les un des autres il est possible d'en démarrer plusieurs, que ce soit avec la même version ou de version différente. Ici j'ai démarrer 3 conteneurs utilisant la même images mysql:5.5 

            $ docker ps
            CONTAINER ID    IMAGE          COMMAND                  CREATED          STATUS          PORTS        NAMES
            aca7e9170345    mysql:5.5      "docker-entrypoint.sh"   2 seconds ago    Up 1 seconds    3306/tcp     berserk_cray
            3777a485cd3c    mysql:5.5      "docker-entrypoint.sh"   3 seconds ago    Up 2 seconds    3306/tcp     ecstatic_bhaskara
            20b147c5b5b5    mysql:5.5      "docker-entrypoint.sh"   7 seconds ago    Up 6 seconds    3306/tcp     grave_fermi

5. Même opération avec une serveur web.

            $ docker run http:2.4 
            AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message
            AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message
            [Wed Nov 16 13:11:05.338493 2016] [mpm_event:notice] [pid 1:tid 140338600580992] AH00489: Apache/2.4.23 (Unix) configured -- resuming normal operations
            [Wed Nov 16 13:11:05.338790 2016] [core:notice] [pid 1:tid 140338600580992] AH00094: Command line: 'httpd -D FOREGROUND'

6. Visualisation du résultat en allant sur l'URL : http://172.17.0.2
    Comme ça le dis : "Ça marche :D "

Ceci est vraiment intéressant pour valider des applications, vous voyez une application qui semble bien, que ce soit web base ou même une application native , vous désirez l'essayer vous télécharger le conteneur , vous valider le fonctionnement si ceci ne vous convient pas vous détruisez le conteneur et on en parle plus :D. Nommez moi une application nous la trouverons sur le **registry** publique de Docker.

* Avantage 
    * **Simplicité de réalisation  de teste d'application sans polluer l'environnement de travail**
    * **Conteneur pré configurer et fonctionnel peut importe le lieu**
    * **Possibilité d'avoir plusieurs application identique avec plusieurs version** (exemple __Mysql__ 5.5, 5.7 , ...)
    * **L'exécution est possible même sur une petite machine, telle qu'un portable** (contrairement à une machine virtuel qui est très couteux en terme de ressource)

# <a name="PrincipeDuConteneur" /> Philosophie lors de l'utilisation du conteneur

L'important est de comprendre  les principes et la philosophie du produit , c'est un nouveau paradigme , comme la visualisation fut une nouvelle manière de gérer un parc informatique.

## <a name="OneProcessByconteneur" /> UN processus par conteneur 

L'objectif n'est pas de recréer une machine Virtuel , nous reprenons le même concept que sous les systèmes GNU/Linux :
* 1 conteneur fait une opération et il le fait BIEN !

Donc lors de la création d'une images si vous avez une application à 3 partie (web, application, base de données) nous aurons au minimum 3 conteneurs.
Dans la partie [Orchestration des conteneurs](#orchestration) nous verrons comment les lier ensemble.

Pourquoi ?!?!
* Pour être en mesure de déployer RAPIDEMENT un conteneur .
* Assurer un démarrage rapide du conteneur, afin de supporter une monté en charge.
* Permettre à l'utilisateur de n'utiliser qu'une partie du tous .
* Permettre de changé un conteneur par un autre , exemple nouvelle base de données tous en conservant les même conteneurs applicatif.
* Ceci vous permet de réutiliser des images pour d'autre conteneur.

### <a name="exampletomcat" /> Application de type service tomcat

Si vous avez une application de contenu dans __Jboss__ ou __Tomcat__ votre application est probablement déjà segmenté selon le service, par exemple :

* /admin : Section de gestion du service applicatif.
* /api : Pour les appels d'applicatif automatisé.
* /websocket : Pour les services web service.
* /urlManagement : Si votre service fait de la gestion d'URL dynamique.

Dans le modèle traditionnel bien souvent nous retrouverons l'ensemble sur la même machine Virtuel sous le même __Tomcat__ regroupant l'ensemble des applications. Dans le modèle **docker** nous essayerons d'avoir 4 conteneurs pour réaliser cette opération , ceci peut être sur la même machine l'un empêche pas l'autre cependant l'ensemble sera isolé l'un de l'autre. 
Ceci permettra par exemple de réutiliser pour une autre application la section /urlManagement , car elle est autonome . De plus si nous avons une monté en charge d'application satellite réalisant un grand nombre de requête nous pourrons augmenter le nombre de conteneur avec un coût minimal afin d'assurer la monté en charge.

Telle que mentionné précédemment __docker__ peut être exécuter sur un simple ordinateur portable, résultat si la personne ne travail que sur le module d'administration il n'aura que le conteneur d'administration à démarrer . Bon OK  ! Probablement l'API aussi cependant nous limitons le requis à uniquement ce qui doit être en exécution.

Si nous poussons un peu plus la logique et regardons le service de cloud , telle que __AWS__ le coût des petites machines sont très abordable , le prix change significativement lors de l'allocation de ressource. Plusieurs petites machines offre donc une plus grande souplesse pour répondre au demande selon la charge.

## <a name="NosoftUseless" /> Ne PAS installé d'application inutile

Ne pas inclure dans le conteneur des applications inutile l'objectif est d'avoir un image minimal au maximum afin d'avoir une taille le plus petit possible afin de faire un déploiement rapidement de l'image. En d'autre mot le strict minimum !

Un exemple d'application inutile :
* VIM ou __VI__ : Vous n'avez pas à modifier des fichiers dans le conteneur, l'image doit être réalisé de manière approprié . Si vous avez besoin de modifier des fichiers dans le conteneur, vous pouvez éditer sur le docker __host__ puis les copier dans le conteneur désirer.
* SSH : S'il vous plait n'activez pas le service SSH dans un conteneur à moins que ce soit le rôles du conteneur, vous utiliserez ssh sur le docker __host__ puis établirez la connexion dans le conteneur.
* ...

Vous comprenez le principe, si vous avez besoin d'une application supplémentaire il est toujours possible de créer une autre image avec comme source l'image original. 

## <a name="conteneurLife" /> Le cycle de vie d'une application dockerisé

Voyons un peu le cycle de vie !!!

Les requis !!!

* Une source de l'application , dans le modèle traditionnel nous utiliserons un système de type __Nexus__ pour conserver nos artefacts applicatif , ce dernier reste en place !! Mais nous ajoutons un nouvelle artefact qui est **l'image docker**, donc en plus d'avoir la __release__ applicative contenant l'ensemble de l'application nous aurons un autre __release__ de l'image docker contenant l'application complète .
    * L'objectif est de fournir un artefact fiable de l'applicatif avec l'ensemble des dépendances requis.
* L'image utiliser doit être la même sur l'ensemble de la chaîne de développement, Le développeur est le premier à l'utiliser. L'image peut être générer avec l'aide de l'équipe **DevOps**. Le développement , la correction de __bug__ est réalisé avec ce conteneur. Bien entendu ce conteneur est un peu particulier car son but premier est d'assurer l'ensemble des dépendances requis , le contenu applicatif peut être plus dynamique. L'image résultant généré à toutes les nuits ou du moins régulièrement est déployé sur les serveurs d'intégration / QA , ...
    * L'objectif : Comme l'ensemble des intervenants utilise la même image de l'application , la détection de problématique sera propagé sur l'ensemble des intervenant. Nous nous assurons aussi que l'ensemble est identique peut importe l'environnement déployé.
* Configuration de l'application , bien entendu tous les environnements ne sont pas identique, si nous nous limitons uniquement au adresses courriel, URL d'accès, etc . Ceci change d'un environnement à l'autre. L'idée est que l'ensemble des ces paramètres sont dynamiquement modifier lors de l'initialisation du conteneur. Donc même image , même installation , même librairie, même __war__ , même code source , uniquement des variables qui sont modifier.

Voyons une représentation graphique de mon propos :

![docker-workflow.png](./imgs/docker-workflow.png)

Éclaircissement sur la question de la configuration lors de l'exécution , nous l'avons vu précédemment lors de l'initialisation du conteneur __mysql__ , nous avions définie lors de l'initialisation le mot de passe de l'administrateur grâce à la variable **MYSQL_ROOT_PASSWORD**, exemple de la commande :

            $ docker run -e MYSQL_ROOT_PASSWORD=super   mysql:5.5

## <a name="ComBetweenContener" /> Communication entre les conteneurs

Les conteneurs peuvent communiquer entre eux via : ![docker-turtles-communication.jpg](./imgs/docker-turtles-communication.jpg)

* Le protocole réseaux : mode privilégier, via des API ceci est donc indépendant du système docker et utilise des protocoles connu.
* Unix socket : Si une communication réseau extérieur n'est pas requis un unix socket peut très bien faire le travail.
* Fichier ou répertoire partagé : Il est possible de partager des répertoires entre plusieurs conteneur pour l'échange de fichiers.

# <a name="DevilIsInDetail" /> Analysons un peu le fonctionnement 

Allons voir un peu le fonctionnement afin de saisir les possibilités, les limitations, les points à prendre en considération. En comprenant le fonctionnement le système vous comprendrez pourquoi il faut manipuler les images ou les conteneurs. L'objectif de cette section n'est pas de vous dire comment utiliser Docker, mais vous expliquer comment il fonctionne. À vous par la suite de trouver votre manière :D !

Voici ma démarche qui sera préconisé :
* Clarification des commandes de base de docker afin de démystifier les commandes que j'utilise.
* Utilisation d'un conteneur apache, afin de présenter les couches (__layers__) d'un conteneur.
* Personnalisation d'une images pour nos besoins.
* Utilisation des données avec un conteneur.

## <a name="cmdDeBaseDeDocker" /> Commande de base d'utilisation de docker.

Je vais rapidement couvrir les commandes que j'ai et vais utiliser par la suite, afin que tous le monde soit confortable avec le processus.

* [docker pull](https://docs.docker.com/engine/reference/commandline/pull/) : Permet de récupérer une images depuis un **registry** privé ou publique.
* [docker images](https://docs.docker.com/engine/reference/commandline/images/) : Permet de lister les images présente sur le docker host.
* [docker run](https://docs.docker.com/engine/reference/commandline/run/) : Permet de démarrer un nouveau conteneur avec une image comme point de départ.
* [docker start](https://docs.docker.com/engine/reference/commandline/start/) : Permet de démarrer un conteneur qui fut initialiser avec l'instruction __docker run__ préalablement. Ceci peut être vue comme un conteneur dormant :D, contrairement à une image ce dernier fut déjà initialisé une fois.
* [docker ps](https://docs.docker.com/engine/reference/commandline/ps/) : Liste les conteneurs en utilisation ou qui fut exécutés récemment.
* [docker exec](https://docs.docker.com/engine/reference/commandline/exec/) : Permet d'exécuter une commande dans le conteneur , comme vous pourrez le constater, il est possible d'utiliser la commande **bash** pour être en mode interactif.
* [docker stop](https://docs.docker.com/engine/reference/commandline/stop/) : Permet d'arrêter un conteneur en exécution.
* [docker rm](https://docs.docker.com/engine/reference/commandline/rm/) : Permet de supprimer un conteneur.
* [docker rmi](https://docs.docker.com/engine/reference/commandline/rmi/) : Permet de supprimer une image qui fut copier sur le serveur local , ceci ne supprime pas l'image du **registry**.
* [docker build](https://docs.docker.com/engine/reference/commandline/build/) : Permet de créer une images en utilisant un fichier __Dockerfile__ comme référence contenant l'ensemble des instructions.

Commençons avec ces instructions, nous verrons par la suite qu'il y a plusieurs autres commande disponible , pour les personnes trop curieuse :P, voici le lien vers les autres possibilité [docker commandline](https://docs.docker.com/engine/reference/commandline/).

## <a name="TheConteneur" /> Le Conteneur

Donc maintenant que nous avons un aperçu des commandes nous allons pouvoir parler des conteneurs et mieux comprendre leur fonctionnement , premièrement je vais récupérer le conteneur **[x3rus/apache:ubuntu](https://hub.docker.com/r/x3rus/apache/)**. Ce n'est pas une image qui révolutionne le genre, mais je voulais avoir quelque chose de simple pour la présentation.

        $ docker pull x3rus/apache:ubuntu

Nous pouvons donc voir le conteneur avec la commande **docker images**

        $ docker images | grep apache
        x3rus/apache                  ubuntu              c135ec9e34db        32 minutes ago      265.4 MB

Exécutons se dernier :

        $ docker run x3rus/apache:ubuntu
         * Starting Apache httpd web server apache2
         * AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message
         *
En allant sur l'URL [http://172.17.0.2/](http://172.17.0.2/), nous avons la page par défaut de Ubuntu.

![defaut_apache_ubuntu.png](./imgs/defaut_apache_ubuntu.png)

Lors de la description j'ai mentionné que :

* " Une **image** est l'artefact d'un conteneur " : L'image est en lecture seul , cette dernière ne peux PAS être modifier.

### <a name="TheConteneurLayer" /> Couche de système de fichier d'un conteneur

Si vous avez déjà eu un système GNU/Linux en lecture seul, vous pouvez tous simplement RIEN faire avec, il n'est pas utilisable. Donc lors de l'initialisation du conteneur le **docker** crée une couche  (**layer**) par dessus l'image qui elle peut être écrite.

(désolé pour la qualité de l'image, je ne suis pas __infographe__ :P )

![conteneur-x3rus-apache.png](./imgs/conteneur-x3rus-apache.png)

Comme vous pouvez le voir l'image de base __x3rus/apache__ est présent au début, avec l'aide du système __d'unionfs__, ce dernier permet d'unir des systèmes de fichier lors de l'initialisation du conteneur, donc d'avoir la couche d'écriture sur le dessus. 

Bien entendu si vous désirez avoir un site web, il est peu probable que vous désirez avec uniquement la page par défaut d'Ubuntu :P. Afin de bien démontré cette couche (__layer__) nous allons modifier la page web, contenu dans __/var/www/html/__

Pour ce faire je vais aller dans le conteneur directement et éditer la page d'index tous simplement.

        $ docker exec -it awesome_feynman bash
        root@f9e12b41da05:/# cd /var/www/html/
        root@f9e12b41da05:/var/www/html#
        root@f9e12b41da05:/var/www/html# mv index.html index-ori.html
        root@f9e12b41da05:/var/www/html# vim index.html
        root@f9e12b41da05:/var/www/html# cat index.html
        Une super page

Si nous regardons maintenant la page : [http://172.17.0.2/](http://172.17.0.2/) , nous n'avons plus la page par défaut mais le petit texte définir.

![super_page_index.png](./imgs/super_page_index.png)

Si j'arrête le conteneur et le redémarre .

        $ docker stop awesome_feynman
        $ docker run x3rus/apache:ubuntu
        * Starting Apache httpd web server apache2
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message
        * 

Même adresse IP , retournons à l'URL : [http://172.17.0.2/](http://172.17.0.2/) ... **OUPSS** retour de la page par défaut d'apache, POURQUOI ? 

* Si nous reprenons la représentation du conteneur préalablement affiché:
    Lors de l'initialisation du conteneur la couche (__RW__) supérieur est ajoutée, lors de l'arrêt du conteneur la couche supérieur est par défaut supprimé.
    ![conteneur-x3rus-apache.png](./imgs/conteneur-x3rus-apache.png)

* **Avantage** :
    * À chaque démarrage vous repartez du point de référence qui est l'image , donc de l'artefact valider en amont
    * S'il y a un problème avec le conteneur l'arrêt et redémarrage de ce dernier nous ramène à l'état original très pratique lors des testes.
* **Desavantage**: 
    * perte des logs sur le système lors d'un redémarrage du serveur voir crash.
    * Si vous avez mis un conteneur __MySQL__ par exemple perte des données de la base de donnée :P

Bon là vous vous dites , finalement c'est **NUL** docker !!

![chevre-langue.png](./imgs/chevre-langue.png)

Mise en contexte historique de la création de docker, ceci vous aidera probablement à comprendre la logique en arrière de cette configuration.
Le système docker fut développé pour la mise en place de **micro-services** , l'objectif original était de pouvoir __scaler__  rapidement un système , lors d'une monté en charge. 

Exemple un service de ventes de tickets pour des spectacles, en temps normale un 10 serveurs sont suffisant , mais voilà 2 fois par année des gros spectacle arrives. Que faire acheter 10 autres serveurs pour une utilisation de 2 semaines par années ?!?!? 
L'idée fut d'avoir un mécanisme simple pour déployé de web service qui ne conserve pas de donnée localement mais se réfère à une base de donnée pour faire le traitement. Avec ce mécanisme, grâce aux images l'ensemble des déploiement sont toujours identique, car tous est inclut dans le conteneur , lors de la suppression tous est effacé par de résidus.

Ça c'était au début :D, bien entendu avec la monté en popularité de __Docker__ de nouveau besoin sont arrivé, donc la communauté a demandée ces nouvelles fonctionnalité. Nous allons voir maintenant ces mécanisme qui nous permettra de conserver les données.

### <a name="NameWritableLayer" /> Nommé le conteneur donc la couche d'écriture

Une des possibilités est de conserver la couche supérieur, avec cette configuration la couche supérieur est attaché au conteneur s'il y a arrêt de se dernier la couche supérieur sera réassignée au conteneur. 

Voyons cette méthode :

        $ docker run --name "mon_site"  x3rus/apache:ubuntu

Comme vous pouvez le constater j'ai ajouter l'instruction **--name** afin de nommé le conteneur, avec la commande **docker ps** maintenant je n'ai plus un nom aléatoire mais le nom de mon conteneur.

        $ docker ps
        CONTAINER ID    IMAGE                 COMMAND        CREATED          STATUS          PORTS       NAMES
        d92896b3aa3f    x3rus/apache:ubuntu   "/start.sh"    27 seconds ago   Up 25 seconds   80/tcp      mon_site

Si j'accède à la page à l'URL [http://172.17.0.2](http://172.17.0.2) je vois la page par défaut d'Ubuntu. 

Je vais modifier la page comme lors de la dernière opération . 

        $ docker exec -it mon_site bash
        root@d92896b3aa3f:/# cd /var/www/html
        root@d92896b3aa3f:/var/www/html# vim index.html
        root@d92896b3aa3f:/var/www/html# cat index.html
        Conteneur nomme mon_site

Super le site affiche maintenant la bonne page ... On repassera pour la "belle" page :D.

J'arrête et redémarrage le conteneur .

        $ docker stop mon_site
        mon_site
        $ docker run --name "mon_site"  x3rus/apache:ubuntu
        docker: Error response from daemon: Conflict. The name "/mon_site" is already in use by container d92896b3aa3f5145f2f9a4643b6ff50ebc6a8a6d362e714c359733017a86a269. You have to remove (or rename) that container to be able to reuse that name..
        See 'docker run --help'.

Si j'utilise la même commande pour démarrer le conteneur j'ai un message d'erreur, car la couche supérieur ne peux être assigné qu'a **UN** conteneur, comme le conteneur fut déjà initialisé nous devons utiliser l'instruction **docker start**.

        $ docker start mon_site
        mon_site

Je communique  sur l'URL [http://172.17.0.2](http://172.17.0.2) , **magie** ma page est toujours présente !!

* Avantage :
    * Dans le cadre de teste et d'exploration d'une configuration ceci peut être intéressant vous évitent de transpirer ou maudire __Docker__ si votre machine crash ou __reboot__ !!
    * Dans le cadre d'un conteneur applicatif de production, il est possible que vous préférez avec la stabilité et surtout l'historique des opérations sur la machine.
* **Problème** :
    * En utilisant cette technique vous serez constamment déphasé avec vos images, dans cette situation vous utiliserez les conteneurs comme des machines virtuel. Résultat à chaque démarrage d'un nouveau conteneur, vous devrez réalisé l'ensemble des configurations et transfère des fichiers afin de l'avoir fonctionnel. Vos images auront peu de valeur et la possibilité de mettre en place un conteneur avec l'ensemble des configurations équivalent est perdu ! Vous avez simplement une installation automatique du système.
    * Vos conteneur ne peuvent être démarrer automatiquement, sur demande pour répondre à une augmentation de charge.
    * L'espace disque dur va augmenter de manière significatif car la couche supérieur prendra de l'espace dans le temps.


Petit truc :D , il est possible que ce soit un conteneur nominatif ou avec un nom aléatoire de connaitre la différence entre l'image et le conteneur en exécution grâce à l'instruction **docker diff**.

        $ docker diff mon_site
        C /var
        C /var/www
        C /var/www/html
        C /var/www/html/index.html
        C /var/log
        C /var/log/apache2
        C /var/log/apache2/access.log
        C /var/log/apache2/error.log
        C /run
        A /run/apache2
        A /run/apache2/apache2.pid
        C /run/lock
        A /run/lock/apache2
        C /root
        A /root/.bash_history

Comme je n'aime pas cette solution je vais détruire le conteneur **mon_site** :

        $ docker stop mon_site
        mon_site
        $ docker rm mon_site
        mon_site


### <a name="UtilisationVolConteneur" /> Utilisation de volume pour le conteneur

Une autre méthode disponible est la possibilité d'assigner un répertoire du **docker host** disponible / accessible depuis le conteneur. Équivalent pour les __GNU/Linuxiens__ d'un **mount bind**.

Pour ce faire je vais démarrer un conteneur avec l'image __x3rus/apache:ubuntu__  en réassignant le répertoire __/var/www/html__ du conteneur par le répertoire __/srv/docker/x3Apache/www/__.

Comme j'initialise une nouveau conteneur j'utilise la commande **docker run** et j'ajoute l'option **--volume**.

        $ docker run --volume /srv/docker/x3Apache/www/:/var/www/html   x3rus/apache:ubuntu

Voici le résultat quand j'accède à l'URL [http://172.17.0.2](http://172.17.0.2).

![apache_ubuntu-sans-index.png](./imgs/apache_ubuntu-sans-index.png)

Bizarre je n'ai pas la page par défaut d'Ubuntu :-/ ... Regardons le contenu du répertoire __/var/www/html/__ .
Ici j'utilise la commande **docker exec**, pour faire changement je n'utilise pas **bash** pour avoir un __shell__, mais exécute la commande **ls**

        $ docker exec  sleepy_lichterman ls -lR /var/www/
        /var/www/:
        total 4
        drwxr-xr-x 2 root root 4096 Nov 17 22:14 html

        /var/www/html:
        total 0

Le répertoire est **VIDE**, car le point de montage dans notre cas __/srv/docker/x3Apache/www/__ à prédominance sur __/var/www/html__.
Ajoutons une page __index.html__ dans le répertoire __/srv/docker/x3Apache/www/__.


        $ sudo vim /srv/docker/x3Apache/www/index.html  
        $ cat /srv/docker/x3Apache/www/index.html
        un page depuis le point de montage

La page s'affiche avec le contenu du répertoire __/srv/docker/x3Apache/www/__ présent sur le docker __host__.

![index_point_de_montage.png](./imgs/index_point_de_montage.png)

Je peux avec cette configuration démarrer un deuxième conteneur utilisant le même répertoire de référence du docker __host__.

        docker run --volume /srv/docker/x3Apache/www/:/var/www/html   x3rus/apache:ubuntu
         * Starting Apache httpd web server apache2
         AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.3. Set the 'ServerName' directive globally to suppress this message
         *

Si vous accédez à l'URL [http://172.17.0.3/](http://172.17.0.3/).

![index_point_de_montage.png](./imgs/index_point_de_montage.png)

* Avantage : 
    * Ceci vous permet de conserver les données du conteneur en dehors du conteneur, que ce soit pour une utilisation entre 2 conteneur applicatif, ou entre le conteneur et votre système.
    * Si vous être en mode développement il est possible que ce répertoire suit utiliser pour être traité par le conteneur, mais que vous préfériez avoir vos éditeur graphique pour faire l'ensemble des modifications sur les fichiers.
    * Ceci vous permet si un conteneur fournissant une application __web__ et que les utilisateurs __upload__ des fichiers de les stocké en dehors du conteneur.
    * Permet d'avoir le contenu de la base de données en dehors du conteneur.
* **Problème** :
    * Si vous réalisez la même opération que moi votre site web n'est PAS dans le conteneur, il n'est donc pas transférable avec le conteneur d'un docker __host__ à l'autre. 
    * Vous cassez le principe du conteneur qui doit être self content, vous n'aurez pas le même application (web, ici) sur l'ensemble des environnements.
    * Vous êtes à risque car vous réaliserez des modifications, alors que le principe est que votre images est le point de références.

Donc avant de voir la partie réseau nous allons voir comment personnaliser votre image afin d'inclure vos informations et ainsi suivre le principe de __docker__.

## <a name="TheImage" /> L'image

Telle que mentionné précédemment l'image est le point de référence du conteneur , **LA SOURCE** ! La création d'une image est réalisé à l'aide du fichier __Dockerfile__, ceci est un fichier texte qui d'écrit les étapes pour la réalisation de l'image.

Analysons le **Dockerfile** de l'image **x3rus/apache:ubuntu** utilisé jusqu'ici : 

        FROM ubuntu:16.04
        MAINTAINER Boutry Thomas "thomas.boutry@x3rus.com"

        # install apps
        RUN apt-get update && \
            apt-get install -y apache2 vim

        COPY start.sh /

        CMD ["/start.sh"]

Lançons la "compilation",  le "__build__" pendant les explications .

        $ time docker build -t x3rus/apache:demo .

Comme vous pouvez le lire je suis partie d'une image **officiel** de Ubuntu LTS (16.04) par la suite :
* j'installe l'application **apache2** ET **vim**
* Je copie le fichier **start.sh** dans le conteneur à la racine
* J'indique que lors du démarrage du conteneur il doit exécuter le script __start.sh__

Et Voilà :D , pas plus compliqué , bien entendu il y énormément plus d'option disponible , pour ne pas charger la formation je vous laisse les consulter :

* [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)

Ce qui est super bien, **VIVE LE LIBRE** est que si vous cherchez des conteneurs sur [http://hub.docker.com](http://hub.docker.com), vous avez plein d'exemple de __Dockerfile__ disponible. Voici par exemple celui pour l'application de sondage : [https://hub.docker.com/r/crramirez/limesurvey/~/dockerfile/](https://hub.docker.com/r/crramirez/limesurvey/~/dockerfile/)


### <a name="TheImageLayer" /> Couche de système de fichier d'une image

Nous avons vu que lors de l'exécution d'un conteneur une couche en Lecture/Écriture était superposé sur l'image de référence , en fait l'image ELLE même est constitué de couche. Si nous reprenons l'image **x3rus/apache:ubuntu** , voici la représentation graphique des couches (je suis toujours pas __infographe__) :

![docker-filesystems-multilayer-x3rus-ubuntu.png](./imgs/docker-filesystems-multilayer-x3rus-ubuntu.png)

Chaque instruction constitue une couche, l'avantage est que si nous modifions une des couches (ajout ou suppression) toutes les couches antérieurs sont conservé et ne doivent pas être recréer .

Voici une démonstration en ajoutant une page web par défaut dans le répertoire __/var/www/html/__. 

Avant tous regardons le temps que prend la création de l'image initialement.

        $ time docker build -t x3rus/apache:ubuntu .
        [ ... OUTPUT COUPÉ ... ]
        Step 6 : CMD /start.sh
         ---> Running in 03bbf1e21a29
         ---> aca1ca5d565a
        Removing intermediate container 03bbf1e21a29
        Successfully built aca1ca5d565a

        real    1m58.875s
        user    0m0.053s
        sys     0m0.020s

Donc 1 minutes et 58 secondes.

Je vais ajouter un fichier grâce à l'instruction **COPY** .

        $ ls
        Dockerfile  index.html  start.sh
        $ cat index.html
        un page fait par moi !

Une fois la page créé je modifie le __Dockerfile__ :

        FROM ubuntu:16.04
        MAINTAINER Boutry Thomas "thomas.boutry@x3rus.com"

        # install apps 
        RUN apt-get update && \
            apt-get install -y apache2 vim

        COPY start.sh /
        COPY index.html /var/www/html/
        EXPOSE 80

        CMD ["/start.sh"]

J'ai ajouter la ligne : **COPY index.html /var/www/html/**

Je refait l'image avec un autre nom :

        $ time docker build -t x3rus/apache:ubuntu-cust .
        Sending build context to Docker daemon 4.096 kB
        Step 1 : FROM ubuntu:16.04
         ---> c73a085dc378
        Step 2 : MAINTAINER Boutry Thomas "thomas.boutry@x3rus.com"
         ---> Using cache                       <<<<= CACHE !!!
         ---> c3ffe3712728
        Step 3 : RUN apt-get update &&     apt-get install -y apache2 vim
         ---> Using cache                       <<<<= CACHE !!!
         ---> 8b488091e528
        Step 4 : COPY start.sh /
         ---> Using cache                       <<<<= CACHE !!!
         ---> f012c91050c3
        Step 5 : COPY index.html /var/www/html/
         ---> 26f40e9b85c4
        Removing intermediate container 1dab3315a54b
        Step 6 : EXPOSE 80
         ---> Running in 7afdd74ae4cc
         ---> 8e56ba0155d2
        Removing intermediate container 7afdd74ae4cc
        Step 7 : CMD /start.sh
         ---> Running in dc6fe9034f03
         ---> d31e49e2c3f5
         Removing intermediate container dc6fe9034f03
        Successfully built d31e49e2c3f5

        real    0m6.979s
        user    0m0.017s
        sys     0m0.007s

Dans ce cas nous n'avons pris que 0 minutes 6 secondes , car l'ensemble des opérations d'installation des pacquages ne fut pas réalisé mais la couche (__layer__) déjà généré fut utilisée.

En d'autre mot le système a réutilisé les couches précédente augmentant la rapidité de déploiement, vous pouvez ainsi facilement modifier votre image pour des testes de déploiement intégré.

Ce système d'utilisation de couche (__layer__) sera aussi utilisé lors du transfert de votre image vers un **registry** !

Dans le même ordre d'idée, si vous avez une images **jboss** sur votre docker __host__ et que vous avez 20 conteneurs de démarrés, vous n'aurez qu'une image et 20 couches (__layers__) minimal en Lecture/Écriture.

Suite à ce changement voyons le résultat en démarrant le conteneur :

        $ docker run x3rus/apache:ubuntu-cust
         * Starting Apache httpd web server apache2
         * AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message

Si nous visitons la page : [http://172.17.0.2](http://172.17.0.2).

![page_perso.png](./imgs/page_perso.png)

Nous venons de personnaliser notre images :D.

### <a name="TheImageStartup" /> Script de démarrage contenu dans l'image

Comme vous pouvez le voir à la fin de la définition de l'image il y a l'instruction **CMD \["/start.sh"\]** qui définie le script qui sera utilisé au démarrage. Voici le contenu du fichier __start.sh__

        #!/bin/bash
        #
        ###############################################

        /etc/init.d/apache2 start

        tail -f /var/log/apache2/access.log

Comme vous pouvez voir je démarre le service **apache2** par la suite j'utilise la commande **tail -f**. 
Afin que le conteneur reste disponible il faut que service ne s'arrête PAS et qu'il soit en premier plan. Si je n'avais mis uniquement l'instruction de démarrage **apache2** le service aurez démarré, mais comme il aurait été mis en arrière plan (__daemon__ , __background__) le conteneur se serait arrêté.

Autre avantage, lors de l'utilisation de la commande **docker logs NOM_CONTENEUR** il m'affichera le résultat du fichier __access.log__

## <a name="reduceLayer" /> Évitez la duplication des couches 

Lors de la création d'une images essayez de limiter le nombre de couche (__layer__), voici un exemple à éviter :

        RUN apt-get update
        RUN apt-get install apache2
        RUN apt-get install php5
        RUN apt-get install php5-gd
        RUN apt-get install php5-mysql

Comme nous avons pu le voir précédemment ceci va générer 5 couches (__layer__) , sachez que docker à un limite de 140 couches (__layers__) possible ... Voici une meilleur façons de l'écrire.

        RUN   apt-get update \
            && apt-get install apache2 php5 php5-gd php5-mysql 

Dans la version ci-dessus nous n'avons qu'une couche (__layer__) de définie réduisant la gestion requis par docker.


# <a name="structureConteneurRéseau" /> Réseautique d'un conteneur




# <a name="orchestration" /> Orchestration des conteneurs

TODO: Présenter la philosophy sous docker
TODO: Pourquoi Docker 
    * Faciliter de réaliser des testes d'application sans polluer l'environnement de travail
    * Conteneur pré-configurer et fonctionnel peut importe le lieu.
    *
TODO: Le workflow

Deep down :

# <a name="whyUseDocker" /> Pourquoi utiliser Docker ?



REFÉRENCE : http://fr.slideshare.net/jpetazzo/docker-quels-enjeux-pour-le-stockage-et-reseau-paris-open-source-summit-2015
