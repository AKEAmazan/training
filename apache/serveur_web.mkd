<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>


# Index 

* [ Introduction](#Intro) 
* [ Installation ](#Installation) 
       * [ Démarrage et test après installation](#start_test) 
* [ Configuration de Base](#basic_conf) 
       * [ Fichier Principale ](#main_file) 
       * [ Fichiers Incluent](#include_files) 
* [ Virtual Host par défaut](#virt_host) 
* [ Paramétrisation du serveur](#param_server) 
       * [ Paramétrisation de la configuration Directory](#param_directory) 
           * [ Changement du répertoire Racine ( DocumentRoot)](#param_docroot) 
           * [ Autorisation d'accès par hostname ou ip ( Require )](#Auth_access) 
           * [Utilisation du Virtual host par défaut (bonne pratique)](#virt_host_good) 
       * [ Organisation de la configuration (context)](#context) 
       * [ Surdéfinition de la configuration dans le fichier .htaccess](#context_htaccess) 
           * [ Permission de redéfinition des configurations](#htaccess_allowoverride) 
       * [ Bonne pratique de l'utilisation du fichier .htaccess](#utilisation_de_htaccess) 
* [ VirtualHost](#VirtualHost) 
       * [ Serveurs virtuels par IP](#Vhost_ip) 
       * [ Serveurs virtuels par Nom](#Vhost_name_base) 
* [ Organisation des sites web](#organisation) 
       * [ Organisation des répertoires des serveurs virtuelle](#organisation_rep_vhosts) 
       * [ Configuration Apache pour les serveurs virtuels](#organisation_config_vhosts) 
       * [ Configuration des logs pour les serveurs virtuels](#organisation_logs_vhosts) 
           * [ Rotation des logs pour les serveurs virtuels](#organisation_rotation_logs_vhosts) 
       * [ Utilisation du répertoire privé](#organisation_repertoire_private) 
       * [ Utilisation de la surcharge de configuration (htaccess)](#organisation_utilisation_htaccess) 
       * [ Mutualisation de contenu  / service (Alias)](#organisation_alias) 
       * [ Permissions des répertoires](#organisation_premission_dir) 
* [ Utilisation des modules apache](#module) 
* [ Mise en place d'un site en httpS](#http_ssl) 
       * [ Théorie du fonctionnement des certificats ](#concept_certificat_ssl) 
           * [ C'est quoi un Certificat ?](#c_quoi_le_certificat) 
           * [ Détail de la communication httpS](#handshake_https) 
               * [ Processsus de négotiation des protocols supporté](#negotiation_des_algo) 
               * [ Processus de validation du certificat](#processus_de_validation) 
               * [ Échange d'une clé symétrique](#echange_de_cle_symetric) 
               * [ Représentation graphique détaillé du protocole SSL](#extra_protocol_ssl_img) 
       * [ Configuration simple d'un site web avec mod_ssl](#setup_ssl_website) 

# <a name="Intro" /> Introduction


Apache est apparu en avril 1995. Au début, il s'agissait d'une collection de correctifs et d'additions au serveur NCSA HTTPd 1.3, qui était dans le domaine public et le serveur HTTP alors le plus répandu. De cette origine, de nombreuses personnes affirment que le nom Apache vient de a patchy server, soit « un serveur rafistolé ». Par la suite, Apache a été complètement réécrit, de sorte que, dans la version 2, il ne reste pas de trace de NCSA HTTPd.

Au début, Apache était la seule alternative sérieuse et libre au serveur HTTP de Netscape (iPlanet, maintenant Sun ONE). Depuis avril 1996, selon l'étude permanente de Netcraft2, Apache est devenu le serveur HTTP le plus répandu sur Internet.

Part de marché d'Apache :

* En mai 1999, il faisait tourner 57 % des serveurs Web, début 2004, il était à environ 69 % de parts de marché, et il ne détient plus que 50,61 % du marché à la fin du mois de janvier 2008 ;
* En février 2008, Apache représente 50,93 % des parts de marché ;
* En novembre 2008, 72,45 % de parts de marché pour Apache ;
* En novembre 2011, 65,00 % de parts de marché pour Apache ;
* En mai 2014, 38,00 % de parts de marché pour Apache et 33,00 % pour Microsoft IIS.
* En janvier 2015 sur l'analyse de 876,812,666 sites, correspondant à 5,061,365 ordinateurs frontaux, les parts de marché sont de 39.74 % pour Apache, et 27,52 % pour IIS. Sur les part de marché des serveurs actifs (en excluant les sites parkings) par contre, 50.72 % pour Apache, 14.82 % pour Nginx et IIS passe en 3e position avec seulement 10.55 %, perdant 1.17 % de parts par rapport au mois précédent.

La popularité de GNU/Linux doit beaucoup au serveur web apache et la monté en puissance de l'Internet. Il est indéniable que les organisation furent à la recherche d'une solution "gratuite" et performance afin de fournir les service Internet. 
Parfois il faut pas grand chose pour que la popularité d'une application ou d'un système voit le jours ...

Nous allons voir la structure du logiciel, Apache fonction avec un système de module permettant d'ajouter des fonctionnalités. La configuration d'Apache ce structure selon une hiérarchie de paramètre définie sous des __context__ , nous permettant de définir des valeurs de manière granulaire.

Bon fini l'intro on va jouer un peu :D.

# <a name="Installation" /> Installation 

S'il y a bien une application testé et valider dans une distribution c'est bien le logiciel Apache ! À ma connaissance toutes les distributions offre le logiciel. Bien entendu l'installation peut être différente , voici comment procéder pour __Ubuntu__ et __Redhat__.

        # Pour Ubuntu 
        $ sudo apt-get install  apache2

        # Pour RedHat
        $ sudo yum install httpd


Si nous regardons la structure des fichiers nous constaterons qu'il diffère voyons pour Ubuntu :

        $  ls -l  /etc/apache2/
        total 80
        -rw-r--r-- 1 root root  7115 Jan  7  2014 apache2.conf
        drwxr-xr-x 2 root root  4096 Nov 25 08:20 conf-available
        drwxr-xr-x 2 root root  4096 Nov 25 08:20 conf-enabled
        -rw-r--r-- 1 root root  1782 Jan  3  2014 envvars
        -rw-r--r-- 1 root root 31063 Jan  3  2014 magic
        drwxr-xr-x 2 root root 12288 Nov 25 08:20 mods-available
        1drwxr-xr-x 2 root root  4096 Nov 25 08:20 mods-enabled
        -rw-r--r-- 1 root root   320 Jan  7  2014 ports.conf
        drwxr-xr-x 2 root root  4096 Nov 25 08:20 sites-available
        drwxr-xr-x 2 root root  4096 Nov 25 08:20 sites-enabled

Et maintenant pour Redhat :

        $ ls -l /etc/httpd/
        total 8
        drwxr-xr-x 2 root root 4096 Nov 20 09:29 conf
        drwxr-xr-x 2 root root 4096 Nov 20 09:29 conf.d
        lrwxrwxrwx 1 root root   19 Nov 20 09:29 logs -> ../../var/log/httpd
        lrwxrwxrwx 1 root root   27 Nov 20 09:29 modules -> ../../usr/lib/httpd/modules
        lrwxrwxrwx 1 root root   19 Nov 20 09:29 run -> ../../var/run/httpd

## <a name="start_test" /> Démarrage et test après installation

Démarrage du service Apache :

        # Pour Ubuntu
        $ sudo service apache2 start
        * Starting web server apache2
          
        # Pour RedHat
        $ sudo service httpd start


Vous pouvez dès a présent valider l'installation en allant a l'URL http://IP-du-serveur ou http://127.0.0.1 si l'installation est réalisé directement sur votre poste. Voici le résultat pour Ubuntu :

![default_page_ubuntu.png](./imgs/default_page_ubuntu.png)

Nous allons maintenant mettre une petite page web pour démontré que nous somme bien en mesure de modifier le contenu. Vous pouvez utiliser votre éditeur préféré pour créer le fichier **/var/www/html/demo.html**

        $ cat /var/www/html/demo.html
        Bonjour Ceci fonctionne bien

Pour valider que tout fonctionne bien vous pouvez aller à l'URL __http://IP-du-serveur/demo.html__ ou __http://127.0.0.1/demo.html__. Déjà à ce stade il est possible d'avoir son site web de disponible en installant l'ensemble de vos fichiers dans ce répertoire.

Nous allons maintenant allé un peu plus loin avec l'analyse de la configuration et mieux comprendre comment tous ceci fonctionne.

# <a name="basic_conf" /> Configuration de Base

L'ensemble de la rédaction du fichier de configuration est équivalant pour les 2 systèmes, l'important est de savoir qu'elle est le premier fichier qui est lu lors du démarrage de d'Apache. Nous verrons à la lecture du fichier de configuration que le premier fichier fait des appel __Include__ pour charger ("loader") les autres fichiers de configuration.

## <a name="main_file" /> Fichier Principale 

Le fichier principale est :

* Redhat : **/etc/httpd/conf/httpd.conf**
* Ubuntu : **/etc/apache2/apache2.conf**

**NOTE / Info** Afin de ne pas surcharger la formation en dupliquant les démonstrations de Ubuntu et Redhat nous nous concentrerons uniquement sur Ubuntu. Cependant l'ensemble est équivalent entre les 2 systèmes, car c'est le même logiciel, éventuellement si vous n'arrivez pas a faire la transposition, contacter moi je vous mettrai sur la piste .

La configuration de Redhat est plus linéaire que celle d'Ubuntu, mais bon nous ne pouvons pas changer de système de référence à chaque fois juste parce que l'un est plus simple que l'autre ;-). Nous avons choisi Ubuntu, nous continuons :D.

Visualisation du fichier Principale , Pour ne pas surcharger la documentation je ne vais pas mettre le fichier au complet ici cependant il est disponible en cliquant sur le lien : /etc/apache2/apache2.conf

À la lecture du fichier nous constatons qu'il y a beaucoup de commentaire définie, comme beaucoup de fichier de configuration sous GNU/Linux le caractère # (dièse) est utilisé. Si nous supprimons l'ensemble des commentaires ainsi que les lignes vide ceci donne :

        $ cat /etc/apache2/apache2.conf | grep -v "^#" | grep -v "^$"
        Mutex file:${APACHE_LOCK_DIR} default
        PidFile ${APACHE_PID_FILE}
        Timeout 300
        KeepAlive On
        MaxKeepAliveRequests 100
        KeepAliveTimeout 5
        User ${APACHE_RUN_USER}
        Group ${APACHE_RUN_GROUP}
        HostnameLookups Off
        ErrorLog ${APACHE_LOG_DIR}/error.log
        LogLevel warn
        IncludeOptional mods-enabled/*.load
        IncludeOptional mods-enabled/*.conf
        Include ports.conf
        <Directory />
                Options FollowSymLinks
                AllowOverride None
                Require all denied
        </Directory>
        <Directory /usr/share>
                AllowOverride None
                Require all granted
        </Directory>
        <Directory /var/www/>
                Options Indexes FollowSymLinks
                AllowOverride None
                Require all granted
        </Directory>
        AccessFileName .htaccess
        <FilesMatch "^\.ht">
                Require all denied
        </FilesMatch>
        LogFormat "%v:%p %h %l %u %t \"%r\" %>s %O \"%{Referer}i\" \"%{User-Agent}i\"" vhost_combined
        LogFormat "%h %l %u %t \"%r\" %>s %O \"%{Referer}i\" \"%{User-Agent}i\"" combined
        LogFormat "%h %l %u %t \"%r\" %>s %O" common
        LogFormat "%{Referer}i -> %U" referer
        LogFormat "%{User-agent}i" agent
        IncludeOptional conf-enabled/*.conf
        IncludeOptional sites-enabled/*.conf

39 Lignes à décortiquer, vu l'ampleur du travail que fait Apache ce n'est pas grand chose :D, soyons positif. Nous allons aussi voir que pris ligne par ligne la configuration est bien simple ... Surtout quand ça fait 15 ans qu'on la consulte :P.

Nous allons aussi nous appuyer sur une documentation solide disponible sur le site d'Apache : 

* Ubuntu 14.04 (apache version 2.4 ) : https://httpd.apache.org/docs/2.4/ 
* Redhat 6 (apache version 2.2)  : https://httpd.apache.org/docs/2.2/.

Nous voyons dans le fichier des variables désigné sous la forme __${Nom\_variable}__ l'ensemble des valeurs sont disponible dans le fichier **/etc/apache2/envvars** dont voici le contenu

        export APACHE_RUN_USER=www-data
        export APACHE_RUN_GROUP=www-data
        export APACHE_PID_FILE=/var/run/apache2/apache2$SUFFIX.pid
        export APACHE_RUN_DIR=/var/run/apache2$SUFFIX
        export APACHE_LOCK_DIR=/var/lock/apache2$SUFFIX
        export APACHE_LOG_DIR=/var/log/apache2$SUFFIX


L'ensemble des valeurs ne seront pas couverte pas que ce n'est pas intéressent, nous pourrons prendre le temps dans le future pour creusé plus en détail. L'objectif pour le moment est d'être en mesure de comprendre et configurer simplement Apache. L'optimisation et l'amélioration de configuration pourra être vu éventuellement dans le future, nous en reparlerons.

* Configuration global
    * [Timeout](https://httpd.apache.org/docs/2.4/fr/mod/core.html#timeout) 300 : Temps en seconde pendant lequel le serveur va attendre  pour l'envoie ou la réception d'instruction au client
    * [KeepAlive](https://httpd.apache.org/docs/2.4/fr/mod/core.html#keepalive) On : Active la possibilité d'utiliser les connexions persistante telle que définie dans le protocole HTTP 1.1
    * User __${APACHE\_RUN\_USER}__ : Définie sous quelle utilisateur le service apache va être exécuté, ceci permet d'éviter que le service soit exécuté comme administrateur du système. L'avantage est que si le service apache est compromis, l'attaquant n'obtient que les droits alloué à l'utilisateur __APACHE\_RUN\_USER__ . Sous Ubuntu l'utilisateur est **www-data**
    * Group __${APACHE\_RUN\_GROUP}__ : Tout comme pour l'utilisateur ici nous définissons le groupe qui exécute l'application sous Ubuntu la valeur est : **www-data**
    * [HostnameLookups](https://httpd.apache.org/docs/2.4/fr/mod/core.html#hostnamelookups) Off  : Lorsque la connexion est établie par un client il est possible de faire le reverse DNS sur l'adresse IP afin d'avoir le nom du client au lieu de l'ip. Généralement cette configuration est à OFF afin de ne pas surcharger le serveur de requête DNS inutile car ceci ralentie le temps de réponse du serveur apache.
    * [ErrorLog](https://httpd.apache.org/docs/2.4/fr/mod/core.html#errorlog) ${APACHE\_LOG\_DIR}/error.log : **Important** définition du fichier de log contenant les erreurs :). Il est fort probable que nous serons amené à le consulter :).
    * [LogLevel](https://httpd.apache.org/docs/2.4/fr/mod/core.html#loglevel) warn : Ceci permet de définir le niveau de sévérité des alertes bien , il est très rare que je change cette valeurs .

* Inclusion
    * [IncludeOptional](https://httpd.apache.org/docs/2.4/fr/mod/core.html#includeoptional) mods-enabled/*.load : Avec l'instruction __IncludeOptional__ il est possible de charger d'autre fichier de configuration afin de segmenté les fichiers pour qu'il soit plus facile a lire ou pour permet l'édition de fichier a certaine personne sans offrir le fichier principal. Dans le cas présent le système charge les modules disponible installé sur le système. (Nous reviendrons plus tard sur les modules)
    * [IncludeOptional](https://httpd.apache.org/docs/2.4/fr/mod/core.html#includeoptional) mods-enabled/*.conf : Même chose que l'instruction précédente mais au lieu de chargé les fichiers des modules, nous chargeons  les configurations des modules. (Nous reviendrons plus tard sur les modules)
    * Include ports.conf : Inclusion du fichier de définition contenant le port d'écoute, nous retrouverons dans ce fichier l'instruction [Listen](https://httpd.apache.org/docs/2.4/fr/mod/mpm_common.html#listen) cette instruction indique sur quelle port écouter pour recevoir les requêtes clients.
    * [IncludeOptional](https://httpd.apache.org/docs/2.4/fr/mod/core.html#includeoptional) conf-enabled/*.conf : Permet de faire l'inclusion des configurations qui doivent être active.
    * [IncludeOptional](https://httpd.apache.org/docs/2.4/fr/mod/core.html#includeoptional) sites-enabled/*.conf : Permet de charger la configuration des sites qui doivent être disponible sur le serveur.

* [Directory](https://httpd.apache.org/docs/2.4/fr/mod/core.html#directory)
L'instruction Directory permet de définir des permissions et configuration qui sont propre au répertoire sur le système de fichier du serveur. Nous verrons qu'il est aussi possible avec l'instruction Location de définir des permissions selon l'URL du site web. La configuration définie pour le répertoire parent sont par défaut hérité au répertoire enfant. Dans la configuration définie ci-dessous l'ensemble des répertoires sous **/var/www** ont les permissions définie par  **Directory /var/www** , pour le répertoire **/home/bob** ou **/tmp/** ils auront les permissions définie par l'instruction **Directory /**.
Nous reviendrons bientôt sur les configurations et permission pour le moment constatons la configuration par défaut.

        <Directory />
                Options FollowSymLinks
                AllowOverride None
                Require all denied
        </Directory>
        <Directory /usr/share>
                AllowOverride None
                Require all granted
        </Directory>
        <Directory /var/www/>
                Options Indexes FollowSymLinks
                AllowOverride None
                Require all granted
        </Directory>

* [LogFormat](https://httpd.apache.org/docs/2.4/fr/mod/mod_log_config.html#logformat)
Définition du format des Log lors de l'accès des clients, ceci permet de collecter plus d'information telle que l'utilisateur (%u) la requête (%r) selon un ordre définie. Ceci est principalement utilisé quand votre système de gestion de statique désire avoir un format particulier. 99% du temps j'utilise __vhost\_combined__ qui répond à mon besoin et à mon logiciel de statistique. Note : avec la version 2.4 il est aussi possible de modifier le [format du message d'erreur](https://httpd.apache.org/docs/2.4/fr/mod/core.html#errorlogformat).

        LogFormat "%v:%p %h %l %u %t \"%r\" %>s %O \"%{Referer}i\" \"%{User-Agent}i\"" vhost_combined
        LogFormat "%h %l %u %t \"%r\" %>s %O \"%{Referer}i\" \"%{User-Agent}i\"" combined
        LogFormat "%h %l %u %t \"%r\" %>s %O" common
        LogFormat "%{Referer}i -> %U" referer
        LogFormat "%{User-agent}i" agent


## <a name="include_files" /> Fichiers Incluent

Debian / Ubuntu structure d'une manière particulière les fichiers d'Apache, on aime ou on n'aime pas je suis pas ici pour me prononcer, mais pour expliquer le concept.

Si nous listons les répertoires présent dans le répertoires nous verrons ceci :


        $ ls -1  /etc/apache2/
        conf-available
        conf-enabled
        mods-available
        mods-enabled
        sites-available
        sites-enabled

Nous pouvons constater 3 groupes :

* conf
    * conf-avaible
    * conf-enabled
* mods
    * mods-avaible
    * mods-enables
* sites
    *  sites-avaible
    *  sites-enabled

Le concept est le suivent l'ensemble des configurations sont disponible dans le répertoire conf-available et pour les activés un lien symbolique est créé dans la répertoire conf-enabled pointant vers le fichier original dans le répertoire conf-available. Cette philosophie s'applique pour les trois groupes **conf**,**mods** et **sites**. 

L'exemple le plus claire est le chargements des modules apaches, regardons la liste des fichiers dans le répertoire des modules disponibles.

        $ ls -l /etc/apache2/mods-available/
        total 516
        -rw-r--r-- 1 root root  100 Jan  7  2014 access_compat.load
        -rw-r--r-- 1 root root  377 Jan  3  2014 actions.conf
        -rw-r--r-- 1 root root   66 Jan  3  2014 actions.load
        -rw-r--r-- 1 root root  843 Jan  3  2014 alias.conf
        -rw-r--r-- 1 root root   62 Jan  3  2014 alias.load
        -rw-r--r-- 1 root root   76 Jan  3  2014 allowmethods.load
        -rw-r--r-- 1 root root   76 Jan  3  2014 asis.load
        [ .... ]
        [ .... ]
        
        # Soit 129 fichier
        $ ls -l /etc/apache2/mods-available/ | wc -l
        129
        
        # A présent les modules activés
        $ ls -l /etc/apache2/mods-enabled/  | head
        total 0
        lrwxrwxrwx 1 root root 36 Nov 25 08:20 access_compat.load -> ../mods-available/access_compat.load
        lrwxrwxrwx 1 root root 28 Nov 25 08:20 alias.conf -> ../mods-available/alias.conf
        lrwxrwxrwx 1 root root 28 Nov 25 08:20 alias.load -> ../mods-available/alias.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 auth_basic.load -> ../mods-available/auth_basic.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 authn_core.load -> ../mods-available/authn_core.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 authn_file.load -> ../mods-available/authn_file.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 authz_core.load -> ../mods-available/authz_core.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 authz_host.load -> ../mods-available/authz_host.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 authz_user.load -> ../mods-available/authz_user.load
        [ .... ]
        [ .... ]
    
        # Il y a donc 28 fichiers de chargé par la configuration apache
        $ ls -l /etc/apache2/mods-enabled/ | wc -l
        28


Conclusion sur 129 fichiers uniquement 28 sont réellement chargé par Apache. Nous ne retrouvons pas ce concept sous Redhat.
Nous mettrons de coté tous ces fichiers de configuration qui sont chargés pour visualiser la configuration du site web par défaut, dans un deuxième temps lors de la configuration de nos site web  nous reviendrons sur l'ajout de fonctionnalité et de modules. Bien entendu libre à vous de jeter un œil aux fichiers et de rechercher la document sur Internet.


# <a name="virt_host" /> Virtual Host par défaut

L'ensemble des sites sont donc chargés en lisant les fichiers contenu dans **/etc/apache2/sites-enabled/**. 
Le système met un fichier par défaut avec le nom **000-default.conf**. Voici le contenu (sans les commentaires):

        <VirtualHost *:80>
    
            ServerAdmin webmaster@localhost
            DocumentRoot /var/www/html
            
            ErrorLog ${APACHE_LOG_DIR}/error.log
            CustomLog ${APACHE_LOG_DIR}/access.log combined
        </VirtualHost>

Nous avons l'instruction :

* [ VirtualHost *:80 ](https://httpd.apache.org/docs/2.4/mod/core.html#virtualhost): Cette instruction indique qu'il peut y avoir plusieurs site web sur le port 80 des Hôtes virtuel ... Heu merci pour la traduction ;-), nous y reviendrons quand nous couvrirons la possibilité d'avoir plusieurs site web . Pour les personnes trop pressé voici le lien avec la section [VirtualHot](#VirtualHost)
* [ServerAdmin](https://httpd.apache.org/docs/2.4/mod/core.html#serveradmin) : URL de l'administrateur qui peut être afficher lors de messages d'erreur 
* [DocumentRoot](https://httpd.apache.org/docs/2.4/mod/core.html#documentroot): Répertoire racine du site web.
* [ErrorLog](https://httpd.apache.org/docs/2.4/mod/core.html#errorlog) : Chemin d'accès ou le fichier d'erreur PROPRE à ce site web sera écrit. On voudra avoir un fichier d'erreur par site web ceci facilite grandement l'identification des problèmes plutôt qu'avoir un gros fichier pour tout le monde. De plus nous serons en mesure de fournir le fichier au développeur pour qu'il analyse les problèmes. 
* [CustomLog](https://httpd.apache.org/docs/2.4/mod/mod_log_config.html#customlog): Fichier contenant les informations d'accès des clients tout comme pour le fichier d'erreur, un fichier d'accès par site. Nous retrouvons l'argument **combined** qui est un des format de log précédemment définie avec l'instruction **Logformat**

Et voilà :) , c'est ceci qui nous a permit de mettre notre fichier **demo.html** et de visualiser le contenu.


# <a name="param_server" /> Paramétrisation du serveur

Maintenant que nous avons vu l'idée générale de la configuration c'est le temps de commencé à y mettre un peu d'ordre ou de désordre :).

## <a name="param_directory" /> Paramétrisation de la configuration Directory

### <a name="param_docroot" /> Changement du répertoire Racine ( DocumentRoot)

Pour le plaisir nous allons fonctionné par un exemple claire, car bien souvent une démonstration aide à la compréhension. Changeons de place le site web de __/var/www/html/__ vers  __/data/www/__, peut importe la raison (espace disque dur, réorganisation du système , ...).

        # Création du répertoire et copie des fichiers
        $ sudo mkdir -p /data/www
        $ sudo cp /var/www/html/*.html  /data/www/

Les fichiers sont donc maintenant dans le nouveau répertoire il reste à modifier la configuration du serveur Web. Nous allons donc modifier la configuration du [DocumentRoot](https://httpd.apache.org/docs/2.4/mod/core.html#documentroot). 
Éditons le fichier **/etc/apache2/sites-available/000-default.conf**

        # Changement de 
        DocumentRoot /var/www/html
    
        # Pour la nouvelle valeur
        DocumentRoot /data/www

Validons la configuration syntaxique du serveur, c'est toujours une bonne pratique de réaliser cette opération après vos modifications ceci permet de corriger des problèmes avant même de recharger la configuration.

        $  sudo apache2ctl configtest
        Syntax OK

Rechargez la configuration :

        $ sudo service apache2 reload
        * Reloading web server apache2

Voici le résultat quand nous accédons à la page principale :  http://127.0.0.1 ou http://127.0.0.1/demo.html

![rep_demo-page_403.png](./imgs/rep_demo-page_403.png)

Nous avons donc une erreur **403** qui est un refus d'accès au serveur. Ceci correspond à un refus d'accès vous pouvez avoir la liste des codes des états sur Wikipédia :  [Code 4xx Erreur Client](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#4xx_Client_Error) 

Le mieux pour comprendre l'erreur reste toujours les logs visualisons donc ce que nous avons dans les fichiers. Pour nous rafraîchir la mémoire nous allons valider la définition des fichiers de logs:

        $ grep "log" /etc/apache2/sites-enabled/000-default.conf | grep -v "#"
        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined
    
        # Et pour la valeur de ${APACHE_LOG_DIR}
        $ grep "APACHE_LOG_DIR" /etc/apache2/envvars 
        export APACHE_LOG_DIR=/var/log/apache2

* Fichier d'accès **/var/log/apache2/access.log**:

        $ sudo tail -f /var/log/apache2/access.log
        172.17.42.1 - - [27/Nov/2015:08:20:52 -0500] "GET / HTTP/1.1" 403 494 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"
        172.17.42.1 - - [27/Nov/2015:08:21:27 -0500] "GET /demo.html HTTP/1.1" 403 503 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"

* Fichier d'erreur **/var/log/apache2/error.log**

        $ sudo tail -f /var/log/apache2/error.log
        [Fri Nov 27 08:20:52.199792 2015] [authz_core:error] [pid 133:tid 3046103872] [client 172.17.42.1:58878] AH01630: client denied by server configuration: /data/www/
        [Fri Nov 27 08:21:27.097668 2015] [authz_core:error] [pid 132:tid 3029318464] [client 172.17.42.1:58882] AH01630: client denied by server configuration: /data/www/demo.html


Le message du serveur est explicite la configuration du serveur refuse d'offrir l'accès au fichier **/data/www/**. COOL !! Le problème est claire et identifier , il ne reste que LA solution :).

L'autorisation des accès à l'arborescence du système est définie par les configurations [Directory](https://httpd.apache.org/docs/2.4/fr/mod/core.html#directory) ,nous avons cette définition dans le fichier **/etc/apache2/apache2.conf** 

        <Directory />
                Options FollowSymLinks
                AllowOverride None
                Require all denied
        </Directory>
        <Directory /usr/share>
                AllowOverride None
                Require all granted
        </Directory>
        <Directory /var/www/>
                Options Indexes FollowSymLinks
                AllowOverride None
                Require all granted
        </Directory>

Les valeurs de configuration hérité selon l'arborescence ce qui veut dire que **TOUS** les répertoires du file système à l'exception de **/usr/share** et **/var/www** (incluant leur sous répertoire) ont la configuration suivante :

         <Directory />
                Options FollowSymLinks
                AllowOverride None
                Require all denied
        </Directory>

Nous sommes donc actuellement bloqué par l'instruction : [Require](https://httpd.apache.org/docs/2.4/mod/mod_authz_core.html#require). Sous Ubuntu l'ensemble des accès au système de fichier est refusé depuis la racine (root / ) en dehors des deux répertoires nommés plus tôt.

Vous me demanderez probablement mais pourquoi /usr/share pour permettre l'accès à la documentation, des icônes ou fichier d'erreur page personnalisé pour les erreurs 404 (not found) depuis l'interface web des icônes.

Nous allons confirmer mes propos , en ajoutant les lignes suivante sous l'instruction __<Directory />__ , dans le fichier **/etc/apache2/apache2.conf** voici le résultat:

        <Directory />
            Options FollowSymLinks
            AllowOverride None
            Require all denied
        </Directory>

        <Directory /data/www >
            Options FollowSymLinks
            AllowOverride None
            Require all granted
        </Directory>

        <Directory /usr/share>
        [ .... ]


Validons la configuration avant de recharger la configuration :

        $ sudo apachectl configtest
        Syntax OK

        $ sudo service apache2 reload 
        * Reloading web server apache2
        *

Allons à l'URL : [http://127.0.0.1/demo.html](http://127.0.0.1/demo.html) 

Cette notion d'héritage des permissions est très important afin de comprendre l'impacte de permission trop permissive au niveau supérieur de la hiérarchie du système de fichier. 

### <a name="Auth_access" /> Autorisation d'accès par hostname ou ip ( Require )

Profitons de l'occasion pour limiter l'accès à un répertoire pour uniquement un segment réseau , car pour la démonstration ci-dessus nous avons simplement ouvert à TOUS l'accès si nous avions un répertoire __admin__ ou __private__ disponible pour le réseau interne mais qui ne devrais pas être disponible sur l'Internet publique.
L'instruction [require](https://httpd.apache.org/docs/2.4/mod/mod_authz_core.html#require) nous permet de faire cette limitation . Nous verrons aussi qu'il est possible de mettre un système d'authentification avec nom d'utilisateur et mot de passe.

Nous allons permettre l'accès uniquement au réseau 192.168.100.0/24 (donc toutes les adresses ip qui commence par 192.168.100) et l'ip 192.168.42.42 (juste pour voir la possibilité de mettre plusieurs valeur :) ). Voici le résultat :

        <Directory /data/www >
            Options FollowSymLinks
            AllowOverride None
            Require all granted
       </Directory>

       <Directory /data/www/admin >
            Options FollowSymLinks
            AllowOverride None
            Require  ip 192.168.100 192.168.42.42
       </Directory>

Validation de la configuration (oui ! Je suis chiant un peu avec ça mais honnêtement ça l'aide BEAUCOUP ) :

        $ sudo apachectl configtest
        Syntax OK

Validation du résultat :

![rep_admin_404.png](./imgs/rep_admin_404.png)
 
Dans mon cas j'aurais dû avoir une erreur d'accès car l'ip de ma machine ne correspond pas à celle autorisé, cependant j'ai une erreur 404 (page non trouvée). Ceci est compréhensible car nous n'avons pas fait la création du répertoire **/data/www/admin** . Ceci veut donc dire que Apache valide l'existence du répertoire avant de valider les permissions d'accès , ceci est un détail cependant je désirai le partagé , je croyais que c'était le contraire :D.

Nous allons donc faire la création du répertoire et mettre un petit fichier **index.html** :

        $ sudo mkdir /data/www/admin 
        $ sudo vim /data/www/admin/index.html
        $ cat /data/www/admin/index.html
        section prive

Voilà le bon message d'erreur :) : 

![rep_admin_403.png](./imgs/rep_admin_403.png)


### <a name="virt_host_good" />Utilisation du Virtual host par défaut (bonne pratique)

Nous avons modifié la configuration du fichier **/etc/apache2/apache2.conf**, à moins que les configurations sont vraiment général pour l'ensemble du serveur je vous conseil de définir vos configurations dans le virtual host approprié. Ceci est pour la simple et bonne raison qu'il est plus facile de migré la configuration d'un site quand on a l'ensemble de ça définition dans un fichier plutôt qu'avoir des configurations éparpillé. 
Plusieurs avantage :

* Visualisation de l'ensemble de la configuration à un point
* Plus facile de migré la site sur un autre serveur , car uniquement un fichier a transférer
* La configuration du site peut être délégué a une autre personne en lui permettant d'éditer qu'un fichier
* Permet d'activer ou désactivé l'ensemble des configurations facilement au lieu d'avoir des configurations qui traine quand un site n'est plus en activité.
* Je pourrais en trouver probablement d'autre mais vous avez compris le concept.

Pour le moment nous n'avons qu'un site je vais donc procéder à la migration de la configuration des répertoires **/data/www** et **/data/www/admin** dans le fichier **/etc/apache2/sites-available/000-default.conf**.

Je vais donc supprimé le ligne du fichier **/etc/apache2/apache2.conf**

        -<Directory /data/www >
        -       Options FollowSymLinks
        -       AllowOverride None
        -       Require all granted 
        -</Directory>
        -
        -<Directory /data/www/admin >
        -        Options FollowSymLinks
        -        AllowOverride None
        -        Require  ip 192.168.100 192.168.42.42
        -</Directory>

Et les rajouter dans le fichier **/etc/apache2/sites-available/000-default.conf** , Personnellement je le met toujours après le [DocumentRoot](https://httpd.apache.org/docs/2.4/mod/core.html#documentroot), mais c'est juste une habitude.

Validation et relecture de la configuration :) :

        $ sudo apache2ctl configtest && sudo service apache2 reload 
        Syntax OK
        * Reloading web server apache2
        * 

Donc à partir de maintenant nous manipulerons principalement les fichiers de vhost à moins que nous appliquions une modification global au système telle que l'ajout de module.


## <a name="context" /> Organisation de la configuration (context)

Voyons les niveaux ou contexte d'organisation des configurations d'apache avant l'aller plus loin. Je vais utiliser la configuration du répertoire **/data/www** et **/data/www/admin** pour faire la démonstration. 
Cette section est très importante, car elle permet de comprendre le système de configuration dans les détails, de nos jours mettre en place un service est assez simple, un copie/collé d'une configuration trouvé sur l'Internet suffit 90% du temps. Le défis survient lors des problèmes et / ou l'intégration de services, à ce moment il est important de comprendre le système.!

Il existe 4 niveaux ou contexte :

* **configuration du serveur** : Ensemble de configuration contenu dans les fichiers de configuration du serveur apache , telle que le fichier __httpd.conf__, cependant ceci ne comprend pas les instructions  à l'intérieur des balises __<VirtualHost>__ ou __<Directory>__. De même, elle n'est pas valide dans les fichiers __.htaccess__.
* **serveur virtuel** : Ensemble des instructions comprise dans les balises __<VirtualHost>__.
* **répertoire** : Ensemble des instructions contenues dans les balises __<Directory>__, __<Location>__, __<Files>__, __<If>__, et __<Proxy>__ .
* **.htaccess** : Ensemble des instructions contenues dans un fichier __.htaccess__.


Reprenons notre modification du répertoire __/data/www__, comme base de référence et ainsi visualiser les contextes que nous avons modifier.

1. Nous avons modifier la directive [DocumentRoot](https://httpd.apache.org/docs/2.4/mod/core.html#documentroot), pour rappel ceci nous a permis de modifier la racine du site web. Si nous regardons documentation disponible pour cette instruction, voici la copie  d'écran :

    ![DocumentRoot-screenshot-documentation.png](./imgs/DocumentRoot-screenshot-documentation.png)

    Comme vous pouvez le constater l'instruction **DocumentRoot** peut être utilisé dans 2 contexte **Server config**  et **Virtual host**. Dans notre configuration nous avons uniquement une définition du __DocumentRoot__ dans le __VirtualHost__  : **sites-available/000-default.conf** 

2. Définition des permissions d'accès pour le répertoire __/data/www__ grâce à l'instruction [Directory](https://httpd.apache.org/docs/2.4/fr/mod/core.html#directory). Cette configuration est encore plus intéressante, car nous avons définie les permissions de ce répertoire dans 2 contexte. Commençons par visualiser la documentation

    ![Directory-screenshot-documentation.png](./imgs/Directory-screenshot-documentation.png)

    Comme vous pouvez le constater nous pouvons utiliser la directive __Directory__ dans le contexte **Server config** ET **Virtual Host**. Si nous nous rappelons l'opération de configuration nous avons définie notre configuration dans les 2 contexte.  Dans contexte **Server config** lors que la configuration été présente dans le fichier __/etc/apache2/apache2.conf__ et dans la configuration du **Virtual Host** lorsque nous avons rapatrié la configuration dans le __Host__ Virtuel.

3. Définition de l'instruction [Require](https://httpd.apache.org/docs/2.4/mod/mod_authz_core.html#require) qui nous à permis de limité l'accès au répertoire __admin__ grâce à l'__IP__ de provenance . Nous avons mis la configuration dans le contexte du répertoire __<Directory /data/www/admin >__ étions nous obligé de le faire ?!?! Que dit la documentation :

    ![Require-screenshot-documentation.png](./imgs/Require-screenshot-documentation.png)

    Encore une fois nous avions 2 possibilités où disposer l'instruction dans contexte __Directory__ ou dans le contexte __.htaccess__ . À la lecture de cette information ceci veut donc dire que je ne peux pas définir un limitation par __IP__ pour l'ensemble d'un __Virtual Host__ ce doit être obligatoirement par répertoire, donc pour limite l'accès à l'ensemble je dois bloqué à dans la répertoire **racine**. 

    Mais que ce passe t il si je ne suis pas les directives de positionnement de la configuration ? Voici un exemple de configuration erroné , j'ai définie l'instruction suivante directement dans le __VirtualHost__:

        $ cat /etc/apache2/sites-available/000-default.conf | grep -C 2 Require
           DocumentRoot /data/www

           Require  ip 192.168.100 192.168.42.42

           <Directory /data/www/>
              Options Indexes FollowSymLinks

        $ sudo apachectl configtest
        AH00526: Syntax error on line 14 of /etc/apache2/sites-enabled/000-default.conf:
        Require not allowed here
        Action 'configtest' failed.
        The Apache error log may have more information.

    Ceci est clairement un avantage d'avoir un message aussi claire ayant utilisé la commande , **apachectl configtest** j'ai eu l'information du problème SANS aucune interruption du service.


Nous avons vu 3 des 4 contexte décrit plus tôt , celui qui manque est le contexte **.htaccess**, donc afin de couvrir cette possibilité nous allons reprendre notre configuration et voir quelle instructions peut être déplacé dans le contexte **.htaccess**. Pour les personnes qui s'inquiète de la couverture légère réalisé jusqu'à présent du contexte __VirtualHost__ ne vous inquiétez pas nous couvrirons le sujets de manière approprié sous peu.

Si nous regardons la seule instruction que nous pouvons utiliser dans le contexte __.htaccess__ est **Require**, nous allons donc procéder à la migration de l'instruction.

* Référence 
    * [http://httpd.apache.org/docs/current/fr/mod/directive-dict.html#Context](http://httpd.apache.org/docs/current/fr/mod/directive-dict.html#Context)
    * [http://httpd.apache.org/docs/current/fr/sections.html](http://httpd.apache.org/docs/current/fr/sections.html)

## <a name="context_htaccess" /> Surdéfinition de la configuration dans le fichier .htaccess

L'objectif du fichier __.htaccess__ est de fournir la possibilité de modifier la configuration du serveur au niveau du répertoire. Le principal avantage de cette fonctionnalité est de pouvoir délégué la gestion d'un partie de la configuration au développeur, il est cependant conseillé de limité les champs d'action de cette fonctionnalité , surtout en production car ceci comprend aussi des risques de sécurité potentiel (nous y reviendrons).

Le nom du fichier __.htaccess__est une convention ceci est définie par l'instruction [AccessFileName](https://httpd.apache.org/docs/current/fr/mod/core.html#accessfilename) 

![Accessfilename-screenshot-documentation.png](./imgs/Accessfilename-screenshot-documentation.png)

Comme nous pouvons le voir sur la copie d'écran de la configuration cette instruction peut être définie dans la configuration du serveur OU dans la configuration du __Virtual Host__.
Je vous conseille de ne pas changer le nom du fichier, afin de faciliter la lecture par l'ensemble des intervenants sur votre système. Personnellement s'il y a un problème sur le site , je vais regarder, s'il y a surcharge (redéfinition) de la configuration avec un fichier __.htaccess__, mais si l'on change le nom du fichier il est peu probable que le considère.

Procédons avec la migration de la configuration afin de valider le comportement, la configuration actuelle du __VirtualHost__ ressemble à ceci :

                <VirtualHost *:80>

                        ServerAdmin webmaster@localhost
                        DocumentRoot /data/www

                        <Directory /data/www/>
                                Options Indexes FollowSymLinks
                                AllowOverride None
                                Require all granted
                        </Directory>

                        <Directory /data/www/admin >
                                Options FollowSymLinks
                                AllowOverride None
                                Require ip 192.168.100 192.168.42.42
                        </Directory>

                        ErrorLog ${APACHE_LOG_DIR}/error.log
                        CustomLog ${APACHE_LOG_DIR}/access.log combined

                </VirtualHost>

Nous allons migré la directive **Require ip 192.168.100 192.168.42.42** dans le fichier __.htaccess__. 

1. Je supprime la ligne définie dans la configuration du répertoire **<Directory /data/www/admin >**
2. Je crée le fichier __/data/www/admin/.htaccess__ avec le contenu suivant 

        $ sudo vim /data/www/admin/.htaccess
        Require ip 192.168.100 192.168.42.42
        $ sudo apachectl configtest && sudo /etc/init.d/apache2 reload

3. J'ai du recharger la configuration d'apache afin que le fichier du __VirtualHost__ soit relue suite à la suppression de la définition **Require** 

Validons le comportement , si je vais sur la page __http://Ip\_du\_server/admin/__ . Mon adresse __ip__ de provenance étant 172.17.42.1 l'accès à la section privé étant autorisé uniquement depuis 192.168.100.0/24 ET 192.168.42.42 , je vais avoir le message d'erreur m'indiquant que l'accès est refusé comme précédemment.

![rep_admin_pas_erreur.png](./imgs/rep_admin_pas_erreur.png)

**Oupsss** la section privé est accessible , mais mais mais ... 

![dont_panic.jpg](./imgs/dont_panic.jpg)

Procédons par validation :

1. Re-validation de la configuration du serveur

        $ sudo apachectl configtest                                    
        Syntax OK

2. Validation des logs 

        $ sudo tail /var/log/apache2/access.log /var/log/apache2/error.log
        ==> /var/log/apache2/access.log <==
        [...  OUTPUT COUPÉ ...]
        172.17.42.1 - - [17/Feb/2016:16:58:05 -0500] "GET /admin/ HTTP/1.1" 200 295 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"

        ==> /var/log/apache2/error.log <==
        [...  OUTPUT COUPÉ ...]
        [Wed Feb 17 16:45:39.294669 2016] [mpm_event:notice] [pid 53:tid 3075459712] AH00489: Apache/2.4.7 (Ubuntu) configured -- resuming normal operations
        [Wed Feb 17 16:45:39.295596 2016] [core:notice] [pid 53:tid 3075459712] AH00094: Command line: '/usr/sbin/apache2'

Aucun message d'erreur donc il y a un **bug** dans le logiciel apache, ou il y a une configuration qui n'est pas compatible avec notre configuration . Nous allons voir la définition du répertoire **admin**

Regardons la définition du répertoire contenu dans le __Virtual Host__ : **/etc/apache2/sites-available/000-default.conf**

        <Directory /data/www/admin >
            Options FollowSymLinks
            AllowOverride None
        </Directory>

Heureusement la définition est courte nous pouvons voir "rapidement" l'erreur , l'instruction **AllowOverride** est définie à **None**, ceci indique que le système apache ne regarde PAS s'il y a un fichier __.htaccess__ dans le répertoire. 
Nous allons corriger la configuration et passer au explication par la suite, nous allons changer **None** par **AuthConfig** . Voyons le résultat :

1. Fichier **/etc/apache2/sites-available/000-default.conf** :
        
            <Directory /data/www/admin >
                Options FollowSymLinks
                AllowOverride AuthConfig
            </Directory>

2. Recharge de la configuration 

            $ sudo apachectl configtest && sudo /etc/init.d/apache2 reload

C'est le temps de valider si maintenant c'est OK !!

![rep_admin_403.png](./imgs/rep_admin_403.png)

**Woot** , l'accès est bloqué, nous pouvons aussi le constater dans les logs 

        $ sudo tail /var/log/apache2/access.log /var/log/apache2/error.log
        ==> /var/log/apache2/access.log <==
        [ ... OUTPUT COUPÉ ... ]
        172.17.42.1 - - [17/Feb/2016:17:14:05 -0500] "GET /admin/ HTTP/1.1" 403 499 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"
        ==> /var/log/apache2/error.log <==
        [ ... OUTPUT COUPÉ ... ]
        [Wed Feb 17 17:13:49.432389 2016] [core:notice] [pid 173:tid 3075066496] AH00094: Command line: '/usr/sbin/apache2'
        [Wed Feb 17 17:14:05.152280 2016] [authz_core:error] [pid 176:tid 2979945280] [client 172.17.42.1:60578] AH01630: client denied by server configuration: /data/www/admin/

Voyons un peu ce que permet l'instruction [AllowOverride](http://httpd.apache.org/docs/2.4/fr/mod/core.html#allowoverride).

### <a name="htaccess_allowoverride" /> Permission de redéfinition des configurations

L'instruction [AllowOverride](http://httpd.apache.org/docs/2.4/fr/mod/core.html#allowoverride), permet d'indiquer au serveur Apache de lire dans le répertoire le fichier __.htaccess__ ( ou fichier autre selon la définition de la variable [AccessFilename](http://httpd.apache.org/docs/2.4/fr/mod/core.html#accessfilename).

![AllowOverride-screenshot-documentation.png](./imgs/AllowOverride-screenshot-documentation.png)

Les valeurs possibles à l'instruction sont :

* **ALL** ( Tous ) : Avec cette configurations Apache regarde le répertoire et l'ensemble des sous répertoire s'il y a un fichier __.htaccess__ . Si un fichier est trouvé, ce dernier est lu et toutes instructions qui peut être définie dans le contexte __.htaccess__ seront interprétés. Résultat la configuration active sera cette définie dans le fichier __.htaccess__.

* **None** ( Rien ) : Avec cette configuration Apache ne regarde même pas s'il y a un fichier __.htaccess__ dans le répertoire

* **AuthConfig** : Permet l'utilisation des directives d'autorisation (__AuthDBMGroupFilex__, __AuthDBMUserFile__, __AuthGroupFile__, __AuthName__, __AuthType__, __AuthUserFile__, __Require__, etc...).

* **FileInfo** : Permet l'utilisation des directives qui contrôlent les types de documents (directives __ErrorDocument__, __ForceType__, __LanguagePriority__, __SetHandler__, __SetInputFilter__, __SetOutputFilter__, et directives du module __mod\_mime__ __Add__\* et __Remove__\*), des métadonnées des documents (__Header__, __RequestHeader__, __SetEnvIf__, __SetEnvIfNoCase__, __BrowserMatch__, __CookieExpires__, __CookieDomain__, __CookieStyle__, __CookieTracking__, __CookieName__), des directives du module __mod\_rewrite__ directives (__RewriteEngine__, __RewriteOptions__, __RewriteBase__, __RewriteCond__, __RewriteRule__), des directives du module __mod\_alias__ directives (__Redirect__, __RedirectTemp__, __RedirectPermanent__, __RedirectMatch__), et de la directive Action du module __mod\_actions__. 

* **Indexes** : Permet l'utilisation des directives qui contrôlent l'indexation des répertoires (__AddDescription__, __AddIcon__, __AddIconByEncoding__, __AddIconByType__, __DefaultIcon__, __DirectoryIndex__, __FancyIndexing__, __HeaderName__, __IndexIgnore__, __IndexOptions__, __ReadmeName__, etc...)

* **Limit** : Permet l'utilisation des directives contrôlant l'accès au serveur (__Allow__, __Deny__ et __Order__).

* **Nonfatal=[Override|Unknown|All]** : Permet d'utiliser l'option __AllowOverride__ pour rendre les erreurs de syntaxe non fatales dans les fichiers __.htaccess__ : au lieu de causer une __Internal Server Error__, les directives non autorisées ou non reconnues seront ignorées et un avertissement enregistré dans le journal :
    * __Nonfatal=Override__ rend les directives interdite par __AllowOverride__ non fatales.
    * __Nonfatal=Unknown__ rend les directives inconnues non fatales. Sont concernées les erreurs de frappe et les directives implémentées par un module non chargé.
    * __Nonfatal=All__ rend toutes les directives précédentes non fatales.
    * **Notez qu'une erreur de syntaxe dans une directive valide causera toujours une internal server error.**

* **Options[=Option,...]** : Permet l'utilisation des directives contrôlant les fonctionnalités spécifiques d'un répertoire (__Options__ et __XBitHack__). "Options" doit être suivi d'un signe "égal", puis d'une liste d'options séparées par des virgules (pas d'espaces) ; ces options doivent être définies à l'aide de la commande [Options](http://httpd.apache.org/docs/2.4/fr/mod/core.html#options). 


Si nous reprenons notre exemple de limitation d'accès par adresse IP, nous avons définie dans le fichier __.htaccess__ l'instruction  [Require](https://httpd.apache.org/docs/2.4/mod/mod_authz_core.html#require). Afin que le fichier de sur définition des configuration soit interprété nous avons changer la valeur de l'instruction **AllowOverride** de __None__ (Rien) à __AuthConfig__ . Nous aurions aussi pu définit l'instruction à __ALL__ (Tous) dans cette situation nous serions en mesure de mettre non seulement des instructions de limitation d'authentification mais aussi des configurations général du système. Un peu plus tard je réaliserai une démonstration du risque de cette possibilité. 

Dans le cadre de la configuration __AuthConfig__ l'option disponible est relativement spécifique et regroupe peu d'instruction , cependant si nous regardons l'instruction __FileInfo__ le nombre de commande est plus significatif. 
Si nous désirons offrir l'option au développeur d'avoir la main sur la configuration pour redéfinir par exemple les documents d'erreur, pour que le message d'erreur soit personnalisé avec une belle image et un jolie texte. Pour réaliser cette opération le développeur voudra modifier l'instruction  [ErrorDocument](https://httpd.apache.org/docs/2.4/fr/mod/core.html#errordocument), et nous devrons permettre la surdéfinition dans __AllowOverride__ avec l'instruction **FileInfo**. Le développeur aura donc beaucoup plus d'instruction disponible que __ErrorDocument__. 

Depuis la version **2.4** d'apache il est possible d'être plus spécifique sur les instructions utilisable dans le fichier __.htaccess__. Il fut introduit la directive [AllowOverrideList](http://httpd.apache.org/docs/2.4/fr/mod/core.html#allowoverridelist), elle permet de lister uniquement les instructions disponible dans le fichier __.htaccess__ . Si nous reprenons notre besoin de pouvoir surdéfinir l'option [ErrorDocument](https://httpd.apache.org/docs/2.4/fr/mod/core.html#errordocument), mais que nous désirons UNIQUEMENT cette instruction nous pourrions la définir comme suit :

        AllowOverride None
        AllowOverrideList ErrorDocument

Dans cette exemple , aucune configuration peut être redéfinit dans le fichier __.htaccess__, à l'exception de la directive __ErrorDocument__ .

**Prendre note que AllowOverride ET AllowOverrideList sont combinatoire**.
En d'autre mot si j'ai l'instruction suivante : 

        AllowOverride AuthConfig
        AllowOverrideList ErrorDocument
 
Je serai en mesure d'utiliser les instructions : __ErrorDocument__ + __AuthDBMGroupFilex__, __AuthDBMUserFile__, __AuthGroupFile__, __AuthName__, __AuthType__, __AuthUserFile__, __Require__, etc...

## <a name="utilisation_de_htaccess" /> Bonne pratique de l'utilisation du fichier .htaccess

En principe, vous ne devriez utiliser les fichiers __.htaccess__ que lorsque vous n'avez pas accès au fichier de configuration du serveur principal. Par exemple, la fausse idée selon laquelle l'authentification de l'utilisateur devrait toujours être faite dans les fichiers __.htaccess__ est très répandue. Il est aussi souvent avancé, ces dernières années, que les directives de mod\_rewrite doivent être définies dans les fichiers __.htaccess__. Ceci est tout simplement faux. Vous pouvez configurer l'authentification des utilisateurs au niveau de la configuration du serveur principal, et c'est en fait cette méthode qui doit être privilégiée. De même, les directives de mod\_rewrite fonctionneront mieux, à de nombreux égards, dans le contexte du serveur principal.

Les fichiers __.htaccess__ ne devraient être utilisés que dans le cas où les fournisseurs de contenu ont besoin de modifier la configuration du serveur au niveau d'un répertoire, mais ne possèdent pas l'accès __root__ sur le système du serveur. Si l'administrateur du serveur ne souhaite pas effectuer des modifications de configuration incessantes, il peut être intéressant de permettre aux utilisateurs isolés d'effectuer eux-mêmes ces modifications par le biais de fichiers __.htaccess__. Ceci est particulièrement vrai dans le cas où le fournisseur d'accès à Internet héberge de nombreux sites d'utilisateurs sur un seul serveur, et souhaite que ces utilisateurs puissent modifier eux-mêmes leurs configurations.

Cependant et d'une manière générale, il vaut mieux éviter d'utiliser les fichiers __.htaccess__. Tout élément de configuration que vous pourriez vouloir mettre dans un fichier __.htaccess__, peut aussi être mis, et avec la même efficacité, dans une section __<Directory>__ du fichier de configuration de votre serveur principal.

Il y a deux raisons principales d'éviter l'utilisation des fichiers __.htaccess__ : 

* La première est liée aux performances. Lorsque la directive __AllowOverride__ est définie de façon à autoriser l'utilisation des fichiers __.htaccess__, __httpd__ va rechercher leur présence dans chaque répertoire. Ainsi, permettre l'utilisation des fichiers __.htaccess__ est déjà en soi une cause de dégradation des performances, que vous utilisiez effectivement ces fichiers ou non ! De plus, le fichier __.htaccess__ est chargé en mémoire chaque fois qu'un document fait l'objet d'une requête. 
 Notez aussi que __httpd__ doit rechercher les fichiers __.htaccess__ dans tous les répertoires de niveau supérieur, afin de rassembler toutes les directives qui s'appliquent au répertoire courant (Voir la section comment sont appliquées les directives). Ainsi, si un fichier fait l'objet d'une requête à partir d'un répertoire __/www/htdocs/exemple__, __httpd__ doit rechercher les fichiers suivants :

        /.htaccess
        /www/.htaccess
        /www/htdocs/.htaccess
        /www/htdocs/exemple/.htaccess

 En conséquence, chaque accès à un fichier de ce répertoire nécessite 4 accès au système de fichiers supplémentaires pour rechercher des fichiers __.htaccess__, même si aucun de ces fichiers n'est présent. Notez que cet exemple ne peut se produire que si les fichiers __.htaccess__ ont été autorisés pour le répertoire /, ce qui est rarement le cas.

* La seconde raison d'éviter l'utilisation des fichiers __.htaccess__ est liée à la sécurité. Si vous permettez aux utilisateurs de modifier la configuration du serveur, il peut en résulter des conséquences sur lesquelles vous n'aurez aucun contrôle. Réfléchissez bien avant de donner ce privilège à vos utilisateurs. Notez aussi que ne pas donner aux utilisateurs les privilèges dont ils ont besoin va entraîner une augmentation des demandes de support technique. Assurez vous d'avoir informé clairement vos utilisateurs du niveau de privilèges que vous leur avez attribué. Indiquer exactement comment vous avez défini la directive __AllowOverride__ et diriger les utilisateurs vers la documentation correspondante vous évitera bien des confusions ultérieures.

* Référence :
    * [https://httpd.apache.org/docs/current/howto/htaccess.html](https://httpd.apache.org/docs/current/howto/htaccess.html) 

# <a name="VirtualHost" /> VirtualHost

Le principe du [VirtualHost](http://httpd.apache.org/docs/2.4/fr/vhosts/) est de permettre sur la même instance apache d'offrir plusieurs site web . Apache a été le précurseur des serveurs proposant cette méthode de serveurs virtuels basés sur les adresses IP, ce qui a grandement aidé à ça popularité.

Il existe 2 type de __VirtualHost__ :

* **Basé sur l'IP** (IP Base) : Comme l'indique le terme par IP, le serveur doit disposer de différentes paires adresses IP/port pour chaque serveur virtuel par IP. La machine peut posséder plusieurs connexions physiques au réseau, ou utiliser des interfaces virtuelles qui sont supportées par la plupart des systèmes d'exploitation modernes (Consultez la documentation des systèmes d'exploitation pour plus de détails, notamment les "alias IP" et la commande "ifconfig" pour les activer), et/ou utiliser plusieurs numéros de port.
Selon la terminologie du serveur HTTP Apache, l'utilisation d'une seule adresse IP avec plusieurs ports TCP s'apparente aussi à de l'hébergement virtuel basé sur IP.
* **Basé sur le nom** (__Name__ Base) : Les serveurs virtuels par IP utilisent l'adresse IP de la connexion afin de déterminer quel serveur virtuel doit répondre. Par conséquent, vous devez disposer d'adresses IP différentes pour chaque serveur.
Avec un hébergement virtuel par nom, le serveur s'appuie sur les informations transmises par le client dans les en-têtes HTTP de ses requêtes. La technique présentée ici vous permet de disposer de serveurs virtuels différents partagés sur une même adresse IP.

Avec la pénurie d'adresse IP disponible sur internet l'utilisation des __virtual host__ IP base sont de moins en moins utilisées surtout pour les sites web (sans chiffrement __https__). 

Voyons comment configurer les 2 types, vous allez constater que ceci est très similaire :).

## <a name="Vhost_ip" /> Serveurs virtuels par IP

Pour pouvoir définir un __VirtualHost__ IP base il faut avoir plusieurs IP, sinon vous utiliser des serveurs virtuel basé sur le nom. Conceptuellement des __VirtualHost__ basé sur le port de connexion sont considéré comme des __VirtualHost__ IP base, j'en fait mention cependant dans le feu de l'action sur la configuration nous ne constatons pas la différence.

Si vous utilisez le docker __x3rus/linux202__ par défaut :

        $ sudo ifconfig
          eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:00:01  
                    inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0
                    inet6 addr: fe80::42:acff:fe11:1/64 Scope:Link
                    UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
                    RX packets:547 errors:0 dropped:0 overruns:0 frame:0
                    TX packets:322 errors:0 dropped:0 overruns:0 carrier:0
                    collisions:0 txqueuelen:0 
                    RX bytes:48132 (48.1 KB)  TX bytes:49572 (49.5 KB)

          lo        Link encap:Local Loopback  
                    inet addr:127.0.0.1  Mask:255.0.0.0
                    inet6 addr: ::1/128 Scope:Host
                    UP LOOPBACK RUNNING  MTU:65536  Metric:1
                    RX packets:0 errors:0 dropped:0 overruns:0 frame:0
                    TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
                    collisions:0 txqueuelen:0 
                    RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

Comme vous pouvez le constater il n'y a qu'une adresse IP de définie (172.17.0.1), nous allons ajouter l'IP 172.17.0.10.
Nous allons ajouter cette IP, comme une IP alias sur la carte eth0, nous allons lui donner le nom **eth0:1**, c'est la méthode la plus commune. Pour information nous aurions très bien pu aussi définir l'alias avec un nom telle que **eth0:moodle**. Je vais faire la démonstration aussi.

        $ sudo ifconfig eth0:1 172.17.0.10
        $ sudo ifconfig 
          eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:00:01  
                    inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0
                    inet6 addr: fe80::42:acff:fe11:1/64 Scope:Link
                    UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
                    RX packets:547 errors:0 dropped:0 overruns:0 frame:0
                    TX packets:322 errors:0 dropped:0 overruns:0 carrier:0
                    collisions:0 txqueuelen:0 
                    RX bytes:48132 (48.1 KB)  TX bytes:49572 (49.5 KB)

          eth0:1    Link encap:Ethernet  HWaddr 02:42:ac:11:00:01
                    inet addr:172.17.0.10  Bcast:172.17.255.255  Mask:255.255.0.0
                    UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1

          lo        Link encap:Local Loopback  
                    inet addr:127.0.0.1  Mask:255.0.0.0
                    inet6 addr: ::1/128 Scope:Host
                    UP LOOPBACK RUNNING  MTU:65536  Metric:1
                    RX packets:0 errors:0 dropped:0 overruns:0 frame:0
                    TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
                    collisions:0 txqueuelen:0 
                    RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

Démonstration avec un nom comme alias :

        $ sudo ifconfig eth0:moodle 172.17.0.5
          eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:00:01  
                    inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0
                    inet6 addr: fe80::42:acff:fe11:1/64 Scope:Link
                    UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
                    RX packets:547 errors:0 dropped:0 overruns:0 frame:0
                    TX packets:322 errors:0 dropped:0 overruns:0 carrier:0
                    collisions:0 txqueuelen:0 
                    RX bytes:48132 (48.1 KB)  TX bytes:49572 (49.5 KB)

          eth0:1    Link encap:Ethernet  HWaddr 02:42:ac:11:00:01
                    inet addr:172.17.0.10  Bcast:172.17.255.255  Mask:255.255.0.0
                    UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1

          eth0:moodle Link encap:Ethernet  HWaddr 02:42:ac:11:00:01
                    inet addr:172.17.0.5  Bcast:172.17.255.255  Mask:255.255.0.0
                    UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1


Maintenant que nous avons 2 adresses IP même 3 :P , nous allons pouvoir définir un serveur virtuel sur l'IP 172.17.0.1 ET 172.17.0.10 ou 172.17.0.5.

**ATTENTION** : j'ai réalisé la configuration d'IP de manière éphémère , en effet lors du prochain redémarrage la machine n'aura plus que son IP principale . Pour réaliser cette configuration permanente valider avec la distribution que vous utilisez , pour Ubuntu voici un lien [Configuration IP alias](TODO : ajouter le lien).


Nous allons précéder à la réalisation du premier __VitualHost__ pour l'IP 172.17.0.1 , nous l'appellerons le site A :P (l'inspiration n'est pas présent aujourd'hui :P). Suivant le principe d'Ubuntu / Debian , nous allons créer le fichier sous le répertoire **/etc/apache2/sites-available** , en utilisant un nom significatif.

        $ cat /etc/apache2/sites-available/siteA.conf
        <VirtualHost 172.17.0.1:80>
                ServerAdmin webmaster@localhost
                DocumentRoot /data/vhosts/siteA

                <Directory /data/vhosts/siteA>
                        Options Indexes FollowSymLinks
                        AllowOverride None
                        Require all granted
                </Directory>
        </VirtualHost>

Nous gardons ça au plus simple , comme vous pouvez le constater , la première ligne contient l'adresse IP ET le port d'écoute.
Je vais faire la même opération pour le site B .

        $ cat /etc/apache2/sites-available/siteB.conf
        <VirtualHost 172.17.0.10:80>
                ServerAdmin webmaster@localhost
                DocumentRoot /data/vhosts/siteB

                <Directory /data/vhosts/siteB>
                        Options Indexes FollowSymLinks
                        AllowOverride None
                        Require all granted
                </Directory>
        </VirtualHost>

En gros nous retrouvons la même configuration avec 2 répertoire racine distincts

* __/data/vhosts/siteA__
* __/data/vhosts/siteB__

Nous allons activer les fichiers de configuration , toujours en suivant le principe d'Ubuntu en réalisant un lien symbolique du répertoire **/etc/apache2/sites-enabled** vers les fichiers contenu dans le répertoire **/etc/apache2/sites-available**.

        $ cd /etc/apache2/sites-enabled
        $ sudo ln -s ../sites-available/siteA.conf .
        $ sudo ln -s ../sites-available/siteB.conf .

Réalisons une validation syntaxique des fichiers de configuration afin de s'assurer que nous n'avons pas fait d'erreur.

        $ sudo apachectl configtest
        AH00112: Warning: DocumentRoot [/data/vhosts/siteA] does not exist
        AH00112: Warning: DocumentRoot [/data/vhosts/siteB] does not exist
        
        Syntax OK

Je voulais profiter de l'occasion pour vous démontrer l'avantage d'utiliser le système de validation d'apache, il est en mesure de nous identifier des problèmes. Dans le cas présent les répertoires des sites web ne sont pas présent. Nous allons donc procéder à la réalisation des répertoires ainsi que la création d'un fichier d'index pour nous permettre d'identifier les 2 sites.

        $ sudo mkdir -p /data/vhosts/siteA
        $ sudo mkdir -p /data/vhosts/siteB

        $ cat /data/vhosts/siteA/index.html
        Le site A
        $ cat /data/vhosts/siteB/index.html
        Le site B

Une petite validation syntaxique pour la route ...

        $ sudo apachectl configtest
        Syntax OK


Nous pouvons démarrer le service :

        $ sudo /etc/init.d/apache2 restart


Voilà si nous utilisons notre fureteur nous verrons pour les URL : http://172.17.0.1 et http://172.17.0.10 les sites web :

![vhost-ip-siteA.png](./imgs/vhost-ip-siteA.png)
![vhost-ip-siteB.png](./imgs/vhost-ip-siteB.png)

Il est donc à ce point possible d'avoir N site pour chaque adresse IP disponible sur le système, car lors de la réception d'une requête HTTP apache la traitera en utilisant le fichier de configuration ayant l'IP  spécifique.
G
Comme vous pouvez le constater alors que nous visualisions originalement la page par défaut de Ubuntu/Debian à présent nous ne voyons que le site A lorsque nous accédons à l'URL http://172.17.0.1 . Même si nous n'avons pas désactivé la configuration par défaut contenu dans le fichier **/etc/apache2/sites-enabled/000-default.conf**. Prenons un instant pour voir le contenu du fichiers : 


        <VirtualHost *:80>
                ServerAdmin webmaster@localhost
                DocumentRoot /data/www
                <Directory /data/www/>
                    Options Indexes FollowSymLinks
                    AllowOverride None
                    Require all granted
                </Directory>
                <Directory /data/www/admin >
                    Options FollowSymLinks
                    AllowOverride AuthConfig
                </Directory>
                ErrorLog ${APACHE_LOG_DIR}/error.log
                CustomLog ${APACHE_LOG_DIR}/access.log combined
        </VirtualHost>

L'instruction __VirtualHost__ est composé avec une astérisque et le port (*:80) ce qui indique que ce serveur virtuel est valide pour toute les adresses IP sur le port 80. Comme nous avons été plus spécifique en indiquant les __VirtualHost__ avec des IP ces derniers ont priorités.


## <a name="Vhost_name_base" /> Serveurs virtuels par Nom

Telle que mentionné dans l'introduction malheureusement avec le nombre d'adresse IP (IPv4) restreint disponible sur internet il est compliqué d'avoir une adresse IP par site. 
Avec un hébergement virtuel par nom, le serveur s'appuie sur les informations transmises par le client dans les en-têtes HTTP de ses requêtes. La technique présentée ici vous permet de disposer de serveurs virtuels différents partagés sur une même adresse IP.

L'hébergement virtuel par nom est habituellement plus simple, car il vous suffit de configurer votre serveur __DNS__ pour que chaque domaine pointe sur l'adresse IP dont vous disposez, et de configurer votre serveur Apache HTTP afin qu'il reconnaisse ces domaines. Il réduit aussi la pénurie en adresses IP. Par conséquent, vous devriez utiliser l'hébergement virtuel par nom, sauf dans le cas où vous utiliseriez des équipements qui nécessitent un hébergement basé sur IP. Les raisons historiques de l'hébergement basé sur IP dans un but de support de certains clients ne s'appliquent plus à un serveur web d'usage général.

**Processus de traitement des requêtes**

* Explication provenant du  [site d'apache](http://httpd.apache.org/docs/2.4/fr/vhosts/name-based.html)
    Il est important de savoir que la première étape de la résolution de serveur virtuel basée sur le nom est une résolution basée sur IP. La résolution de serveur virtuel basée sur le nom ne fait que choisir le serveur virtuel basé sur le nom le plus approprié, en se limitant aux candidats qui conviennent le mieux du point de vue IP. La résolution basée sur IP est sans objet si l'on utilise un caractère générique (*) pour l'adresse IP dans toutes les directives __VirtualHost__.

    A l'arrivée d'une requête, le serveur va rechercher l'argument de section __<VirtualHost>__ présentant la meilleure (la plus exacte) correspondance avec la paire adresse IP/port utilisée dans la requête. Si plusieurs serveurs virtuels possèdent cette même paire adresse IP/port, Apache va ensuite comparer les valeurs des directives __ServerName__ et __ServerAlias__ avec le nom de serveur présent dans la requête.

    Si vous ne définissez pas de directive __ServerName__ pour un serveur virtuel à base de nom, le serveur utilisera par défaut le nom de domaine entièrement qualifié (__FQDN__) déduit du nom d'hôte système. Cette configuration sans nom de serveur explicite peut conduire à des erreurs de choix du serveur virtuel à utiliser et est déconseillée.


* Maintenant ma version :P , à vous de choisir la plus claire.
    Lorsque le client utilisant son fureteur réalise une requête vers le site web , la première étape est la résolution __DNS__, si nous prenons le site __www.x3rus.com__ la résolution donnera l'IP : 198.100.146.119 . Le serveur apache doit avoir un serveur Virtuel configurer sur cette adresse IP. Ce peut être avec l'IP spécifier telle que __<VirtualHost 198.100.146.119:80>__ou une configuration plus général à l'aide d'un __wildcard__ __<VirtualHost *:80>__. 
    Si le serveur apache reçoit une requête pour le __VirtualHost__ avec l'adresse IP et constater qu'il y a plusieurs définition pour ce même __VirtualHost__ comme le système ne sait pas pour quelle site la requête est destiné il regarde l'entête de la requête . En effet quand le fureteur a transmis la requête sur internet en plus d'utiliser l'IP pour rejoindre le serveur il a aussi demande __www.x3rus.com__. Apache va donc lire les fichiers de configuration des __VirtualHost__  à la recherche du nom du site. Il va chercher 2 variable [ServerName](http://httpd.apache.org/docs/2.4/fr/mod/core.html#servername) qui est unique et [ServerAlias](http://httpd.apache.org/docs/2.4/fr/mod/core.html#serveralias) cette entré permet de définir plusieurs nom au serveur virtuel. Le système fournis le site le plus spécifique , s'il ne trouve pas le nom du site dans l'ensemble des fichiers de configuration concordant à l'IP il fournira un des serveurs virtuel selon le chargement des fichiers.

Réalisons un petit exemple pour avoir un peu de pratique.

Nous allons créer des serveurs virtuel basé sur le nom pour l'adresse IP __172.17.0.1__ , nous réaliserons quelques testes avec l'autre adresse IP pour démontrer la différence de traitement.

Commençons par associer un nom de serveur virtuel au site A, j'édite donc le fichier **/etc/apache2/sites-available/siteA.conf**

        $ cat  siteA.conf
        <VirtualHost 172.17.0.1:80>
            ServerAdmin webmaster@localhost

            ServerName www.linux202-siteA.com
            ServerAlias linux202-siteA.com
            ServerAlias toto.linux202-siteA.com

            DocumentRoot /data/vhosts/siteA

            <Directory /data/vhosts/siteA>
                Options Indexes FollowSymLinks
                AllowOverride None
                Require all granted
            </Directory>
        </VirtualHost>

        $ sudo apachectl configtest && sudo /etc/init.d/apache2 restart

Si nous utilisons un fureteur pour voir le site web nous aurons une erreur car il n'y a pas de __DNS__ associé a ce nom , nous allons donc modifier notre fichier **/etc/hosts** pour "simuler" la résolution de nom . Ce changement  est doit être réaliser sur la machine **cliente** qui à le fureteur pour consulter les pages web. Et ceci est uniquement une solution de contournement car malheureusement je n'ai pas gagné au loto je n'ai acheter des nom de domaines pour la formation ;-).

Donc avant le changement du fichier **/etc/hosts** :

        client $ ping www.linux202-siteA.com
        ping: unknown host www.linux202-siteA.com
        client $ vim /etc/hosts
        client $ cat /etc/hosts
        $ cat /etc/hosts
        #
        # /etc/hosts: static lookup table for host names
        #

        #<ip-address>   <hostname.domain.org>   <hostname>
        127.0.0.1       localhost.localdomain   localhost
        ::1             localhost.localdomain   localhost

        172.17.0.1      www.linux202-siteA.com linux202-siteA.com toto.linux202-siteA.com
        client $ ping www.linux202-siteA.com
        PING www.linux202-siteA.com (172.17.0.1) 56(84) bytes of data.
        64 bytes from www.linux202-siteA.com (172.17.0.1): icmp_seq=1 ttl=64 time=0.102 ms


Suite à ce petit changement si nous retentons une connexion avec le fureteur nous aurons la __page siteA__ de disponible

![vhost-ip-siteA-avec_nom.png](./imgs/vhost-ip-siteA-avec_nom.png)

Jusqu'ici tout va bien le système fonctionne comme prévus , cependant telle que mentionné plus tôt nous ne somme en serveur virtuelle basé sur nom uniquement s'il y a plusieurs définition du même __VirtualHost__ avec la même IP. Dans notre cas nous n'avons que le __siteA__ avec la définition de l'IP 172.17.0.1 . Nous allons donc procéder à la création du __siteC__, commençons par le fichier de configuration **/etc/apache2/sites-available/siteC.conf**.

        $ cat siteC.conf
        <VirtualHost 172.17.0.1:80>
                ServerAdmin webmaster@localhost

                ServerName www.siteC.com
                ServerAlias siteC.com

                DocumentRoot /data/vhosts/siteC

                <Directory /data/vhosts/siteC>
                    Options Indexes FollowSymLinks
                    AllowOverride None
                    Require all granted
                </Directory>
        </VirtualHost>

Nous allons procéder à la création du répertoire du site et la petite page d'index pour visualisé le site.

        $ sudo mkdir /data/vhosts/siteC
        $ cat /data/vhosts/siteC/index.html
        Le site C

Activation de la configuration , validation de cette dernière et rechargement de la configuration d'apache.

        $ cd /etc/apache2/sites-enabled
        $ sudo ln -s ../sites-available/siteC.conf .
        $ sudo apachectl configtest && sudo /etc/init.d/apache2 restart

Ceci été pour la partie serveur , nous allons modifier le fichier **/etc/hosts** de notre machine client afin de simuler la résolution __DNS__.

        $ sudo vim /etc/hosts
        $ cat /etc/hosts
        #
        # /etc/hosts: static lookup table for host names
        #

        #<ip-address>   <hostname.domain.org>   <hostname>
        127.0.0.1       localhost.localdomain   localhost
        ::1             localhost.localdomain   localhost

        172.17.0.1      www.linux202-siteA.com linux202-siteA.com toto.linux202-siteA.com
        172.17.0.1      www.siteC.com siteC.com 
        $ ping siteC.com
        PING www.siteC.com (172.17.0.1) 56(84) bytes of data.
        64 bytes from www.linux202-siteA.com (172.17.0.1): icmp_seq=1 ttl=64 time=0.102 ms

Validons à présent avec un navigateur ....

![vhost-ip-siteC-avec_nom.png](./imgs/vhost-ip-siteC-avec_nom.png)

**Woww** magie !!

Rappel rapide du processus, de sélection de configuration 

1. Le client via le fureteur à demandé la site __www.siteC.com__ 
2. Le fureteur à réaliser une résolution __DNS__ afin de pouvoir communiquer sur Internet et transmettre le paquet vers le bon serveur web.
3. Le serveur apache à reçu la requête sur l'adresse IP 172.17.0.1 
4. Il a constater qu'il y avait 2 configuration pour cette même adresse IP contenue dans le fichier **/etc/apache2/sites-enabled/siteA.conf** et **/etc/apache2/sites-enabled/siteC.conf**.
5. Le système apache à donc analyser le contenu de la requête client afin d'identifier dans l'entête des paquets HTTP (conformément au protocole __http__) quelle nom de site fut demandé.
6. Avec cette information apache à tenté de trouvé ce nom de domaine dans la définition des serveurs virtuels en interrogeant les directives __ServerName__ et __ServeurAlias__ dans les fichiers **/etc/apache2/sites-enabled/siteA.conf** et **/etc/apache2/sites-enabled/siteC.conf**.
7. Apache a trouvé dans le fichier  **/etc/apache2/sites-enabled/siteC.conf** la définition dans l'instruction __ServerName www.siteC.com__ 
8. Apache à donc consulter les fichier du site définie dans le __DocumentRoot__ soit __/data/vhosts/siteC__, trouvé le fichier __index.html__ et transmis au fureteur.

Super ça , mais s'il avait pas trouvé d'entré __ServerName__ et __ServerAlias__ ?!?! 

Réalisons le teste, car ceci est important c'est une erreur commune :P .

Je vais éditer le fichier __/etc/hosts__ pour simulé une autre résolution __DNS__ pour le nom __site-noname.com__

        $ sudo vim /etc/hosts
        $ cat /etc/hosts
        #
        # /etc/hosts: static lookup table for host names
        #

        #<ip-address>   <hostname.domain.org>   <hostname>
        127.0.0.1       localhost.localdomain   localhost
        ::1             localhost.localdomain   localhost

        172.17.0.1      www.linux202-siteA.com linux202-siteA.com toto.linux202-siteA.com
        172.17.0.1      www.siteC.com siteC.com 
        172.17.0.1      www.site-noname.com site-noname.com #
        # /etc/hosts: static lookup table for host names
        #

        #<ip-address>   <hostname.domain.org>   <hostname>
        127.0.0.1       localhost.localdomain   localhost
        ::1             localhost.localdomain   localhost

        172.17.0.1      www.linux202-siteA.com linux202-siteA.com toto.linux202-siteA.com
        172.17.0.1      www.siteC.com siteC.com 
        172.17.0.1      www.site-noname.com site-noname.com 
        $ ping site-noname.com
        PING www.site-noname.com (172.17.0.1) 56(84) bytes of data.


Utilisons le fureteur à présent 

![vhost-ip-site-noname-avec_nom.png](./imgs/vhost-ip-site-noname-avec_nom.png)

Le système à choisie le premier serveur virtuel qu'il a trouvé ! Attention avec ce comportement vous pouvez avoir des surprise.

**Note version antérieure :** Avant la version 2.4 vous devez spécifier les adresses IP qui vont être utilisé avec des serveurs virtuel basé sur le nom avec l'instruction [NameVirtualHost](http://httpd.apache.org/docs/2.2/mod/core.html#namevirtualhost)

Ceci couvre la démonstration d'un serveur virtuel basé sur le nom en HTTP, nous pouvons toujours consulter le site sur l'IP 172.17.0.10 sans problème. Il est possible d'avoir une configuration mixe sur la même serveur !

* Référence : http://httpd.apache.org/docs/2.4/fr/vhosts/name-based.html

# <a name="organisation" /> Organisation des sites web

Maintenant que nous avons la possibilité de mettre plusieurs site web, il faut faire attention que ça ne devienne pas rapidement un gros problème de gestion. Je vais vous faire une suggestion d'organisation de structure, ceci est le fruit d'expérience de plusieurs année. J'ai rencontré des contraintes et des demandes d'utilisateurs qui m'ont amenés à mettre en place cette organisation, comme toujours libre à vous de l'adapter pour vos besoins. Je vais en profité pour couvrir d'autre configuration avec des explications pourquoi j'ai opté pour cette configuration.

## <a name="organisation_rep_vhosts"/> Organisation des répertoires des serveurs virtuelle

Commençons par la structure des répertoires qui hébergerons les site web. 
Voici une représentation de la structure du répertoire :

            /data/
                 /vhost/
                       /siteA/
                             /docroot/
                             /logs/
                             /privates/
                             /uploads/
                       /siteB/
                       /siteC/

Prenons maintenant quelques minutes pour lire la structure , j'aime avoir l'ensemble des __VirtualHost__ sous un même répertoire. Parce que ceci me permet de définir des permissions avec l'instruction [Directory](https://httpd.apache.org/docs/2.4/fr/mod/core.html#directory) depuis la racine et ceci ce répercute sur l'ensemble des répertoires enfants. Ceci me permet d'être plus restrictif et par la suite permettre plus d'option selon le répertoire.

Chaque site on la même structure encore une fois ceci simplifie la gestion par la suite :

* **docroot** : Contient le site web c'est le répertoire qui sera associé à la configuration [DocumentRoot](https://httpd.apache.org/docs/2.4/mod/core.html#documentroot). Ce sera donc le répertoire racine du site.
* **logs** : Avec le temps j'ai constaté que les développeurs web aime avoir accès au logs , que ce soit pour analyser les erreurs ou simplement voir l'activité en temps réel. Nous nous assurerons des permissions sur ce répertoire pour que ce ne soit qu'en lecture, par  mesure de précaution.
* **privates** : Ce répertoire n'est pas accessible depuis Internet, ce répertoire peut être utilisé par le développeur pour stocké des fichiers à usage interne au serveur uniquement. Nous pourrions retrouvé par exemple un fichier de configuration pour établir une connexion à la BD. Nous ne désirons pas qu'une personne puisse récupérer ce fichier via un fureteur car il devine le nom. Je vous laisse le soin de faire un testes sur vos serveur :P . Si vous avez un fichier __config.conf__ par exemple dans le répertoire __inc__ sous la définition du __DocumentRoot__, vous constaterez que tout le monde peut l'avoir :-/. Bien entendu ce répertoire est totalement inutile si l'administrateur du site ne l'utilise pas :-/.
* **uploads** : Ce répertoire a les permissions d'écriture à apache et permet l'écriture par l'applicatif web. Il n'est pas toujours possible de l'utiliser, car certaine applications désire l'avoir sous le __docroot__ donc faut voir selon vos applications. Je le met en place, car ceci permet tous de suite au développeur d'avoir un répertoire disponible sans prendre contact avec moi pour un changement de permission.


Voici un petit script pour faire la création des répertoires, attention ceci est vraiment un point de départ, je vous invite à le modifier afin de rajouter la définition des permissions pour le répertoire docroot, ... Ce que je veut surtout souligner avec la création d'un script est qu'il faut tout faire pour automatiser les opérations manuel. Car si vous réalisez souvent cette opération, parfois vous ferez une erreur dans le nom du répertoire, une erreur de permissions , ...
2 possibilités s'offre à vous , réaliser des scripts ou utiliser un système de gestion de configuration telle que [ansible](http://www.ansible.com) ou [puppet](http://puppetlabs.com), nous verrons plus tard ces systèmes ! 

        #!/bin/bash
        #
        ##############################################
        
        # Vars
        VHOSTS_BASE=/data/vhosts
        APACHE_GROUP=www-data
        LST_REPS_VHOSTS="docroot logs privates uploads"
        
        # Arguments passer sur la ligne de commande.
        VHOST_TO_CREATE=$@
        
        if [ "$VHOST_TO_CREATE" == "" ]; then
                echo "ERROR: Il n'y a pas d'argument avec un ou plusieurs site a creer "
                echo "$0 siteA " 
                echo "$0 siteA siteB siteC"
                exit 1
        fi
        
        for site in $VHOST_TO_CREATE
        do
                echo "sudo mkdir -p $VHOSTS_BASE/$site"
                for rep in $LST_REPS_VHOSTS
                do
                        echo "sudo mkdir $VHOSTS_BASE/$site/$rep"
                        if [ "$rep" == "uploads" ] ; then
                                echo "sudo chmod g=rwX $VHOSTS_BASE/$site/$rep" 
                                echo "sudo chown :$APACHE_GROUP $VHOSTS_BASE/$site/$rep"        
                        fi # if uploads
                done #for rep
        done # for vhosts

## <a name="organisation_config_vhosts"/> Configuration Apache pour les serveurs virtuels

Nous avons maintenant la structure des répertoires, nous allons mettre en place la configuration apache approprié.

Nous allons définir une configuration par défaut qui sera hérité par l'ensemble des sites virtuel. 
Toujours en suivant la structure de Ubuntu/Debian nous allons définir le fichier **/etc/apache2/conf-available/vhosts\_base.conf**. Nous allons y définir la configuration pour le répertoire **/data/vhosts/**.

Voici le contenu du fichier : **/etc/apache2/conf-available/vhosts\_base.conf**

        # Configuration par default qui sera appliquer par default a l'ensemble des vhosts

        <Directory /data/vhosts>
                Options None
                AllowOverride None
                Require all denied
        </Directory>

Dans le cas présent je désactive l'ensemble des options , nous y reviendrons lors de la configuration d'un serveur virtuel et je désactive la possibilité d'utiliser les fichiers __.htaccess__. Ceci pour une question de performance ET de sécurité. De plus je bloque l'accès aux répertoire avec l'instruction **Require all denied** . Je réalise cette opération afin que l'on soit obligé de définir spécifiquement les répertoires accessible depuis internet .

Nous activons la configuration en réalisant un lien symbolique et on valide la configuration pour être certain !

        $ cd /etc/apache2/conf-enabled
        $ sudo ln -s ../conf-available/vhosts_base.conf .
        $ sudo apachectl configtest
        Syntax OK

Tout semble bon, nous pouvons procéder à la configuration du serveur virtuel. Toujours selon la structure d'Ubuntu nous allons faire la création du fichier **/etc/apache2/sites-available/siteA.conf**, en fait nous allons modifier le fichier déjà existant .

Voici le fichier pour le __siteA__ et le __siteC__

        <VirtualHost 172.17.0.1:80>
                ServerAdmin webmaster@localhost

                ServerName www.linux202-siteA.com
                ServerAlias linux202-siteA.com
                ServerAlias toto.linux202-siteA.com

                DocumentRoot /data/vhosts/siteA/docroot/

                <Directory /data/vhosts/siteA/docroot/>
                    Options none
                    AllowOverride None
                    Require all granted
                </Directory>

                <Directory /data/vhosts/siteA/uploads/>
                    Options none
                    AllowOverride None
                    Require all granted
                </Directory>

                # Configuration des logs
                ErrorLog /data/vhosts/siteA/logs/error.log
                CustomLog /data/vhosts/siteA/logs/access.log combined
        </VirtualHost>

        <VirtualHost 172.17.0.1:80>
                ServerAdmin webmaster@localhost

                ServerName www.siteC.com
                ServerAlias siteC.com

                DocumentRoot /data/vhosts/siteC/docroot/

                <Directory /data/vhosts/siteC/docroot/>
                    Options none
                    AllowOverride None
                    Require all granted
                </Directory>

                <Directory /data/vhosts/siteC/uploads/>
                    Options none
                    AllowOverride None
                    Require all granted
                </Directory>

                # Configuration des logs
                ErrorLog /data/vhosts/siteC/logs/error.log
                CustomLog /data/vhosts/siteC/logs/access.log combined
         </VirtualHost>


Comme d'habitude avant d'aller plus loin, une validation de configuration est une bonne chose . 

        $ sudo apachectl configtest
        Syntax OK

J'autorise spécifiquement les répertoires __docroot__ et __uploads__, le répertoire __uploads__ est susceptible de contenir des images ou autre document diffusé au publique donc l'autorisation est donnée. Les répertoires __privates__ et __logs__ n'étant destiné qu'a usage interne ne sont pas permis.
Comme vous pouvez le constater nous avons ajouter 2 instructions : **ErrorLog** et **CustomLog** prenons quelques minutes pour les analyser.

## <a name="organisation_logs_vhosts"/> Configuration des logs pour les serveurs virtuels

Pour faire la gestion des logs qui est un point SUPER important si vous voulez être en mesure d'analyser le trafic d'un site web ou de visualiser les erreurs survenu sur le site.

Nous avons déjà une configuration présente comme configuration par défaut :

        $ grep -n ErrorLog /etc/apache2/apache2.conf 
        122:# ErrorLog: The location of the error log file.
        123:# If you do not specify an ErrorLog directive within a <VirtualHost>
        128:ErrorLog ${APACHE_LOG_DIR}/error.log
        $ egrep 'APACHE_LOG_DIR' -n /etc/apache2/envvars 
        23:export APACHE_LOG_DIR=/var/log/apache2$SUFFIX

L'instruction [ErrorLog](https://httpd.apache.org/docs/2.4/fr/mod/core.html#errorlog) permet de définir le fichier qui sera utilisé pour contenir les logs d'erreur par défaut , donc ce fichier contiendra l'ensemble des erreurs de démarrage et les logs d'erreurs des serveurs virtuel SI vous n'avez pas redéfinie cette instruction.

![ErrorLog-screenshot-documentation.png](./imgs/ErrorLog-screenshot-documentation.png)

Comme vous pouvez le constater cette instruction ne peut être utilisé que dans la configuration global du serveur ET / OU dans un __VirtualHost__.

En le redéfinissant dans le __VirtualHost__, le fichier d'erreur de logs contiendra **uniquement** les erreurs relatif au __VirtualHost__ vous n'aurez pas les erreurs global du serveur. Vous aurez dans le fichier les erreurs telle que les 404 , les erreur 500 (problème d'exécution), les erreurs de PHP si vous utilisez ce langage , ... Ceci est très très intéressant afin d'ajuster votre site en cas de problème.

Ceci étant dit j'ai définie une autre instruction qui est [CustomLog](http://httpd.apache.org/docs/current/fr/mod/mod_log_config.html#customlog), cette instruction permet de définir le fichier de log qui contiendra l'information d'accès au site , donc SANS les erreurs.

![CustomLog-screenshot-documentation.png](./imgs/CustomLog-screenshot-documentation.png)

Tout comme pour l'instruction d'erreur cette instruction peut être définie dans le fichier Global ou dans un __VirtualHost__.
Si nous regardons l'instruction dans le fichier ceci est composé de 2 partie le nom du fichier et le format .

        CustomLog /data/vhosts/siteA/logs/access.log combined

Donc nous écrivons le fichier __/data/vhosts/siteA/logs/access.log__ avec le format **combined**. Parlons donc un peu format , 98% (c'est vraiment sortie de mon chapeau, j'ai pas de statistique réelle :P ) vous utiliserai le formant **combined**. 
Les formats disponible sont décrit par l'instruction [Logformat](http://httpd.apache.org/docs/current/fr/mod/mod_log_config.html#logformat), regardons les formats de log pré définie sur le serveur .

        $ grep "LogFormat" -n -R /etc/apache2/apache2.conf
        207:LogFormat "%v:%p %h %l %u %t \"%r\" %>s %O \"%{Referer}i\" \"%{User-Agent}i\"" vhost_combined
        208:LogFormat "%h %l %u %t \"%r\" %>s %O \"%{Referer}i\" \"%{User-Agent}i\"" combined
        209:LogFormat "%h %l %u %t \"%r\" %>s %O" common
        210:LogFormat "%{Referer}i -> %U" referer
        211:LogFormat "%{User-agent}i" agent

Nous avons donc les formats :

* vhost_combined
* combined
* common

Si nous regardons rapidement l'instruction [Logformat](http://httpd.apache.org/docs/current/fr/mod/mod_log_config.html#logformat) pour **combined** nous avons le format :

* %h : Serveur distant. Contiendra l'adresse IP si la directive HostnameLookups est définie à Off
* %l : Le nom de connexion distant , Affiche un tiret, sauf si mod\_ident est présent
* %u : L'utilisateur distant (en provenance d'auth ; peut être faux si le statut de retour (%s) est 401).
* %t : Date à laquelle la requête a été reçue
* %r : La première ligne de la requête
* %>s : Statut. Pour les requêtes redirigées en interne, il s'agit du statut de la requête *originale* --- %>s pour la dernière.
* %O : Nombre d'octets envoyés, y compris les en-têtes. Peut être nul dans les rares cas où une requête est avortée avant que la réponse ne soit envoyée. Nécessite l'activation de mod\_logio.
* %Referer : Référence de la provenance de la requête
* %User-Agent : Le type de client établissant la connexion  (Firefox , Chrome, windows, Linux , ...)

Voici un exemple de contenu dans les logs en format __combined__:

        172.17.42.1 - - [26/Feb/2016:08:43:17 -0500] "GET / HTTP/1.1" 200 3594 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"
        172.17.42.1 - - [26/Feb/2016:08:43:17 -0500] "GET /icons/ubuntu-logo.png HTTP/1.1" 200 3688 "http://172.17.0.10/" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"

Quand avez vous besoin de définir un format de log ?!?! En fait c'est très rare, généralement le besoin ce fait sentir si vous avez une informations spécifique à récupérer qui n'est pas déjà contenu dans le format __combined__. L'autre situation plus probable est quand votre logiciel de traitement des logs et de générateur de statistiques vous demande un format spécifique, ceci est cependant rare. 

Grâce à ces 2 instructions maintenant vous offrez à vos "clients" / "utilisateurs" la possibilité d'avoir accès à LEUR logs !

### <a name="organisation_rotation_logs_vhosts"/> Rotation des logs pour les serveurs virtuels

**ATTENTION** ce n'est pas fini , si nous laissons en l'état la configuration les fichiers __error.log__ et __access.log__ pour les serveurs virtuelles vont grossir de manière infinie. Résultat après 6 mois ou 1 an le fichier d'erreur ou d'accès fera plusieurs Gigs résultat ce sera dure à traiter. Il est important de mettre un système de rotation des logs avec une conservation de temps définie. 

GNU/Linux a le système __Logrotate__ de disponible qui est parfait pour notre besoin , il est possible de définir une règle pour la rotation de vos logs. L'ensemble des distributions offre se mécanisme de rotation , si nous prenons notre machine il y a déjà la méthode de rotation de mise en place pour les fichiers d'Apache par défaut soit **/var/log/apache2/error.log** et **/var/log/apache2/access.log**. Regardons le fichier déjà en place disponible : **/etc/logrotate.d/apache2**

        $ cat /etc/logrotate.d/apache2
        /var/log/apache2/*.log {
                weekly
                missingok
                rotate 52
                compress
                delaycompress
                notifempty
                create 640 root adm
                sharedscripts
                postrotate
                    if /etc/init.d/apache2 status > /dev/null ; then \
                    /etc/init.d/apache2 reload > /dev/null; \
                    fi;
                endscript
                prerotate
                    if [ -d /etc/logrotate.d/httpd-prerotate ]; then \
                    run-parts /etc/logrotate.d/httpd-prerotate; \
                    fi; \
                endscript
         }

Prenons quelques minutes pour analyser ce fichier, car  il est composé par des personnes d'expérience et c'est une bonne source de référence nous pourrons nous en inspirer pour notre besoin.

* **/var/log/apache2/\*.log** : Ceci défini les fichiers qui seront traités, il est important de ne pas définir **/var/log/apache2/\*** sinon les fichiers qui auront été traités dans le passé seront traité à nouveau et ceci en boucle !
* **weekly** : La rotation ici est exécutée une fois par semaine , il est bien entendu possible de mettre une configuration journalière (**daily**) ou par mois selon les besoins.
* **missingok** : Le système de rotation ne va pas générer une erreur s'il n'y a pas de fichier
* **rotate 52** : Le système va conserver les fichiers traité pendant 52 fois , comme nous avons définie une rotation hebdomadaire ceci indique que les fichiers de logs d'apache seront conservé pendant 1 an.
* **compress** : Une fois le fichier de logs traiter ce dernier sera compressé par défaut avec __gzip__ , ceci permet d'économiser de l'espace disque , car le texte ce compresse très bien 
* **delaycompress** : Le traitement de compression peut être long surtout si les fichiers sont volumineux. L'objectif de mettre en place un délai pour la compression est de s'assurer que l'ensemble des fichiers sont traité relativement en même temps et que par la suite ils sont compressé. Résultat si le fichier de logs d'accès est traité en premier puis le fichier d'erreur ils seront fait en même temps, ce sera plus facile de faire une corrélation des accès / erreur que si l'information est dans des fichier distinct traiter dans un temps différent.
* **notifyempty** : Si le fichier est présent mais vide un courriel sera transmis au __root__.
* **create 640 root adm** : Les fichiers créé par le système de rotation auront les permissions Utilisateur __root__ et groupe __adm__ avec les permissions en octal 640.
* **sharedscripts** : Ceci indique qu'il est y a des scripts qui doivent être exécuté lors de la rotation , dans notre cas __postrotate__ et __prerotate__.
* **postrotate** : Ceci définie une instruction qui doit être exécuter **APRÈS** la rotation de tous les fichiers . Lisons la configuration le script valide que apache est en exécution __/etc/init.d/apache2 status__ s'il est en exécution il recharge la configuration apache __/etc/init.d/apache2 reload__. Mais pourquoi ?!?! Quand apache démarre il ouvre un __File Descripteur__ sur le fichier, ceci est un pointeur vers le fichier, lors de la rotation le système __logrotate__ réalise un **move** du fichier. Si nous nous ne rechargeons pas la configuration d'Apache ceci aurait pour conséquence qu'apache continuerait d'écrire dans le fichier original donc celui traité par __logrotate__. Le processus de recharge de la configuration force apache a refaire la connexion au fichier donc prendre en charge le nouveau fichier créé par __logrotate__.
* **prerotate** : Ceci définie une instruction qui doit être exécuter **AVANT** la rotation des fichiers, généralement nous utilisons ce mécanisme pour faire le traitement des fichiers d'accès et d'erreur avec un script fournit par notre logiciel de traitement des statistiques. Comme nos fichiers de logs sont compressé une fois la rotation réalisé il est plus facile de lire le fichier avant lors compression :D. Dans le cas présent le script valide la présence du répertoire __/etc/logrotate.d/httpd-prerotate__ et exécute l'ensemble des scripts présent dans le répertoire __run-parts /etc/logrotate.d/httpd-prerotate__.

Comme nous pouvons le voir ceci donne un très bon point de départ pour débuter. Réalisons maintenant notre configuration en nous en inspirant. Nous allons créer le fichier **/etc/logrotate.d/vhosts\_apache**


        /data/vhosts/*/logs/*.conf {
                daily
                missingok
                rotate 365
                compress
                delaycompress
                create 644 root adm
                sharedscripts
                postrotate
                    if /etc/init.d/apache2 status > /dev/null ; then \
                    /etc/init.d/apache2 reload > /dev/null; \
                    fi;
                endscript
        }

Je ne vais souligner que les changements réalisés sur les configurations, comparativement au fichier __apache2__ d'origine.

* **/data/vhosts/\*/logs/\*.conf** : J'utilise un __wildcard__ (\*) afin de couvrir l'ensemble des sites web sous le répertoire **/data/vhosts** , ceci me permet de mettre en place la rotation peut importe le nombre de site présent et ainsi je suis certain de ne pas oublier la configuration. Tout comme pour la configuration par défaut je prend en considération dans la rotation que les fichiers \*.conf.
* **daily** : Personnellement je préfère une rotation journalière surtout si vous avez un trafic important.
* **rotate 365**: ça fait beaucoup de fichier j'ai voulu conservé les logs 1 an , libre à vous de juger de la pertinence de l'opération.
* **notifyempty** : J'ai désactivé cette fonctionnalité, car je veux pas le savoir :P .
* **create 644 root adm** : Ici j'ai modifier les permissions des fichiers afin de permettre à TOUS de lire le contenu, cependant UNIQUEMENT **root** peut écrire / effacer le contenu. C'est important car je veux offrir l'accès au personne pour consulter l'information , mais je ne veux surtout pas que quelqu'un puisse enlever de l'information. 
* **prerotate** : À ce stade du déploiement je n'ai pas mis en place de traitement des fichiers donc je l'ai désactivé , si vous désirez mettre en place un logiciel de statistique il y a bien entendu __google analytic__ , mais de la monde du libre vous avez [piwik](http://www.piwik.org) de disponible qui est très bien.

Nous avons donc maintenant une solution de logs pérenne !

## <a name="organisation_repertoire_private"/> Utilisation du répertoire privé

Ceci sort un peu du cadre de la formation, ceci est plus orienté sur l'organisation du site web et de ça programmation, cependant avec l'importance de la sécurité de nos jours il est important de couvrir rapidement ce point. Même si nous avons le rôle d'offrir uniquement le serveur apache, dans la réalité nous agissons souvent comme conseillé sur les systèmes.

Nous allons maintenant voir l'utilisation du répertoire __private__, comment écrire notre site web afin de profiter de ce répertoire non accessible depuis internet. Pour la démonstration je vais utilisé le langage de programmation __php__, loin d'être un expert dans ce langage , cependant de par la simplicité du langage la démonstration sera facile.

Nous allons donc installer __php__ et valider son installation 

        $ sudo apt-get update && sudo apt-get install php5
        $ sudo vim /data/vhosts/siteA/docroot/info.php
        $ cat /data/vhosts/siteA/docroot/info.php
        <?php

        // Show all information, defaults to INFO_ALL
        phpinfo();

        ?>
        $ sudo apachectl configtest && sudo /etc/init.d/apache2 restart
         * Restarting web server apache2
         *    ...done.

Si nous accédons au site via l'URL : http://linux202-sitea.com/info.php nous aurons l'information sur le __php__ installé.

![phpinfo.png](./imgs/phpinfo.png)

Donc __php__ fonctionne , nous allons pouvoir poursuivre ...avec le vrai objectif. Je vais commencé par montrer la méthode "classique" soit inclure un fichier de configuration directement dans l'application , je vais créer 2 fichier **app.php** et **config.conf** . Le premier va charger le second , pour les développeurs __php__ je sais ce n'est pas très beau mais c'est pas un cours __php__ ;-).

        $ sudo vim /data/vhosts/siteA/docroot/app.php
        $ cat /data/vhosts/siteA/docroot/app.php
        <?php

        include('./config.conf');

        ?>
        $ sudo vim /data/vhosts/siteA/docroot/config.conf
        $ cat /data/vhosts/siteA/docroot/config.conf
        toto=blabla
        titi=encore

Bon avec cette configuration si vous allez avec votre fureteur sur l'URL de l'application vous aurez ceci : 

* http://linux202-sitea.com/app.php

![siteA-app-config-classic.png](./imgs/siteA-app-config-classic.png)

Donc la configuration fut bien chargé , nous voyons le contenu de la configuration :D, mais heu ... Si j'essaye ceci 

* http://linux202-sitea.com/config.conf

![siteA-config-conf.png](./imgs/siteA-config-conf.png)

**oupss** , __Yep__ tout le monde peux voir ce fichier de configuration :P, faut juste connaître l'URL , puis **config.conf** ou **db.conf** c'est pas très dur à deviner et surtout à scripter pour récupérer de l'information d'un site. Nous verrons probablement plus tard comment bloqué l'accès à des extensions de fichier, il existe des mécanismes dans apache . Mais Si nous sortons le fichier du **DocumentRoot** donc de la racine c'est garantie que personne pourra avoir accès au fichier. 
Voyons l'autre méthode avec l'utilisation du répertoire **private**.

        $ sudo vim /data/vhosts/siteA/docroot/app_w_priv.php
        $ cat /data/vhosts/siteA/docroot/app_w_priv.php
        <?php

        include('../privates/config.conf');

        ?>
        $ sudo vim /data/vhosts/siteA/privates/config.conf
        $ cat /data/vhosts/siteA/privates/config.conf
        private=info
        super=priv

Donc cette fois __l'include__ est réalisé en remontant d'un cran (..) et on va dans le répertoire __privates__. 

Le résultat : http://linux202-sitea.com/app_w_priv.php

![siteA-app-config-private.png](./imgs/siteA-app-config-private.png) 

**woot** ça marche toujours :D. Maintenant je vais tenté d'accéder au fichier de configuration , si je reprend la configuration ceci devrait être bon : http://linux202-sitea.com/../privates/config.conf, je monte d'un répertoire et je vais dans __privates__.

![siteA-privates-config-conf.png](./imgs/siteA-privates-config-conf.png)

**NOPE** impossible , car on ne peut pas remonté avant le **DocumentRoot** :D , c'est pas beau ça :)


## <a name="organisation_utilisation_htaccess"/> Utilisation de la surcharge de configuration (htaccess)

Je vais revenir rapidement sur le système de surcharge de configuration, nous avons déjà abordé l'aspect son utilisation. Nous avons parlé des coût en terme de performance et "rapidement" de la sécurité. Par contre nous n'avons pas eu d'exemple claire des risques de la surcharge de la configuration , donc c'est partie pour une petite démonstration. 
La majorité des hébergeur publique vous permet de redéfinir l'ensemble des configurations via le système __htaccess__. Nous allons voir le risque possible . 

Je vais premièrement modifier la configuration du __siteA__ afin de permettre la surcharge :

        $ sudo vim /etc/apache2/sites-available/siteA.conf
        [ ... OUTPUT COUPÉ ...]
        <Directory /data/vhosts/siteA/docroot/>
            Options none
            AllowOverride ALL
            Require all granted
        </Directory>
        [ ... OUTPUT COUPÉ ...]

Si nous lisons la définition du répertoire du __DocumentRoot__ j'ai modifier l'entrée pour l'instruction de **AllowOverride** de **NONE** à **ALL** , pour garder ça simple .

On valide la configuration et recharge cette dernière...

À ce stade nous pouvons redéfinir l'ensemble des configurations d'apache sous le répertoire du __DocumentRoot__ , nous allons profiter de cette occasion pour présenter l'instruction [Options](https://httpd.apache.org/docs/2.4/fr/mod/core.html#options).

![Options-screenshot-documentation.png](./imgs/Options-screenshot-documentation.png)

Bon [Options](https://httpd.apache.org/docs/2.4/fr/mod/core.html#options) c'est quoi ça nous permet de définir les fonctionnalités d'un répertoire ... Désolé c'est la descriptions directement du site d'apache :P. En gros ça nous permet de définir le comportement du traitement des requêtes , par exemple si il y a un lien symbolique est-ce qu'il le suit ? S'il n'y a pas de fichier d'index que faire ? ... Regardons les Argument disponible ceci va éclaircir les possibilités.

* **ExecCGI** : Permet l'appel de scripts externe telle que des scripts écrit en python , __perl__ , même en C . Apache exécute le fichier ou binaire.
* **FollowSymLinks** : Le serveur va suivre les liens symboliques dans le répertoire concerné.
* **Indexes** : Si une URL requise correspond au répertoire concerné, et si aucun DirectoryIndex (par exemple index.html) n'est défini pour ce répertoire, le module mod\_autoindex va renvoyer un listing formaté du répertoire.
* **MultiViews** : Les vues multiples ("multiviews") à contenu négocié à l'aide du module mod\_negotiation sont autorisées. 
* **SymLinksIfOwnerMatch** : Le serveur ne suivra que les liens symboliques qui renvoient vers un fichier ou un répertoire dont le propriétaire est le même que celui du lien.
* **ALL** / **NONE** : respectivement toute les options cité plus haut ou aucune options :D.

Bon Cool pour le moment on vois pas le problème ou si peut-être :P , bon allez on y va avec la démonstration. Si vous regardez mes configurations précédente je définie toujours l'[Options](https://httpd.apache.org/docs/2.4/fr/mod/core.html#options) à **None** . Vous allez comprendre pourquoi...

Je vais éditer le fichier __.htaccess__  dans le répertoire __DocumentRoot__ du __SiteA__ .

        $ sudo vim /data/vhosts/siteA/docroot/.htaccess
        $ cat /data/vhosts/siteA/docroot/.htaccess
        Options FollowSymLinks

On va juste mettre **FollowSymLinks** , on va créer un petit lien symbolique qui va bien avec :).

        $ cd /data/vhosts/siteA/docroot
        $ sudo ln -s /etc/passwd lst_users
        $ ls -l lst_users 
        lrwxrwxrwx 1 root root 11 Mar 11 17:24 lst_users -> /etc/passwd

Maintenant allons sur l'URL qui va bien :D : http://linux202-sitea.com/lst_users

![siteA-lst-users.png](./imgs/siteA-lst-users.png)

**Oupss** ou **YEahh** selon le besoin :P, yep **FollowSymLinks** c'est __evil__ :P. Bon mais ça m'ennuie de faire un lien symbolique pour chaque fichier que je veux consulter non ?!?!. 
On va changer le fichier __htaccess__ un peu , pour avoir encore plus de plaisir.

        $ sudo vim /data/vhosts/siteA/docroot/.htaccess
        $ cat /data/vhosts/siteA/docroot/.htaccess
        Options FollowSymLinks Indexes

Pas besoin de recharger apache , on va juste faire un autre lien symbolique .

        $ cd /data/vhosts/siteA/docroot
        $ sudo ln -s /etc sys
        $ ls -l sys
        lrwxrwxrwx 1 root root 4 Mar 11 17:31 sys -> /etc

C'est partie avec L'URL :D , que du plaisir : http://linux202-sitea.com/sys/

![siteA-sys.png](./imgs/siteA-sys.png)

**Woot** , maintenant je peux choisir quelle fichier je veux lire dans le répertoire **/etc** , beaucoup plus facile :). Bien entendu nous sommes limité par les permissions de l'utilisateur Apache. En effet le processus **httpd** qui fait la lecture des fichier est exécuté sous l'utilisateur **www-data** nous sommes donc limité par les permissions des fichiers.
Exemple :

* **/etc/passwd** : est lisible par tout le monde , donc __www-data__  peut le consulter 

                $ ls -l /etc/passwd 
                -rw-r--r-- 1 root root 1001 Dec  9 14:09 /etc/passwd

* **/etc/shadow** : Ce dernier contient les mot de passe des utilisateurs présent sur le système n'est lisible que par **root** et le groupe **shadow** comme __www-data__ n'est pas membre du groupe , ni __root__ la lecture est impossible.
            
                $ ls -l /etc/shadow
                -rw-r----- 1 root shadow 652 Dec  9 14:09 /etc/shadow

![siteA-sys-shadow.png](./imgs/siteA-sys-shadow.png)

Je ne poursuivrai pas plus en détail , la démonstration du risque de la surcharge des configurations, cependant pour des environnement de production il faut prendre en considération les risques que ceci implique .


## <a name="organisation_alias"/> Mutualisation de contenu  / service (Alias)

Il est fort probable que les sites web que vous hébergez est du contenu équivalent que nous parlions d'images ou de contenu d'information. Si nous prenons l'exemple de sites corporatif , nous pouvons penser au logo de la compagnie , il peut être intéressant que tous les sites utilise les même fichiers . L'avantage est que si le logo de l'entreprise change nous n'avons qu'un fichier à changer au lieu de visiter tous les sites et finalement constater que nous avons fait un oublie.
Si vous réalisé de l'hébergement publique votre réalité peut être différente en terme de contenu mutualisé cependant nous retrouvons un besoin similaire. Si vous offrez un service complet avec un service de courriel vous désirez peut-être offrir un __webmail__ au client. Si vous installez un __webmail__ ou un __phpmyadmin__ pour chaque client quand une mise à jour sera à réalisé vous maudirez le développeur d'avoir sortie cette nouvelle version !! De plus nous voulons éviter que chaque client installe leurs propre application, ceci principalement pour des questions de sécurité, car il est peu probable que ce dernier soit conscientisé au risque :P.

Nous retrouvons l'option d'utiliser les Alias , ceci permet de définir un chemin qui sera utilisable et pointera vers un répertoire disponible pour tous. Ce répertoire peut être en dehors du répertoire __DocumentRoot__ du site web.

Pour faire une utilisation simple, nous allons mettre en place un répertoire mutualisé pour les images de la compagnie.
Commençons par la structure des répertoires, personnellement je réalise un répertoire __common__ sous le répertoire __vhost__ , ce qui donne :

            /data/
                 /vhost/
                       /siteA/
                       /siteB/
                       /siteC/
                       /common/
                              webmail/
                              phpmyadmin/
                              images/

Dans la structure ci-dessus, j'ai créé les répertoires pour accueillir le logiciel de __webmail__ et __phpmyadmin__, pour le moment nous nous occuperons uniquement d'images. Cependant le concept reste le même .

Mise en place de la configuration , création du répertoire et mise en place d'une images :

            $ sudo mkdir /data/vhosts/common/
            $ sudo mkdir /data/vhosts/common/images /data/vhosts/common/webmail /data/vhosts/common/phpmyadmin
            $ sudo cp ~/post-it.jpg /data/vhosts/common/images/

Donc sous __/data/vhosts/common/images/__ nous avons une images disponible, nous allons procéder à la modification de la configuration du site __siteA__ afin qu'il puisse utiliser cette configuration.
Édition du fichier **/etc/apache2/sites-available/siteA.conf**

            [ ... OUTPUT COUPÉ ... ] 
            DocumentRoot /data/vhosts/siteA/docroot/

            Alias "/cm-images" "/data/vhosts/common/images"

            <Directory /data/vhosts/siteA/docroot/>
                Options none
                AllowOverride ALL
                Require all granted
            </Directory>
            [ ... OUTPUT COUPÉ ... ] 

J'ai réalisé l'ajout de l'instruction [Alias](https://httpd.apache.org/docs/2.4/mod/mod_alias.html#alias).

![Alias-screenshot-documentation.png](./imgs/Alias-screenshot-documentation.png)

Comme l'on peut voir la configuration d'un alias est disponible pour :

* La configuration globale du serveur
* La configuration d'un serveur Virtuel (__VirtualHost__)
* Un répertoire.

On valide et recharge la configuration

        $ sudo apachectl configtest && sudo /etc/init.d/apache2 reload 
        Syntax OK
        * Reloading web server apache2
        *

Accédons au site 

* http://linux202-sitea.com/  : OK ,pas de problème le site est toujours disponible :) c'est un bon début.
* http://linux202-sitea.com/cm-images/post-it.jpg : KO , **Forbidden** __You don't have permission to access__.

Pourquoi pensez vous que le problème survient ?

Un petit truc d'analyse, c'est peut-être subtile , mais étant confortables avec apache ceci me fournit de l'information. Premièrement comme nous avons l'erreur **Forbidden** , moi j'en déduis que mon instructions est bien interprété. En effet si je fait une erreur dans l'URL et que j'écris : http://linux202-sitea.com/ko-images/post-it.jpg , je n'ai pas un **Forbidden** mais **Not found** , donc clairement mon instruction est interprété :D.

Maintenant regardons les logs :D , comme les logs sont maintenant généré dans le répertoire de serveur virtuel nous ne devons plus consulter __/var/log/apache2/error.log__ mais __/data/vhosts/siteA/logs/error.log__.

        $ tail /data/vhosts/siteA/logs/error.log
        [Fri Mar 18 08:49:23.999085 2016] [authz_core:error] [pid 98] [client 172.17.42.1:50796] AH01630: client denied by server configuration: /data/vhosts/common/images/
        [Fri Mar 18 08:50:18.929006 2016] [authz_core:error] [pid 99] [client 172.17.42.1:50806] AH01630: client denied by server configuration: /data/vhosts/common/images/post-it.jpg


Suite à ses indices une idée ?

Le problème est au niveau de la permission du répertoire , je ne parle pas des permissions du système de fichier mais des permissions dans Apache qui bloque l'accès au répertoire .
Si nous reprenons la configuration du répertoire **/** , contenu dans le fichier : **/etc/apache2/apache2.conf**

        <Directory />
            Options FollowSymLinks
            AllowOverride None
            Require all denied
        </Directory>

L'ensemble des répertoires non définie son refusé, nous devons donc permettre l'accès au répertoire __common__ afin d'autoriser les accès à ce dernier. Pour ce faire nous allons modifier le fichier **/etc/apache2/conf-available/vhosts\_base.conf** afin de lui définir le nouveau répertoire : 

        <Directory /data/vhosts/common >
            Options None
            AllowOverride None
            Require all granted
        </Directory>

Nous procédons à la validation de la configuration et la recharge de la configuration :

        $ sudo apachectl configtest && sudo /etc/init.d/apache2 reload


C'est repartie [http://linux202-sitea.com/cm-images/post-it.jpg](http://linux202-sitea.com/cm-images/post-it.jpg). Normalement vous devriez voir un __Mario Bross__ en post-it. Si ce n'est pas le cas , valider votre fichier image , et lisez les logs du serveur :).

Pourquoi avoir définie l'alias dans le __VirtualHost__ au lieu du fichier commun ?

J'ai tendance à générer mes fichiers de configuration, surtout pour les configurations similaire que ce soit par scripte ou via des outils de configuration (__puppet__, __ansible__,...) , je ne vois donc pas de problème à définir des instructions supplémentaire. De plus lors de la définition d'un alias ce derniers sur définir les répertoires locaux du **DocumentRoot** , en d'autre mot le __siteA__ ne peux plus utiliser la répertoire. Un petit exemple juste pour bien comprendre .

Créons le répertoire **cm-images** sous le **DocumentRoot** du __siteA__ et un fichier __html__.

        $ sudo mkdir /data/vhosts/siteA/docroot/cm-images
        $ sudo vim /data/vhosts/siteA/docroot/cm-images/toto.html
        $ cat /data/vhosts/siteA/docroot/cm-images/toto.html
        Toto sous cm-images du site A ... 

        AAaaa :P

Si nous accédons au site : [http://linux202-sitea.com/cm-images/toto.html](http://linux202-sitea.com/cm-images/toto.html), nous avons un **404 Not Found**. Si nous regardons dans les logs nous aurons confirmation :

![Alias-404-not-found-siteA.png](./imgs/Alias-404-not-found-siteA.png)

        $ tail /data/vhosts/siteA/logs/access.log
        172.17.42.1 - - [21/Mar/2016:08:46:04 -0400] "GET /cm-images/toto.html HTTP/1.1" 404 516 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"

Pour le plaisir allons créer le fichier toto sous **/data/vhosts/common/images** :

        $ sudo vim /data/vhosts/common/images/toto.html
        $ cat /data/vhosts/common/images/toto.html
        Fichier TOTO sous le common images

Retournons à l'URL : [http://linux202-sitea.com/cm-images/toto.html](http://linux202-sitea.com/cm-images/toto.html)

![Alias-200-toto.png](./imgs/Alias-200-toto.png)

Comme vous pouvez le constater l'alias à priorité sur les répertoires locaux du site web. Pour revenir à la question original pourquoi je ne l'ai pas mis dans la configuration global justement pour avoir une configuration plus granulaire. Permettre l'activation par serveur virtuel. Ceci m'amène aussi à souligner l'importance du choix du nom de l'alias , il est serait  non désirer de mettre en place un alias **images** par exemple , voilà pourquoi j'avais opté pour **cm-images** pour limiter les risques de conflit avec le répertoire local du site.

Il existe aussi [AliasMatch](https://httpd.apache.org/docs/2.4/mod/mod_alias.html#aliasmatch) qui nous permet comme Alias de réaliser une association d'un répertoire à l'extérieur du __DocumentRoot__, l'avantage de **AliasMatch** est de permettre d'y inclure une expression régulière comme critère. 

## <a name="organisation_premission_dir"/> Permissions des répertoires

J'aurais peut-être dû commencé par ça , mais comme les méthodes d'accès au serveur sont très variées je ne l'ai pas privilégié . Lorsque je par d'accès au serveur vous pouvez fournir un accès __ftp__, __scp/ssh__ , __webdav__, partage __NFS__ , ...


TODO : Ajouter l'info ici p-e avec un scp chrooté ça serait cool !!

* Access au répertoire ecriture via Git :P / access au fichier scp , ssh , ...

# <a name="module" /> Utilisation des modules apache

Telle que mentionné lors de l'introduction apache est un logiciel modulaire, nous allons donc voir quelle sont les modules disponible avec l'installation par défaut sous __Ubuntu__ ainsi que quelques explication pour les utiliser.

La structure des fichiers / répertoires sous __Debian__ / __Ubuntu__ bien que contraignante offre au moins l'avantage d'être claire. Nous retrouvons donc la liste des modules disponible dans le répertoire **/etc/apache2/mods-available**.

        $ ls /etc/apache2/mods-available/*.load
        access_compat.load    authz_user.load     ext_filter.load           mpm_worker.load      sed.load
        actions.load          autoindex.load      file_cache.load           negotiation.load     session.load
        alias.load            buffer.load         filter.load               php5.load            session_cookie.load
        allowmethods.load     cache.load          headers.load              proxy.load           session_crypto.load
        asis.load             cache_disk.load     heartbeat.load            proxy_ajp.load       session_dbd.load
        auth_basic.load       cache_socache.load  heartmonitor.load         proxy_balancer.load  setenvif.load
        auth_digest.load      cgi.load            include.load              proxy_connect.load   slotmem_plain.load
        auth_form.load        cgid.load           info.load                 proxy_express.load   slotmem_shm.load
        authn_anon.load       charset_lite.load   lbmethod_bybusyness.load  proxy_fcgi.load      socache_dbm.load
        authn_core.load       data.load           lbmethod_byrequests.load  proxy_fdpass.load    socache_memcache.load
        authn_dbd.load        dav.load            lbmethod_bytraffic.load   proxy_ftp.load       socache_shmcb.load
        authn_dbm.load        dav_fs.load         lbmethod_heartbeat.load   proxy_html.load      speling.load
        authn_file.load       dav_lock.load       ldap.load                 proxy_http.load      ssl.load
        authn_socache.load    dbd.load            log_debug.load            proxy_scgi.load      status.load
        authnz_ldap.load      deflate.load        log_forensic.load         proxy_wstunnel.load  substitute.load
        authz_core.load       dialup.load         lua.load                  ratelimit.load       suexec.load
        authz_dbd.load        dir.load            macro.load                reflector.load       unique_id.load
        authz_dbm.load        dump_io.load        mime.load                 remoteip.load        userdir.load
        authz_groupfile.load  echo.load           mime_magic.load           reqtimeout.load      usertrack.load
        authz_host.load       env.load            mpm_event.load            request.load         vhost_alias.load
        authz_owner.load      expires.load        mpm_prefork.load          rewrite.load         xml2enc.load

Comme nous pouvons le voir la liste est significatif, la liste des modules activé par défaut est moins volumineuse :

        $ ls /etc/apache2/mods-enabled/*.load
        access_compat.load  authn_core.load  authz_host.load  deflate.load  filter.load       negotiation.load  status.load
        alias.load          authn_file.load  authz_user.load  dir.load      mime.load         php5.load
        auth_basic.load     authz_core.load  autoindex.load   env.load      mpm_prefork.load  setenvif.load


Il est bien entendu conseiller de ne pas charger les modules non utilisés, car en plus d'augmenter l'emprunte mémoire d'apache lors de son exécution, ceci augmente les possibilités de faille de sécurité.
Je ne prendrai pas le temps de nommé l'ensemble des modules disponible, je vous laisserai le plaisir de faire les recherches , je vais en sélectionner quelque un . 

* **alias** : Permet de réalisé des alias de répertoire sur le système, nous l'avons vu dans la section [Mutualisation de contenu  / service](#organisation_alias).
* **auth\*** : Module relatif au système d'authentification, la validation utilisateur / mot de passe , peut être réalisé avec un fichier plat (comme nous l'avons vu) ou avec des services externe telle que **ldap**.
* **dir** : Permet de charger un fichier définie d'un répertoire sans être obligé de le nommée. Le cas classique est l'utilisation du fichier index.html qui est chargé automatiquement lorsque l'on va dans un répertoire.
* **php** : Permet de faire l'interprétation des fichiers de type __php__.
* **status** : nous aurons l'occasion de le voir dans la section [Performance et analyse](#performance) , nous permet de visualiser l'utilisation du serveur par __VirtualHost__. Ce module est très intéressant pour comprendre l'utilisation du système.


La nomenclature de __Ubuntu/Debian__ utilise 2 fichiers **.conf** et **.load** ceci est purement une convention , ce n'est pas obligatoire, sous __CentOs/RedHat__ l'ensemble est dans le même fichier.
Je vais prendre comme exemple le module **dir** , simple et permet de bien comprendre le fonctionnement .

* **dir.load** 

                LoadModule dir_module /usr/lib/apache2/modules/mod_dir.so

* **dir.conf** 

                <IfModule mod_dir.c>
                        DirectoryIndex index.html index.cgi index.pl index.php index.xhtml index.htm
                </IfModule>

Comme vous pouvez le constater le fichier __load__ , charge un fichier **.so** contenu dans le répertoire **/usr/lib/apache2/modules/** . Il est possible de rajouter des modules à apache, cependant il est important que le module fut créer pour la bonne version qui est en place !

Le fichier **.conf** , contient la configuration pour le module , comme vous pouvez voir il y a l'instruction **IfModule...**, ceci permet de valider la présence d'un module est de charger la configuration uniquement si le module est présent. Ceci est encore plus pratique quand on a un gros fichier de configuration et que l'on active ou non les modules au début. Car si je prend le cas présent si l'instruction **DirectoryIndex** est définie dans le fichier mais que le module n'est pas présent Apache ne va pas démarrer.

Vous pouvez utiliser **apachectl** afin de connaître les modules actuellement charger par apache. Il est possible de les inclure directement dans le binaire **apache2**, ceci est fait lors de la compilation du programme. 

* **/usr/sbin/apachectl -l** : liste les modules apache compilé dans apache.
* **/usr/sbin/apachectl -M** : liste les modules qui sont chargé au démarrage.

Je vous dirai que l'ensemble 99% du temps les modules offert par le système de pacquage répond au besoin. Sous __Debian / Ubuntu__ vous pouvez avoir la liste des modules apaches disponible avec le système grâce à la commande : **apt-cache search libapache2** Pour les personnes qui désire voir comment compiler un modules amusons nous ... :D


# <a name="http_ssl" /> Mise en place d'un site en httpS

La sécurisation des communication est plus que critique de nos jours, nous désirons que les informations non publique ne soit lisible que par les personnes autorisées. Le protocole **HTTP** est un protocole non sécurisé , l'ensemble des paquets réseaux sont lisible (non chiffré) , si un personne est sur votre réseau et peut intercepté les communications il peut lire l'ensemble du trafic. Le protocole **httpS** règle le problème en chiffrant les communications entre le client (fureteur) et le serveur (apache) , résultat le trafic ne peut pas être lu.

Sous __Ubuntu__ le module **ssl** est inclut lors de l'installation du pacquage **apache2**, sous __RedHat/CentOS__ vous devez installer le module **mod_ssl** spécifiquement. Nous allons prendre quelques minutes pour voir la théorie autour du système de certificat __SSL/TLS__ , car d'expérience j'ai constaté que pour beaucoup le concept de certificat __SSL__ est floue alors que l'ensemble de nos communications sont assurées par ce système. Par la suite nous mettrons en place la configuration dans apache.

## <a name="concept_certificat_ssl" /> Théorie du fonctionnement des certificats 

Nous allons donc voir comment tous ceci fonctionne, je vais essayer d'y allé en détail mais tranquillement ! Je crois qu'il est important de comprendre ce fonctionnement. Comprendre le fonctionnement des certificats permet de mieux diagnostiquer les problèmes comme administrateur mais aussi comme utilisateur.

Ces certificats permettent d'effectuer des opérations cryptographiques, comme le chiffrement et la signature numérique qui offrent les garanties suivantes lors des transactions électroniques :

* **Confidentialité** : elle garantit que seul le destinataire (ou le possesseur) légitime d'un bloc de données ou d'un message peut en avoir une vision intelligible ;
* **authentification** : elle garantit à tout destinataire d'un bloc de données ou d'un message ou à tout système auquel tente de se connecter un utilisateur l'identité de l'expéditeur ou de l'utilisateur en question ;
* **intégrité** : elle garantit qu'un bloc de données ou qu'un message n'a pas été altéré, accidentellement ou intentionnellement ;
* **non-répudiation** : elle garantit à quiconque que l'auteur d'un bloc de données ou d'un message ne peut renier son œuvre, c'est-à-dire prétendre ne pas en être l'auteur.


### <a name="c_quoi_le_certificat" /> C'est quoi un Certificat ?

Lors de la mise en place d'un site web **https** , nous déclarons une pair de clé , le **certificat** et **la clé privé** , ceci suit le principe de [cryptographie asymétrique](https://fr.wikipedia.org/wiki/Cryptographie_asym%C3%A9trique). La cryptographique asymétrique est utilisé dans bien des cas (clé __ssh__ , ...) , le système **HTTPS** s'appuie sur ce principe , nous allons voir les détails.

Le principe du système de chiffrement asymétrique est basé sur une pair de clé : 

* Une clé publique qui est distribué à tous 
* Une clé privé , l'ensemble de la sécurité réside dans cette clé il est primordiale de la conserver dans un lieu sécuritaire. Non lisible par tous

![250px-Public-key-crypto_svg.png](./imgs/250px-Public-key-crypto_svg.png)

**ATTENTION** : lors de la génération des clés leur association est **unique**, en d'autre terme si vous perdez une des deux clé il est **impossible** de régénéré l'une d'elle !!

Le système de pair de clé ( [cryptographie asymétrique](https://fr.wikipedia.org/wiki/Cryptographie_asym%C3%A9trique) ) est en contraste avec le système de chiffrement à une clé ( [cryptographie_symétrique](https://fr.wikipedia.org/wiki/Certificat_%C3%A9lectronique#Rappels_sur_le_chiffrement) ) où l'ensemble des utilisateurs connaisse la clé. 
Voici une représentation des mécanismes de chiffrement : 

* Chiffrement Symétrique :

![Cles_symetriques.png](./imgs/Cles_symetriques.png)

Comme nous pouvons le constater Anne et Bob (aka Robert) ont tous les deux la clé de chiffrement donc peuvent chiffrer et déchiffrer les messages.

* Chiffrement Asymétrique :

![Assymetrie_-_signature_vs_chiffrement.png](./imgs/Assymetrie_-_signature_vs_chiffrement.png)

Dans l'image ci-dessus nous constatons que Anne est la seule à avoir la **clé Privé**, les autres intervenant n'ont en leur possession que la clé publique d'Anne. Deux opération sont réalisées dans le diagramme la première la signature de message , Anne envoie un message signé avec ça clé privé , grâce à la clé publique Bob et Dylan peuvent garantir que le message provient d'Anne. Le déchiffrement de la signature n'est possible qu'avec la pair associé à la clé publique donc la clé privé dont Anne est la seule propriétaire.
L'autre opération est le chiffrement d'information que Bob transmet à Anne , ce dernier chiffre l'information avec la clé publique d'Anne résultat uniquement la clé privé d'Anne est en mesure de déchiffrer le contenu. 

**ATTENTION** : prendre note que lors du chiffrement de message avec la clé privé tous le monde peut déchiffrer avec la clé publique distribué sur le net ! Donc si Anne désire transmettre un message chiffré à Bob, elle doit être avoir la clé publique de ce dernier.

Si nous revenons sur notre sujet, le système de certificat pour le site web , nous retrouvons cette pair de clé :

* Clé publique == Certificat 
* Clé privé == Clé privé installé sur le serveur


La clé n'est qu'une partie du Certificat, ce dernier est composé de plusieurs partie, il existe plusieurs type de certificat pour différent usage ( Certificat de courriel, d'authentification de machine , ... ). Dans le cadre de la configuration d'un serveur web nous utilisons les certificat [X.509](https://fr.wikipedia.org/wiki/X.509). 

Voici le contenu de la structure d'un certificat :

* Version
* Numéro de série
* Algorithme de signature du certificat
* DN (Distinguished Name) du délivreur (autorité de certification)
* Validité (dates limite)
*   Pas avant
*   Pas après
* DN de l'objet du certificat
* Informations sur la clé publique :
*   Algorithme de la clé publique
*   Clé publique proprement dite
* Identifiant unique du signataire (optionnel, X.509v2)
* Identifiant unique du détenteur du certificat (optionnel, X.509v2)
* Extensions (optionnel, à partir de X.509v3)
*   Liste des extensions
* Signature des informations ci-dessus par l'autorité de certification

À ce stade des explications je ne vais pas faire mention du **CA** (l'autorité de certification) gardons notre environnement autonome, mais pas de panique nous allons en parler :D.

Afin d'avoir un peu de concret je vous propose de faire la création d'un certificat **autonome**, donc un certificat (clé publique) et une clé privé.

        $ openssl req -x509 -newkey rsa:2048 -nodes -keyout server.key -out server.crt -days 365
        Generating a 2048 bit RSA private key
        ................+++
        ....................................................................................+++
        writing new private key to 'server.key'
        -----
        You are about to be asked to enter information that will be incorporated
        into your certificate request.
        What you are about to enter is what is called a Distinguished Name or a DN.
        There are quite a few fields but you can leave some blank
        For some fields there will be a default value,
        If you enter '.', the field will be left blank.
        -----
        Country Name (2 letter code) [AU]:CA
        State or Province Name (full name) [Some-State]:Quebec
        Locality Name (eg, city) []:Montreal
        Organization Name (eg, company) [Internet Widgits Pty Ltd]:X3rus
        Organizational Unit Name (eg, section) []:Formation
        Common Name (e.g. server FQDN or YOUR name) []:www.x3rus.com
        Email Address []:

        $ ls
        server.crt  server.key

        $ head -5 server.key server.crt 
        ==> server.key <==
        -----BEGIN PRIVATE KEY-----
        MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDJsYXLGDBE8Zlh
        4++b6bI0zDxonvPvuS/BI9M1wF7G2JPAhXHmBT7TpVfp3ekR7SuFIJVKEOn7xQiV
        4kJwtnLexZDx3MaEJnBVsOcmz8dvyJ2eYif3p2WkGxbcyRRAV+KTXHSZgHdY6LfB
        H08nBasY5nqJ5v27W2O/gC1RavsjAuHIPW7khcP2ksJEdbTsW1ihxp03NkA8xRX/

        ==> server.crt <==
        -----BEGIN CERTIFICATE-----
        MIIDrTCCApWgAwIBAgIJAIM6pAb71wACMA0GCSqGSIb3DQEBCwUAMG0xCzAJBgNV
        BAYTAkNBMQ8wDQYDVQQIDAZRdWViZWMxETAPBgNVBAcMCE1vbnRyZWFsMQ4wDAYD
        VQQKDAVYM3J1czESMBAGA1UECwwJRm9ybWF0aW9uMRYwFAYDVQQDDA13d3cueDNy
        dXMuY29tMB4XDTE2MDQwNTEyNDgyM1oXDTE3MDQwNTEyNDgyM1owbTELMAkGA1UE

Donc un peu d'explication pour bien saisir nous avons utilisé la commande **openssl** pour faire la génération d'un nouveau d'un certificat / clé privé de type **rsa** d'une taille de **2048 bits** le fichier de la clé privé est stocké dans le fichier __server.key__ alors que le certificat est contenu dans le fichier __server.crt__. Telle que mentionné dans la structure du certificat ce dernier doit avoir une date de validité , ici j'indique une validité de 365 jours à partir d'aujourd'hui **-days 365** .

Quand nous visualisons le fichier **server.crt** ce n'est pas très lisible , nous pouvons utilisons la commande **openssl** aussi pour afficher le contenu du certificat :

        $ openssl x509 -in server.crt -text
        Certificate:
            Data:
                Version: 3 (0x2)
                Serial Number:
                    83:3a:a4:06:fb:d7:00:02
            Signature Algorithm: sha256WithRSAEncryption
                 Issuer: C=CA, ST=Quebec, L=Montreal, O=X3rus, OU=Formation, CN=www.x3rus.com
                 Validity
                    Not Before: Apr  5 12:48:23 2016 GMT
                    Not After : Apr  5 12:48:23 2017 GMT
                 Subject: C=CA, ST=Quebec, L=Montreal, O=X3rus, OU=Formation, CN=www.x3rus.com
                 Subject Public Key Info:
                    Public Key Algorithm: rsaEncryption
                        Public-Key: (2048 bit)
                        Modulus:
                            00:c9:b1:85:cb:18:30:44:f1:99:61:e3:ef:9b:e9:
                            b2:34:cc:3c:68:9e:f3:ef:b9:2f:c1:23:d3:35:c0:
                            5e:c6:d8:93:c0:85:71:e6:05:3e:d3:a5:57:e9:dd:
                            e9:11:ed:2b:85:20:95:4a:10:e9:fb:c5:08:95:e2:
                            42:70:b6:72:de:c5:90:f1:dc:c6:84:26:70:55:b0:
           [ ... OUTPUT COUPÉ ... ]
             X509v3 extensions:
                X509v3 Subject Key Identifier:
                    0A:F2:CE:D0:5B:C1:84:F1:8F:AC:3B:73:FC:37:56:54:31:1F:C5:8F
                X509v3 Authority Key Identifier:
                    keyid:0A:F2:CE:D0:5B:C1:84:F1:8F:AC:3B:73:FC:37:56:54:31:1F:C5:8F
                X509v3 Basic Constraints:
                    CA:TRUE
                Signature Algorithm: sha256WithRSAEncryption
                    c5:08:1c:e0:d5:99:a4:44:e2:f0:41:ab:40:38:6b:fa:b9:00:
                    f9:6f:74:be:14:bc:4f:7f:c9:27:88:76:31:00:28:57:be:17:
           [ ... OUTPUT COUPÉ ... ]

Comme vous pouvez le constater à la lecture ci-dessus nous avons l'information sur du site web , nom du domaine , organisation , ... Ceci à la ligne **Subject:**, de plus nous avons la durée de validité du certificat disponible **Validity:**.

Un certificat n'est valide que pour un **FQDN** (__Fully Qualified domain name__) en d'autre mot que pour un nom de domaine complet le certificat ici présent est valide pour le domaine __www.x3rus.com__ mais n'est pas valide pour le domaine __x3rus.com__ . Il est possible de faire l'achat de certificat **wildcard** donc qui couvre l'ensemble des sous domaine d'un domaine (__\*.x3rus.com__) cependant le prix est significativement plus élevé.

Si nous mettons en place ce certificat, votre fureteur vous donnera une erreur lors de l'accès au site web mentionnant que ce dernier est auto signé. Ce qui veut dire que les communications seront chiffré, car il y a une clé publique (certificat) et une clé privé qui est disponible cependant l'authenticité du site web ne peut être validé.

Le système **httpS** offre aussi une garantie d'authenticité du site web avec qui nous communiquons. Pour permettre cette validation nous avons besoin d'un tierce qui va effectué cette validation, c'est à ce moment qu'arrive le **Certificat Authority** (__CA__) . C'est pour ce service que vous avez besoin d'acheter un certificat depuis un fournisseur, c'est uniquement pour que votre site soit certifié comme étant bien celui pour lequel il se présente. 

Vous vous demandez alors, mais alors qu'elle est la différence entre le certificat auto signé (__self Sign__) et celui fournit par un __CA__. Il n'y a qu'un légère différence , le système de clé publique et clé privé ne change pas , car le fournisseur de service ne doit JAMAIS avoir votre clé privé , il va uniquement apposer ça signature sur votre certificat.
Voici une représentation du certificat :

![representation_certificat.png](./imgs/representation_certificat.png)

La première partie correspond à la requête de certificat qui est transmise à l'autorité de certification ( __CA__ ), ceci comprend la clé public en relation avec la clé privé ainsi que l'information sur l'organisation. Ce n'est pas un certificat complet car il ne contient pas de date d'expiration ni d'émetteur (__issuer__). 
Quand l'on transmet la requête de certificat ce dernier ajouter les parties manquante , et signe le tous pour l'authentifier. 

Pour faire la création de la requête vous pouvez utiliser la commande :

        $ openssl req -new -newkey rsa:2048 -nodes -keyout server.key -out server.csr
        Generating a 2048 bit RSA private key
        .......................+++
        ......................................................+++
        writing new private key to 'server.key'
        -----
        You are about to be asked to enter information that will be incorporated
        into your certificate request.
        What you are about to enter is what is called a Distinguished Name or a DN.
        There are quite a few fields but you can leave some blank
        For some fields there will be a default value,
        If you enter '.', the field will be left blank.
        -----
        Country Name (2 letter code) [AU]:CA
        State or Province Name (full name) [Some-State]:Quebec
        Locality Name (eg, city) []:Montreal
        Organization Name (eg, company) [Internet Widgits Pty Ltd]:X3rus
        Organizational Unit Name (eg, section) []:formation
        Common Name (e.g. server FQDN or YOUR name) []:www.x3rus.com
        Email Address []:

        Please enter the following 'extra' attributes
        to be sent with your certificate request
        A challenge password []:
        An optional company name []:


Comme vous pouvez le constater quand nous avons créé un certificat auto signée et pour la requête nous avons fournit les mêmes informations. Une fois la requête crée généralement l'autorité de certification à un formulaire pour transmettre la requête puis vous recevez le certificat complet. La requête de certificat ne contenant pas de date peut être réutilisé lors de chaque renouvellement , CEPENDANT il est important de comprendre que la requête de certificat est aussi la clé publique donc vous devez conserver la même clé privé.


* Référence :

    * https://fr.wikipedia.org/wiki/Certificat_%C3%A9lectronique
    * https://fr.wikipedia.org/wiki/Infrastructure_%C3%A0_cl%C3%A9s_publiques

### <a name="handshake_https" /> Détail de la communication httpS

Maintenant que nous avons une meilleur compréhension du certificat nous allons voir le processus de communications lorsque le fureteur établie la connexion. Ceci nous permettra aussi de comprendre comment le certificat est valider avec l'autorité de certification. 

Une image vaut mille mot , voici donc 2 graphiques représentant la communication du processus de communication __SSL__. 

![SSLHandshake-v1.png](./imgs/SSLHandshake-v1.png)
![SSLHandshake-v2.gif](./imgs/SSLHandshake-v2.gif)


Si nous prenons la première image.

1. **TCP/IP** : Les flèches en bleu représente la connexion __TCP/IP__ la poignée de main ( __3 hand shake__ ) ceci représenté par les paquets (__SYN__, __SYN/ACK__, __ACK__). 

#### <a name="negotiation_des_algo" /> Processsus de négotiation des protocols supporté


1. **Client hello** : Le client transmet au serveur les protocoles __SSL/TLS__ qu'il supporte et désire utiliser pour la communication , de plus il fournit une liste de chiffrement supporté (__cipher suites__) pour la clé symétrique qui sera utilisé par la suite nous y reviendrons. Il y a aussi une numéro de session (session __ID__), ceci est un numéro aléatoire qui sera utilisé pour la génération des clés. Il peut y avoir d'autre information transmis.
2. **Server hello** : Le serveur reçoit la réponse du client et analyse s'il y a un match entre les protocoles __SSL/TLS__ supporté par le client et ceux qu'il supporte et en choisie un. Il réalise la même opération pour les chiffrements supportés (__cipher suites__). Lors de la réponse le serveur transmet sont certificats __SSL__ . Il y a aussi une numéro de session (session __ID__), ceci est un numéro aléatoire qui sera utilisé pour la génération des clés. Il peut y avoir d'autre information transmis.

#### <a name="processus_de_validation" /> Processus de validation du certificat

Lors de la réception du certificat le client valide ce dernier :

1. Validation de la date de validité , est-ce que le certificat est encore valide ? Ceci est réalisé récupérant l'information  : __Validity Not Before__ et __Validity Not After__
2. Par la suite le système valide que le certificat fut bien émis pour le site web indiqué, que l'URL concorde avec l'entrée __CN__ du certificat (__Subject: C=CA, ST=Quebec, L=Montreal, O=X3rus, OU=Formation, CN=www.x3rus.com__)
3. La client valide que le certificat fut signé / validé par une autorité de certificat (__verysign__,__godaddy__, __digicert__, ...) Pour ce faire il utilise les certificats (clé publique) présent sur le système ou dans le fureteur pour déchiffrer la signature réalisé par la clé privé du certificat d'autorité (__CA__). Lors de la description du certificat j'avais fait mention du processus de signature avec un certificat je vous invite a relire [cette section](#c_quoi_le_certificat). Vous pouvez voir dans votre fureteur la liste des certificats des __CA__ disponible :

![firefox_list_certificats.png](./imgs/firefox_list_certificats.png) 

4. Une fois que le certificat fut confirmé comme valide et émis par un fournisseur de certification, le système valide au près de cette autorité si le certificat présent ne fut pas révoqué. Il communique avec la __Certification Revocation List__ **CRL**, cette dernière est disponible comme information dans le certificat du __CA__

![firefox_digicert_crl.png](./imgs/firefox_digicert_crl.png)

Il existe aussi un autre protocole __OCSP__ qui permet d'avoir les certificats révoqué. L'objectif de ce mécanisme est que si pour une raison X votre système est compromis et quelqu'un vous vole la clé privé , vous êtes en mesure d'invalider le certificat pour que personne puisse l'utiliser. Cette opération doit être réalisé au près de votre autorité de certificat.

#### <a name="echange_de_cle_symetric" /> Échange d'une clé symétrique

Telle que mentionné plus tôt le système de clé asymétrique ne permet le chiffrement qu'avec le système de pair de clé, nous avons le certificat __SSL__ du serveur (clé publique) donc le client peut chiffrer les données qui ne seront décrypté que par le serveur. Le "problème" est que par défaut le client n'a PAS de certificat (ce est possible aussi certaine organisation utilise des certificats pour identifier les clients, cependant je conserve la cas classique telle que les communications avec une institue bancaire grand publique). De plus si le client avez un certificat afin d'assurer l'identité de ce dernier nous serions obligé de le renouveler régulièrement au près d'un __CA__.
Autre aspect négatif de l'utilisation d'un système de chiffrement par clé asymétrique telle que les certificats __SSL__ est le coût __CPU__ / mémoire requise pour chiffré et déchiffrer les communications. Ce système est beaucoup plus gourmand  en ressource. 

Donc pour contourner le problème de l'absence de certificat du client et pour améliorer les performances des communications __SSL__ un échange de clé symétrique est réalisé entre le client et le serveur. Le client génère un numéro aléatoire appelé **PRE-master key secret** qui est transmis au serveur. Afin d'assurer la confidentialité de cette clé , cette dernière est chiffré avec le certificat (clé public ) du serveur, ceci assure que uniquement le serveur sera en mesure de le lire.

Ceci est appelé **pre-master key** car le client ET le serveur réalise un calcule algorithmique afin de générer la clé de chiffrement final. Ce calcule génère la clé de chiffrement symétrique qui sera utilisé lors des communications entre le client et le serveur. La clé final n'est donc JAMAIS transmise sur le réseaux. 

Le client et le serveur transmette un message de fin de la négociation , validant ainsi le chiffrement , par la suite l'ensemble des communications sont chiffré avec la clé symétrique.

#### <a name="extra_protocol_ssl_img" /> Représentation graphique détaillé du protocole SSL

Une représentation plus détaillé du protocole __SSL__ avec l'ensemble des clés et de nombre aléatoire généré.

![SSLHandshake-v3-two-way-auth.png](./imgs/SSLHandshake-v3-two-way-auth.png)

## <a name="setup_ssl_website" /> Configuration simple d'un site web avec mod_ssl

Nous allons précéder à la mise en place d'une configuration très simpliste , ceci nous permettra avec l'ensemble des options de couvrir la théorie autour. 

Pour commencer nous allons activer le module **ssl** dans apache :

        $ cd /etc/apache2/mods-enabled
        $ sudo ln -s ../mods-available/ssl.load .
        $ sudo ln -s ../mods-available/socache_shmcb.load .
        $ sudo ln -s ../mods-available/ssl.conf .
        $ cat ssl.load  
        # Depends: setenvif mime socache_shmcb
        LoadModule ssl_module /usr/lib/apache2/modules/mod_ssl.so

Le fichier __ssl.conf__ contient des configurations par défaut, je vous laisse le plaisir de regarder le contenu , nous verrons certaines instruction par la suite.

Nous allons prendre le temps de réaliser la validation de la configuration suite à l'ajout des modules :

        $ sudo apachectl configtest
        Syntax OK

Si vous avez l'erreur suivante : 

        AH00526: Syntax error on line 43 of /etc/apache2/mods-enabled/ssl.conf:
        SSLSessionCache: 'shmcb' session cache not supported (known names: ). Maybe you need to load the appropriate socache module (mod_socache_shmcb?).

Ceci indique que vous n'avez pas créer le liens symbolique pour **socache\_shmcb.load** ce module est requis par **mod\_ssl** si vous lisez le fichier **ssl.load** c'est clairement indiqué :P.


Nous allons maintenant faire la création du site web pour __www.linux202-siteA.com__ aka __siteA__. Mais avant j'aimerai que l'on prenne une seconde pour voir le fichier **ports.conf**

        $ cat /etc/apache2/ports.conf
        Listen 80

        <IfModule ssl_module>
            Listen 443
        </IfModule>

        <IfModule mod_gnutls.c>
            Listen 443
        </IfModule>

Comme vous le savez peut-être et sinon je vais vous le dire , les communications en __http__ sont réalisées sur le port 80 alors que les communications chiffré sont réalisé sur le port 443. Si vous regardez le fichier __ports.conf__ nous pouvons voir que le port 443 sera ouvert si le module **ssl_module** est charger sinon il n'ouvre pas le port .

Ceci étant clarifier , pas de mystère nous pouvons procéder à la mise en place de la configuration pour le __siteA__ en **ssl**.

        $ sudo vim /etc/apache2/sites-available/siteA-ssl.conf
        $ cat /etc/apache2/sites-available/siteA-ssl.conf
        <VirtualHost 172.17.0.1:443>
            ServerAdmin webmaster@localhost
            ServerName www.linux202-siteA.com
            ServerAlias linux202-siteA.com
            ServerAlias toto.linux202-siteA.com
            
            DocumentRoot /data/vhosts/siteA/docroot/
            Alias "/cm-images" "/data/vhosts/common/images"

            <Directory /data/vhosts/siteA/docroot/>
                Options none
                AllowOverride ALL
                Require all granted
            </Directory>
            
            <Directory /data/vhosts/siteA/uploads/>
                Options none
                AllowOverride None
                Require all granted
            </Directory>
            
            # Configuration des logs
            ErrorLog /data/vhosts/siteA/logs/ssl_error.log
            CustomLog /data/vhosts/siteA/logs/ssl_access.log combined
            
            ## SSL section 
            SSLEngine on
            SSLCertificateFile "/etc/apache2/ssl/www_linux202-siteA_com.crt"
            SSLCertificateKeyFile "/etc/apache2/ssl/www_linux202-siteA_com.key"
        </VirtualHost>


Génération du certificat __SSL__ auto-signé , j'ai pas d'argent pour acheter un certificat pour la formation ;-), cependant bien que le certificat ne soit PAS valide le protocole __SSL__ est tous de même respecté. Le client utilisera le certificat pour transmettre les données chiffré au serveur pour la négotiation de la clé symétrique.

        $ cd ~
        $ mkdir ssl && cd ssl
        $ openssl req -x509 -newkey rsa:2048 -nodes -keyout www_linux202-siteA_com.key -out www_linux202-siteA_com.crt -days 365
        Generating a 2048 bit RSA private key
        ..............................................................................................................+++
        .................+++
        writing new private key to 'www_linux202-siteA_com.key'
        -----
        You are about to be asked to enter information that will be incorporated
        into your certificate request.
        What you are about to enter is what is called a Distinguished Name or a DN.
        There are quite a few fields but you can leave some blank
        For some fields there will be a default value,
        If you enter '.', the field will be left blank.
        -----
        Country Name (2 letter code) [AU]:CA
        State or Province Name (full name) [Some-State]:Quebec
        Locality Name (eg, city) []:Montreal
        Organization Name (eg, company) [Internet Widgits Pty Ltd]:X3rus
        Organizational Unit Name (eg, section) []:training
        Common Name (e.g. server FQDN or YOUR name) []: www.linux202-sitea.com
        Email Address []:
        $ sudo mkdir /etc/apache2/ssl
        $ sudo cp * /etc/apache2/ssl


Telle que mentionné plus tôt votre clé privé de chiffrement ET très très importante , car l'ensemble de la sécurité réside sur ce fichier. Il est très important de s'assurer de sécurisé ce dernier.

        $  ls -l /etc/apache2/ssl
        total 8
        -rw-r--r-- 1 root root 1334 Apr 20 08:36 www_linux202-siteA_com.crt
        -rw-r--r-- 1 root root 1704 Apr 20 08:36 www_linux202-siteA_com.key
        $ sudo chmod o-r /etc/apache2/ssl/www_linux202-siteA_com.key


Activation du serveur virtuel, validation de la configuration et redémarrage du service.

        $ cd /etc/apache/sites-enabled
        $ sudo ln -s ../sites-available/siteA-ssl.conf
        $ sudo apachectl configtest && sudo /etc/init.d/apache2 restart
        Syntax OK
         * Restarting web server apache2
         ...done.

Nous pouvons à présent accéder au site web __SSL__ avec notre fureteur: [https://www.linux202-sitea.com](https://www.linux202-sitea.com)

![sitea-ssl_untrusted_certificat.png](./imgs/sitea-ssl_untrusted_certificat.png)

Bien entendu comme nous n'avons pas un certificat signé par une autorité de certificat, nous avons ce message. **ATTENTION** il est important de bien prendre en considération se message et de ne pas accepter le certificat sans revalidé l'URL. Ce message ne devrais jamais s'affiché si vous communiquez avec un site "officiel".

Un fois le certificat accepté , le site nous est présenté :

![sitea-ssl.png](./imgs/sitea-ssl.png)

Lien : 
    * https://fr.wikipedia.org/wiki/Certificat_%C3%A9lectronique
    * https://en.wikipedia.org/wiki/Public_key_infrastructure + EN

* Référence : https://httpd.apache.org/docs/2.4/fr/ssl/ssl_howto.html

