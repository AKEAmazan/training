<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>

TODO : Corriger les \_

# Index 

* [ Introduction](#Intro) 
* [ Installation ](#Installation) 
       * [ Démarrage et test après installation](#start_test) 
* [ Configuration de Base](#basic_conf) 
       * [ Fichier Principale ](#main_file) 
       * [ Fichiers Incluent](#include_files) 
* [ Virtual Host par défaut](#virt_host) 
* [ Paramétrisation du serveur](#param_server) 
       * [ Paramétrisation de la configuration Directory](#param_directory) 
           * [ Changement du répertoire Racine ( DocumentRoot)](#param_docroot) 
           * [ Autorisation d'accès par hostname ou ip ( Require )](#Auth_access) 
           * [Utilisation du Virtual host par défaut (bonne pratique)](#virt_host_good) 
       * [ Autorisation d'accès avec authentification local](#auth_local_access) 
           * [ Création du fichier de mot de passe ( __htpasswd__ )](#htpasswd) 
* [ Référence :](#Reference) 

# <a name="Intro" /> Introduction


Apache est apparu en avril 1995. Au début, il s'agissait d'une collection de correctifs et d'additions au serveur NCSA HTTPd 1.3, qui était dans le domaine public et le serveur HTTP alors le plus répandu. De cette origine, de nombreuses personnes affirment que le nom Apache vient de a patchy server, soit « un serveur rafistolé ». Par la suite, Apache a été complètement réécrit, de sorte que, dans la version 2, il ne reste pas de trace de NCSA HTTPd.

Au début, Apache était la seule alternative sérieuse et libre au serveur HTTP de Netscape (iPlanet, maintenant Sun ONE). Depuis avril 1996, selon l'étude permanente de Netcraft2, Apache est devenu le serveur HTTP le plus répandu sur Internet.

Part de marché d'Apache :

* En mai 1999, il faisait tourner 57 % des serveurs Web, début 2004, il était à environ 69 % de parts de marché, et il ne détient plus que 50,61 % du marché à la fin du mois de janvier 2008 ;
* En février 2008, Apache représente 50,93 % des parts de marché ;
* En novembre 2008, 72,45 % de parts de marché pour Apache ;
* En novembre 2011, 65,00 % de parts de marché pour Apache ;
* En mai 2014, 38,00 % de parts de marché pour Apache et 33,00 % pour Microsoft IIS.
* En janvier 2015 sur l'analyse de 876,812,666 sites, correspondant à 5,061,365 ordinateurs frontaux, les parts de marché sont de 39.74 % pour Apache, et 27,52 % pour IIS. Sur les part de marché des serveurs actifs (en excluant les sites parkings) par contre, 50.72 % pour Apache, 14.82 % pour Nginx et IIS passe en 3e position avec seulement 10.55 %, perdant 1.17 % de parts par rapport au mois précédent.

La popularité de GNU/Linux doit beaucoup au serveur web apache et la monté en puissance de l'Internet. Il est indéniable que les organisation furent à la recherche d'une solution "gratuite" et performance afin de fournir les service Internet. 
Parfois il faut pas grand chose pour que la popularité d'une application ou d'un système voit le jours ...

Nous allons voir la structure du logiciel, Apache fonction avec un système de module permettant d'ajouter des fonctionnalités. La configuration d'Apache ce structure selon une hiérarchie de paramètre définie sous des __context__ , nous permettant de définir des valeurs de manière granulaire.

Bon fini l'intro on va jouer un peu :D.

# <a name="Installation" /> Installation 

S'il y a bien une application testé et valider dans une distribution c'est bien le logiciel Apache ! À ma connaissance toutes les distributions offre le logiciel. Bien entendu l'installation peut être différente , voici comment procéder pour __Ubuntu__ et __Redhat__.

        # Pour Ubuntu 
        $ sudo apt-get install  apache2

        # Pour RedHat
        $ sudo yum install httpd


Si nous regardons la structure des fichiers nous constaterons qu'il diffère voyons pour Ubuntu :

        $  ls -l  /etc/apache2/
        total 80
        -rw-r--r-- 1 root root  7115 Jan  7  2014 apache2.conf
        drwxr-xr-x 2 root root  4096 Nov 25 08:20 conf-available
        drwxr-xr-x 2 root root  4096 Nov 25 08:20 conf-enabled
        -rw-r--r-- 1 root root  1782 Jan  3  2014 envvars
        -rw-r--r-- 1 root root 31063 Jan  3  2014 magic
        drwxr-xr-x 2 root root 12288 Nov 25 08:20 mods-available
        1drwxr-xr-x 2 root root  4096 Nov 25 08:20 mods-enabled
        -rw-r--r-- 1 root root   320 Jan  7  2014 ports.conf
        drwxr-xr-x 2 root root  4096 Nov 25 08:20 sites-available
        drwxr-xr-x 2 root root  4096 Nov 25 08:20 sites-enabled

Et maintenant pour Redhat :

        $ ls -l /etc/httpd/
        total 8
        drwxr-xr-x 2 root root 4096 Nov 20 09:29 conf
        drwxr-xr-x 2 root root 4096 Nov 20 09:29 conf.d
        lrwxrwxrwx 1 root root   19 Nov 20 09:29 logs -> ../../var/log/httpd
        lrwxrwxrwx 1 root root   27 Nov 20 09:29 modules -> ../../usr/lib/httpd/modules
        lrwxrwxrwx 1 root root   19 Nov 20 09:29 run -> ../../var/run/httpd

## <a name="start_test" /> Démarrage et test après installation

Démarrage du service Apache :

        # Pour Ubuntu
        $ sudo service apache2 start
        * Starting web server apache2
          
        # Pour RedHat
        $ sudo service httpd start


Vous pouvez dès a présent valider l'installation en allant a l'URL http://IP-du-serveur ou http://127.0.0.1 si l'installation est réalisé directement sur votre poste. Voici le résultat pour Ubuntu :

![default_page_ubuntu.png](./imgs/default_page_ubuntu.png)

Nous allons maintenant mettre une petite page web pour démontré que nous somme bien en mesure de modifier le contenu. Vous pouvez utiliser votre éditeur préféré pour créer le fichier **/var/www/html/demo.html**

        $ cat /var/www/html/demo.html
        Bonjour Ceci fonctionne bien

Pour valider que tout fonctionne bien vous pouvez aller à l'URL __http://IP-du-serveur/demo.html__ ou __http://127.0.0.1/demo.html__. Déjà à ce stade il est possible d'avoir son site web de disponible en installant l'ensemble de vos fichiers dans ce répertoire.

Nous allons maintenant allé un peu plus loin avec l'analyse de la configuration et mieux comprendre comment tous ceci fonctionne.

# <a name="basic_conf" /> Configuration de Base

L'ensemble de la rédaction du fichier de configuration est équivalant pour les 2 systèmes, l'important est de savoir qu'elle est le premier fichier qui est lu lors du démarrage de d'Apache. Nous verrons à la lecture du fichier de configuration que le premier fichier fait des appel __Include__ pour charger ("loader") les autres fichiers de configuration.

## <a name="main_file" /> Fichier Principale 

Le fichier principale est :

* Redhat : **/etc/httpd/conf/httpd.conf**
* Ubuntu : **/etc/apache2/apache2.conf**

**NOTE / Info** Afin de ne pas surcharger la formation en dupliquant les démonstrations de Ubuntu et Redhat nous nous concentrerons uniquement sur Ubuntu. Cependant l'ensemble est équivalent entre les 2 systèmes, car c'est le même logiciel, éventuellement si vous n'arrivez pas a faire la transposition, contacter moi je vous mettrai sur la piste .

La configuration de Redhat est plus linéaire que celle d'Ubuntu, mais bon nous ne pouvons pas changer de système de référence à chaque fois juste parce que l'un est plus simple que l'autre ;-). Nous avons choisi Ubuntu, nous continuons :D.

Visualisation du fichier Principale , Pour ne pas surcharger la documentation je ne vais pas mettre le fichier au complet ici cependant il est disponible en cliquant sur le lien : /etc/apache2/apache2.conf

À la lecture du fichier nous constatons qu'il y a beaucoup de commentaire définie, comme beaucoup de fichier de configuration sous GNU/Linux le caractère # (dièse) est utilisé. Si nous supprimons l'ensemble des commentaires ainsi que les lignes vide ceci donne :

        $ cat /etc/apache2/apache2.conf | grep -v "^#" | grep -v "^$"
        Mutex file:${APACHE_LOCK_DIR} default
        PidFile ${APACHE_PID_FILE}
        Timeout 300
        KeepAlive On
        MaxKeepAliveRequests 100
        KeepAliveTimeout 5
        User ${APACHE_RUN_USER}
        Group ${APACHE_RUN_GROUP}
        HostnameLookups Off
        ErrorLog ${APACHE_LOG_DIR}/error.log
        LogLevel warn
        IncludeOptional mods-enabled/*.load
        IncludeOptional mods-enabled/*.conf
        Include ports.conf
        <Directory />
                Options FollowSymLinks
                AllowOverride None
                Require all denied
        </Directory>
        <Directory /usr/share>
                AllowOverride None
                Require all granted
        </Directory>
        <Directory /var/www/>
                Options Indexes FollowSymLinks
                AllowOverride None
                Require all granted
        </Directory>
        AccessFileName .htaccess
        <FilesMatch "^\.ht">
                Require all denied
        </FilesMatch>
        LogFormat "%v:%p %h %l %u %t \"%r\" %>s %O \"%{Referer}i\" \"%{User-Agent}i\"" vhost_combined
        LogFormat "%h %l %u %t \"%r\" %>s %O \"%{Referer}i\" \"%{User-Agent}i\"" combined
        LogFormat "%h %l %u %t \"%r\" %>s %O" common
        LogFormat "%{Referer}i -> %U" referer
        LogFormat "%{User-agent}i" agent
        IncludeOptional conf-enabled/*.conf
        IncludeOptional sites-enabled/*.conf

39 Lignes à décortiquer, vu l'ampleur du travail que fait Apache ce n'est pas grand chose :D, soyons positif. Nous allons aussi voir que pris ligne par ligne la configuration est bien simple ... Surtout quand ça fait 15 ans qu'on la consulte :P.

Nous allons aussi nous appuyer sur une documentation solide disponible sur le site d'Apache : 

* Ubuntu 14.04 (apache version 2.4 ) : https://httpd.apache.org/docs/2.4/ 
* Redhat 6 (apache version 2.2)  : https://httpd.apache.org/docs/2.2/.

Nous voyons dans le fichier des variables désigné sous la forme __${Nom\_variable}__ l'ensemble des valeurs sont disponible dans le fichier **/etc/apache2/envvars** dont voici le contenu

        export APACHE_RUN_USER=www-data
        export APACHE_RUN_GROUP=www-data
        export APACHE_PID_FILE=/var/run/apache2/apache2$SUFFIX.pid
        export APACHE_RUN_DIR=/var/run/apache2$SUFFIX
        export APACHE_LOCK_DIR=/var/lock/apache2$SUFFIX
        export APACHE_LOG_DIR=/var/log/apache2$SUFFIX


L'ensemble des valeurs ne seront pas couverte pas que ce n'est pas intéressent, nous pourrons prendre le temps dans le future pour creusé plus en détail. L'objectif pour le moment est d'être en mesure de comprendre et configurer simplement Apache. L'optimisation et l'amélioration de configuration pourra être vu éventuellement dans le future, nous en reparlerons.

* Configuration global
    * [Timeout](https://httpd.apache.org/docs/2.4/fr/mod/core.html#timeout) 300 : Temps en seconde pendant lequel le serveur va attendre  pour l'envoie ou la réception d'instruction au client
    * [KeepAlive](https://httpd.apache.org/docs/2.4/fr/mod/core.html#keepalive) On : Active la possibilité d'utiliser les connexions persistante telle que définie dans le protocole HTTP 1.1
    * User __${APACHE\_RUN\_USER}__ : Définie sous quelle utilisateur le service apache va être exécuté, ceci permet d'éviter que le service soit exécuté comme administrateur du système. L'avantage est que si le service apache est compromis, l'attaquant n'obtient que les droits alloué à l'utilisateur __APACHE\_RUN\_USER__ . Sous Ubuntu l'utilisateur est **www-data**
    * Group __${APACHE\_RUN\_GROUP}__ : Tout comme pour l'utilisateur ici nous définissons le groupe qui exécute l'application sous Ubuntu la valeur est : **www-data**
    * [HostnameLookups](https://httpd.apache.org/docs/2.4/fr/mod/core.html#hostnamelookups) Off  : Lorsque la connexion est établie par un client il est possible de faire le reverse DNS sur l'adresse IP afin d'avoir le nom du client au lieu de l'ip. Généralement cette configuration est à OFF afin de ne pas surcharger le serveur de requête DNS inutile car ceci ralentie le temps de réponse du serveur apache.
    * [ErrorLog](https://httpd.apache.org/docs/2.4/fr/mod/core.html#errorlog) ${APACHE\_LOG\_DIR}/error.log : **Important** définition du fichier de log contenant les erreurs :). Il est fort probable que nous serons amené à le consulter :).
    * [LogLevel](https://httpd.apache.org/docs/2.4/fr/mod/core.html#loglevel) warn : Ceci permet de définir le niveau de sévérité des alertes bien , il est très rare que je change cette valeurs .

* Inclusion
    * [IncludeOptional](https://httpd.apache.org/docs/2.4/fr/mod/core.html#includeoptional) mods-enabled/*.load : Avec l'instruction __IncludeOptional__ il est possible de charger d'autre fichier de configuration afin de segmenté les fichiers pour qu'il soit plus facile a lire ou pour permet l'édition de fichier a certaine personne sans offrir le fichier principal. Dans le cas présent le système charge les modules disponible installé sur le système. (Nous reviendrons plus tard sur les modules)
    * [IncludeOptional](https://httpd.apache.org/docs/2.4/fr/mod/core.html#includeoptional) mods-enabled/*.conf : Même chose que l'instruction précédente mais au lieu de chargé les fichiers des modules, nous chargeons  les configurations des modules. (Nous reviendrons plus tard sur les modules)
    * Include ports.conf : Inclusion du fichier de définition contenant le port d'écoute, nous retrouverons dans ce fichier l'instruction [Listen](https://httpd.apache.org/docs/2.4/fr/mod/mpm_common.html#listen) cette instruction indique sur quelle port écouter pour recevoir les requêtes clients.
    * [IncludeOptional](https://httpd.apache.org/docs/2.4/fr/mod/core.html#includeoptional) conf-enabled/*.conf : Permet de faire l'inclusion des configurations qui doivent être active.
    * [IncludeOptional](https://httpd.apache.org/docs/2.4/fr/mod/core.html#includeoptional) sites-enabled/*.conf : Permet de charger la configuration des sites qui doivent être disponible sur le serveur.

* [Directory](https://httpd.apache.org/docs/2.4/fr/mod/core.html#directory)
L'instruction Directory permet de définir des permissions et configuration qui sont propre au répertoire sur le système de fichier du serveur. Nous verrons qu'il est aussi possible avec l'instruction Location de définir des permissions selon l'URL du site web. La configuration définie pour le répertoire parent sont par défaut hérité au répertoire enfant. Dans la configuration définie ci-dessous l'ensemble des répertoires sous **/var/www** ont les permissions définie par  **Directory /var/www** , pour le répertoire **/home/bob** ou **/tmp/** ils auront les permissions définie par l'instruction **Directory /**.
Nous reviendrons bientôt sur les configurations et permission pour le moment constatons la configuration par défaut.

        <Directory />
                Options FollowSymLinks
                AllowOverride None
                Require all denied
        </Directory>
        <Directory /usr/share>
                AllowOverride None
                Require all granted
        </Directory>
        <Directory /var/www/>
                Options Indexes FollowSymLinks
                AllowOverride None
                Require all granted
        </Directory>

* [LogFormat](https://httpd.apache.org/docs/2.4/fr/mod/mod_log_config.html#logformat)
Définition du format des Log lors de l'accès des clients, ceci permet de collecter plus d'information telle que l'utilisateur (%u) la requête (%r) selon un ordre définie. Ceci est principalement utilisé quand votre système de gestion de statique désire avoir un format particulier. 99% du temps j'utilise __vhost\_combined__ qui répond à mon besoin et à mon logiciel de statistique. Note : avec la version 2.4 il est aussi possible de modifier le [format du message d'erreur](https://httpd.apache.org/docs/2.4/fr/mod/core.html#errorlogformat).

        LogFormat "%v:%p %h %l %u %t \"%r\" %>s %O \"%{Referer}i\" \"%{User-Agent}i\"" vhost_combined
        LogFormat "%h %l %u %t \"%r\" %>s %O \"%{Referer}i\" \"%{User-Agent}i\"" combined
        LogFormat "%h %l %u %t \"%r\" %>s %O" common
        LogFormat "%{Referer}i -> %U" referer
        LogFormat "%{User-agent}i" agent


## <a name="include_files" /> Fichiers Incluent

Debian / Ubuntu structure d'une manière particulière les fichiers d'Apache, on aime ou on n'aime pas je suis pas ici pour me prononcer, mais pour expliquer le concept.

Si nous listons les répertoires présent dans le répertoires nous verrons ceci :


        $ ls -1  /etc/apache2/
        conf-available
        conf-enabled
        mods-available
        mods-enabled
        sites-available
        sites-enabled

Nous pouvons constater 3 groupes :

* conf
    * conf-avaible
    * conf-enabled
* mods
    * mods-avaible
    * mods-enables
* sites
    *  sites-avaible
    *  sites-enabled

Le concept est le suivent l'ensemble des configurations sont disponible dans le répertoire conf-available et pour les activés un lien symbolique est créé dans la répertoire conf-enabled pointant vers le fichier original dans le répertoire conf-available. Cette philosophie s'applique pour les trois groupes **conf**,**mods** et **sites**. 

L'exemple le plus claire est le chargements des modules apaches, regardons la liste des fichiers dans le répertoire des modules disponibles.

        $ ls -l /etc/apache2/mods-available/
        total 516
        -rw-r--r-- 1 root root  100 Jan  7  2014 access_compat.load
        -rw-r--r-- 1 root root  377 Jan  3  2014 actions.conf
        -rw-r--r-- 1 root root   66 Jan  3  2014 actions.load
        -rw-r--r-- 1 root root  843 Jan  3  2014 alias.conf
        -rw-r--r-- 1 root root   62 Jan  3  2014 alias.load
        -rw-r--r-- 1 root root   76 Jan  3  2014 allowmethods.load
        -rw-r--r-- 1 root root   76 Jan  3  2014 asis.load
        [ .... ]
        [ .... ]
        
        # Soit 129 fichier
        $ ls -l /etc/apache2/mods-available/ | wc -l
        129
        
        # A présent les modules activés
        $ ls -l /etc/apache2/mods-enabled/  | head
        total 0
        lrwxrwxrwx 1 root root 36 Nov 25 08:20 access_compat.load -> ../mods-available/access_compat.load
        lrwxrwxrwx 1 root root 28 Nov 25 08:20 alias.conf -> ../mods-available/alias.conf
        lrwxrwxrwx 1 root root 28 Nov 25 08:20 alias.load -> ../mods-available/alias.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 auth_basic.load -> ../mods-available/auth_basic.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 authn_core.load -> ../mods-available/authn_core.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 authn_file.load -> ../mods-available/authn_file.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 authz_core.load -> ../mods-available/authz_core.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 authz_host.load -> ../mods-available/authz_host.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 authz_user.load -> ../mods-available/authz_user.load
        [ .... ]
        [ .... ]
    
        # Il y a donc 28 fichiers de chargé par la configuration apache
        $ ls -l /etc/apache2/mods-enabled/ | wc -l
        28


Conclusion sur 129 fichiers uniquement 28 sont réellement chargé par Apache. Nous ne retrouvons pas ce concept sous Redhat.
Nous mettrons de coté tous ces fichiers de configuration qui sont chargés pour visualiser la configuration du site web par défaut, dans un deuxième temps lors de la configuration de nos site web  nous reviendrons sur l'ajout de fonctionnalité et de modules. Bien entendu libre à vous de jeter un œil aux fichiers et de rechercher la document sur Internet.


# <a name="virt_host" /> Virtual Host par défaut

L'ensemble des sites sont donc chargés en lisant les fichiers contenu dans **/etc/apache2/sites-enabled/**. 
Le système met un fichier par défaut avec le nom **000-default.conf**. Voici le contenu (sans les commentaires):

        <VirtualHost *:80>
    
            ServerAdmin webmaster@localhost
            DocumentRoot /var/www/html
            
            ErrorLog ${APACHE_LOG_DIR}/error.log
            CustomLog ${APACHE_LOG_DIR}/access.log combined
        </VirtualHost>

Nous avons l'instruction :

* [ VirtualHost *:80 ](https://httpd.apache.org/docs/2.4/mod/core.html#virtualhost): Cette instruction indique qu'il peut y avoir plusieurs site web sur le port 80 des Hôtes virtuel ... Heu merci pour la traduction ;-), nous y reviendrons quand nous couvrirons la possibilité d'avoir plusieurs site web . Pour les personnes trop pressé voici le lien avec la section [VirtualHot](#VirtualHost)
* [ServerAdmin](https://httpd.apache.org/docs/2.4/mod/core.html#serveradmin) : URL de l'administrateur qui peut être afficher lors de messages d'erreur 
* [DocumentRoot](https://httpd.apache.org/docs/2.4/mod/core.html#documentroot): Répertoire racine du site web.
* [ErrorLog](https://httpd.apache.org/docs/2.4/mod/core.html#errorlog) : Chemin d'accès ou le fichier d'erreur PROPRE à ce site web sera écrit. On voudra avoir un fichier d'erreur par site web ceci facilite grandement l'identification des problèmes plutôt qu'avoir un gros fichier pour tout le monde. De plus nous serons en mesure de fournir le fichier au développeur pour qu'il analyse les problèmes. 
* [CustomLog](https://httpd.apache.org/docs/2.4/mod/mod_log_config.html#customlog): Fichier contenant les informations d'accès des clients tout comme pour le fichier d'erreur, un fichier d'accès par site. Nous retrouvons l'argument **combined** qui est un des format de log précédemment définie avec l'instruction **Logformat**

Et voilà :) , c'est ceci qui nous a permit de mettre notre fichier **demo.html** et de visualiser le contenu.


# <a name="param_server" /> Paramétrisation du serveur

Maintenant que nous avons vu l'idée générale de la configuration c'est le temps de commencé à y mettre un peu d'ordre ou de désordre :).

## <a name="param_directory" /> Paramétrisation de la configuration Directory

### <a name="param_docroot" /> Changement du répertoire Racine ( DocumentRoot)

Pour le plaisir nous allons fonctionné par un exemple claire, car bien souvent une démonstration aide à la compréhension. Changeons de place le site web de __/var/www/html/__ vers  __/data/www/__, peut importe la raison (espace disque dur, réorganisation du système , ...).

        # Création du répertoire et copie des fichiers
        $ sudo mkdir -p /data/www
        $ sudo cp /var/www/html/*.html  /data/www/

Les fichiers sont donc maintenant dans le nouveau répertoire il reste à modifier la configuration du serveur Web. Nous allons donc modifier la configuration du [DocumentRoot](https://httpd.apache.org/docs/2.4/mod/core.html#documentroot). 
Éditons le fichier **/etc/apache2/sites-available/000-default.conf**

        # Changement de 
        DocumentRoot /var/www/html
    
        # Pour la nouvelle valeur
        DocumentRoot /data/www

Validons la configuration syntaxique du serveur, c'est toujours une bonne pratique de réaliser cette opération après vos modifications ceci permet de corriger des problèmes avant même de recharger la configuration.

        $  sudo apache2ctl configtest
        Syntax OK

Rechargez la configuration :

        $ sudo service apache2 reload
        * Reloading web server apache2

Voici le résultat quand nous accédons à la page principale :  http://127.0.0.1 ou http://127.0.0.1/demo.html

![rep_demo-page_403.png](./imgs/rep_demo-page_403.png)

Nous avons donc une erreur **403** qui est un refus d'accès au serveur. Ceci correspond à un refus d'accès vous pouvez avoir la liste des codes des états sur Wikipédia :  [Code 4xx Erreur Client](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#4xx_Client_Error) 

Le mieux pour comprendre l'erreur reste toujours les logs visualisons donc ce que nous avons dans les fichiers. Pour nous rafraîchir la mémoire nous allons valider la définition des fichiers de logs:

        $ grep "log" /etc/apache2/sites-enabled/000-default.conf | grep -v "#"
        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined
    
        # Et pour la valeur de ${APACHE_LOG_DIR}
        $ grep "APACHE_LOG_DIR" /etc/apache2/envvars 
        export APACHE_LOG_DIR=/var/log/apache2

* Fichier d'accès **/var/log/apache2/access.log**:

        $ sudo tail -f /var/log/apache2/access.log
        172.17.42.1 - - [27/Nov/2015:08:20:52 -0500] "GET / HTTP/1.1" 403 494 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"
        172.17.42.1 - - [27/Nov/2015:08:21:27 -0500] "GET /demo.html HTTP/1.1" 403 503 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"

* Fichier d'erreur **/var/log/apache2/error.log**

        $ sudo tail -f /var/log/apache2/error.log
        [Fri Nov 27 08:20:52.199792 2015] [authz_core:error] [pid 133:tid 3046103872] [client 172.17.42.1:58878] AH01630: client denied by server configuration: /data/www/
        [Fri Nov 27 08:21:27.097668 2015] [authz_core:error] [pid 132:tid 3029318464] [client 172.17.42.1:58882] AH01630: client denied by server configuration: /data/www/demo.html


Le message du serveur est explicite la configuration du serveur refuse d'offrir l'accès au fichier **/data/www/**. COOL !! Le problème est claire et identifier , il ne reste que LA solution :).

L'autorisation des accès à l'arborescence du système est définie par les configurations [Directory](https://httpd.apache.org/docs/2.4/fr/mod/core.html#directory) ,nous avons cette définition dans le fichier **/etc/apache2/apache2.conf** 

        <Directory />
                Options FollowSymLinks
                AllowOverride None
                Require all denied
        </Directory>
        <Directory /usr/share>
                AllowOverride None
                Require all granted
        </Directory>
        <Directory /var/www/>
                Options Indexes FollowSymLinks
                AllowOverride None
                Require all granted
        </Directory>

Les valeurs de configuration hérité selon l'arborescence ce qui veut dire que **TOUS** les répertoires du file système à l'exception de **/usr/share** et **/var/www** (incluant leur sous répertoire) ont la configuration suivante :

         <Directory />
                Options FollowSymLinks
                AllowOverride None
                Require all denied
        </Directory>

Nous sommes donc actuellement bloqué par l'instruction : [Require](https://httpd.apache.org/docs/2.4/mod/mod_authz_core.html#require). Sous Ubuntu l'ensemble des accès au système de fichier est refusé depuis la racine (root / ) en dehors des deux répertoires nommés plus tôt.

Vous me demanderez probablement mais pourquoi /usr/share pour permettre l'accès à la documentation, des icônes ou fichier d'erreur page personnalisé pour les erreurs 404 (not found) depuis l'interface web des icônes.

Nous allons confirmer mes propos , en ajoutant les lignes suivante sous l'instruction __<Directory />__ , dans le fichier **/etc/apache2/apache2.conf** voici le résultat:

        <Directory />
            Options FollowSymLinks
            AllowOverride None
            Require all denied
        </Directory>

        <Directory /data/www >
            Options FollowSymLinks
            AllowOverride None
            Require all granted
        </Directory>

        <Directory /usr/share>
        [ .... ]


Validons la configuration avant de recharger la configuration :

        $ sudo apachectl configtest
        Syntax OK

        $ sudo service apache2 reload 
        * Reloading web server apache2
        *

Allons à l'URL : [http://127.0.0.1/demo.html](http://127.0.0.1/demo.html) 

Cette notion d'héritage des permissions est très important afin de comprendre l'impacte de permission trop permissive au niveau supérieur de la hiérarchie du système de fichier. 

### <a name="Auth_access" /> Autorisation d'accès par hostname ou ip ( Require )

Profitons de l'occasion pour limiter l'accès à un répertoire pour uniquement un segment réseau , car pour la démonstration ci-dessus nous avons simplement ouvert à TOUS l'accès si nous avions un répertoire __admin__ ou __private__ disponible pour le réseau interne mais qui ne devrais pas être disponible sur l'Internet publique.
L'instruction [require](https://httpd.apache.org/docs/2.4/mod/mod_authz_core.html#require) nous permet de faire cette limitation . Nous verrons aussi qu'il est possible de mettre un système d'authentification avec nom d'utilisateur et mot de passe.

Nous allons permettre l'accès uniquement au réseau 192.168.100.0/24 (donc toutes les adresses ip qui commence par 192.168.100) et l'ip 192.168.42.42 (juste pour voir la possibilité de mettre plusieurs valeur :) ). Voici le résultat :

        <Directory /data/www >
            Options FollowSymLinks
            AllowOverride None
            Require all granted
       </Directory>

       <Directory /data/www/admin >
            Options FollowSymLinks
            AllowOverride None
            Require  ip 192.168.100 192.168.42.42
       </Directory>

Validation de la configuration (oui ! Je suis chiant un peu avec ça mais honnêtement ça l'aide BEAUCOUP ) :

        $ sudo apachectl configtest
        Syntax OK

Validation du résultat :

![rep_admin_404.png](./imgs/rep_admin_404.png)
 
Dans mon cas j'aurais dû avoir une erreur d'accès car l'ip de ma machine ne correspond pas à celle autorisé, cependant j'ai une erreur 404 (page non trouvée). Ceci est compréhensible car nous n'avons pas fait la création du répertoire **/data/www/admin** . Ceci veut donc dire que Apache valide l'existence du répertoire avant de valider les permissions d'accès , ceci est un détail cependant je désirai le partagé , je croyais que c'était le contraire :D.

Nous allons donc faire la création du répertoire et mettre un petit fichier **index.html** :

        $ sudo mkdir /data/www/admin 
        $ sudo vim /data/www/admin/index.html
        $ cat /data/www/admin/index.html
        section prive

Voilà le bon message d'erreur :) : 

![rep_admin_403.png](./imgs/rep_admin_403.png)


### <a name="virt_host_good" />Utilisation du Virtual host par défaut (bonne pratique)

Nous avons modifié la configuration du fichier **/etc/apache2/apache2.conf**, à moins que les configurations sont vraiment général pour l'ensemble du serveur je vous conseil de définir vos configurations dans le virtual host approprié. Ceci est pour la simple et bonne raison qu'il est plus facile de migré la configuration d'un site quand on a l'ensemble de ça définition dans un fichier plutôt qu'avoir des configurations éparpillé. 
Plusieurs avantage :

* Visualisation de l'ensemble de la configuration à un point
* Plus facile de migré la site sur un autre serveur , car uniquement un fichier a transférer
* La configuration du site peut être délégué a une autre personne en lui permettant d'éditer qu'un fichier
* Permet d'activer ou désactivé l'ensemble des configurations facilement au lieu d'avoir des configurations qui traine quand un site n'est plus en activité.
* Je pourrais en trouver probablement d'autre mais vous avez compris le concept.

Pour le moment nous n'avons qu'un site je vais donc procéder à la migration de la configuration des répertoires **/data/www** et **/data/www/admin** dans le fichier **/etc/apache2/sites-available/000-default.conf**.

Je vais donc supprimé le ligne du fichier **/etc/apache2/apache2.conf**

        -<Directory /data/www >
        -       Options FollowSymLinks
        -       AllowOverride None
        -       Require all granted 
        -</Directory>
        -
        -<Directory /data/www/admin >
        -        Options FollowSymLinks
        -        AllowOverride None
        -        Require  ip 192.168.100 192.168.42.42
        -</Directory>

Et les rajouter dans le fichier **/etc/apache2/sites-available/000-default.conf** , Personnellement je le met toujours après le [DocumentRoot](https://httpd.apache.org/docs/2.4/mod/core.html#documentroot), mais c'est juste une habitude.

Validation et relecture de la configuration :) :

        $ sudo apache2ctl configtest && sudo service apache2 reload 
        Syntax OK
        * Reloading web server apache2
        * 

Donc à partir de maintenant nous manipulerons principalement les fichiers de vhost à moins que nous appliquions une modification global au système telle que l'ajout de module.


## <a name="context" /> Organisation de la configuration (context)

Voyons les niveaux ou contexte d'organisation des configurations d'apache avant l'aller plus loin. Je vais utiliser la configuration du répertoire **/data/www** et **/data/www/admin** pour faire la démonstration. 
Cette section est très importante, car elle permet de comprendre le système de configuration dans les détails, de nos jours mettre en place un service est assez simple, un copie/collé d'une configuration trouvé sur l'Internet suffit 90% du temps. Le défis survient lors des problèmes et / ou l'intégration de services, à ce moment il est important de comprendre le système.!

Il existe 4 niveaux ou contexte :

* **configuration du serveur** : Ensemble de configuration contenu dans les fichiers de configuration du serveur apache , telle que le fichier __httpd.conf__, cependant ceci ne comprend pas les instructions  à l'intérieur des balises __<VirtualHost>__ ou __<Directory>__. De même, elle n'est pas valide dans les fichiers __.htaccess__.
* **serveur virtuel** : Ensemble des instructions comprise dans les balises __<VirtualHost>__.
* **répertoire** : Ensemble des instructions contenues dans les balises __<Directory>__, __<Location>__, __<Files>__, __<If>__, et __<Proxy>__ .
* **.htaccess** : Ensemble des instructions contenues dans un fichier __.htaccess__.


Reprenons notre modification du répertoire __/data/www__, comme base de référence et ainsi visualiser les contextes que nous avons modifier.

1. Nous avons modifier la directive [DocumentRoot](https://httpd.apache.org/docs/2.4/mod/core.html#documentroot), pour rappel ceci nous a permis de modifier la racine du site web. Si nous regardons documentation disponible pour cette instruction, voici la copie  d'écran :

    ![DocumentRoot-screenshot-documentation.png](./imgs/DocumentRoot-screenshot-documentation.png)

    Comme vous pouvez le constater l'instruction **DocumentRoot** peut être utilisé dans 2 contexte **Server config**  et **Virtual host**. Dans notre configuration nous avons uniquement une définition du __DocumentRoot__ dans le __VirtualHost__  : **sites-available/000-default.conf** 

2. Définition des permissions d'accès pour le répertoire __/data/www__ grâce à l'instruction [Directory](https://httpd.apache.org/docs/2.4/fr/mod/core.html#directory). Cette configuration est encore plus intéressante, car nous avons définie les permissions de ce répertoire dans 2 contexte. Commençons par visualiser la documentation

    ![Directory-screenshot-documentation.png](./imgs/Directory-screenshot-documentation.png)

    Comme vous pouvez le constater nous pouvons utiliser la directive __Directory__ dans le contexte **Server config** ET **Virtual Host**. Si nous nous rappelons l'opération de configuration nous avons définie notre configuration dans les 2 contexte.  Dans contexte **Server config** lors que la configuration été présente dans le fichier __/etc/apache2/apache2.conf__ et dans la configuration du **Virtual Host** lorsque nous avons rapatrié la configuration dans le __Host__ Virtuel.

3. Définition de l'instruction [Require](https://httpd.apache.org/docs/2.4/mod/mod_authz_core.html#require) qui nous à permis de limité l'accès au répertoire __admin__ grâce à l'__IP__ de provenance . Nous avons mis la configuration dans le contexte du répertoire __<Directory /data/www/admin >__ étions nous obligé de le faire ?!?! Que dit la documentation :

    ![Require-screenshot-documentation.png](./imgs/Require-screenshot-documentation.png)

    Encore une fois nous avions 2 possibilités où disposer l'instruction dans contexte __Directory__ ou dans le contexte __.htaccess__ . À la lecture de cette information ceci veut donc dire que je ne peux pas définir un limitation par __IP__ pour l'ensemble d'un __Virtual Host__ ce doit être obligatoirement par répertoire, donc pour limite l'accès à l'ensemble je dois bloqué à dans la répertoire **racine**. 

    Mais que ce passe t il si je ne suis pas les directives de positionnement de la configuration ? Voici un exemple de configuration erroné , j'ai définie l'instruction suivante directement dans le __VirtualHost__:

        $ cat /etc/apache2/sites-available/000-default.conf | grep -C 2 Require
           DocumentRoot /data/www

           Require  ip 192.168.100 192.168.42.42

           <Directory /data/www/>
              Options Indexes FollowSymLinks

        $ sudo apachectl configtest
        AH00526: Syntax error on line 14 of /etc/apache2/sites-enabled/000-default.conf:
        Require not allowed here
        Action 'configtest' failed.
        The Apache error log may have more information.

    Ceci est clairement un avantage d'avoir un message aussi claire ayant utilisé la commande , **apachectl configtest** j'ai eu l'information du problème SANS aucune interruption du service.


Nous avons vu 3 des 4 contexte décrit plus tôt , celui qui manque est le contexte **.htaccess**, donc afin de couvrir cette possibilité nous allons reprendre notre configuration et voir quelle instructions peut être déplacé dans le contexte **.htaccess**. Pour les personnes qui s'inquiète de la couverture légère réalisé jusqu'à présent du contexte __VirtualHost__ ne vous inquiétez pas nous couvrirons le sujets de manière approprié sous peu.

Si nous regardons la seule instruction que nous pouvons utiliser dans le contexte __.htaccess__ est **Require**, nous allons donc procéder à la migration de l'instruction.

* Référence 
    * [http://httpd.apache.org/docs/current/fr/mod/directive-dict.html#Context](http://httpd.apache.org/docs/current/fr/mod/directive-dict.html#Context)
    * [http://httpd.apache.org/docs/current/fr/sections.html](http://httpd.apache.org/docs/current/fr/sections.html)

## <a name="context_htaccess" /> Surdéfinition de la configuration dans le fichier .htaccess

L'objectif du fichier __.htaccess__ est de fournir la possibilité de modifier la configuration du serveur au niveau du répertoire. Le principal avantage de cette fonctionnalité est de pouvoir délégué la gestion d'un partie de la configuration au développeur, il est cependant conseillé de limité les champs d'action de cette fonctionnalité , surtout en production car ceci comprend aussi des risques de sécurité potentiel (nous y reviendrons).

Le nom du fichier __.htaccess__est une convention ceci est définie par l'instruction [AccessFileName](https://httpd.apache.org/docs/current/fr/mod/core.html#accessfilename) 

![Accessfilename-screenshot-documentation.png](./imgs/Accessfilename-screenshot-documentation.png)

Comme nous pouvons le voir sur la copie d'écran de la configuration cette instruction peut être définie dans la configuration du serveur OU dans la configuration du __Virtual Host__.
Je vous conseille de ne pas changer le nom du fichier, afin de faciliter la lecture par l'ensemble des intervenants sur votre système. Personnellement s'il y a un problème sur le site , je vais regarder, s'il y a surcharge (redéfinition) de la configuration avec un fichier __.htaccess__, mais si l'on change le nom du fichier il est peu probable que le considère.

Procédons avec la migration de la configuration afin de valider le comportement, la configuration actuelle du __VirtualHost__ ressemble à ceci :

                <VirtualHost *:80>

                        ServerAdmin webmaster@localhost
                        DocumentRoot /data/www

                        <Directory /data/www/>
                                Options Indexes FollowSymLinks
                                AllowOverride None
                                Require all granted
                        </Directory>

                        <Directory /data/www/admin >
                                Options FollowSymLinks
                                AllowOverride None
                                Require ip 192.168.100 192.168.42.42
                        </Directory>

                        ErrorLog ${APACHE_LOG_DIR}/error.log
                        CustomLog ${APACHE_LOG_DIR}/access.log combined

                </VirtualHost>

Nous allons migré la directive **Require ip 192.168.100 192.168.42.42** dans le fichier __.htaccess__. 

1. Je supprime la ligne définie dans la configuration du répertoire **<Directory /data/www/admin >**
2. Je crée le fichier __/data/www/admin/.htaccess__ avec le contenu suivant 

        $ sudo vim /data/www/admin/.htaccess
        Require ip 192.168.100 192.168.42.42
        $ sudo apachectl configtest && sudo /etc/init.d/apache2 reload

3. J'ai du recharger la configuration d'apache afin que le fichier du __VirtualHost__ soit relue suite à la suppression de la définition **Require** 

Validons le comportement , si je vais sur la page __http://Ip\_du\_server/admin/__ . Mon adresse __ip__ de provenance étant 172.17.42.1 l'accès à la section privé étant autorisé uniquement depuis 192.168.100.0/24 ET 192.168.42.42 , je vais avoir le message d'erreur m'indiquant que l'accès est refusé comme précédemment.

![rep_admin_pas_erreur.png](./imgs/rep_admin_pas_erreur.png)

**Oupsss** la section privé est accessible , mais mais mais ... 

![dont_panic.jpg](./imgs/dont_panic.jpg)

Procédons par validation :

1. Re-validation de la configuration du serveur

        $ sudo apachectl configtest                                    
        Syntax OK

2. Validation des logs 

        $ sudo tail /var/log/apache2/access.log /var/log/apache2/error.log
        ==> /var/log/apache2/access.log <==
        [...  OUTPUT COUPÉ ...]
        172.17.42.1 - - [17/Feb/2016:16:58:05 -0500] "GET /admin/ HTTP/1.1" 200 295 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"

        ==> /var/log/apache2/error.log <==
        [...  OUTPUT COUPÉ ...]
        [Wed Feb 17 16:45:39.294669 2016] [mpm_event:notice] [pid 53:tid 3075459712] AH00489: Apache/2.4.7 (Ubuntu) configured -- resuming normal operations
        [Wed Feb 17 16:45:39.295596 2016] [core:notice] [pid 53:tid 3075459712] AH00094: Command line: '/usr/sbin/apache2'

Aucun message d'erreur donc il y a un **bug** dans le logiciel apache, ou il y a une configuration qui n'est pas compatible avec notre configuration . Nous allons voir la définition du répertoire **admin**

Regardons la définition du répertoire contenu dans le __Virtual Host__ : **/etc/apache2/sites-available/000-default.conf**

        <Directory /data/www/admin >
            Options FollowSymLinks
            AllowOverride None
        </Directory>

Heureusement la définition est courte nous pouvons voir "rapidement" l'erreur , l'instruction **AllowOverride** est définie à **None**, ceci indique que le système apache ne regarde PAS s'il y a un fichier __.htaccess__ dans le répertoire. 
Nous allons corriger la configuration et passer au explication par la suite, nous allons changer **None** par **AuthConfig** . Voyons le résultat :

1. Fichier **/etc/apache2/sites-available/000-default.conf** :
        
            <Directory /data/www/admin >
                Options FollowSymLinks
                AllowOverride AuthConfig
            </Directory>

2. Recharge de la configuration 

            $ sudo apachectl configtest && sudo /etc/init.d/apache2 reload

C'est le temps de valider si maintenant c'est OK !!

![rep_admin_403.png](./imgs/rep_admin_403.png)

**Woot** , l'accès est bloqué, nous pouvons aussi le constater dans les logs 

        $ sudo tail /var/log/apache2/access.log /var/log/apache2/error.log
        ==> /var/log/apache2/access.log <==
        [ ... OUTPUT COUPÉ ... ]
        172.17.42.1 - - [17/Feb/2016:17:14:05 -0500] "GET /admin/ HTTP/1.1" 403 499 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"
        ==> /var/log/apache2/error.log <==
        [ ... OUTPUT COUPÉ ... ]
        [Wed Feb 17 17:13:49.432389 2016] [core:notice] [pid 173:tid 3075066496] AH00094: Command line: '/usr/sbin/apache2'
        [Wed Feb 17 17:14:05.152280 2016] [authz_core:error] [pid 176:tid 2979945280] [client 172.17.42.1:60578] AH01630: client denied by server configuration: /data/www/admin/

Voyons un peu ce que permet l'instruction [AllowOverride](http://httpd.apache.org/docs/2.4/fr/mod/core.html#allowoverride).

### <a name="htaccess_allowoverride" /> Permission de redéfinition des configurations

L'instruction [AllowOverride](http://httpd.apache.org/docs/2.4/fr/mod/core.html#allowoverride), permet d'indiquer au serveur Apache de lire dans le répertoire le fichier __.htaccess__ ( ou fichier autre selon la définition de la variable [AccessFilename](http://httpd.apache.org/docs/2.4/fr/mod/core.html#accessfilename).

![AllowOverride-screenshot-documentation.png](./imgs/AllowOverride-screenshot-documentation.png)

Les valeurs possibles à l'instruction sont :

* **ALL** ( Tous ) : Avec cette configurations Apache regarde le répertoire et l'ensemble des sous répertoire s'il y a un fichier __.htaccess__ . Si un fichier est trouvé, ce dernier est lu et toutes instructions qui peut être définie dans le contexte __.htaccess__ seront interprétés. Résultat la configuration active sera cette définie dans le fichier __.htaccess__.

* **None** ( Rien ) : Avec cette configuration Apache ne regarde même pas s'il y a un fichier __.htaccess__ dans le répertoire

* **AuthConfig** : Permet l'utilisation des directives d'autorisation (__AuthDBMGroupFilex__, __AuthDBMUserFile__, __AuthGroupFile__, __AuthName__, __AuthType__, __AuthUserFile__, __Require__, etc...).

* **FileInfo** : Permet l'utilisation des directives qui contrôlent les types de documents (directives __ErrorDocument__, __ForceType__, __LanguagePriority__, __SetHandler__, __SetInputFilter__, __SetOutputFilter__, et directives du module __mod\_mime__ __Add__\* et __Remove__\*), des métadonnées des documents (__Header__, __RequestHeader__, __SetEnvIf__, __SetEnvIfNoCase__, __BrowserMatch__, __CookieExpires__, __CookieDomain__, __CookieStyle__, __CookieTracking__, __CookieName__), des directives du module __mod\_rewrite__ directives (__RewriteEngine__, __RewriteOptions__, __RewriteBase__, __RewriteCond__, __RewriteRule__), des directives du module __mod\_alias__ directives (__Redirect__, __RedirectTemp__, __RedirectPermanent__, __RedirectMatch__), et de la directive Action du module __mod\_actions__. 

* **Indexes** : Permet l'utilisation des directives qui contrôlent l'indexation des répertoires (__AddDescription__, __AddIcon__, __AddIconByEncoding__, __AddIconByType__, __DefaultIcon__, __DirectoryIndex__, __FancyIndexing__, __HeaderName__, __IndexIgnore__, __IndexOptions__, __ReadmeName__, etc...)

* **Limit** : Permet l'utilisation des directives contrôlant l'accès au serveur (__Allow__, __Deny__ et __Order__).

* **Nonfatal=[Override|Unknown|All]** : Permet d'utiliser l'option __AllowOverride__ pour rendre les erreurs de syntaxe non fatales dans les fichiers __.htaccess__ : au lieu de causer une __Internal Server Error__, les directives non autorisées ou non reconnues seront ignorées et un avertissement enregistré dans le journal :
    * __Nonfatal=Override__ rend les directives interdite par __AllowOverride__ non fatales.
    * __Nonfatal=Unknown__ rend les directives inconnues non fatales. Sont concernées les erreurs de frappe et les directives implémentées par un module non chargé.
    * __Nonfatal=All__ rend toutes les directives précédentes non fatales.
    * **Notez qu'une erreur de syntaxe dans une directive valide causera toujours une internal server error.**

* **Options[=Option,...]** : Permet l'utilisation des directives contrôlant les fonctionnalités spécifiques d'un répertoire (__Options__ et __XBitHack__). "Options" doit être suivi d'un signe "égal", puis d'une liste d'options séparées par des virgules (pas d'espaces) ; ces options doivent être définies à l'aide de la commande [Options](http://httpd.apache.org/docs/2.4/fr/mod/core.html#options). 


Si nous reprenons notre exemple de limitation d'accès par adresse IP, nous avons définie dans le fichier __.htaccess__ l'instruction  [Require](https://httpd.apache.org/docs/2.4/mod/mod_authz_core.html#require). Afin que le fichier de sur définition des configuration soit interprété nous avons changer la valeur de l'instruction **AllowOverride** de __None__ (Rien) à __AuthConfig__ . Nous aurions aussi pu définit l'instruction à __ALL__ (Tous) dans cette situation nous serions en mesure de mettre non seulement des instructions de limitation d'authentification mais aussi des configurations général du système. Un peu plus tard je réaliserai une démonstration du risque de cette possibilité. 

Dans le cadre de la configuration __AuthConfig__ l'option disponible est relativement spécifique et regroupe peu d'instruction , cependant si nous regardons l'instruction __FileInfo__ le nombre de commande est plus significatif. 
Si nous désirons offrir l'option au développeur d'avoir la main sur la configuration pour redéfinir par exemple les documents d'erreur, pour que le message d'erreur soit personnalisé avec une belle image et un jolie texte. Pour réaliser cette opération le développeur voudra modifier l'instruction  [ErrorDocument](https://httpd.apache.org/docs/2.4/fr/mod/core.html#errordocument), et nous devrons permettre la surdéfinition dans __AllowOverride__ avec l'instruction **FileInfo**. Le développeur aura donc beaucoup plus d'instruction disponible que __ErrorDocument__. 

Depuis la version **2.4** d'apache il est possible d'être plus spécifique sur les instructions utilisable dans le fichier __.htaccess__. Il fut introduit la directive [AllowOverrideList](http://httpd.apache.org/docs/2.4/fr/mod/core.html#allowoverridelist), elle permet de lister uniquement les instructions disponible dans le fichier __.htaccess__ . Si nous reprenons notre besoin de pouvoir surdéfinir l'option [ErrorDocument](https://httpd.apache.org/docs/2.4/fr/mod/core.html#errordocument), mais que nous désirons UNIQUEMENT cette instruction nous pourrions la définir comme suit :

        AllowOverride None
        AllowOverrideList ErrorDocument

Dans cette exemple , aucune configuration peut être redéfinit dans le fichier __.htaccess__, à l'exception de la directive __ErrorDocument__ .

**Prendre note que AllowOverride ET AllowOverrideList sont combinatoire**.
En d'autre mot si j'ai l'instruction suivante : 

        AllowOverride AuthConfig
        AllowOverrideList ErrorDocument
 
Je serai en mesure d'utiliser les instructions : __ErrorDocument__ + __AuthDBMGroupFilex__, __AuthDBMUserFile__, __AuthGroupFile__, __AuthName__, __AuthType__, __AuthUserFile__, __Require__, etc...

## <a name="utilisation_de_htaccess" /> Bonne pratique de l'utilisation du fichier .htaccess

En principe, vous ne devriez utiliser les fichiers __.htaccess__ que lorsque vous n'avez pas accès au fichier de configuration du serveur principal. Par exemple, la fausse idée selon laquelle l'authentification de l'utilisateur devrait toujours être faite dans les fichiers __.htaccess__ est très répandue. Il est aussi souvent avancé, ces dernières années, que les directives de mod\_rewrite doivent être définies dans les fichiers __.htaccess__. Ceci est tout simplement faux. Vous pouvez configurer l'authentification des utilisateurs au niveau de la configuration du serveur principal, et c'est en fait cette méthode qui doit être privilégiée. De même, les directives de mod\_rewrite fonctionneront mieux, à de nombreux égards, dans le contexte du serveur principal.

Les fichiers __.htaccess__ ne devraient être utilisés que dans le cas où les fournisseurs de contenu ont besoin de modifier la configuration du serveur au niveau d'un répertoire, mais ne possèdent pas l'accès __root__ sur le système du serveur. Si l'administrateur du serveur ne souhaite pas effectuer des modifications de configuration incessantes, il peut être intéressant de permettre aux utilisateurs isolés d'effectuer eux-mêmes ces modifications par le biais de fichiers __.htaccess__. Ceci est particulièrement vrai dans le cas où le fournisseur d'accès à Internet héberge de nombreux sites d'utilisateurs sur un seul serveur, et souhaite que ces utilisateurs puissent modifier eux-mêmes leurs configurations.

Cependant et d'une manière générale, il vaut mieux éviter d'utiliser les fichiers __.htaccess__. Tout élément de configuration que vous pourriez vouloir mettre dans un fichier __.htaccess__, peut aussi être mis, et avec la même efficacité, dans une section __<Directory>__ du fichier de configuration de votre serveur principal.

Il y a deux raisons principales d'éviter l'utilisation des fichiers __.htaccess__ : 

* La première est liée aux performances. Lorsque la directive __AllowOverride__ est définie de façon à autoriser l'utilisation des fichiers __.htaccess__, __httpd__ va rechercher leur présence dans chaque répertoire. Ainsi, permettre l'utilisation des fichiers __.htaccess__ est déjà en soi une cause de dégradation des performances, que vous utilisiez effectivement ces fichiers ou non ! De plus, le fichier __.htaccess__ est chargé en mémoire chaque fois qu'un document fait l'objet d'une requête. 
 Notez aussi que __httpd__ doit rechercher les fichiers __.htaccess__ dans tous les répertoires de niveau supérieur, afin de rassembler toutes les directives qui s'appliquent au répertoire courant (Voir la section comment sont appliquées les directives). Ainsi, si un fichier fait l'objet d'une requête à partir d'un répertoire __/www/htdocs/exemple__, __httpd__ doit rechercher les fichiers suivants :

        /.htaccess
        /www/.htaccess
        /www/htdocs/.htaccess
        /www/htdocs/exemple/.htaccess

 En conséquence, chaque accès à un fichier de ce répertoire nécessite 4 accès au système de fichiers supplémentaires pour rechercher des fichiers __.htaccess__, même si aucun de ces fichiers n'est présent. Notez que cet exemple ne peut se produire que si les fichiers __.htaccess__ ont été autorisés pour le répertoire /, ce qui est rarement le cas.

* La seconde raison d'éviter l'utilisation des fichiers __.htaccess__ est liée à la sécurité. Si vous permettez aux utilisateurs de modifier la configuration du serveur, il peut en résulter des conséquences sur lesquelles vous n'aurez aucun contrôle. Réfléchissez bien avant de donner ce privilège à vos utilisateurs. Notez aussi que ne pas donner aux utilisateurs les privilèges dont ils ont besoin va entraîner une augmentation des demandes de support technique. Assurez vous d'avoir informé clairement vos utilisateurs du niveau de privilèges que vous leur avez attribué. Indiquer exactement comment vous avez défini la directive __AllowOverride__ et diriger les utilisateurs vers la documentation correspondante vous évitera bien des confusions ultérieures.

* Référence :
    * [https://httpd.apache.org/docs/current/howto/htaccess.html](https://httpd.apache.org/docs/current/howto/htaccess.html) 

# <a name="VirtualHost" /> VirtualHost

Le principe du [VirtualHost](http://httpd.apache.org/docs/2.4/fr/vhosts/) est de permettre sur la même instance apache d'offrir plusieurs site web . Apache a été le précurseur des serveurs proposant cette méthode de serveurs virtuels basés sur les adresses IP, ce qui a grandement aidé à ça popularité.

Il existe 2 type de __VirtualHost__ :

* **Basé sur l'IP** (IP Base) : Comme l'indique le terme par IP, le serveur doit disposer de différentes paires adresses IP/port pour chaque serveur virtuel par IP. La machine peut posséder plusieurs connexions physiques au réseau, ou utiliser des interfaces virtuelles qui sont supportées par la plupart des systèmes d'exploitation modernes (Consultez la documentation des systèmes d'exploitation pour plus de détails, notamment les "alias IP" et la commande "ifconfig" pour les activer), et/ou utiliser plusieurs numéros de port.
Selon la terminologie du serveur HTTP Apache, l'utilisation d'une seule adresse IP avec plusieurs ports TCP s'apparente aussi à de l'hébergement virtuel basé sur IP.
* **Basé sur le nom** (__Name__ Base) : Les serveurs virtuels par IP utilisent l'adresse IP de la connexion afin de déterminer quel serveur virtuel doit répondre. Par conséquent, vous devez disposer d'adresses IP différentes pour chaque serveur.
Avec un hébergement virtuel par nom, le serveur s'appuie sur les informations transmises par le client dans les en-têtes HTTP de ses requêtes. La technique présentée ici vous permet de disposer de serveurs virtuels différents partagés sur une même adresse IP.

Avec la pénurie d'adresse IP disponible sur internet l'utilisation des __virtual host__ IP base sont de moins en moins utilisées surtout pour les sites web (sans chiffrement __https__). 

Voyons comment configurer les 2 types, vous allez constater que ceci est très similaire :).

## <a name="Vhost_ip"> Serveurs virtuels par IP

Pour pouvoir définir un __VirtualHost__ IP base il faut avoir plusieurs IP, sinon vous utiliser des serveurs virtuel basé sur le nom. Conceptuellement des __VirtualHost__ basé sur le port de connexion sont considéré comme des __VirtualHost__ IP base, j'en fait mention cependant dans le feu de l'action sur la configuration nous ne constatons pas la différence.

Si vous utilisez le docker __x3rus/linux202__ par défaut :

        $ sudo ifconfig
          eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:00:01  
                    inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0
                    inet6 addr: fe80::42:acff:fe11:1/64 Scope:Link
                    UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
                    RX packets:547 errors:0 dropped:0 overruns:0 frame:0
                    TX packets:322 errors:0 dropped:0 overruns:0 carrier:0
                    collisions:0 txqueuelen:0 
                    RX bytes:48132 (48.1 KB)  TX bytes:49572 (49.5 KB)

          lo        Link encap:Local Loopback  
                    inet addr:127.0.0.1  Mask:255.0.0.0
                    inet6 addr: ::1/128 Scope:Host
                    UP LOOPBACK RUNNING  MTU:65536  Metric:1
                    RX packets:0 errors:0 dropped:0 overruns:0 frame:0
                    TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
                    collisions:0 txqueuelen:0 
                    RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

Comme vous pouvez le constater il n'y a qu'une adresse IP de définie (172.17.0.1), nous allons ajouter l'IP 172.17.0.10.
Nous allons ajouter cette IP, comme une IP alias sur la carte eth0, nous allons lui donner le nom **eth0:1**, c'est la méthode la plus commune. Pour information nous aurions très bien pu aussi définir l'alias avec un nom telle que **eth0:moodle**. Je vais faire la démonstration aussi.

        $ sudo ifconfig eth0:1 172.17.0.10
        $ sudo ifconfig 
          eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:00:01  
                    inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0
                    inet6 addr: fe80::42:acff:fe11:1/64 Scope:Link
                    UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
                    RX packets:547 errors:0 dropped:0 overruns:0 frame:0
                    TX packets:322 errors:0 dropped:0 overruns:0 carrier:0
                    collisions:0 txqueuelen:0 
                    RX bytes:48132 (48.1 KB)  TX bytes:49572 (49.5 KB)

          eth0:1    Link encap:Ethernet  HWaddr 02:42:ac:11:00:01
                    inet addr:172.17.0.10  Bcast:172.17.255.255  Mask:255.255.0.0
                    UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1

          lo        Link encap:Local Loopback  
                    inet addr:127.0.0.1  Mask:255.0.0.0
                    inet6 addr: ::1/128 Scope:Host
                    UP LOOPBACK RUNNING  MTU:65536  Metric:1
                    RX packets:0 errors:0 dropped:0 overruns:0 frame:0
                    TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
                    collisions:0 txqueuelen:0 
                    RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

Démonstration avec un nom comme alias :

        $ sudo ifconfig eth0:moodle 172.17.0.5
          eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:00:01  
                    inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0
                    inet6 addr: fe80::42:acff:fe11:1/64 Scope:Link
                    UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
                    RX packets:547 errors:0 dropped:0 overruns:0 frame:0
                    TX packets:322 errors:0 dropped:0 overruns:0 carrier:0
                    collisions:0 txqueuelen:0 
                    RX bytes:48132 (48.1 KB)  TX bytes:49572 (49.5 KB)

          eth0:1    Link encap:Ethernet  HWaddr 02:42:ac:11:00:01
                    inet addr:172.17.0.10  Bcast:172.17.255.255  Mask:255.255.0.0
                    UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1

          eth0:moodle Link encap:Ethernet  HWaddr 02:42:ac:11:00:01
                    inet addr:172.17.0.5  Bcast:172.17.255.255  Mask:255.255.0.0
                    UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1


Maintenant que nous avons 2 adresses IP même 3 :P , nous allons pouvoir définir un serveur virtuel sur l'IP 172.17.0.1 ET 172.17.0.10 ou 172.17.0.5.

**ATTENTION** : j'ai réalisé la configuration d'IP de manière éphémère , en effet lors du prochain redémarrage la machine n'aura plus que son IP principale . Pour réaliser cette configuration permanente valider avec la distribution que vous utilisez , pour Ubuntu voici un lien [Configuration IP alias](TODO : ajouter le lien).


Nous allons précéder à la réalisation du premier __VitualHost__ pour l'IP 172.17.0.1 , nous l'appellerons le site A :P (l'inspiration n'est pas présent aujourd'hui :P). Suivant le principe d'Ubuntu / Debian , nous allons créer le fichier sous le répertoire **/etc/apache2/sites-available** , en utilisant un nom significatif.

        $ cat /etc/apache2/sites-available/siteA.conf
        <VirtualHost 172.17.0.1:80>
                ServerAdmin webmaster@localhost
                DocumentRoot /data/vhosts/siteA

                <Directory /data/vhosts/siteA>
                        Options Indexes FollowSymLinks
                        AllowOverride None
                        Require all granted
                </Directory>
        </VirtualHost>

Nous gardons ça au plus simple , comme vous pouvez le constater , la première ligne contient l'adresse IP ET le port d'écoute.
Je vais faire la même opération pour le site B .

        $ cat /etc/apache2/sites-available/siteB.conf
        <VirtualHost 172.17.0.10:80>
                ServerAdmin webmaster@localhost
                DocumentRoot /data/vhosts/siteB

                <Directory /data/vhosts/siteB>
                        Options Indexes FollowSymLinks
                        AllowOverride None
                        Require all granted
                </Directory>
        </VirtualHost>

En gros nous retrouvons la même configuration avec 2 répertoire racine distincts

* __/data/vhosts/siteA__
* __/data/vhosts/siteB__

Nous allons activer les fichiers de configuration , toujours en suivant le principe d'Ubuntu en réalisant un lien symbolique du répertoire **/etc/apache2/sites-enabled** vers les fichiers contenu dans le répertoire **/etc/apache2/sites-available**.

        $ cd /etc/apache2/sites-enabled
        $ sudo ln -s ../sites-available/siteA.conf .
        $ sudo ln -s ../sites-available/siteB.conf .

Réalisons une validation syntaxique des fichiers de configuration afin de s'assurer que nous n'avons pas fait d'erreur.

        $ sudo apachectl configtest
        AH00112: Warning: DocumentRoot [/data/vhosts/siteA] does not exist
        AH00112: Warning: DocumentRoot [/data/vhosts/siteB] does not exist
        
        Syntax OK

Je voulais profiter de l'occasion pour vous démontrer l'avantage d'utiliser le système de validation d'apache, il est en mesure de nous identifier des problèmes. Dans le cas présent les répertoires des sites web ne sont pas présent. Nous allons donc procéder à la réalisation des répertoires ainsi que la création d'un fichier d'index pour nous permettre d'identifier les 2 sites.

        $ sudo mkdir -p /data/vhosts/siteA
        $ sudo mkdir -p /data/vhosts/siteB

        $ cat /data/vhosts/siteA/index.html
        Le site A
        $ cat /data/vhosts/siteB/index.html
        Le site B

Une petite validation syntaxique pour la route ...

        $ sudo apachectl configtest
        Syntax OK


Nous pouvons démarrer le service :

        $ sudo /etc/init.d/apache2 restart


Voilà si nous utilisons notre fureteur nous verrons pour les URL : http://172.17.0.1 et http://172.17.0.10 les sites web :

![vhost-ip-siteA.png](./imgs/vhost-ip-siteA.png)
![vhost-ip-siteB.png](./imgs/vhost-ip-siteB.png)

Il est donc à ce point possible d'avoir N site pour chaque adresse IP disponible sur le système, car lors de la réception d'une requête HTTP apache la traitera en utilisant le fichier de configuration ayant l'IP  spécifique.
G
Comme vous pouvez le constater alors que nous visualisions originalement la page par défaut de Ubuntu/Debian à présent nous ne voyons que le site A lorsque nous accédons à l'URL http://172.17.0.1 . Même si nous n'avons pas désactivé la configuration par défaut contenu dans le fichier **/etc/apache2/sites-enabled/000-default.conf**. Prenons un instant pour voir le contenu du fichiers : 


        <VirtualHost *:80>
                ServerAdmin webmaster@localhost
                DocumentRoot /data/www
                <Directory /data/www/>
                    Options Indexes FollowSymLinks
                    AllowOverride None
                    Require all granted
                </Directory>
                <Directory /data/www/admin >
                    Options FollowSymLinks
                    AllowOverride AuthConfig
                </Directory>
                ErrorLog ${APACHE_LOG_DIR}/error.log
                CustomLog ${APACHE_LOG_DIR}/access.log combined
        </VirtualHost>

L'instruction __VirtualHost__ est composé avec une astérisque et le port (*:80) ce qui indique que ce serveur virtuel est valide pour toute les adresses IP sur le port 80. Comme nous avons été plus spécifique en indiquant les __VirtualHost__ avec des IP ces derniers ont priorités.


## <a name="Vhost_name_base"> Serveurs virtuels par Nom

Telle que mentionné dans l'introduction malheureusement avec le nombre d'adresse IP (IPv4) restreint disponible sur internet il est compliqué d'avoir une adresse IP par site. 
Avec un hébergement virtuel par nom, le serveur s'appuie sur les informations transmises par le client dans les en-têtes HTTP de ses requêtes. La technique présentée ici vous permet de disposer de serveurs virtuels différents partagés sur une même adresse IP.

L'hébergement virtuel par nom est habituellement plus simple, car il vous suffit de configurer votre serveur __DNS__ pour que chaque domaine pointe sur l'adresse IP dont vous disposez, et de configurer votre serveur Apache HTTP afin qu'il reconnaisse ces domaines. Il réduit aussi la pénurie en adresses IP. Par conséquent, vous devriez utiliser l'hébergement virtuel par nom, sauf dans le cas où vous utiliseriez des équipements qui nécessitent un hébergement basé sur IP. Les raisons historiques de l'hébergement basé sur IP dans un but de support de certains clients ne s'appliquent plus à un serveur web d'usage général.

**Processus de traitement des requêtes**

* Explication provenant du  [site d'apache](http://httpd.apache.org/docs/2.4/fr/vhosts/name-based.html)
    Il est important de savoir que la première étape de la résolution de serveur virtuel basée sur le nom est une résolution basée sur IP. La résolution de serveur virtuel basée sur le nom ne fait que choisir le serveur virtuel basé sur le nom le plus approprié, en se limitant aux candidats qui conviennent le mieux du point de vue IP. La résolution basée sur IP est sans objet si l'on utilise un caractère générique (*) pour l'adresse IP dans toutes les directives __VirtualHost__.

    A l'arrivée d'une requête, le serveur va rechercher l'argument de section __<VirtualHost>__ présentant la meilleure (la plus exacte) correspondance avec la paire adresse IP/port utilisée dans la requête. Si plusieurs serveurs virtuels possèdent cette même paire adresse IP/port, Apache va ensuite comparer les valeurs des directives __ServerName__ et __ServerAlias__ avec le nom de serveur présent dans la requête.

    Si vous ne définissez pas de directive __ServerName__ pour un serveur virtuel à base de nom, le serveur utilisera par défaut le nom de domaine entièrement qualifié (__FQDN__) déduit du nom d'hôte système. Cette configuration sans nom de serveur explicite peut conduire à des erreurs de choix du serveur virtuel à utiliser et est déconseillée.


* Maintenant ma version :P , à vous de choisir la plus claire.
    Lorsque le client utilisant son fureteur réalise une requête vers le site web , la première étape est la résolution __DNS__, si nous prenons le site __www.x3rus.com__ la résolution donnera l'IP : 198.100.146.119 . Le serveur apache doit avoir un serveur Virtuel configurer sur cette adresse IP. Ce peut être avec l'IP spécifier telle que __<VirtualHost 198.100.146.119:80>__ou une configuration plus général à l'aide d'un __wildcard__ __<VirtualHost *:80>__. 
    Si le serveur apache reçoit une requête pour le __VirtualHost__ avec l'adresse IP et constater qu'il y a plusieurs définition pour ce même __VirtualHost__ comme le système ne sait pas pour quelle site la requête est destiné il regarde l'entête de la requête . En effet quand le fureteur a transmis la requête sur internet en plus d'utiliser l'IP pour rejoindre le serveur il a aussi demande __www.x3rus.com__. Apache va donc lire les fichiers de configuration des __VirtualHost__  à la recherche du nom du site. Il va chercher 2 variable [ServerName](http://httpd.apache.org/docs/2.4/fr/mod/core.html#servername) qui est unique et [ServerAlias](http://httpd.apache.org/docs/2.4/fr/mod/core.html#serveralias) cette entré permet de définir plusieurs nom au serveur virtuel. Le système fournis le site le plus spécifique , s'il ne trouve pas le nom du site dans l'ensemble des fichiers de configuration concordant à l'IP il fournira un des serveurs virtuel selon le chargement des fichiers.

Réalisons un petit exemple pour avoir un peu de pratique.

Nous allons créer des serveurs virtuel basé sur le nom pour l'adresse IP __172.17.0.1__ , nous réaliserons quelques testes avec l'autre adresse IP pour démontrer la différence de traitement.

Commençons par associer un nom de serveur virtuel au site A, j'édite donc le fichier **/etc/apache2/sites-available/siteA.conf**

        $ cat  siteA.conf
        <VirtualHost 172.17.0.1:80>
            ServerAdmin webmaster@localhost

            ServerName www.linux202-siteA.com
            ServerAlias linux202-siteA.com
            ServerAlias toto.linux202-siteA.com

            DocumentRoot /data/vhosts/siteA

            <Directory /data/vhosts/siteA>
                Options Indexes FollowSymLinks
                AllowOverride None
                Require all granted
            </Directory>
        </VirtualHost>

        $ sudo apachectl configtest && sudo /etc/init.d/apache2 restart

Si nous utilisons un fureteur pour voir le site web nous aurons une erreur car il n'y a pas de __DNS__ associé a ce nom , nous allons donc modifier notre fichier **/etc/hosts** pour "simuler" la résolution de nom . Ce changement  est doit être réaliser sur la machine **cliente** qui à le fureteur pour consulter les pages web. Et ceci est uniquement une solution de contournement car malheureusement je n'ai pas gagné au loto je n'ai acheter des nom de domaines pour la formation ;-).

Donc avant le changement du fichier **/etc/hosts** :

        client $ ping www.linux202-siteA.com
        ping: unknown host www.linux202-siteA.com
        client $ vim /etc/hosts
        client $ cat /etc/hosts
        $ cat /etc/hosts
        #
        # /etc/hosts: static lookup table for host names
        #

        #<ip-address>   <hostname.domain.org>   <hostname>
        127.0.0.1       localhost.localdomain   localhost
        ::1             localhost.localdomain   localhost

        172.17.0.1      www.linux202-siteA.com linux202-siteA.com toto.linux202-siteA.com
        client $ ping www.linux202-siteA.com
        PING www.linux202-siteA.com (172.17.0.1) 56(84) bytes of data.
        64 bytes from www.linux202-siteA.com (172.17.0.1): icmp_seq=1 ttl=64 time=0.102 ms


Suite à ce petit changement si nous retentons une connexion avec le fureteur nous aurons la __page siteA__ de disponible

![vhost-ip-siteA-avec_nom.png](./imgs/vhost-ip-siteA-avec_nom.png)

Jusqu'ici tout va bien le système fonctionne comme prévus , cependant telle que mentionné plus tôt nous ne somme en serveur virtuelle basé sur nom uniquement s'il y a plusieurs définition du même __VirtualHost__ avec la même IP. Dans notre cas nous n'avons que le __siteA__ avec la définition de l'IP 172.17.0.1 . Nous allons donc procéder à la création du __siteC__, commençons par le fichier de configuration **/etc/apache2/sites-available/siteC.conf**.

        $ cat siteC.conf
        <VirtualHost 172.17.0.1:80>
                ServerAdmin webmaster@localhost

                ServerName www.siteC.com
                ServerAlias siteC.com

                DocumentRoot /data/vhosts/siteC

                <Directory /data/vhosts/siteC>
                    Options Indexes FollowSymLinks
                    AllowOverride None
                    Require all granted
                </Directory>
        </VirtualHost>

Nous allons procéder à la création du répertoire du site et la petite page d'index pour visualisé le site.

        $ sudo mkdir /data/vhosts/siteC
        $ cat /data/vhosts/siteC/index.html
        Le site C

Activation de la configuration , validation de cette dernière et rechargement de la configuration d'apache.

        $ cd /etc/apache2/sites-enabled
        $ sudo ln -s ../sites-available/siteC.conf .
        $ sudo apachectl configtest && sudo /etc/init.d/apache2 restart

Ceci été pour la partie serveur , nous allons modifier le fichier **/etc/hosts** de notre machine client afin de simuler la résolution __DNS__.

        $ sudo vim /etc/hosts
        $ cat /etc/hosts
        #
        # /etc/hosts: static lookup table for host names
        #

        #<ip-address>   <hostname.domain.org>   <hostname>
        127.0.0.1       localhost.localdomain   localhost
        ::1             localhost.localdomain   localhost

        172.17.0.1      www.linux202-siteA.com linux202-siteA.com toto.linux202-siteA.com
        172.17.0.1      www.siteC.com siteC.com 
        $ ping siteC.com
        PING www.siteC.com (172.17.0.1) 56(84) bytes of data.
        64 bytes from www.linux202-siteA.com (172.17.0.1): icmp_seq=1 ttl=64 time=0.102 ms

Validons à présent avec un navigateur ....

![vhost-ip-siteC-avec_nom.png](./imgs/vhost-ip-siteC-avec_nom.png)

**Woww** magie !!

Rappel rapide du processus, de sélection de configuration 

1. Le client via le fureteur à demandé la site __www.siteC.com__ 
2. Le fureteur à réaliser une résolution __DNS__ afin de pouvoir communiquer sur Internet et transmettre le paquet vers le bon serveur web.
3. Le serveur apache à reçu la requête sur l'adresse IP 172.17.0.1 
4. Il a constater qu'il y avait 2 configuration pour cette même adresse IP contenue dans le fichier **/etc/apache2/sites-enabled/siteA.conf** et **/etc/apache2/sites-enabled/siteC.conf**.
5. Le système apache à donc analyser le contenu de la requête client afin d'identifier dans l'entête des paquets HTTP (conformément au protocole __http__) quelle nom de site fut demandé.
6. Avec cette information apache à tenté de trouvé ce nom de domaine dans la définition des serveurs virtuels en interrogeant les directives __ServerName__ et __ServeurAlias__ dans les fichiers **/etc/apache2/sites-enabled/siteA.conf** et **/etc/apache2/sites-enabled/siteC.conf**.
7. Apache a trouvé dans le fichier  **/etc/apache2/sites-enabled/siteC.conf** la définition dans l'instruction __ServerName www.siteC.com__ 
8. Apache à donc consulter les fichier du site définie dans le __DocumentRoot__ soit __/data/vhosts/siteC__, trouvé le fichier __index.html__ et transmis au fureteur.

Super ça , mais s'il avait pas trouvé d'entré __ServerName__ et __ServerAlias__ ?!?! 

Réalisons le teste, car ceci est important c'est une erreur commune :P .

Je vais éditer le fichier __/etc/hosts__ pour simulé une autre résolution __DNS__ pour le nom __site-noname.com__

        $ sudo vim /etc/hosts
        $ cat /etc/hosts
        #
        # /etc/hosts: static lookup table for host names
        #

        #<ip-address>   <hostname.domain.org>   <hostname>
        127.0.0.1       localhost.localdomain   localhost
        ::1             localhost.localdomain   localhost

        172.17.0.1      www.linux202-siteA.com linux202-siteA.com toto.linux202-siteA.com
        172.17.0.1      www.siteC.com siteC.com 
        172.17.0.1      www.site-noname.com site-noname.com #
        # /etc/hosts: static lookup table for host names
        #

        #<ip-address>   <hostname.domain.org>   <hostname>
        127.0.0.1       localhost.localdomain   localhost
        ::1             localhost.localdomain   localhost

        172.17.0.1      www.linux202-siteA.com linux202-siteA.com toto.linux202-siteA.com
        172.17.0.1      www.siteC.com siteC.com 
        172.17.0.1      www.site-noname.com site-noname.com 
        $ ping site-noname.com
        PING www.site-noname.com (172.17.0.1) 56(84) bytes of data.


Utilisons le fureteur à présent 

![vhost-ip-site-noname-avec_nom.png](./imgs/vhost-ip-site-noname-avec_nom.png)

Le système à choisie le premier serveur virtuel qu'il a trouvé ! Attention avec ce comportement vous pouvez avoir des surprise.

**Note version antérieure :** Avant la version 2.4 vous devez spécifier les adresses IP qui vont être utilisé avec des serveurs virtuel basé sur le nom avec l'instruction [NameVirtualHost](http://httpd.apache.org/docs/2.2/mod/core.html#namevirtualhost)

Ceci couvre la démonstration d'un serveur virtuel basé sur le nom en HTTP, nous pouvons toujours consulter le site sur l'IP 172.17.0.10 sans problème. Il est possible d'avoir une configuration mixe sur la même serveur !

* Référence : http://httpd.apache.org/docs/2.4/fr/vhosts/name-based.html

# <a name="organisation" /> Organisation des sites web

Maintenant que nous avons la possibilité de mettre plusieurs site web, il faut faire attention que ça ne devienne pas rapidement un gros problème de gestion. Je vais vous faire une suggestion d'organisation de structure, ceci est le fruit d'expérience de plusieurs année. J'ai rencontré des contraintes et des demandes d'utilisateurs qui m'ont amenés à mettre en place cette organisation, comme toujours libre à vous de l'adapter pour vos besoins. Je vais en profité pour couvrir d'autre configuration avec des explications pourquoi j'ai opté pour cette configuration.

## <a name="organisation_rep_vhosts"/> Organisation des répertoires des serveurs virtuelle

Commençons par la structure des répertoires qui hébergerons les site web. 
Voici une représentation de la structure du répertoire :

            /data/
                 /vhost/
                       /siteA/
                             /docroot/
                             /logs/
                             /privates/
                             /uploads/
                       /siteB/
                       /siteC/

Prenons maintenant quelques minutes pour lire la structure , j'aime avoir l'ensemble des __VirtualHost__ sous un même répertoire. Parce que ceci me permet de définir des permissions avec l'instruction [Directory](https://httpd.apache.org/docs/2.4/fr/mod/core.html#directory) depuis la racine et ceci ce répercute sur l'ensemble des répertoires enfants. Ceci me permet d'être plus restrictif et par la suite permettre plus d'option selon le répertoire.

Chaque site on la même structure encore une fois ceci simplifie la gestion par la suite :

* **docroot** : Contient le site web c'est le répertoire qui sera associé à la configuration [DocumentRoot](https://httpd.apache.org/docs/2.4/mod/core.html#documentroot). Ce sera donc le répertoire racine du site.
* **logs** : Avec le temps j'ai constaté que les développeurs web aime avoir accès au logs , que ce soit pour analyser les erreurs ou simplement voir l'activité en temps réel. Nous nous assurerons des permissions sur ce répertoire pour que ce ne soit qu'en lecture, par  mesure de précaution.
* **privates** : Ce répertoire n'est pas accessible depuis Internet, ce répertoire peut être utilisé par le développeur pour stocké des fichiers à usage interne au serveur uniquement. Nous pourrions retrouvé par exemple un fichier de configuration pour établir une connexion à la BD. Nous ne désirons pas qu'une personne puisse récupérer ce fichier via un fureteur car il devine le nom. Je vous laisse le soin de faire un testes sur vos serveur :P . Si vous avez un fichier __config.conf__ par exemple dans le répertoire __inc__ sous la définition du __DocumentRoot__, vous constaterez que tout le monde peut l'avoir :-/. Bien entendu ce répertoire est totalement inutile si l'administrateur du site ne l'utilise pas :-/.
* **uploads** : Ce répertoire a les permissions d'écriture à apache et permet l'écriture par l'applicatif web. Il n'est pas toujours possible de l'utiliser, car certaine applications désire l'avoir sous le __docroot__ donc faut voir selon vos applications. Je le met en place, car ceci permet tous de suite au développeur d'avoir un répertoire disponible sans prendre contact avec moi pour un changement de permission.


Voici un petit script pour faire la création des répertoires, attention ceci est vraiment un point de départ, je vous invite à le modifier afin de rajouter la définition des permissions pour le répertoire docroot, ... Ce que je veut surtout souligner avec la création d'un script est qu'il faut tout faire pour automatiser les opérations manuel. Car si vous réalisez souvent cette opération, parfois vous ferez une erreur dans le nom du répertoire, une erreur de permissions , ...
2 possibilités s'offre à vous , réaliser des scripts ou utiliser un système de gestion de configuration telle que [ansible](http://www.ansible.com) ou [puppet](http://puppetlabs.com), nous verrons plus tard ces systèmes ! 

        #!/bin/bash
        #
        ##############################################
        
        # Vars
        VHOSTS_BASE=/data/vhosts
        APACHE_GROUP=www-data
        LST_REPS_VHOSTS="docroot logs privates uploads"
        
        # Arguments passer sur la ligne de commande.
        VHOST_TO_CREATE=$@
        
        if [ "$VHOST_TO_CREATE" == "" ]; then
                echo "ERROR: Il n'y a pas d'argument avec un ou plusieurs site a creer "
                echo "$0 siteA " 
                echo "$0 siteA siteB siteC"
                exit 1
        fi
        
        for site in $VHOST_TO_CREATE
        do
                echo "sudo mkdir -p $VHOSTS_BASE/$site"
                for rep in $LST_REPS_VHOSTS
                do
                        echo "sudo mkdir $VHOSTS_BASE/$site/$rep"
                        if [ "$rep" == "uploads" ] ; then
                                echo "sudo chmod g=rwX $VHOSTS_BASE/$site/$rep" 
                                echo "sudo chown :$APACHE_GROUP $VHOSTS_BASE/$site/$rep"        
                        fi # if uploads
                done #for rep
        done # for vhosts

## <a name="organisation_config_vhosts"/> Configuration Apache pour les serveurs virtuels

Nous avons maintenant la structure des répertoires, nous allons mettre en place la configuration apache approprié.

Nous allons définir une configuration par défaut qui sera hérité par l'ensemble des sites virtuel. 
Toujours en suivant la structure de Ubuntu/Debian nous allons définir le fichier **/etc/apache2/conf-available/vhosts_base.conf**. Nous allons y définir la configuration pour le répertoire **/data/vhosts/**.

Voici le contenu du fichier : **/etc/apache2/conf-available/vhosts_base.conf**

        # Configuration par default qui sera appliquer par default a l'ensemble des vhosts

        <Directory /data/vhosts>
                Options None
                AllowOverride None
                Require all denied
        </Directory>

Dans le cas présent je désactive l'ensemble des options , nous y reviendrons lors de la configuration d'un serveur virtuel et je désactive la possibilité d'utiliser les fichiers __.htaccess__. Ceci pour une question de performance ET de sécurité. De plus je bloque l'accès aux répertoire avec l'instruction **Require all denied** . Je réalise cette opération afin que l'on soit obligé de définir spécifiquement les répertoires accessible depuis internet .

Nous activons la configuration en réalisant un lien symbolique et on valide la configuration pour être certain !

        $ cd /etc/apache2/conf-enabled
        $ sudo ln -s ../conf-available/vhosts_base.conf .
        $ sudo apachectl configtest
        Syntax OK

Tout semble bon, nous pouvons procéder à la configuration du serveur virtuel. Toujours selon la structure d'Ubuntu nous allons faire la création du fichier **/etc/apache2/sites-available/siteA.conf**, en fait nous allons modifier le fichier déjà existant .

Voici le fichier pour le __siteA__ et le __siteC__

        <VirtualHost 172.17.0.1:80>
                ServerAdmin webmaster@localhost

                ServerName www.linux202-siteA.com
                ServerAlias linux202-siteA.com
                ServerAlias toto.linux202-siteA.com

                DocumentRoot /data/vhosts/siteA/docroot/

                <Directory /data/vhosts/siteA/docroot/>
                    Options none
                    AllowOverride None
                    Require all granted
                </Directory>

                <Directory /data/vhosts/siteA/uploads/>
                    Options none
                    AllowOverride None
                    Require all granted
                </Directory>

                # Configuration des logs
                ErrorLog /data/vhosts/siteA/logs/error.log
                CustomLog /data/vhosts/siteA/logs/access.log combined
        </VirtualHost>

        <VirtualHost 172.17.0.1:80>
                ServerAdmin webmaster@localhost

                ServerName www.siteC.com
                ServerAlias siteC.com

                DocumentRoot /data/vhosts/siteC/docroot/

                <Directory /data/vhosts/siteC/docroot/>
                    Options none
                    AllowOverride None
                    Require all granted
                </Directory>

                <Directory /data/vhosts/siteC/uploads/>
                    Options none
                    AllowOverride None
                    Require all granted
                </Directory>

                # Configuration des logs
                ErrorLog /data/vhosts/siteC/logs/error.log
                CustomLog /data/vhosts/siteC/logs/access.log combined
         </VirtualHost>


Comme d'habitude avant d'aller plus loin, une validation de configuration est une bonne chose . 

        $ sudo apachectl configtest
        Syntax OK

J'autorise spécifiquement les répertoires __docroot__ et __uploads__, le répertoire __uploads__ est susceptible de contenir des images ou autre document diffusé au publique donc l'autorisation est donnée. Les répertoires __privates__ et __logs__ n'étant destiné qu'a usage interne ne sont pas permis.
Comme vous pouvez le constater nous avons ajouter 2 instructions : **ErrorLog** et **CustomLog** prenons quelques minutes pour les analyser.

## <a name="organisation_logs_vhosts"/> Configuration des logs pour les serveurs virtuels

Pour faire la gestion des logs qui est un point SUPER important si vous voulez être en mesure d'analyser le trafic d'un site web ou de visualiser les erreurs survenu sur le site.

Nous avons déjà une configuration présente comme configuration par défaut :

        $ grep -n ErrorLog /etc/apache2/apache2.conf 
        122:# ErrorLog: The location of the error log file.
        123:# If you do not specify an ErrorLog directive within a <VirtualHost>
        128:ErrorLog ${APACHE_LOG_DIR}/error.log
        $ egrep 'APACHE_LOG_DIR' -n /etc/apache2/envvars 
        23:export APACHE_LOG_DIR=/var/log/apache2$SUFFIX

L'instruction [ErrorLog](https://httpd.apache.org/docs/2.4/fr/mod/core.html#errorlog) permet de définir le fichier qui sera utilisé pour contenir les logs d'erreur par défaut , donc ce fichier contiendra l'ensemble des erreurs de démarrage et les logs d'erreurs des serveurs virtuel SI vous n'avez pas redéfinie cette instruction.

![ErrorLog-screenshot-documentation.png](./imgs/ErrorLog-screenshot-documentation.png)

Comme vous pouvez le constater cette instruction ne peut être utilisé que dans la configuration global du serveur ET / OU dans un __VirtualHost__.

En le redéfinissant dans le __VirtualHost__, le fichier d'erreur de logs contiendra **uniquement** les erreurs relatif au __VirtualHost__ vous n'aurez pas les erreurs global du serveur. Vous aurez dans le fichier les erreurs telle que les 404 , les erreur 500 (problème d'exécution), les erreurs de PHP si vous utilisez ce langage , ... Ceci est très très intéressant afin d'ajuster votre site en cas de problème.

Ceci étant dit j'ai définie une autre instruction qui est [CustomLog](http://httpd.apache.org/docs/current/fr/mod/mod_log_config.html#customlog), cette instruction permet de définir le fichier de log qui contiendra l'information d'accès au site , donc SANS les erreurs.

![CustomLog-screenshot-documentation.png](./imgs/CustomLog-screenshot-documentation.png)

Tout comme pour l'instruction d'erreur cette instruction peut être définie dans le fichier Global ou dans un __VirtualHost__.
Si nous regardons l'instruction dans le fichier ceci est composé de 2 partie le nom du fichier et le format .

        CustomLog /data/vhosts/siteA/logs/access.log combined

Donc nous écrivons le fichier __/data/vhosts/siteA/logs/access.log__ avec le format **combined**. Parlons donc un peu format , 98% (c'est vraiment sortie de mon chapeau, j'ai pas de statistique réelle :P ) vous utiliserai le formant **combined**. 
Les formats disponible sont décrit par l'instruction [Logformat](http://httpd.apache.org/docs/current/fr/mod/mod_log_config.html#logformat), regardons les formats de log pré définie sur le serveur .

        $ grep "LogFormat" -n -R /etc/apache2/apache2.conf
        207:LogFormat "%v:%p %h %l %u %t \"%r\" %>s %O \"%{Referer}i\" \"%{User-Agent}i\"" vhost_combined
        208:LogFormat "%h %l %u %t \"%r\" %>s %O \"%{Referer}i\" \"%{User-Agent}i\"" combined
        209:LogFormat "%h %l %u %t \"%r\" %>s %O" common
        210:LogFormat "%{Referer}i -> %U" referer
        211:LogFormat "%{User-agent}i" agent

Nous avons donc les formats :

* vhost_combined
* combined
* common

Si nous regardons rapidement l'instruction [Logformat](http://httpd.apache.org/docs/current/fr/mod/mod_log_config.html#logformat) pour **combined** nous avons le format :

* %h : Serveur distant. Contiendra l'adresse IP si la directive HostnameLookups est définie à Off
* %l : Le nom de connexion distant , Affiche un tiret, sauf si mod_ident est présent
* %u : L'utilisateur distant (en provenance d'auth ; peut être faux si le statut de retour (%s) est 401).
* %t : Date à laquelle la requête a été reçue
* %r : La première ligne de la requête
* %>s : Statut. Pour les requêtes redirigées en interne, il s'agit du statut de la requête *originale* --- %>s pour la dernière.
* %O : Nombre d'octets envoyés, y compris les en-têtes. Peut être nul dans les rares cas où une requête est avortée avant que la réponse ne soit envoyée. Nécessite l'activation de mod_logio.
* %Referer : Référence de la provenance de la requête
* %User-Agent : Le type de client établissant la connexion  (Firefox , Chrome, windows, Linux , ...)

Voici un exemple de contenu dans les logs en format __combined__:

        172.17.42.1 - - [26/Feb/2016:08:43:17 -0500] "GET / HTTP/1.1" 200 3594 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"
        172.17.42.1 - - [26/Feb/2016:08:43:17 -0500] "GET /icons/ubuntu-logo.png HTTP/1.1" 200 3688 "http://172.17.0.10/" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"

Quand avez vous besoin de définir un format de log ?!?! En fait c'est très rare, généralement le besoin ce fait sentir si vous avez une informations spécifique à récupérer qui n'est pas déjà contenu dans le format __combined__. L'autre situation plus probable est quand votre logiciel de traitement des logs et de générateur de statistiques vous demande un format spécifique, ceci est cependant rare. 

Grâce à ces 2 instructions maintenant vous offrez à vos "clients" / "utilisateurs" la possibilité d'avoir accès à LEUR logs !

### <a name="organisation_rotation_logs_vhosts"/> Rotation des logs pour les serveurs virtuels

**ATTENTION** ce n'est pas fini , si nous laissons en l'état la configuration les fichiers __error.log__ et __access.log__ pour les serveurs virtuelles vont grossir de manière infinie. Résultat après 6 mois ou 1 an le fichier d'erreur ou d'accès fera plusieurs Gigs résultat ce sera dure à traiter. Il est important de mettre un système de rotation des logs avec une conservation de temps définie. 

* Fichier de logs / rotation des logs
* Répertoire privers 
* Utilisation du fichier htaccess 
* Permission Directory 
* Access au répertoire ecriture via Git :P / access au fichier scp , ssh , ...

# <a name="performance" /> Performance et analyse d'apache

* serveur __status__

TODO : ajouter l'information 

