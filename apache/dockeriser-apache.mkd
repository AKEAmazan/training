
<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>

TODO corriger les \_

# Index 


# <a name="dockeriser" /> Dockeriser Apache

Nous avons vu la configuration de apache, en long en large et en détail, nous allons maintenant voir comment __dockeriser__ apache . Comme toujours la partie __docker__ est optionnel , mais je trouve très intéressant pour standardiser vos déploiement. Je vais prendre le temps de présenter un mode simple de mise en place et d'adresser quelques problème que vous pourriez rencontrer.


## <a name="dockeriser_simple" /> Dockeriser Apache version simple 

Nous allons continuer d'utiliser le système Ubuntu pour faire le déploiement libre à vous de modifier la distribution bien entendu vous aurez des problèmes de chemin des fichiers si vous optez pour __CentOS__ et __RedHat__.

Nous avons déjà vu la création d'une image personnaliser docker, comme ça fait un petit peu de temps nous allons y aller tranquillement offrant la possibilité à tous le monde de ce rafraichir la mémoire. 

Nous allons mettre en place les bases en installant apache et ainsi que la structure des fichiers . Mettons en place une structure de travail :

        $ mkdir ~/git/mein_apache
        $ cd ~/git/mein_apache
        $ git init .
        $ touch Licence
        $ git add Licence
        $ git commit -a -m "Initialisation du dépot Git "
        $ vim Dockerfile

Je vous invite FORTEMENT à utiliser __git__ afin de conserver une traçabilité des modifications de votre Docker.

        $ cat Dockerfile
        # Définition de l'image de Base ( distribution )
        FROM i686/ubuntu
        MAINTAINER Boutry Thomas 'thomas.boutry@x3rus.com'

        # Activation du mode non interactif pour apt
        ENV DEBIAN_FRONTEND noninteractive

        # Installation des applications de Base
        RUN apt-get update && apt-get install -y \
          apache2 apache2-utils && apt-get clean

        # Fix timezone
        RUN ln -s -f /usr/share/zoneinfo/Canada/Eastern /etc/localtime

        # Port exposer 
        EXPOSE 80

        CMD ["/usr/sbin/apache2","-DFOREGROUND"]

Réalisons le __build__ de l'image en lui donnant un nom significatif dans mon cas : __apache-train__

        $ docker build -t apache-train . 
        [... OUTPUT COUPÉ ...]
        Step 5 : EXPOSE 80
         ---> Running in cb3cec30ef9c
         ---> 7648874030d3
        Removing intermediate container cb3cec30ef9c
        Step 6 : CMD /usr/sbin/apache2 -DFOREGROUND
         ---> Running in c37de7aa4829
         ---> 6c9f625812c5
        Removing intermediate container c37de7aa4829
        Successfully built 6c9f625812c5

On fait un test ?? Je vous dis tous de suite ça ne fonctionnera pas :P , c'est partie 

        $ docker run apache-train
        [Tue Jul 12 17:25:05.374632 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_LOCK_DIR} is not defined
        [Tue Jul 12 17:25:05.377490 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_PID_FILE} is not defined
        [Tue Jul 12 17:25:05.377522 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_RUN_USER} is not defined
        [Tue Jul 12 17:25:05.377529 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_RUN_GROUP} is not defined
        [Tue Jul 12 17:25:05.377556 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_LOG_DIR} is not defined
        [Tue Jul 12 17:25:05.396087 2016] [core:warn] [pid 1:tid 3075414656] AH00111: Config variable ${APACHE_LOG_DIR} is not defined
        [Tue Jul 12 17:25:05.397428 2016] [core:warn] [pid 1:tid 3075414656] AH00111: Config variable ${APACHE_LOG_DIR} is not defined
        [Tue Jul 12 17:25:05.397458 2016] [core:warn] [pid 1:tid 3075414656] AH00111: Config variable ${APACHE_LOG_DIR} is not defined
        AH00526: Syntax error on line 74 of /etc/apache2/apache2.conf:
        Invalid Mutex directory in argument file:${APACHE_LOCK_DIR}


Nous allons profiter de cette opportunité pour voir comment nous allons analyser ce problème , mon premier reflex et de démarrer la conteneur non plus en mode automatique avec exécution  de l'instruction **EXEC** contenu à la fin du __Dockerfile__

        [ ... OUTPUT COUPÉ ... ]
        # Port exposer 
        EXPOSE 80

        CMD ["/usr/sbin/apache2","-DFOREGROUND"]

Donc exécutons  le conteneur avec __bash__ en mode interactif :

        $ docker run -it apache-train bash
        root@46e37e65f98b:/# ip addr show
        [... OUTPUT COUPÉ ...]
        15: eth0@if16: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
            link/ether 02:42:ac:11:00:06 brd ff:ff:ff:ff:ff:ff
                inet 172.17.0.6/16 scope global eth0

Nous allons démarrer le service apache de la manière "classique" :

        root@46e37e65f98b:/# /etc/init.d/apache2 start
         * Starting web server apache2                                                                                                /usr/sbin/apache2ctl: 87: ulimit: error setting limit (Operation not permitted)
         Setting ulimit failed. See README.Debian for more information.
         AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.6. Set the 'ServerName' directive globally to suppress this message
         *
        root@46e37e65f98b:/# ps aux | grep apac
        root        37  0.0  0.2   5500  4124 ?        Ss   17:32   0:00 /usr/sbin/apache2 -k start
        www-data    40  0.0  0.1 228132  3744 ?        Sl   17:32   0:00 /usr/sbin/apache2 -k start
        www-data    41  0.0  0.1 228132  3832 ?        Sl   17:32   0:00 /usr/sbin/apache2 -k start

Si nous allons à l'URL : http://172.17.0.6/ ça fonctionne :

![default_page_ubuntu.png](./imgs/default_page_ubuntu.png)

Mais dans l'instruction du __Dockerfile__ ce n'est PAS __/etc/init.d/apache2 start__ qui est utilisé , essayons avec la commande dans le __Dockerfile__ :

        root@46e37e65f98b:/# /usr/sbin/apache2 -DFOREGROUND
        [Tue Jul 12 17:37:40.874436 2016] [core:warn] [pid 146] AH00111: Config variable ${APACHE_LOCK_DIR} is not defined
        [Tue Jul 12 17:37:40.874582 2016] [core:warn] [pid 146] AH00111: Config variable ${APACHE_PID_FILE} is not defined
        [Tue Jul 12 17:37:40.874623 2016] [core:warn] [pid 146] AH00111: Config variable ${APACHE_RUN_USER} is not defined
        [Tue Jul 12 17:37:40.874642 2016] [core:warn] [pid 146] AH00111: Config variable ${APACHE_RUN_GROUP} is not defined
        [Tue Jul 12 17:37:40.876067 2016] [core:warn] [pid 146] AH00111: Config variable ${APACHE_LOG_DIR} is not defined
        [Tue Jul 12 17:37:40.882795 2016] [core:warn] [pid 146:tid 3075172992] AH00111: Config variable ${APACHE_LOG_DIR} is not defined
        [Tue Jul 12 17:37:40.883647 2016] [core:warn] [pid 146:tid 3075172992] AH00111: Config variable ${APACHE_LOG_DIR} is not defined
        [Tue Jul 12 17:37:40.883699 2016] [core:warn] [pid 146:tid 3075172992] AH00111: Config variable ${APACHE_LOG_DIR} is not defined
        AH00526: Syntax error on line 74 of /etc/apache2/apache2.conf:
        Invalid Mutex directory in argument file:${APACHE_LOCK_DIR}

SUPER , on a pas la solution mais on peut le reproduire , mais pourquoi on utiliserai pas la commande qui fonctionne dans le __Dockerfile__. Le problème avec l'instruction du __service apache start__ est que le processus sera mis en arrière plan , donc le conteneur docker va démarrer , il va démarrer apache avec succès mais comme ce dernier sera en arrière plan le conteneur va s'arrêter . Démonstration :

        root@46e37e65f98b:/# exit

        $ tail Dockerfile 
        [... OUTPUT COUPÉ ...]
        # Port exposer
        EXPOSE 80

        CMD ["/etc/init.d/apache2","start"]

        $ docker build -t apache-train .
        [... OUTPUT COUPÉ ...]
        Step 5 : EXPOSE 80
         ---> Using cache
         ---> 7648874030d3
        Step 6 : CMD /etc/init.d/apache2 start
         ---> Running in 5921092110f2
         ---> 8bd040c92c51
        Removing intermediate container 5921092110f2
        Successfully built 8bd040c92c51

        $ docker  run apache-train
         * Starting web server apache2
        /usr/sbin/apache2ctl: 87: ulimit: error setting limit (Operation not permitted)
        Setting ulimit failed. See README.Debian for more information.
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.7. Set the 'ServerName' directive globally to suppress this message
        * 

        $ docker  ps
        CONTAINER ID     IMAGE         COMMAND        CREATED         STATUS       PORTS               NAMES

Donc le processus de création de l'image fut un succès mais lors de l'exécution, apache est démarrer mais comme le processus est en arrière plan le docker s'est arrêter avec succès. Nous le voyons lors de l'utilisation de la commande **docker ps** .

Revenons à la première tentative avec la mise en avant plan (__FOREGROUND__) du processus apache si nous regardons les erreurs que nous avions l'ensemble est dû à des variables d'environnement non définie. Lors de l'utilisation de la commande __Service__ ce dernier charge le fichier , si vous exécutez le conteneur __apache_train__ vous pourrez visualiser ce fichier :

        # cat /etc/apache2/envvars  | grep -v "^#" | grep -v "^$"
        unset HOME
        if [ "${APACHE_CONFDIR##/etc/apache2-}" != "${APACHE_CONFDIR}" ] ; then
            SUFFIX="-${APACHE_CONFDIR##/etc/apache2-}"
        else
           SUFFIX=
        fi
        export APACHE_RUN_USER=www-data
        export APACHE_RUN_GROUP=www-data
        export APACHE_PID_FILE=/var/run/apache2/apache2$SUFFIX.pid
        export APACHE_RUN_DIR=/var/run/apache2$SUFFIX
        export APACHE_LOCK_DIR=/var/lock/apache2$SUFFIX
        export APACHE_LOG_DIR=/var/log/apache2$SUFFIX
        export LANG=C
        export LANG

Si vous revitalisons les erreurs, nous pourrons constater ce manque :

        [Tue Jul 12 17:25:05.374632 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_LOCK_DIR} is not defined
        [Tue Jul 12 17:25:05.377490 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_PID_FILE} is not defined
        [Tue Jul 12 17:25:05.377522 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_RUN_USER} is not defined
        [Tue Jul 12 17:25:05.377529 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_RUN_GROUP} is not defined
        [Tue Jul 12 17:25:05.377556 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_LOG_DIR} is not defined

Afin de corriger ce problème lors de la création de l'image donc le __Dockerfile__ je vais pré définie ces variables . Ceci donne :

        $ cat Dockerfile
        [... OUTPUT COUPÉ ...]
        # Fix timezone
        RUN ln -s -f /usr/share/zoneinfo/Canada/Eastern /etc/localtime

        ENV APACHE_RUN_USER  www-data
        ENV APACHE_RUN_GROUP www-data
        ENV APACHE_PID_FILE  /var/run/apache2.pid
        ENV APACHE_RUN_DIR   /var/run/apache2
        ENV APACHE_LOCK_DIR  /var/lock/apache2
        ENV APACHE_LOG_DIR   /var/log/apache2

        # Port exposer 
        EXPOSE 80

        CMD ["/usr/sbin/apache2","-DFOREGROUND"]
         
Reprenons la création de l'image : 

        $ docker build -t apache-train .
        [... OUTPUT COUPÉ ...]
        Removing intermediate container 2be1c89d4526
        Step 10 : ENV APACHE_LOG_DIR /var/log/apache2
         ---> Running in 5eca720fb524
         ---> 7746103ca4f7
        Removing intermediate container 5eca720fb524
        Step 11 : EXPOSE 80
         ---> Running in 64727159ffb2
         ---> 3fc14f0e80ac
        Removing intermediate container 64727159ffb2
        Step 12 : CMD /usr/sbin/apache2 -DFOREGROUND
         ---> Running in 525ec50bd3aa
         ---> 52d35906d969
        Removing intermediate container 525ec50bd3aa
        Successfully built 52d35906d969

Exécutons l'image afin de créer le conteneur :

        $ docker  run apache-train
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message

Comme vous pouvez le constater le système ne vous redonne pas la main , vous avez le processus apache en avant plan , si vous prenez un autre terminal vous pourrez constater que le conteneur est bien en exécution

        $ docker  ps
        CONTAINER ID    IMAGE          COMMAND                CREATED              STATUS              PORTS    NAMES
        e03dc52435a9    apache-train   "/usr/sbin/apache2 -   About a minute ago   Up About a minute   80/tcp   angry_tesla

Afin de compléter la validation récupérons l'adresse IP du conteneur pour confirmer que nous voyons bien la page par défaut d'apache. Comme vous pouvez le voir la dernière colonne comprend le nom "générique" qui fut donné au conteneur dans le cas présent __angry_tesla__ , nous allons donc utiliser l'instruction __docker inspect__ afin d'extraire l'adresse IP qui fut alloué par __DHCP__ par le __deamon__ __docker__.

        $ docker inspect angry_tesla | grep IPAddress
                "IPAddress": "172.17.0.2",
                "SecondaryIPAddresses": null,

Donc si vous allez à l'URL : http://172.17.0.2 , vous aurez la page web par défaut d'apache . **Woot**, ça fonctionne , mais car il a souvent des mais , essayer sur une autre machine de votre réseau d'accéder à la page avec l'IP 172.17.0.2 , vous constaterez que ça ne fonctionne PAS  :-(. 

## <a name="dockeriser_network" /> Considération réseau pour le conteneur Apache

Nous avons un conteneur qui fonctionne la page par défaut d'apache s'affiche, mais ce n'est accessible que depuis la machine où roule le conteneur. Reprenons quelques minute pour parler de la réseautique sous docker , commençons par une représentation graphique des adresses IP et du réseau :

![docker-network-diagramme.png](./imgs/docker-network-diagramme.png)

Donc ici nous avons un docker __host__ qui à 2 conteneurs, __apache-train__ et __apache-test__ (manque d'imagination :P).

Le docker __host__ à l'IP 192.168.42.25 sur le réseau , si nous devons établir une connexion ssh, nous utilisons cette adresse IP . La machine docker gère un réseau "interne" pour les conteneurs le segment réseau choisie est __172.17.0.0/16__ ce segment réseau n'est connu QUE du docker __host__.
Lors de l'initialisation d'un nouveau conteneur :

1. docker initialise  l'instance du conteneur 
2. crée une interface virtuel qui sera  le docker __host__ exemple : **vethcdff57c** qui sera associé au conteneur 
3. Docker crée une interface **eth0** dans le conteneur et l'associer à l'interface créé soit **vethcdff57c**
4. Par la suite le docker __host__ pige dans son pool d'adresse IP et l'assigne au conteneur soit **172.17.0.4**

Donc le segment réseau 172.17.0.0/16 n'est connu QUE du docker __host__ il n'est pas possible de communiquer directement avec les conteneurs en utilisant leur IP interne. 

Oui mais pourtant j'arrive à me connecter depuis mon conteneur sur les dépôts de logiciel pour faire les installations, donc le réseau fonctionne même à l'extérieur . Effectivement les communications sortante fonctionne SANS problème ,est-ce de la magie ? 

J'aimerai vous dire oui, mais non ... La magie est réalisé par un système de **nat** (**N**etwork **A**ddress **T**ranslation). Heu et en français ça veut dire quoi ? 

Si vous réaliser la commande suivante si votre docker __host__ vous aurez quelque chose de similaire :

        $ sudo iptables -L -n -v -t nat
        [... OUTPUT COUPÉ ...]
        Chain POSTROUTING (policy ACCEPT 876 packets, 59176 bytes)
         pkts bytes target     prot opt in     out     source               destination
             0     0 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0

        [... OUTPUT COUPÉ ...]

Nous utilisons **iptables** qui est le __firewall__  interne à GNU/Linux , il est capable de faire du __nat__ aussi .

En gros l'instruction suivante veut dire , Si l'adresse IP source est dans le segment réseau 172.17.0.0/16 donc :

        $  ipcalc 172.17.0.0/16
        [... OUTPUT COUPÉ ...]
        HostMin:   172.17.0.1           10101100.00010001. 00000000.00000001
        HostMax:   172.17.255.254       10101100.00010001. 11111111.11111110

Donc si l'adresse de provenance est comprise entre l'IP 172.17.0.1 et 172.17.255.254 et que l'interface de destination n'est PAS **docker0** donc qui n'est pas une communication interne entre les conteneurs alors change l'adresse IP source afin de mettre l'adresse IP : 192.168.42.45 (la c'est implicite :P )

Donc voyons le chemin des paquets réseaux afin de clarifier la situation une petite image aide souvent dans l'explication :

![docker-network-NAT-diagramme.png](./imgs/docker-network-NAT-diagramme.png)

Si vous vous demandez comment le système est en mesure de transmettre l'information quand le serveur distant lui réponds , lorsqu'il y a changement d'adressage __iptables__ conserver une table de correspondance afin de gérer lorsque le paquets revient . Il refera le changement d'adressage mais au lieu de changer la Source du paquet il changera la destination , il remplacera 192.168.42.45 par l'IP du conteneur soit 172.17.0.6 dans notre exemple. 

Maintenant que l'explication sur les communications vers l'externe est réalisé comment on fait pour les communications initié depuis l'extérieur qui désire voir la page web dans le conteneur. Pour ce faire nous allons associé un port sur l'adresse IP "publique" sur le réseau qui sera associé avec le conteneur. En anglais / français on va faire un __port-forward__.

![docker-network-port-fw-diagramme.png](./imgs/docker-network-port-fw-diagramme.png)

Réalisons l'opération afin de confirmer que je ne vous ment pas :P , sans farce afin de voir le fonctionnement.

        $ docker  run  -p 80:80 apache-train 
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message

Nous utilisons l'option **-p** pour définir le port sur la machine local -> vers -> le port du conteneur . Si nous réalisons la commande **netstat** nous verrons le port disponible 

        $ sudo netstat -lntp | grep 80
        tcp6       0      0 :::80                   :::*                    LISTEN      4608/docker-proxy
        $ ps aux | grep 4608
        root      4608  0.0  0.7 837704 15600 ?        Sl   17:02   0:00 docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 80 -container-ip 172.17.0.6 -container-port 80


Maintenant nous pouvons accéder à page par défaut d'apache depuis l'ensemble du réseau en utilisant l'IP de la machine hôtes. Soit http://192.168.42.45.

Super donc nous avons un conteneur avec apache qui fonctionne , disponible sur l'ensemble du réseau , il est temps de mettre du contenu dessus . 

## <a name="dockeriser_site-web" /> Mise en place du site web

Nous arrivons tranquillement dans le dur, le mise en place du site web afin qu'il soit disponible pour tous. Plusieurs méthodes sont disponible pour cette opération, vous devrez choisir la plus approprié pour vous. Ce qui va probablement être un facteur décisionnel est la maturité de votre site , si ce dernier est plutôt statique ou énormément modifié.

Pour rappel , le système de docker fut originalement mis en place afin de fournir une application ou un service avec un __packging__ complet ( OS + application + ensemble des dépendances ... ) nous parlons donc de version final ou du moins qui sera __repackgé__ lors de modification nous allons donc voir la première méthode en utilisant ce mode. 


### <a name="dockeriser_site-web_git" /> Mise en place du site web via Git ou Subversion

Une méthode est de brûler dans l'image de base le site web, personnellement je trouve cette solution la meilleur , utiliser le contrôleur de révision ( __Git__ ou __subversion__ ou autre ) comme source. Rappelez vous de la formation __git__ vous pourriez faire appel à une branche spécifique afin d'avoir une version exacte de votre site web dans votre conteneur apache.

Voyons un exemple avec le dépôt git : [https://github.com/x3rus/siteweb\_formation](https://github.com/x3rus/siteweb_formation).

Nous avons un site web dans git composé de 3 branches : __master__, 2.0 et 2.1 .

Nous allons voir pour mettre en place les différentes version et la gestion de l'images . C'est partie modifions notre image afin d'avoir une page approprié avec la branche __master__



### <a name="dockeriser_site-web_git" /> Mise en place du site web via Git ou Subversion

### <a name="dockeriser_site-volume" /> Mise en place du site web avec un volume 


## <a name="dockeriser_config" /> Configuration Apache

## <a name="dockeriser_apache_logs" /> Visualisation des logs Apache

## <a name="dockeriser_reuse_imgs" /> Réutilisation des images docker

