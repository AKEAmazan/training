
<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>

TODO corriger les \_

# Index 


# <a name="dockeriser" /> Dockeriser Apache

Nous avons vu la configuration de apache, en long en large et en détail, nous allons maintenant voir comment __dockeriser__ apache . Comme toujours la partie __docker__ est optionnel , mais je trouve très intéressant pour standardiser vos déploiement. Je vais prendre le temps de présenter un mode simple de mise en place et d'adresser quelques problème que vous pourriez rencontrer.


## <a name="dockeriser_simple" /> Dockeriser Apache version simple 

Nous allons continuer d'utiliser le système Ubuntu pour faire le déploiement libre à vous de modifier la distribution bien entendu vous aurez des problèmes de chemin des fichiers si vous optez pour __CentOS__ et __RedHat__.

Nous avons déjà vu la création d'une image personnaliser docker, comme ça fait un petit peu de temps nous allons y aller tranquillement offrant la possibilité à tous le monde de ce rafraichir la mémoire. 

Nous allons mettre en place les bases en installant apache et ainsi que la structure des fichiers . Mettons en place une structure de travail :

        $ mkdir ~/git/mein_apache
        $ cd ~/git/mein_apache
        $ git init .
        $ touch Licence
        $ git add Licence
        $ git commit -a -m "Initialisation du dépot Git "
        $ vim Dockerfile

Je vous invite FORTEMENT à utiliser __git__ afin de conserver une traçabilité des modifications de votre Docker.

        $ cat Dockerfile
        # Définition de l'image de Base ( distribution )
        FROM i686/ubuntu
        MAINTAINER Boutry Thomas 'thomas.boutry@x3rus.com'

        # Activation du mode non interactif pour apt
        ENV DEBIAN_FRONTEND noninteractive

        # Installation des applications de Base
        RUN apt-get update && apt-get install -y \
          apache2 apache2-utils && apt-get clean

        # Fix timezone
        RUN ln -s -f /usr/share/zoneinfo/Canada/Eastern /etc/localtime

        # Port exposer 
        EXPOSE 80

        CMD ["/usr/sbin/apache2","-DFOREGROUND"]

Réalisons le __build__ de l'image en lui donnant un nom significatif dans mon cas : __apache-train__

        $ docker build -t apache-train . 
        [... OUTPUT COUPÉ ...]
        Step 5 : EXPOSE 80
         ---> Running in cb3cec30ef9c
         ---> 7648874030d3
        Removing intermediate container cb3cec30ef9c
        Step 6 : CMD /usr/sbin/apache2 -DFOREGROUND
         ---> Running in c37de7aa4829
         ---> 6c9f625812c5
        Removing intermediate container c37de7aa4829
        Successfully built 6c9f625812c5

On fait un test ?? Je vous dis tous de suite ça ne fonctionnera pas :P , c'est partie 

        $ docker run apache-train
        [Tue Jul 12 17:25:05.374632 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_LOCK_DIR} is not defined
        [Tue Jul 12 17:25:05.377490 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_PID_FILE} is not defined
        [Tue Jul 12 17:25:05.377522 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_RUN_USER} is not defined
        [Tue Jul 12 17:25:05.377529 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_RUN_GROUP} is not defined
        [Tue Jul 12 17:25:05.377556 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_LOG_DIR} is not defined
        [Tue Jul 12 17:25:05.396087 2016] [core:warn] [pid 1:tid 3075414656] AH00111: Config variable ${APACHE_LOG_DIR} is not defined
        [Tue Jul 12 17:25:05.397428 2016] [core:warn] [pid 1:tid 3075414656] AH00111: Config variable ${APACHE_LOG_DIR} is not defined
        [Tue Jul 12 17:25:05.397458 2016] [core:warn] [pid 1:tid 3075414656] AH00111: Config variable ${APACHE_LOG_DIR} is not defined
        AH00526: Syntax error on line 74 of /etc/apache2/apache2.conf:
        Invalid Mutex directory in argument file:${APACHE_LOCK_DIR}


Nous allons profiter de cette opportunité pour voir comment nous allons analyser ce problème , mon premier reflex et de démarrer la conteneur non plus en mode automatique avec exécution  de l'instruction **EXEC** contenu à la fin du __Dockerfile__

        [ ... OUTPUT COUPÉ ... ]
        # Port exposer 
        EXPOSE 80

        CMD ["/usr/sbin/apache2","-DFOREGROUND"]

Donc exécutons  le conteneur avec __bash__ en mode interactif :

        $ docker run -it apache-train bash
        root@46e37e65f98b:/# ip addr show
        [... OUTPUT COUPÉ ...]
        15: eth0@if16: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
            link/ether 02:42:ac:11:00:06 brd ff:ff:ff:ff:ff:ff
                inet 172.17.0.6/16 scope global eth0

Nous allons démarrer le service apache de la manière "classique" :

        root@46e37e65f98b:/# /etc/init.d/apache2 start
         * Starting web server apache2                                                                                                /usr/sbin/apache2ctl: 87: ulimit: error setting limit (Operation not permitted)
         Setting ulimit failed. See README.Debian for more information.
         AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.6. Set the 'ServerName' directive globally to suppress this message
         *
        root@46e37e65f98b:/# ps aux | grep apac
        root        37  0.0  0.2   5500  4124 ?        Ss   17:32   0:00 /usr/sbin/apache2 -k start
        www-data    40  0.0  0.1 228132  3744 ?        Sl   17:32   0:00 /usr/sbin/apache2 -k start
        www-data    41  0.0  0.1 228132  3832 ?        Sl   17:32   0:00 /usr/sbin/apache2 -k start

Si nous allons à l'URL : http://172.17.0.6/ ça fonctionne :

![default_page_ubuntu.png](./imgs/default_page_ubuntu.png)

Mais dans l'instruction du __Dockerfile__ ce n'est PAS __/etc/init.d/apache2 start__ qui est utilisé , essayons avec la commande dans le __Dockerfile__ :

        root@46e37e65f98b:/# /usr/sbin/apache2 -DFOREGROUND
        [Tue Jul 12 17:37:40.874436 2016] [core:warn] [pid 146] AH00111: Config variable ${APACHE_LOCK_DIR} is not defined
        [Tue Jul 12 17:37:40.874582 2016] [core:warn] [pid 146] AH00111: Config variable ${APACHE_PID_FILE} is not defined
        [Tue Jul 12 17:37:40.874623 2016] [core:warn] [pid 146] AH00111: Config variable ${APACHE_RUN_USER} is not defined
        [Tue Jul 12 17:37:40.874642 2016] [core:warn] [pid 146] AH00111: Config variable ${APACHE_RUN_GROUP} is not defined
        [Tue Jul 12 17:37:40.876067 2016] [core:warn] [pid 146] AH00111: Config variable ${APACHE_LOG_DIR} is not defined
        [Tue Jul 12 17:37:40.882795 2016] [core:warn] [pid 146:tid 3075172992] AH00111: Config variable ${APACHE_LOG_DIR} is not defined
        [Tue Jul 12 17:37:40.883647 2016] [core:warn] [pid 146:tid 3075172992] AH00111: Config variable ${APACHE_LOG_DIR} is not defined
        [Tue Jul 12 17:37:40.883699 2016] [core:warn] [pid 146:tid 3075172992] AH00111: Config variable ${APACHE_LOG_DIR} is not defined
        AH00526: Syntax error on line 74 of /etc/apache2/apache2.conf:
        Invalid Mutex directory in argument file:${APACHE_LOCK_DIR}

SUPER , on a pas la solution mais on peut le reproduire , mais pourquoi on utiliserai pas la commande qui fonctionne dans le __Dockerfile__. Le problème avec l'instruction du __service apache start__ est que le processus sera mis en arrière plan , donc le conteneur docker va démarrer , il va démarrer apache avec succès mais comme ce dernier sera en arrière plan le conteneur va s'arrêter . Démonstration :

        root@46e37e65f98b:/# exit

        $ tail Dockerfile 
        [... OUTPUT COUPÉ ...]
        # Port exposer
        EXPOSE 80

        CMD ["/etc/init.d/apache2","start"]

        $ docker build -t apache-train .
        [... OUTPUT COUPÉ ...]
        Step 5 : EXPOSE 80
         ---> Using cache
         ---> 7648874030d3
        Step 6 : CMD /etc/init.d/apache2 start
         ---> Running in 5921092110f2
         ---> 8bd040c92c51
        Removing intermediate container 5921092110f2
        Successfully built 8bd040c92c51

        $ docker  run apache-train
         * Starting web server apache2
        /usr/sbin/apache2ctl: 87: ulimit: error setting limit (Operation not permitted)
        Setting ulimit failed. See README.Debian for more information.
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.7. Set the 'ServerName' directive globally to suppress this message
        * 

        $ docker  ps
        CONTAINER ID     IMAGE         COMMAND        CREATED         STATUS       PORTS               NAMES

Donc le processus de création de l'image fut un succès mais lors de l'exécution, apache est démarrer mais comme le processus est en arrière plan le docker s'est arrêter avec succès. Nous le voyons lors de l'utilisation de la commande **docker ps** .

Revenons à la première tentative avec la mise en avant plan (__FOREGROUND__) du processus apache si nous regardons les erreurs que nous avions l'ensemble est dû à des variables d'environnement non définie. Lors de l'utilisation de la commande __Service__ ce dernier charge le fichier , si vous exécutez le conteneur __apache_train__ vous pourrez visualiser ce fichier :

        # cat /etc/apache2/envvars  | grep -v "^#" | grep -v "^$"
        unset HOME
        if [ "${APACHE_CONFDIR##/etc/apache2-}" != "${APACHE_CONFDIR}" ] ; then
            SUFFIX="-${APACHE_CONFDIR##/etc/apache2-}"
        else
           SUFFIX=
        fi
        export APACHE_RUN_USER=www-data
        export APACHE_RUN_GROUP=www-data
        export APACHE_PID_FILE=/var/run/apache2/apache2$SUFFIX.pid
        export APACHE_RUN_DIR=/var/run/apache2$SUFFIX
        export APACHE_LOCK_DIR=/var/lock/apache2$SUFFIX
        export APACHE_LOG_DIR=/var/log/apache2$SUFFIX
        export LANG=C
        export LANG

Si vous revitalisons les erreurs, nous pourrons constater ce manque :

        [Tue Jul 12 17:25:05.374632 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_LOCK_DIR} is not defined
        [Tue Jul 12 17:25:05.377490 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_PID_FILE} is not defined
        [Tue Jul 12 17:25:05.377522 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_RUN_USER} is not defined
        [Tue Jul 12 17:25:05.377529 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_RUN_GROUP} is not defined
        [Tue Jul 12 17:25:05.377556 2016] [core:warn] [pid 1] AH00111: Config variable ${APACHE_LOG_DIR} is not defined

Afin de corriger ce problème lors de la création de l'image donc le __Dockerfile__ je vais pré définie ces variables . Ceci donne :

        $ cat Dockerfile
        [... OUTPUT COUPÉ ...]
        # Fix timezone
        RUN ln -s -f /usr/share/zoneinfo/Canada/Eastern /etc/localtime

        ENV APACHE_RUN_USER  www-data
        ENV APACHE_RUN_GROUP www-data
        ENV APACHE_PID_FILE  /var/run/apache2.pid
        ENV APACHE_RUN_DIR   /var/run/apache2
        ENV APACHE_LOCK_DIR  /var/lock/apache2
        ENV APACHE_LOG_DIR   /var/log/apache2

        # Port exposer 
        EXPOSE 80

        CMD ["/usr/sbin/apache2","-DFOREGROUND"]
         
Reprenons la création de l'image : 

        $ docker build -t apache-train .
        [... OUTPUT COUPÉ ...]
        Removing intermediate container 2be1c89d4526
        Step 10 : ENV APACHE_LOG_DIR /var/log/apache2
         ---> Running in 5eca720fb524
         ---> 7746103ca4f7
        Removing intermediate container 5eca720fb524
        Step 11 : EXPOSE 80
         ---> Running in 64727159ffb2
         ---> 3fc14f0e80ac
        Removing intermediate container 64727159ffb2
        Step 12 : CMD /usr/sbin/apache2 -DFOREGROUND
         ---> Running in 525ec50bd3aa
         ---> 52d35906d969
        Removing intermediate container 525ec50bd3aa
        Successfully built 52d35906d969

Exécutons l'image afin de créer le conteneur :

        $ docker  run apache-train
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message

Comme vous pouvez le constater le système ne vous redonne pas la main , vous avez le processus apache en avant plan , si vous prenez un autre terminal vous pourrez constater que le conteneur est bien en exécution

        $ docker  ps
        CONTAINER ID    IMAGE          COMMAND                CREATED              STATUS              PORTS    NAMES
        e03dc52435a9    apache-train   "/usr/sbin/apache2 -   About a minute ago   Up About a minute   80/tcp   angry_tesla

Afin de compléter la validation récupérons l'adresse IP du conteneur pour confirmer que nous voyons bien la page par défaut d'apache. Comme vous pouvez le voir la dernière colonne comprend le nom "générique" qui fut donné au conteneur dans le cas présent __angry_tesla__ , nous allons donc utiliser l'instruction __docker inspect__ afin d'extraire l'adresse IP qui fut alloué par __DHCP__ par le __deamon__ __docker__.

        $ docker inspect angry_tesla | grep IPAddress
                "IPAddress": "172.17.0.2",
                "SecondaryIPAddresses": null,

Donc si vous allez à l'URL : http://172.17.0.2 , vous aurez la page web par défaut d'apache . **Woot**, ça fonctionne , mais car il a souvent des mais , essayer sur une autre machine de votre réseau d'accéder à la page avec l'IP 172.17.0.2 , vous constaterez que ça ne fonctionne PAS  :-(. 

## <a name="dockeriser_network" /> Considération réseau pour le conteneur Apache

Nous avons un conteneur qui fonctionne la page par défaut d'apache s'affiche, mais ce n'est accessible que depuis la machine où roule le conteneur. Reprenons quelques minute pour parler de la réseautique sous docker , commençons par une représentation graphique des adresses IP et du réseau :

![docker-network-diagramme.png](./imgs/docker-network-diagramme.png)

Donc ici nous avons un docker __host__ qui à 2 conteneurs, __apache-train__ et __apache-test__ (manque d'imagination :P).

Le docker __host__ à l'IP 192.168.42.25 sur le réseau , si nous devons établir une connexion ssh, nous utilisons cette adresse IP . La machine docker gère un réseau "interne" pour les conteneurs le segment réseau choisie est __172.17.0.0/16__ ce segment réseau n'est connu QUE du docker __host__.
Lors de l'initialisation d'un nouveau conteneur :

1. docker initialise  l'instance du conteneur 
2. crée une interface virtuel qui sera  le docker __host__ exemple : **vethcdff57c** qui sera associé au conteneur 
3. Docker crée une interface **eth0** dans le conteneur et l'associer à l'interface créé soit **vethcdff57c**
4. Par la suite le docker __host__ pige dans son pool d'adresse IP et l'assigne au conteneur soit **172.17.0.4**

Donc le segment réseau 172.17.0.0/16 n'est connu QUE du docker __host__ il n'est pas possible de communiquer directement avec les conteneurs en utilisant leur IP interne. 

Oui mais pourtant j'arrive à me connecter depuis mon conteneur sur les dépôts de logiciel pour faire les installations, donc le réseau fonctionne même à l'extérieur . Effectivement les communications sortante fonctionne SANS problème ,est-ce de la magie ? 

J'aimerai vous dire oui, mais non ... La magie est réalisé par un système de **nat** (**N**etwork **A**ddress **T**ranslation). Heu et en français ça veut dire quoi ? 

Si vous réaliser la commande suivante si votre docker __host__ vous aurez quelque chose de similaire :

        $ sudo iptables -L -n -v -t nat
        [... OUTPUT COUPÉ ...]
        Chain POSTROUTING (policy ACCEPT 876 packets, 59176 bytes)
         pkts bytes target     prot opt in     out     source               destination
             0     0 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0

        [... OUTPUT COUPÉ ...]

Nous utilisons **iptables** qui est le __firewall__  interne à GNU/Linux , il est capable de faire du __nat__ aussi .

En gros l'instruction suivante veut dire , Si l'adresse IP source est dans le segment réseau 172.17.0.0/16 donc :

        $  ipcalc 172.17.0.0/16
        [... OUTPUT COUPÉ ...]
        HostMin:   172.17.0.1           10101100.00010001. 00000000.00000001
        HostMax:   172.17.255.254       10101100.00010001. 11111111.11111110

Donc si l'adresse de provenance est comprise entre l'IP 172.17.0.1 et 172.17.255.254 et que l'interface de destination n'est PAS **docker0** donc qui n'est pas une communication interne entre les conteneurs alors change l'adresse IP source afin de mettre l'adresse IP : 192.168.42.45 (la c'est implicite :P )

Donc voyons le chemin des paquets réseaux afin de clarifier la situation une petite image aide souvent dans l'explication :

![docker-network-NAT-diagramme.png](./imgs/docker-network-NAT-diagramme.png)

Si vous vous demandez comment le système est en mesure de transmettre l'information quand le serveur distant lui réponds , lorsqu'il y a changement d'adressage __iptables__ conserver une table de correspondance afin de gérer lorsque le paquets revient . Il refera le changement d'adressage mais au lieu de changer la Source du paquet il changera la destination , il remplacera 192.168.42.45 par l'IP du conteneur soit 172.17.0.6 dans notre exemple. 

Maintenant que l'explication sur les communications vers l'externe est réalisé comment on fait pour les communications initié depuis l'extérieur qui désire voir la page web dans le conteneur. Pour ce faire nous allons associé un port sur l'adresse IP "publique" sur le réseau qui sera associé avec le conteneur. En anglais / français on va faire un __port-forward__.

![docker-network-port-fw-diagramme.png](./imgs/docker-network-port-fw-diagramme.png)

Réalisons l'opération afin de confirmer que je ne vous ment pas :P , sans farce afin de voir le fonctionnement.

        $ docker  run  -p 80:80 apache-train 
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message

Nous utilisons l'option **-p** pour définir le port sur la machine local -> vers -> le port du conteneur . Si nous réalisons la commande **netstat** nous verrons le port disponible 

        $ sudo netstat -lntp | grep 80
        tcp6       0      0 :::80                   :::*                    LISTEN      4608/docker-proxy
        $ ps aux | grep 4608
        root      4608  0.0  0.7 837704 15600 ?        Sl   17:02   0:00 docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 80 -container-ip 172.17.0.6 -container-port 80


Maintenant nous pouvons accéder à page par défaut d'apache depuis l'ensemble du réseau en utilisant l'IP de la machine hôtes. Soit http://192.168.42.45.

Super donc nous avons un conteneur avec apache qui fonctionne , disponible sur l'ensemble du réseau , il est temps de mettre du contenu dessus . 

## <a name="dockeriser_site-web" /> Mise en place du site web

Nous arrivons tranquillement dans le dur, le mise en place du site web afin qu'il soit disponible pour tous. Plusieurs méthodes sont disponible pour cette opération, vous devrez choisir la plus approprié pour vous. Ce qui va probablement être un facteur décisionnel est la maturité de votre site , si ce dernier est plutôt statique ou énormément modifié.

Pour rappel , le système de docker fut originalement mis en place afin de fournir une application ou un service avec un __packging__ complet ( OS + application + ensemble des dépendances ... ) nous parlons donc de version final ou du moins qui sera __repackgé__ lors de modification nous allons donc voir la première méthode en utilisant ce mode. 


### <a name="dockeriser_site-web_git" /> Mise en place du site web via Git ou Subversion

Une méthode est de brûler dans l'image de base le site web, personnellement je trouve cette solution la meilleur , utiliser le contrôleur de révision ( __Git__ ou __subversion__ ou autre ) comme source. Rappelez vous de la formation __git__ vous pourriez faire appel à une branche spécifique afin d'avoir une version exacte de votre site web dans votre conteneur apache.

Voyons un exemple avec le dépôt git : [https://github.com/x3rus/siteweb\_formation](https://github.com/x3rus/siteweb_formation).

Nous avons un site web dans git composé de 3 branches : __master__, 2.0 et 2.1 .

Nous allons voir pour mettre en place les différentes version et la gestion de l'images . C'est partie modifions notre image afin d'avoir une page approprié avec la branche __master__

        # Définition de l'image de Base ( distribution )
        FROM i686/ubuntu
        MAINTAINER Boutry Thomas 'thomas.boutry@x3rus.com'

        # Activation du mode non interactif pour apt
        ENV DEBIAN_FRONTEND noninteractive

        # Installation des applications de Base
        RUN apt-get update && apt-get install -y \
          apache2 apache2-utils git && apt-get clean

        # Fix timezone
        RUN ln -s -f /usr/share/zoneinfo/Canada/Eastern /etc/localtime

        ENV APACHE_RUN_USER  www-data
        ENV APACHE_RUN_GROUP www-data
        ENV APACHE_PID_FILE  /var/run/apache2.pid
        ENV APACHE_RUN_DIR   /var/run/apache2
        ENV APACHE_LOCK_DIR  /var/lock/apache2
        ENV APACHE_LOG_DIR   /var/log/apache2

        ENV SITE_DOCROOT /var/www/html/
        ENV SITE_REPO https://github.com/x3rus/siteweb_formation
        ENV SITE_VERSION master

        # Mise en place du site
        RUN rm -rf $SITE_DOCROOT  &&  git clone $SITE_REPO -b $SITE_VERSION $SITE_DOCROOT

        # Port exposer 
        EXPOSE 80

        CMD ["/usr/sbin/apache2","-DFOREGROUND"]

Petit ajustement dans la configuration premièrement en plus d'installer apache , nous installons l'application __git__ afin de nous permettre de récupérer la version du site web sur le dépôt. De plus j'ai défini 3 variables :

* __SITE\_DOCROOT__ : répertoire où nous installons le site web
* __SITE\_REPO__ : URL où faire le __checkout__ / la récupération du site web
* __SITE\_VERSION__ : la branche que je désire extraire

Si nous réalisons le __build__ et démarrons le conteneur nous aurons accès au site web .

        $ docker build -t apache-train .
        $ docker  run   apache-train
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.8. Set the 'ServerName' directive globally to suppress this message


Si nous désirons créer le conteneur pour la version 2.0 du site je n'ai qu'à modifier la variable __SITE\_VERSION__ . Bien entendu nous pourrions utiliser la même commande de __build__, mais profitons de l'occasion pour voir l'utilisation des __tags__ disponible pour l'image.

    $ cat Dockerfile
    [... OUTPUT COUPÉ ...]
    ENV SITE_DOCROOT /var/www/html/
    ENV SITE_REPO https://github.com/x3rus/siteweb_formation
    ENV SITE_VERSION 2.0

    # Mise en place du site
    RUN rm -rf $SITE_DOCROOT  &&  git clone $SITE_REPO -b $SITE_VERSION $SITE_DOCROOT
    [... OUTPUT COUPÉ ...]

    $ docker build -t apache-train:2.0 .
    [... OUTPUT COUPÉ ...]
    Step 11 : ENV SITE_DOCROOT /var/www/html/
     ---> Using cache
     ---> ffb88a8f9010
    Step 12 : ENV SITE_REPO https://github.com/x3rus/siteweb_formation
     ---> Using cache
     ---> 96a00982c41c
    Step 13 : ENV SITE_VERSION 2.0
     ---> Running in bb0f9948e540
     ---> bb0edcfebf23
    Removing intermediate container bb0f9948e540
    Step 14 : RUN rm -rf $SITE_DOCROOT  &&  git clone $SITE_REPO -b $SITE_VERSION $SITE_DOCROOT
     ---> Running in 620ecdce4428
    Cloning into '/var/www/html'...
     ---> 19218c816f5b
    Removing intermediate container 620ecdce4428
    Step 15 : EXPOSE 80
     ---> Running in 0f3595f15808
     ---> c74a55cf7036
    Removing intermediate container 0f3595f15808
    Step 16 : CMD /usr/sbin/apache2 -DFOREGROUND
     ---> Running in f56d32de0082
     ---> 8e8ba8bd17ac
    Removing intermediate container f56d32de0082
    Successfully built 8e8ba8bd17ac

Comme vous pouvez le constater l'ensemble de la création du conteneur ne fut pas refait, comme nous avions des couches de création similaire entre la version __master__ et la version __2.0__ il réutilise les couches de création jusqu'à la première différence.

Résultat si nous affichons les images disponible sur le système nous avons la version __master__ == __latest__ et la version 2.0 qui est nommé avec ce même numéro.

        $ docker  images | grep apache
        apache-train        2.0                 8e8ba8bd17ac        3 minutes ago       339.1 MB
        apache-train        latest              865ad6322b1b        18 minutes ago      339.1 MB

Maintenant vous pouvez démarrer la version de votre site web :

        $ docker  run   apache-train 
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.10. Set the 'ServerName' directive globally to suppress this message

        $ docker  run   apache-train:2.0
         AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.11. Set the 'ServerName' directive globally to suppress this message


### <a name="dockeriser_site-volume" /> Mise en place du site web avec un volume 

Pour les personnes ayant un site web "mature" qui ne bouge pas beaucoup ou qui est en évolution avec un système de __release__ bien définie ceci est très bien cependant si vous avez un petit site personnel qui bouge tranquillement dans le temps il est probable que cette solution soit contraignante. Nous allons donc voir une autre solution , nous allons extériorisé le site web du conteneur. Cette solution est moins belle , car n'ayant pas le site web inclut dans le conteneur ce dernier n'est pas complet , mais chacun ça réalité avec les contraintes.

Voyons le système de volume ce mécanisme permet de définir un répertoire du __docker host__ dans le conteneur. Je vais commencer par enlever la configuration la commande __git__ du __DockerFile__ afin de ne plus inclure le site web dans le conteneur.

Voici le résultat du __DockerFile__ :

        # Définition de l'image de Base ( distribution )
        FROM i686/ubuntu
        MAINTAINER Boutry Thomas 'thomas.boutry@x3rus.com'

        # Activation du mode non interactif pour apt
        ENV DEBIAN_FRONTEND noninteractive

        # Installation des applications de Base
        RUN apt-get update && apt-get install -y \
          apache2 apache2-utils git && apt-get clean

        # Fix timezone
        RUN ln -s -f /usr/share/zoneinfo/Canada/Eastern /etc/localtime

        ENV APACHE_RUN_USER  www-data
        ENV APACHE_RUN_GROUP www-data
        ENV APACHE_PID_FILE  /var/run/apache2.pid
        ENV APACHE_RUN_DIR   /var/run/apache2
        ENV APACHE_LOCK_DIR  /var/lock/apache2
        ENV APACHE_LOG_DIR   /var/log/apache2

        # Port exposer 
        EXPOSE 80

        CMD ["/usr/sbin/apache2","-DFOREGROUND"]

Je __build__ l'image avec le __tag:flat__ :

        $ docker build -t apache-train:flat .
        Sending build context to Docker daemon 44.54 kB
        Sending build context to Docker daemon
        Step 0 : FROM i686/ubuntu
         ---> 6a6004b92956
        [ ... OUTPUT COUPÉ ...]

        Removing intermediate container 71625a7802d8
        Successfully built 0e166a670d17

        $ docker  images | grep flat
        apache-train        flat                0e166a670d17        About a minute ago   338.6 MB

Si on démarre le conteneur nous aurons la page par défaut d'apache :

        $ docker  run apache-train:flat
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.1. Set the 'ServerName' directive globally to suppress this message

 
Arrêtons le conteneur et réalisons le point de montage / **volume**. Premièrement je crée le site web dans le répertoire __/data/apache/html__ et redémarre le conteneur apache avec le volume.

        $ sudo mkdir -p /data/apache/html
        $ sudo vim /data/apache/html/index.html
        $ sudo cat /data/apache/html/index.html
        Super site web directement
        dans le docker host

Démarrage du conteneur 

        $ docker  run -v /data/apache/html/:/var/www/html apache-train:flat
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message

Si nous allons à l'URL : http://172.17.0.2 , nous aurons la page précédemment créer , nous pouvons modifier le fichier __index.html__ sans être obligé de refaire / recréer un conteneur.

Mais je le répète cette solution à un inconvénient majeur le fait que le conteneur n'est pas complet cependant ceci vous permet d'isoler facilement votre application apache du reste du système. 
Comme j'aime moins cette solution je vais retourné à la méthode avec le système d'extraction du site avec __git__ , c'est ma formation je suis libre :P , par contre nous allons voir un usage intéressant du volume , tous de suite :D.

### <a name="dockeriser_volume4data" /> Conservation des données du sites (volume et nommage du conteneur)

Reprenons donc notre conteneur avec l'extraction du site avec le système de git , je vais aussi réaliser une petite modification afin d'avoir __php__ de présent afin de faire une démonstration. De plus j'ai créer la branche 2.2 du site web , car nous avons une nouvelle version celle ci utilisant __php__.

Voici le résultat du __DockerFile__ : 

        # Définition de l'image de Base ( distribution )
        FROM i686/ubuntu
        MAINTAINER Boutry Thomas 'thomas.boutry@x3rus.com'

        # Activation du mode non interactif pour apt
        ENV DEBIAN_FRONTEND noninteractive

        # Installation des applications de Base
        RUN apt-get update && apt-get install -y \
          apache2 apache2-utils git libapache2-mod-php5 && apt-get clean

        # Fix timezone
        RUN ln -s -f /usr/share/zoneinfo/Canada/Eastern /etc/localtime

        ENV APACHE_RUN_USER  www-data
        ENV APACHE_RUN_GROUP www-data
        ENV APACHE_PID_FILE  /var/run/apache2.pid
        ENV APACHE_RUN_DIR   /var/run/apache2
        ENV APACHE_LOCK_DIR  /var/lock/apache2
        ENV APACHE_LOG_DIR   /var/log/apache2

        ENV SITE_DOCROOT /var/www/html/
        ENV SITE_REPO https://github.com/x3rus/siteweb_formation
        ENV SITE_VERSION 2.2

        # Mise en place du site
        RUN rm -rf $SITE_DOCROOT  &&  git clone $SITE_REPO -b $SITE_VERSION $SITE_DOCROOT && \
            chown $APACHE_RUN_USER:$APACHE_RUN_GROUP $SITE_DOCROOT/data

        # Port exposer
        EXPOSE 80

        CMD ["/usr/sbin/apache2","-DFOREGROUND"]

Je réalise l'image __apache-train:2.2__ avec cette nouvelle configuration

        $ docker build -t apache-train:2.2 .

On l'exécute 

        $ docker run apache-train:2.2
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.7. Set the 'ServerName' directive globally to suppress this message

Si vous allez à la page web http://172.17.0.7 vous aurez la page avec le mouton, j'ai ajouté un petit fichier __php__ nommé __cfile.php__ ce dernier fait la création de 10 fichiers dans le répertoire __/var/www/html/data__ sur le serveur.

Regardons ensemble le mécanisme , avant de générer les fichiers nous allons voir le contenu du répertoire , pour ce faire nous allons allez en mode interactif dans le conteneur. J'utilise la commande **docker ps** pour lister les conteneurs en exécution. 

        $ docker ps
        CONTAINER ID    IMAGE             COMMAND                CREATED        STATUS         PORTS    NAMES
        e05bf8a9adae    apache-train:2.2  "/usr/sbin/apache2 -   4 seconds ago  Up 3 seconds   80/tcp   admiring_feynman

Nous voyons notre conteneur basé sur l'image **apache-train:2.2** , qui est en exécution depuis 4 secondes, le nom du conteneur est **admiring_feynman**. Je vais utilisé ce nom pour m'y connecter.

        $ docker exec -it admiring_feynman bash
        root@e05bf8a9adae:/# ls
        bin  boot  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
        root@e05bf8a9adae:/# ls /var/www/html/
        LICENSE  cfile.php  data  data.dtd  dessin_mouton.jpg  index.html
        root@e05bf8a9adae:/# ls /var/www/html/data
        README


Le site web est présent ainsi que le répertoire contenant les données , si nous accédons à l'URL __http://172.17.0.7/cfile.php__ vous devriez avoir l'information suivante dans votre browser :

        58
        58
        58
        58
        58
        58
        58
        58
        58
        58

De plus , nous aurons 10 fichiers dans le répertoire __/var/www/html/data__ :

        root@e05bf8a9adae:/# ls /var/www/html/data
        0.txt  1.txt  2.txt  3.txt  4.txt  5.txt  6.txt  7.txt  8.txt  9.txt  README

Si j'arrête le conteneur , et le redémarre , le tout proprement :

        root@e05bf8a9adae:/# exit
        $ docker  stop admiring_feynman
        $ docker run apache-train:2.2
        AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.8. Set the 'ServerName' directive globally to suppress this message


        $ docker  ps
        CONTAINER ID  IMAGE               COMMAND                CREATED         STATUS         PORTS    NAMES
        4dcddcf83a7b  apache-train:2.2    "/usr/sbin/apache2 -   48 seconds ago  Up 46 seconds  80/tcp   lonely_pare


        $ docker exec -it lonely_pare bash
        root@4dcddcf83a7b:/# ls /var/www/html/  
        LICENSE  cfile.php  data  data.dtd  dessin_mouton.jpg  index.html
        root@4dcddcf83a7b:/# ls /var/www/html/data
        README


ICI ICI ICI ICI << dire que les donneés perdu rappel layer write effemaire 

## <a name="dockeriser_config" /> Configuration Apache

## <a name="dockeriser_apache_logs" /> Visualisation des logs Apache

## <a name="dockeriser_reuse_imgs" /> Réutilisation des images docker

## <a name="dockeriser_fix_tempo" /> Correctif d'urgence

## <a name="dockeriser_dockercompose" /> Docker-Compose pour simplifier

