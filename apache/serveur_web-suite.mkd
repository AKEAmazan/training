<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>

TODO : Corriger les \_

# Index 


# <a name="redirect" /> Redirection d'URL

La manipulation des __URL__ est maintenant une pratique très courante dans l'industrie , les raisons sont multiple :

* Cacher la structure réelle des fichiers sur le système 
* Rediriger l'ensemble des requêtes vers un fichier principale (__.php__, ...)
* Rediriger les erreurs vers une page , plus jolie que l'erreur par défaut d'apache
* Migré un site web tout en conservant la structure original, afin de satisfaire les exigences client et les __référenceurs__ (__google__, __yahoo__, __altavista__ :P, ...)
* Rediriger les requêtes d'accès au site non chiffré (__http__) pour la version chiffré (**https**)
* Rediriger les requêtes des clients mobile vers un site plus adapté à l'équipement, voir bloquer les OS impures :P (c'est un blague)
* Traiter les arguments transmis dans l'URL pour un comportement particulier.
* ...

Nous allons voir quelques méthodes de mise en place de redirection , certaines configuration sont simple à mettre en place d'autre complexe. Nous verrons le système **mod_rewrite** qui permet de réaliser des configurations très complexe , je vous conseille d'avoir un environnement de teste avant d'essayer d'effectuer, les configurations directement en production. Une mauvaise configuration peut rendre votre site web inaccessible.

## <a name="simple_redirect" /> Redirection Simple

Avant de parler de [mod_rewrite](https://httpd.apache.org/docs/2.4/fr/mod/mod_rewrite.html) nous allons voir d'autre méthode de redirection. Bien que **mod_rewrite** peut répondre à l'ensemble des exemples couvert ci-dessous, il est plus simple d'utiliser des méthodes avec lesquelles nous sommes plus confortable, car plus simple. Libre à vous par la suite :P.


### <a name="html_redirect" /> Redirection avec un fichier html

Je sort un peu du cadre d'apache, cependant j'aime bien cette méthode, car elle est simple et n'oblige pas d'avoir un accès à la configuration apache. Il suffit de créer un fichier __index.html__ dans le répertoire désiré , par exemple la racine du site et de mettre le code de redirection .

Si nous prenons le __siteC__ que nous avons préalablement créé , si nous accédons au site site actuellement nous avons simplement le message : "Le site C ". Nous allons réaliser une redirection vers le site __google__ quand on accède au site.

Pour ce faire je vais modifier le fichier __index.html__ avec l'instruction suivant :

        <html>
          <head>
              <title>HTML redirect</title>
              <META http-equiv="refresh" content="5;URL=http://www.google.com">
          </head>
          <body bgcolor="#ffffff">
            <center>
                Vous allez etre redirigé dans 5 seconde vers google.com
            </center>
          </body>
        </html>


Ceci fonctionne très bien cependant ça ne fonctionne que si nous accédons à la racine du site web , en effet si on crée un fichier __info.html__ dans le __DocumentRoot__ et que l'on y accède directement nous ne serons pas redirigé . Démonstration !


        $ sudo vim info.html
        $ cat info.html
        un peu de texte pour fournir de l'information

Si vous accédez à http://www.sitec.com/info.html , telle que mentionné vous aurez le contenu du fichier sans aucune redirection. Il est possible que ceci soit ce que vous désirez, chaque problème à ça solution !

Référence :

* http://webmaster.iu.edu/tools-and-guides/maintenance/redirect-meta-refresh.phtml

### <a name="redirect_instruction" /> Redirection avec l'instruction redirect

Avant de voir le module **mod_rewrite** nous allons voir l'instruction [redirect](https://httpd.apache.org/docs/current/fr/mod/mod_alias.html#redirect) cette dernière fait partie du module **mod_alias**.

![redirect_screenshot-documentation.png](./imgs/redirect_screenshot-documentation.png)

Comme vous pouvez le voir dans la documentation l'instruction peut être utilisé dans plusieurs contexte de configuration :

* Configuration globale du serveur
* Un serveur virtuel (__Virtual host__)
* Un répertoire
* Un fichier __.htaccess__

Voici un exemple simple est très très classique de l'utilisation de l'instruction **redirect**, renvoyer l'ensemble des communications du site __http__ vers le mode __ssl__ __http__**S**.

Nous allons donc modifier la configuration du serveur virtuel __siteA__ afin que lors de la réception de requête sur le canal non chiffré l'ensemble soit redirigé vers le site en __SSL__.

Nous allons éditer le fichier **/etc/apache2/sites-available/siteA.conf** :

        $ sudo vim /etc/apache2/sites-available/siteA.conf
        $ cat siteA.conf

        <VirtualHost 172.17.0.1:80>
                ServerAdmin webmaster@localhost

                ServerName www.linux202-siteA.com
                ServerAlias linux202-siteA.com
                ServerAlias toto.linux202-siteA.com
                
                DocumentRoot /data/vhosts/siteA/docroot/
                
                Redirect / https://www.linux202-siteA.com/

               # Configuration des logs
               ErrorLog /data/vhosts/siteA/logs/error.log
               CustomLog /data/vhosts/siteA/logs/access.log combined
         </VirtualHost>

Si vous regardez le fichier original de configuration vous constaterez que j'ai supprimer l'ensemble des instructions en lien avec les permissions des répertoires. En effet j'ai enlever l'ensemble des instructions pour simplifier le fichier au maximum car de toute manière l'ensemble des instructions seront redirigé vers la configuration **SSL**.

Si vous réalisez quelques tests 

* http://www.linux202-sitea.com/ : Redirige effectivement vers le site en https://www.linux202-sitea.com/
* http://www.linux202-sitea.com/info.php : Redirige aussi vers le site en __https__ tous en conservant le fichier de référence.

Il est aussi possible de réaliser une redirection d'une section uniquement vers un site externe. Dans l'exemple suivant la section __/search__ redirigera vers le site **duckduckgo.com**.

        $ cat /etc/apache2/sites-available/siteA.conf
        [ ... OUTPUT COUPÉ ... ]
             DocumentRoot /data/vhosts/siteA/docroot/
              
             Redirect /search https://www.duckduckgo.com
             Redirect / https://www.linux202-siteA.com/
        [ ... OUTPUT COUPÉ ... ]


Ceci peut être très utile lorsque qu'il y a du mouvement dans l'organisation du site web. L'image corporative étant très importante de nos jours et le site web de service ou la compagnie est la vitrine de notre aptitude à gérer les changements. Un autre exemple d'expérience que j'ai eu est le changement de serveur pour fournir du contenu multimédia . Originalement l'ensemble du matériel était sur le serveur fournissant le service mais avec le temps l'espace ou la performance du serveur n'était plus au rendez-vous. Nous avons donc modifier le serveur afin que le répertoires __imgs__ soit redirigés vers http://img.corposite.com.

Autre exemple de situation la conversion de fichier __gif__ ou __bmp__ :P vers un format de fichier __png__ ou __jpg__. Nous avons l'instruction [RedirectMatch](https://httpd.apache.org/docs/current/fr/mod/mod_alias.html#redirectmatch), qui fonctionne comme l'instruction __Redirect__ mais nous permet d'utiliser des expressions régulière et des variables . Voici un exemple d'utilisation pour convertir les fichiers __gif__ vers __png__ .

        RedirectMatch "(.*)\.gif$" "https://www.linux202-sitea.com$1.png"

Mettons en place cette configuration :

        $ cat /etc/apache2/sites-enabled/siteA-ssl.conf

        <VirtualHost 172.17.0.1:443>
                ServerAdmin webmaster@localhost

                ServerName www.linux202-siteA.com
                ServerAlias linux202-siteA.com
                ServerAlias toto.linux202-siteA.com

                DocumentRoot /data/vhosts/siteA/docroot/

                Alias "/cm-images" "/data/vhosts/common/images"

                <Directory /data/vhosts/siteA/docroot/>
                    Options none
                    AllowOverride ALL
                    Require all granted
                </Directory>
                                                                                                                                              <Directory /data/vhosts/siteA/uploads/>
                    Options none
                    AllowOverride None
                    Require all granted
                </Directory>
                
                RedirectMatch "(.*)\.gif$" "https://www.linux202-sitea.com$1.png"
                [ ... OUTPUT COUPÉ ... ] 


Nous allons donc rediriger les requêtes dirigées vers les fichier **gif** vers les fichiers **png** . Avant d'activer cette configuration nous allons mettre un fichier __.gif__  et accéder à la page pour le visualiser voici le logo de la **FSF** .

* Version Gif 
    * ![Free_Software_Foundation_logo.gif](./imgs/Free_Software_Foundation_logo.gif)
* Version Png 
    * ![Free_Software_Foundation_logo.png](./imgs/Free_Software_Foundation_logo.png)

Copiez le dans le **DocumentRoot** du site et accédez à l'URL , dans mon cas :

        $ sudo cp Free_Software_Foundation_logo.gif /data/vhosts/siteA/docroot/
        $ sudo cp Free_Software_Foundation_logo.png /data/vhosts/siteA/docroot/

URL : https://www.linux202-sitea.com/Free_Software_Foundation_logo.gif

Activons maintenant la configuration de la redirection :

        $ sudo apachectl configtest && sudo /etc/init.d/apache2 restart

URL : https://www.linux202-sitea.com/Free_Software_Foundation_logo.png

Donc comme vous pouvez le constater nous voyons la redirection selon la configuration suivante la redirection aura lieu peut importe le répertoire où ce trouve le fichier. Si nous créons le répertoire **toto/blabla/** et mettons le fichier __png__ lors de l'accès la redirection aura lieu aussi , démonstration.

        $ sudo mkdir -p /data/vhosts/siteA/docroot/toto/blabal/
        $ sudo cp Free_Software_Foundation_logo.png /data/vhosts/siteA/docroot/toto/blabal/

URL : https://www.linux202-sitea.com/toto/blabla/Free_Software_Foundation_logo.png

Si nous regardons les logs nous voyons bien la redirection :

        $ tail /data/vhosts/siteA//logs/ssl_access.log
        172.17.42.1 - - [12/May/2016:08:38:01 -0400] "GET /toto/blabla/Free_Software_Foundation_logo.gif HTTP/1.1" 302 2373 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"
        172.17.42.1 - - [12/May/2016:08:38:01 -0400] "GET /toto/blabla/Free_Software_Foundation_logo.png HTTP/1.1" 304 209 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"

Revenons sur la ligne qui réalise cette magie :P , et prenons quelques minutes pour la comprendre :
        
        RedirectMatch "(.*)\.gif$" "https://www.linux202-sitea.com$1.png"

* **RedirectMatch** : Instruction contenu dans le module alias 
* **"(.*)\.gif$"**  : Ceci est certainement moins claire , ceci est une [expression régulière](https://fr.wikipedia.org/wiki/Expression_rationnelle) qui va traiter les requêtes et voir s'il y a action à apporter sur cette dernière c'est la condition . Les expressions régulière sont très importante car ceci vous permet de traiter des chaînes de caractères de manière conditionnel. Analysons donc ce que ceci veut dire, je reviendrais sur les parenthèses :
    * **.** == N'importe quelle caractère ceci peut être un espace , un chiffre, une lettre , ...
    * **\*** == l'étoile est un opérateur ceci correspond à ce qui le précède, répété zéro fois ou plusieurs fois. Donc si nous regardons l'ensemble ceci veut dire ( **.\***) n'importe quelle caractère zéro fois ou plusieurs fois .
    * **\\.** == Comme nous l'avons vu le point  (**.**) représente n'importe quelle caractère donc si nous désirons spécifier explicitement le caractère **.** nous devons le précéder d'un **\\** . 
    * **gif** == l'expression régulière s'attend donc a voir les caractères **gif**
    * **$** == Ce prédicat ne correspond à aucun caractère mais fixe une condition nécessaire permettant de trouver un accord sur ce qui le précède en indiquant que ce doit être à la fin d’une ligne (donc être à la fin du texte d’entrée ou juste avant un saut de ligne). 
    * **Résumé** : Quand l'URL est traitée , le système regarde tous les caractères qu'il soit présent 0 ou plusieurs fois (**.\***) , de plus il valide que l'URL traitée fini par **.gif**. L'utilisation des **()** permet de regroupé un ensemble de texte pour les réutiliser par la suite via les variables $1 , $2, $3 selon le nombre de parenthèse utilisées. Nous allons voir sont utilisation dans la prochaine instruction. 
* **"https://www.linux202-sitea.com$1.png"** : Dernier argument le lien où sera réalisé la redirection, telle que mentionné ci-dessus l'information contenu entre les parenthèses sera substitué au lieu de $1. Comme vous l'avez probablement constaté l'extension __.gif__ n'est pas contenu dans les parenthèses voilà pourquoi non réalisons le changement d'extension lors de la redirection avec le __.png__

Maintenant que nous avons traiter chaque argument voyons un peu d'exemple ceci simplifiera surement la compréhension .

Si nous prenons la requête : https://www.linux202-sitea.com/Free_Software_Foundation_logo.gif
Regardons l'entrée dans les logs

        172.17.42.1 - - [12/May/2016:08:27:36 -0400] "GET /Free_Software_Foundation_logo.gif HTTP/1.1" 302 681 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"


Du point de vu d'apache lors du traitement de l'instruction **RedirectMatch** ce dernier reçoit : **/Free_Software_Foundation_logo.gif** . 

0. Apache Reçoit dans le __VirtualHost__ : **/Free_Software_Foundation_logo.gif** 
1. Traitement de la règle de redirection :

        RedirectMatch "(.*)\.gif$" "https://www.linux202-sitea.com$1.png"
2. La requête __Match__  le critère si nous reprenons la __regex__  : **(.\*)\.gif$** ceci donne :

    * (.\*) == /Free_Software_Foundation_logo
    * \.gif$ == .gif

3. Réalisation de la redirection en substituant la variable $1 par le contenu de la variable :

    * "https://www.linux202-sitea.com$1.png" == "https://www.linux202-sitea.com/Free_Software_Foundation_logo.png"

Nous pouvons donc constaté que la formule fonctionne aussi bien si le fichier est dans un répertoire et non à la racine du site :

Si nous accédons à l'URL : https://www.linux202-sitea.com//toto/blabla/Free_Software_Foundation_logo.gif

        172.17.42.1 - - [12/May/2016:08:28:58 -0400] "GET /toto/blabla/Free_Software_Foundation_logo.gif HTTP/1.1" 302 705 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"

Du point de vu d'apache lors du traitement de l'instruction **RedirectMatch** ce dernier reçoit : **/toto/blabla/Free_Software_Foundation_logo.gif** . 

1. Décortiquons la __regex__ : **(.\*)\.gif$**

    * (.\*) == /toto/blabla/Free_Software_Foundation_logo
    * \.gif$ == .gif

2. Réalisation de la redirection en substituant la variable $1 par le contenu de la variable :

    * "https://www.linux202-sitea.com$1.png" == "https://www.linux202-sitea.com/toto/blabla/Free_Software_Foundation_logo.png"

Bien entendu, les opérations disponibles sont multiple avec les __regex__ ceci est uniquement un exemple , à vous de voir vos besoin.

Référence :

* https://httpd.apache.org/docs/current/fr/mod/mod_alias.html#redirect
* https://fr.wikipedia.org/wiki/Graphics_Interchange_Format
* https://fr.wikipedia.org/wiki/Portable_Network_Graphics

## <a name="mod_rewrite" /> Mod_rewrite pour réécrire les URL



Référence :

* https://httpd.apache.org/docs/2.4/fr/rewrite/remapping.html

# <a name="mod_proxy" /> Mod_proxy pour rediriger les requêtes
# <a name="mod_webdav" /> Mod_webdav pour avoir un lieu de stockage de fichiers

# <a name="performance" /> Performance et analyse d'apache




# <a name="auth_local_access" /> Autorisation d'accès avec authentification local

Nous allons maintenant revoir notre configuration pour l'accès au répertoire admin , au lieu d'utiliser un système de limitation par adresse ip, nous allons mettre en place une authentification local. La limitation par adresse ip c'est bien, malheureusement quand nous sommes en mouvement nous n'avons pas toujours la même adresse ip. Nous allons utiliser le module apache [mod\_authn\_core](https://httpd.apache.org/docs/2.4/mod/mod_authn_core.html#authtype). 

Commençons par valider que ce dernier est bien chargé :

        $ ls -l /etc/apache2/mods-enabled/*auth*
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/auth_basic.load -> ../mods-available/auth_basic.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/authn_core.load -> ../mods-available/authn_core.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/authn_file.load -> ../mods-available/authn_file.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/authz_core.load -> ../mods-available/authz_core.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/authz_host.load -> ../mods-available/authz_host.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/authz_user.load -> ../mods-available/authz_user.load

Comme nous pouvons le constater plusieurs module d'authentification sont chargé par défaut incluant [mod_authn_core](https://httpd.apache.org/docs/2.4/mod/mod_authn_core.html#authtype) (ligne 2 :P )

Pour information voici le contenu :

        $ cat /etc/apache2/mods-enabled/authn_core.load 
        LoadModule authn_core_module /usr/lib/apache2/modules/mod_authn_core.so

Apache charge un fichier **.so** qui est l'équivalent d'un **DLL** qui permet d'avoir une suite d'instruction en plus, disponible pour le service. Le module fut compilé pour la version spécifique d'Apache il n'est pas possible de prendre un module écrit pour la version 2.2 et le faire fonctionner sur la version 2.4 . Nous verrons plus en détail plus tard les modules apaches cependant il est bien d'avoir une compréhension, sommaire du fonctionnement.


Procédons à la modification du fichier de configuration de notre site par défaut (**/etc/apache2/sites-available/000-default.conf**). Voici la configuration :

        <Directory /data/www/admin >
            Options FollowSymLinks
            AllowOverride None
    
            #  Section d'authentification
            AuthType Basic
            AuthName "Authentication Required"
            AuthUserFile "/data/private-www/.htpasswd-admin"
            Require valid-user
        </Directory>

Analysons les paramètres :

* [AuthType](https://httpd.apache.org/docs/2.4/fr/mod/mod_authn_core.html#authtype) : Définie le type de module d'authentification , nous avions vu que plusieurs module été disponible dans le cas présent nous utiliserons le mode __Basic__. Il est important de souligné que dans le mode de communication actuelle le transfert du mot de passe est transmis en claire . Afin d'augmenter le niveau de sécurité nous devrions activer le support __SSL__ nous y reviendrons. Voici les type disponibles :
    * [Basic](https://httpd.apache.org/docs/2.4/fr/mod/mod_auth_basic.html) 
    * [Digest](https://httpd.apache.org/docs/2.4/fr/mod/mod_auth_digest.html)
    * [form](https://httpd.apache.org/docs/2.4/fr/mod/mod_auth_form.html)
* [AuthName](https://httpd.apache.org/docs/2.4/fr/mod/mod_authn_core.html#authname) : message affiché à l'utilisateur afin qu'il entre les informations d'authentification requis .
* [AuthUserFile](https://httpd.apache.org/docs/2.4/fr/mod/mod_authn_file.html#authuserfile) : Ficher local sur le serveur web contenant la liste des utilisateurs et mot de passe permettant de valider l'authentification des utilisateurs.
* [Require](https://httpd.apache.org/docs/2.4/fr/mod/mod_authz_core.html#require) : Instruction spécifiant le critère d'autorisation, dans les démonstrations passé nous avions utilisé les adresses ip comme critère ici nous pourrons utiliser des noms d'utilisateur ou définir comme dans le cas présent n'importe quelle utilisateur s'authentifiant avec succès. 


Validons qu'il n'y pas d'erreur syntaxique et rechargeons le fichier de configuration :

        $ sudo apache2ctl configtest && sudo service apache2 restart
        Syntax OK
        * Restarting web server apache2
        *    ...done.

Donc si nous allons à l'URL nous avons bien le message demandant le nom d'utilisateur et mot de passe :

![imgs/auth_admin-request.png](imgs/auth_admin-request.png)

Par contre, comme nous n'avons jamais définie de nom d'usagé / mot de passe quand on rentre n'importe quoi nous avons une [erreur 500](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#5xx_Server_Error) indiquant un problème sur le serveur. Le message d'erreur sur le serveur est très claire :

        $ sudo tail /var/log/apache2/error.log
        [Tue Dec 01 08:40:05.516453 2015] [authn_file:error] [pid 457:tid 2869857088] (2)No such file or directory: [client 172.17.42.1:52744] AH01620: Could not open password file: /data/private-www/.htpasswd-admin


## <a name="htpasswd" /> Création du fichier de mot de passe ( __htpasswd__ )

Pour réaliser la création du fichier contenant le nom d'utilisateur et le mot de passe nous avons besoin de l'application **htpasswd** , cette application est disponible dans le pacquage : **apache2-utils**

        $ sudo apt-get install apache2-utils

Nous allons faire la création du fichier :

        $ sudo mkdir /data/private-www/
        $ sudo htpasswd -c /data/private-www/.htpasswd-admin admin
        New password:
        Re-type new password:
        Adding password for user admin
        $ sudo htpasswd  /data/private-www/.htpasswd-admin robert
        New password: 
        Re-type new password: 
        Adding password for user robert

**IMPORTANT** : entre le 2 commandes il y a une différence, pour réaliser la création du fichier j'ai utilisé l'option **-c** par la suite je ne l'utilise pas . En fait il faut surtout pas que je l'utilise sinon ça vide le fichier pour créer un nouveau fichier , nous perdons donc l'information :-/ . Ouin c'est dangereux, heureusement que vous savez ce que vous faites :D, sinon il y a les backups ...

Visualisons le contenu du fichier, dans les 2 cas j'ai mis le même mot de passe (toto) :

        $ cat /data/private-www/.htpasswd-admin
        admin:$apr1$6gHZyTty$lxisZ66JPD7yK6K8fcXlU.
        robert:$apr1$fUI6se3h$40k/ftJPUtVOrptHlMiYB0

Si nous retournons à l'URL nous devrions avoir une authentification avec succès avec l'un ou l'autre des utilisateurs. La page indiquant que nous sommes dans une "section prive" devrais s'afficher.


# <a name="Reference" /> Référence :

* [Documentation Apache 2.4](https://httpd.apache.org/docs/2.4/) : https://httpd.apache.org/docs/2.4/
* [Liste des code d'état du protocole http](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes): https://en.wikipedia.org/wiki/List_of_HTTP_status_codes


## <a name="compilation_module" /> Compilation d'un modules apache (a valider)

TODO : a analyser 

https://httpd.apache.org/docs/2.4/developer/modguide.html

ODO: demontration du symlink vers /etc/passwd == sudo ln -s /etc/ /var/www/html/sys
