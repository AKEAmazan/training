<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>

TODO : Corriger les \_

# Index 

## <a name="compilation_module" /> Compilation d'un modules apache (a valider)

TODO : a analyser 

https://httpd.apache.org/docs/2.4/developer/modguide.html


# <a name="redirect" /> Redirection d'URL

La manipulation des __URL__ est maintenant une pratique très courante dans l'industrie , les raisons sont multiple :

* Cacher la structure réelle des fichiers sur le système 
* Rediriger l'ensemble des requêtes vers un fichier principale (__.php__, ...)
* Rediriger les erreurs vers une page , plus jolie que l'erreur par défaut d'apache
* Migré un site web tout en conservant la structure original, afin de satisfaire les exigences client et les __référenceurs__ (__google__, __yahoo__, __altavista__ :P, ...)
* Rediriger les requêtes d'accès au site non chiffré (__http__) pour la version chiffré (**https**)
* Rediriger les requêtes des clients mobile vers un site plus adapté à l'équipement, voir bloquer les OS impures :P (c'est un blague)
* Traiter les arguments transmis dans l'URL pour un comportement particulier.
* ...

Nous allons voir quelques méthodes de mise en place de redirection , certaines configuration sont simple à mettre en place d'autre complexe. Nous verrons le système **mod_rewrite** qui permet de réaliser des configurations très complexe , je vous conseille d'avoir un environnement de teste avant d'essayer d'effectuer, les configurations directement en production. Une mauvaise configuration peut rendre votre site web inaccessible.

## <a name="simple_redirect" /> Redirection Simple

Avant de parler de [mod_rewrite](https://httpd.apache.org/docs/2.4/fr/mod/mod_rewrite.html) nous allons voir d'autre méthode de redirection. Bien que **mod_rewrite** peut répondre à l'ensemble des exemples couvert ci-dessous, il est plus simple d'utiliser des méthodes avec lesquelles nous sommes plus confortable, car plus simple. Libre à vous par la suite :P.


### <a name="html_redirect" /> Redirection avec un fichier html

Je sort un peu du cadre d'apache, cependant j'aime bien cette méthode ... TODO : http://webmaster.iu.edu/tools-and-guides/maintenance/redirect-meta-refresh.phtml


## <a name="mod_rewrite" /> Mod_rewrite pour réécrire les URL

# <a name="mod_proxy" /> Mod_proxy pour rediriger les requêtes
# <a name="mod_rewrite" /> Mod_webdav pour avoir un lieu de stockage de fichiers

# <a name="performance" /> Performance et analyse d'apache




# <a name="auth_local_access" /> Autorisation d'accès avec authentification local

Nous allons maintenant revoir notre configuration pour l'accès au répertoire admin , au lieu d'utiliser un système de limitation par adresse ip, nous allons mettre en place une authentification local. La limitation par adresse ip c'est bien, malheureusement quand nous sommes en mouvement nous n'avons pas toujours la même adresse ip. Nous allons utiliser le module apache [mod\_authn\_core](https://httpd.apache.org/docs/2.4/mod/mod_authn_core.html#authtype). 

Commençons par valider que ce dernier est bien chargé :

        $ ls -l /etc/apache2/mods-enabled/*auth*
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/auth_basic.load -> ../mods-available/auth_basic.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/authn_core.load -> ../mods-available/authn_core.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/authn_file.load -> ../mods-available/authn_file.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/authz_core.load -> ../mods-available/authz_core.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/authz_host.load -> ../mods-available/authz_host.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/authz_user.load -> ../mods-available/authz_user.load

Comme nous pouvons le constater plusieurs module d'authentification sont chargé par défaut incluant [mod_authn_core](https://httpd.apache.org/docs/2.4/mod/mod_authn_core.html#authtype) (ligne 2 :P )

Pour information voici le contenu :

        $ cat /etc/apache2/mods-enabled/authn_core.load 
        LoadModule authn_core_module /usr/lib/apache2/modules/mod_authn_core.so

Apache charge un fichier **.so** qui est l'équivalent d'un **DLL** qui permet d'avoir une suite d'instruction en plus, disponible pour le service. Le module fut compilé pour la version spécifique d'Apache il n'est pas possible de prendre un module écrit pour la version 2.2 et le faire fonctionner sur la version 2.4 . Nous verrons plus en détail plus tard les modules apaches cependant il est bien d'avoir une compréhension, sommaire du fonctionnement.


Procédons à la modification du fichier de configuration de notre site par défaut (**/etc/apache2/sites-available/000-default.conf**). Voici la configuration :

        <Directory /data/www/admin >
            Options FollowSymLinks
            AllowOverride None
    
            #  Section d'authentification
            AuthType Basic
            AuthName "Authentication Required"
            AuthUserFile "/data/private-www/.htpasswd-admin"
            Require valid-user
        </Directory>

Analysons les paramètres :

* [AuthType](https://httpd.apache.org/docs/2.4/fr/mod/mod_authn_core.html#authtype) : Définie le type de module d'authentification , nous avions vu que plusieurs module été disponible dans le cas présent nous utiliserons le mode __Basic__. Il est important de souligné que dans le mode de communication actuelle le transfert du mot de passe est transmis en claire . Afin d'augmenter le niveau de sécurité nous devrions activer le support __SSL__ nous y reviendrons. Voici les type disponibles :
    * [Basic](https://httpd.apache.org/docs/2.4/fr/mod/mod_auth_basic.html) 
    * [Digest](https://httpd.apache.org/docs/2.4/fr/mod/mod_auth_digest.html)
    * [form](https://httpd.apache.org/docs/2.4/fr/mod/mod_auth_form.html)
* [AuthName](https://httpd.apache.org/docs/2.4/fr/mod/mod_authn_core.html#authname) : message affiché à l'utilisateur afin qu'il entre les informations d'authentification requis .
* [AuthUserFile](https://httpd.apache.org/docs/2.4/fr/mod/mod_authn_file.html#authuserfile) : Ficher local sur le serveur web contenant la liste des utilisateurs et mot de passe permettant de valider l'authentification des utilisateurs.
* [Require](https://httpd.apache.org/docs/2.4/fr/mod/mod_authz_core.html#require) : Instruction spécifiant le critère d'autorisation, dans les démonstrations passé nous avions utilisé les adresses ip comme critère ici nous pourrons utiliser des noms d'utilisateur ou définir comme dans le cas présent n'importe quelle utilisateur s'authentifiant avec succès. 


Validons qu'il n'y pas d'erreur syntaxique et rechargeons le fichier de configuration :

        $ sudo apache2ctl configtest && sudo service apache2 restart
        Syntax OK
        * Restarting web server apache2
        *    ...done.

Donc si nous allons à l'URL nous avons bien le message demandant le nom d'utilisateur et mot de passe :

![imgs/auth_admin-request.png](imgs/auth_admin-request.png)

Par contre, comme nous n'avons jamais définie de nom d'usagé / mot de passe quand on rentre n'importe quoi nous avons une [erreur 500](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#5xx_Server_Error) indiquant un problème sur le serveur. Le message d'erreur sur le serveur est très claire :

        $ sudo tail /var/log/apache2/error.log
        [Tue Dec 01 08:40:05.516453 2015] [authn_file:error] [pid 457:tid 2869857088] (2)No such file or directory: [client 172.17.42.1:52744] AH01620: Could not open password file: /data/private-www/.htpasswd-admin


## <a name="htpasswd" /> Création du fichier de mot de passe ( __htpasswd__ )

Pour réaliser la création du fichier contenant le nom d'utilisateur et le mot de passe nous avons besoin de l'application **htpasswd** , cette application est disponible dans le pacquage : **apache2-utils**

        $ sudo apt-get install apache2-utils

Nous allons faire la création du fichier :

        $ sudo mkdir /data/private-www/
        $ sudo htpasswd -c /data/private-www/.htpasswd-admin admin
        New password:
        Re-type new password:
        Adding password for user admin
        $ sudo htpasswd  /data/private-www/.htpasswd-admin robert
        New password: 
        Re-type new password: 
        Adding password for user robert

**IMPORTANT** : entre le 2 commandes il y a une différence, pour réaliser la création du fichier j'ai utilisé l'option **-c** par la suite je ne l'utilise pas . En fait il faut surtout pas que je l'utilise sinon ça vide le fichier pour créer un nouveau fichier , nous perdons donc l'information :-/ . Ouin c'est dangereux, heureusement que vous savez ce que vous faites :D, sinon il y a les backups ...

Visualisons le contenu du fichier, dans les 2 cas j'ai mis le même mot de passe (toto) :

        $ cat /data/private-www/.htpasswd-admin
        admin:$apr1$6gHZyTty$lxisZ66JPD7yK6K8fcXlU.
        robert:$apr1$fUI6se3h$40k/ftJPUtVOrptHlMiYB0

Si nous retournons à l'URL nous devrions avoir une authentification avec succès avec l'un ou l'autre des utilisateurs. La page indiquant que nous sommes dans une "section prive" devrais s'afficher.


# <a name="Reference" /> Référence :

* [Documentation Apache 2.4](https://httpd.apache.org/docs/2.4/) : https://httpd.apache.org/docs/2.4/
* [Liste des code d'état du protocole http](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes): https://en.wikipedia.org/wiki/List_of_HTTP_status_codes


TODO: demontration du symlink vers /etc/passwd == sudo ln -s /etc/ /var/www/html/sys
