<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>

# Index 

* [ Redirection d'URL](#redirect) 
       * [ Redirection Simple](#simple_redirect) 
           * [ Redirection avec un fichier html](#html_redirect) 
           * [ Redirection avec l'instruction redirect](#redirect_instruction) 
           * [ Redirection avec l'instruction RedirectMatch](#redirectMatch_instruction) 
       * [ Mod\_rewrite pour réécrire les URL](#mod_rewrite) 
           * [ Réécriture des images gif vers png](#mod_rewrite-RewriteImgs) 
           * [ Mise en place de condition de réécriture ](#mod_rewrite-RewriteCond) 
               * [ Mise en place de condition de réécriture selon le fureteur](#mod_rewrite-RewriteCond_browser) 
               * [ Mise en place de condition de réécriture selon l'origine](#mod_rewrite-RewriteCond_refferrer) 
               * [ Mise en place de redirection sur le PATH de l'URL](#mod_rewrite-RewriteCond_path) 
               * [ Quand ne pas utiliser mod\_rewrite](#mod_rewrite-avoid) 

# <a name="redirect" /> Redirection d'URL

La manipulation des __URL__ est maintenant une pratique très courante dans l'industrie , les raisons sont multiple :

* Cacher la structure réelle des fichiers sur le système 
* Rediriger l'ensemble des requêtes vers un fichier principale (__.php__, ...)
* Rediriger les erreurs vers une page , plus jolie que l'erreur par défaut d'apache
* Migré un site web tout en conservant la structure original, afin de satisfaire les exigences client et les __référenceurs__ (__google__, __yahoo__, __altavista__ :P, ...)
* Rediriger les requêtes d'accès au site non chiffré (__http__) pour la version chiffré (**https**)
* Rediriger les requêtes des clients mobile vers un site plus adapté à l'équipement, voir bloquer les OS impures :P (c'est un blague)
* Traiter les arguments transmis dans l'URL pour un comportement particulier.
* ...

Nous allons voir quelques méthodes de mise en place de redirection , certaines configuration sont simple à mettre en place d'autre complexe. Nous verrons le système **mod\_rewrite** qui permet de réaliser des configurations très complexe , je vous conseille d'avoir un environnement de teste avant d'essayer d'effectuer, les configurations directement en production. Une mauvaise configuration peut rendre votre site web inaccessible.

## <a name="simple_redirect" /> Redirection Simple

Avant de parler de [mod\_rewrite](https://httpd.apache.org/docs/2.4/fr/mod/mod_rewrite.html) nous allons voir d'autre méthode de redirection. Bien que **mod\_rewrite** peut répondre à l'ensemble des exemples couvert ci-dessous, il est plus simple d'utiliser des méthodes avec lesquelles nous sommes plus confortable, car plus simple. Libre à vous par la suite :P.


### <a name="html_redirect" /> Redirection avec un fichier html

Je sort un peu du cadre d'apache, cependant j'aime bien cette méthode, car elle est simple et n'oblige pas d'avoir un accès à la configuration apache. Il suffit de créer un fichier __index.html__ dans le répertoire désiré , par exemple la racine du site et de mettre le code de redirection .

Si nous prenons le __siteC__ que nous avons préalablement créé , si nous accédons au site site actuellement nous avons simplement le message : "Le site C ". Nous allons réaliser une redirection vers le site __google__ quand on accède au site.

Pour ce faire je vais modifier le fichier __index.html__ avec l'instruction suivant :

        <html>
          <head>
              <title>HTML redirect</title>
              <META http-equiv="refresh" content="5;URL=http://www.google.com">
          </head>
          <body bgcolor="#ffffff">
            <center>
                Vous allez etre redirigé dans 5 seconde vers google.com
            </center>
          </body>
        </html>


Ceci fonctionne très bien cependant ça ne fonctionne que si nous accédons à la racine du site web , en effet si on crée un fichier __info.html__ dans le __DocumentRoot__ et que l'on y accède directement nous ne serons pas redirigé . Démonstration !


        $ sudo vim info.html
        $ cat info.html
        un peu de texte pour fournir de l'information

Si vous accédez à http://www.sitec.com/info.html , telle que mentionné vous aurez le contenu du fichier sans aucune redirection. Il est possible que ceci soit ce que vous désirez, chaque problème à ça solution !

Référence :

* http://webmaster.iu.edu/tools-and-guides/maintenance/redirect-meta-refresh.phtml

### <a name="redirect_instruction" /> Redirection avec l'instruction redirect

Avant de voir le module **mod\_rewrite** nous allons voir l'instruction [redirect](https://httpd.apache.org/docs/current/fr/mod/mod_alias.html#redirect) cette dernière fait partie du module **mod\_alias**.

![redirect_screenshot-documentation.png](./imgs/redirect_screenshot-documentation.png)

Comme vous pouvez le voir dans la documentation l'instruction peut être utilisé dans plusieurs contexte de configuration :

* Configuration globale du serveur
* Un serveur virtuel (__Virtual host__)
* Un répertoire
* Un fichier __.htaccess__

Voici un exemple simple est très très classique de l'utilisation de l'instruction **redirect**, renvoyer l'ensemble des communications du site __http__ vers le mode __ssl__ __http__**S**.

Nous allons donc modifier la configuration du serveur virtuel __siteA__ afin que lors de la réception de requête sur le canal non chiffré l'ensemble soit redirigé vers le site en __SSL__.

Nous allons éditer le fichier **/etc/apache2/sites-available/siteA.conf** :

        $ sudo vim /etc/apache2/sites-available/siteA.conf
        $ cat siteA.conf

        <VirtualHost 172.17.0.1:80>
                ServerAdmin webmaster@localhost

                ServerName www.linux202-siteA.com
                ServerAlias linux202-siteA.com
                ServerAlias toto.linux202-siteA.com
                
                DocumentRoot /data/vhosts/siteA/docroot/
                
                Redirect / https://www.linux202-siteA.com/

               # Configuration des logs
               ErrorLog /data/vhosts/siteA/logs/error.log
               CustomLog /data/vhosts/siteA/logs/access.log combined
         </VirtualHost>

Si vous regardez le fichier original de configuration vous constaterez que j'ai supprimer l'ensemble des instructions en lien avec les permissions des répertoires. En effet j'ai enlever l'ensemble des instructions pour simplifier le fichier au maximum car de toute manière l'ensemble des instructions seront redirigé vers la configuration **SSL**.

Si vous réalisez quelques tests 

* http://www.linux202-sitea.com/ : Redirige effectivement vers le site en https://www.linux202-sitea.com/
* http://www.linux202-sitea.com/info.php : Redirige aussi vers le site en __https__ tous en conservant le fichier de référence.

Il est aussi possible de réaliser une redirection d'une section uniquement vers un site externe. Dans l'exemple suivant la section __/search__ redirigera vers le site **duckduckgo.com**.

        $ cat /etc/apache2/sites-available/siteA.conf
        [ ... OUTPUT COUPÉ ... ]
             DocumentRoot /data/vhosts/siteA/docroot/
              
             Redirect /search https://www.duckduckgo.com
             Redirect / https://www.linux202-siteA.com/
        [ ... OUTPUT COUPÉ ... ]


Ceci peut être très utile lorsque qu'il y a du mouvement dans l'organisation du site web. L'image corporative étant très importante de nos jours et le site web de service ou la compagnie est la vitrine de notre aptitude à gérer les changements. Un autre exemple d'expérience que j'ai eu est le changement de serveur pour fournir du contenu multimédia . Originalement l'ensemble du matériel était sur le serveur fournissant le service mais avec le temps l'espace ou la performance du serveur n'était plus au rendez-vous. Nous avons donc modifier le serveur afin que le répertoires __imgs__ soit redirigés vers http://img.corposite.com.

### <a name="redirectMatch_instruction" /> Redirection avec l'instruction RedirectMatch

Autre exemple de situation la conversion de fichier __gif__ ou __bmp__ :P vers un format de fichier __png__ ou __jpg__. Nous avons l'instruction [RedirectMatch](https://httpd.apache.org/docs/current/fr/mod/mod_alias.html#redirectmatch), qui fonctionne comme l'instruction __Redirect__ mais nous permet d'utiliser des expressions régulière et des variables . Voici un exemple d'utilisation pour convertir les fichiers __gif__ vers __png__ .

        RedirectMatch "(.*)\.gif$" "https://www.linux202-sitea.com$1.png"

Mettons en place cette configuration :

        $ cat /etc/apache2/sites-enabled/siteA-ssl.conf

        <VirtualHost 172.17.0.1:443>
                ServerAdmin webmaster@localhost

                ServerName www.linux202-siteA.com
                ServerAlias linux202-siteA.com
                ServerAlias toto.linux202-siteA.com

                DocumentRoot /data/vhosts/siteA/docroot/

                Alias "/cm-images" "/data/vhosts/common/images"

                <Directory /data/vhosts/siteA/docroot/>
                    Options none
                    AllowOverride ALL
                    Require all granted
                </Directory>
                                                                                                                                              <Directory /data/vhosts/siteA/uploads/>
                    Options none
                    AllowOverride None
                    Require all granted
                </Directory>
                
                RedirectMatch "(.*)\.gif$" "https://www.linux202-sitea.com$1.png"
                [ ... OUTPUT COUPÉ ... ] 


Nous allons donc rediriger les requêtes dirigées vers les fichier **gif** vers les fichiers **png** . Avant d'activer cette configuration nous allons mettre un fichier __.gif__  et accéder à la page pour le visualiser voici le logo de la **FSF** .

* Version Gif 
    * ![Free_Software_Foundation_logo.gif](./imgs/Free_Software_Foundation_logo.gif)
* Version Png 
    * ![Free_Software_Foundation_logo.png](./imgs/Free_Software_Foundation_logo.png)

Copiez le dans le **DocumentRoot** du site et accédez à l'URL , dans mon cas :

        $ sudo cp Free_Software_Foundation_logo.gif /data/vhosts/siteA/docroot/
        $ sudo cp Free_Software_Foundation_logo.png /data/vhosts/siteA/docroot/

URL : https://www.linux202-sitea.com/Free_Software_Foundation\_logo.gif

Activons maintenant la configuration de la redirection :

        $ sudo apachectl configtest && sudo /etc/init.d/apache2 restart

URL : https://www.linux202-sitea.com/Free_Software_Foundation\_logo.png

Donc comme vous pouvez le constater nous voyons la redirection selon la configuration suivante la redirection aura lieu peut importe le répertoire où ce trouve le fichier. Si nous créons le répertoire **toto/blabla/** et mettons le fichier __png__ lors de l'accès la redirection aura lieu aussi , démonstration.

        $ sudo mkdir -p /data/vhosts/siteA/docroot/toto/blabal/
        $ sudo cp Free_Software_Foundation_logo.png /data/vhosts/siteA/docroot/toto/blabal/

URL : https://www.linux202-sitea.com/toto/blabla/Free_Software_Foundation\_logo.png

Si nous regardons les logs nous voyons bien la redirection :

        $ tail /data/vhosts/siteA//logs/ssl_access.log
        172.17.42.1 - - [12/May/2016:08:38:01 -0400] "GET /toto/blabla/Free_Software_Foundation_logo.gif HTTP/1.1" 302 2373 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"
        172.17.42.1 - - [12/May/2016:08:38:01 -0400] "GET /toto/blabla/Free_Software_Foundation_logo.png HTTP/1.1" 304 209 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"

Revenons sur la ligne qui réalise cette magie :P , et prenons quelques minutes pour la comprendre :
        
        RedirectMatch "(.*)\.gif$" "https://www.linux202-sitea.com$1.png"

* **RedirectMatch** : Instruction contenu dans le module alias 
* **"(.*)\.gif$"**  : Ceci est certainement moins claire , ceci est une [expression régulière](https://fr.wikipedia.org/wiki/Expression_rationnelle) qui va traiter les requêtes et voir s'il y a action à apporter sur cette dernière c'est la condition . Les expressions régulière sont très importante car ceci vous permet de traiter des chaînes de caractères de manière conditionnel. Analysons donc ce que ceci veut dire, je reviendrais sur les parenthèses :
    * **.** == N'importe quelle caractère ceci peut être un espace , un chiffre, une lettre , ...
    * **\*** == l'étoile est un opérateur ceci correspond à ce qui le précède, répété zéro fois ou plusieurs fois. Donc si nous regardons l'ensemble ceci veut dire ( **.\***) n'importe quelle caractère zéro fois ou plusieurs fois .
    * **\\.** == Comme nous l'avons vu le point  (**.**) représente n'importe quelle caractère donc si nous désirons spécifier explicitement le caractère **.** nous devons le précéder d'un **\\** . 
    * **gif** == l'expression régulière s'attend donc a voir les caractères **gif**
    * **$** == Ce prédicat ne correspond à aucun caractère mais fixe une condition nécessaire permettant de trouver un accord sur ce qui le précède en indiquant que ce doit être à la fin d’une ligne (donc être à la fin du texte d’entrée ou juste avant un saut de ligne). 
    * **Résumé** : Quand l'URL est traitée , le système regarde tous les caractères qu'il soit présent 0 ou plusieurs fois (**.\***) , de plus il valide que l'URL traitée fini par **.gif**. L'utilisation des **()** permet de regroupé un ensemble de texte pour les réutiliser par la suite via les variables $1 , $2, $3 selon le nombre de parenthèse utilisées. Nous allons voir sont utilisation dans la prochaine instruction. 
* **"https://www.linux202-sitea.com$1.png"** : Dernier argument le lien où sera réalisé la redirection, telle que mentionné ci-dessus l'information contenu entre les parenthèses sera substitué au lieu de $1. Comme vous l'avez probablement constaté l'extension __.gif__ n'est pas contenu dans les parenthèses voilà pourquoi non réalisons le changement d'extension lors de la redirection avec le __.png__

Maintenant que nous avons traiter chaque argument voyons un peu d'exemple ceci simplifiera surement la compréhension .

Si nous prenons la requête : https://www.linux202-sitea.com/Free_Software_Foundation\_logo.gif
Regardons l'entrée dans les logs

        172.17.42.1 - - [12/May/2016:08:27:36 -0400] "GET /Free_Software_Foundation_logo.gif HTTP/1.1" 302 681 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"


Du point de vu d'apache lors du traitement de l'instruction **RedirectMatch** ce dernier reçoit : **/Free_Software_Foundation\_logo.gif** . 

0. Apache Reçoit dans le __VirtualHost__ : **/Free_Software_Foundation\_logo.gif** 
1. Traitement de la règle de redirection :

        RedirectMatch "(.*)\.gif$" "https://www.linux202-sitea.com$1.png"
2. La requête __Match__  le critère si nous reprenons la __regex__  : **(.\*)\.gif$** ceci donne :

    * (.\*) == /Free_Software_Foundation\_logo
    * \.gif$ == .gif

3. Réalisation de la redirection en substituant la variable $1 par le contenu de la variable :

    * "https://www.linux202-sitea.com$1.png" == "https://www.linux202-sitea.com/Free_Software_Foundation\_logo.png"

Nous pouvons donc constaté que la formule fonctionne aussi bien si le fichier est dans un répertoire et non à la racine du site :

Si nous accédons à l'URL : https://www.linux202-sitea.com//toto/blabla/Free_Software_Foundation\_logo.gif

        172.17.42.1 - - [12/May/2016:08:28:58 -0400] "GET /toto/blabla/Free_Software_Foundation_logo.gif HTTP/1.1" 302 705 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"

Du point de vu d'apache lors du traitement de l'instruction **RedirectMatch** ce dernier reçoit : **/toto/blabla/Free_Software_Foundation\_logo.gif** . 

1. Décortiquons la __regex__ : **(.\*)\.gif$**

    * (.\*) == /toto/blabla/Free_Software_Foundation\_logo
    * \.gif$ == .gif

2. Réalisation de la redirection en substituant la variable $1 par le contenu de la variable :

    * "https://www.linux202-sitea.com$1.png" == "https://www.linux202-sitea.com/toto/blabla/Free_Software_Foundation\_logo.png"

Bien entendu, les opérations disponibles sont multiple avec les __regex__ ceci est uniquement un exemple , à vous de voir vos besoin.

Référence :

* https://httpd.apache.org/docs/current/fr/mod/mod\_alias.html#redirect
* https://fr.wikipedia.org/wiki/Graphics_Interchange_Format
* https://fr.wikipedia.org/wiki/Portable_Network_Graphics

## <a name="mod_rewrite" /> Mod\_rewrite pour réécrire les URL

Après avoir couvert l'instruction [Redirect](https://httpd.apache.org/docs/current/fr/mod/mod_alias.html#redirect) et __RedirectMatch__ , vous êtes en mesure de réaliser beaucoup de chose. Avec L'utilisation de __mod\_rewrite__ vos possibilités décuple, cependant un niveau de complexité aussi sera significativement augmenté. 

Le module __mod\_rewrite__ utilise un moteur de réécriture à base de règles, basé sur un interpréteur d'expressions rationnelles **PCRE**, pour réécrire les URLs à la volée. Par défaut, __mod\_rewrite__ met en correspondance une URL avec le système de fichiers. Cependant, on peut aussi l'utiliser pour rediriger une URL vers une autre URL, ou pour invoquer une requête interne à destination du mandataire.

__mod\_rewrite__ fournit une méthode souple et puissante pour manipuler les URLs en utilisant un nombre illimité de règles. Chaque règle peut être associée à un nombre illimité de conditions, afin de vous permettre de réécrire les URLs en fonction de variables du serveur, de variables d'environnement, d'en-têtes HTTP, ou de repères temporels.

__mod\_rewrite__ agit sur la totalité de l'URL, y compris la partie chemin. Une règle de réécriture peut être invoquée dans __httpd.conf__ ou dans un fichier __.htaccess__. Le chemin généré par une règle de réécriture peut inclure une chaîne de paramètres, ou peut renvoyer vers un traitement secondaire interne, une redirection vers une requête externe ou vers le mandataire interne.

Vous trouverez d'avantage de détails, discussions et exemples dans la [documentation détaillée sur mod\_rewrite](https://httpd.apache.org/docs/2.4/fr/rewrite/).

### <a name="mod_rewrite-RewriteImgs" /> Réécriture des images gif vers png

Nous avons vu l'instruction __RedirectMatch__ qui fait partie du module __mod\_alias__ pour faire la redirection de fichier originalement en format __.gif__ vers __.png__ . Comme nous avons déjà compris le fonctionnement nous allons refaire la même configuration avec __mod\_rewrite__ uniquement pour ce familiarisé avec la syntaxe. 

Premièrement nous devons activer le module **mod\_rewrite** , afin de pouvoir utiliser les instructions du module.

        $ cd /etc/apache2/mods-enabled
        $ sudo ln -s ../mods-available/rewrite.load .

Si vous ne réalisez pas cette opération lors de la validation syntaxique de la configuration (**sudo apachectl configtest**) vous aurez le message suivant : 

        AH00526: Syntax error on line 26 of /etc/apache2/sites-enabled/siteA-ssl.conf:
        Invalid command 'RewriteEngine', perhaps misspelled or defined by a module not included in the server configuration
        Action 'configtest' failed.
        The Apache error log may have more information.

Pour rappel la configuration original :

        RedirectMatch "(.*)\.gif$" "https://www.linux202-sitea.com$1.png"

Voici l'instruction avec [RewriteRule](https://httpd.apache.org/docs/2.4/fr/mod/mod_rewrite.html#rewriterule) :

        RewriteEngine  on
        RewriteRule    "(.*)\.gif$" "$1.png" [R,L]

On valide et recharge la configuration :

        $ sudo apachectl configtest && sudo /etc/init.d/apache2 restart
        Syntax OK
        * Restarting web server apache2
        ...done.
        *

Accédons à présent aux l'URL de l'image : 

* https://www.linux202-sitea.com/toto/blabla/Free_Software_Foundation\_logo.gif
* https://www.linux202-sitea.com/Free_Software_Foundation\_logo.gif


Dans les deux cas la redirection est réalisé vers le fichier **png** et l'URL reécrite dans la barre de votre fureteur:

* https://www.linux202-sitea.com/toto/blabla/Free_Software_Foundation\_logo.png
* https://www.linux202-sitea.com/Free_Software_Foundation\_logo.png

Analysons un peut les instructions :

1. Activation du module __mod\_rewrite__ pour le __VirtualHost__

        RewriteEngine  on

2. Réalisation de la règle de redirection :

        RewriteRule    "(.*)\.gif$" "$1.png" [R,L]

3. Nous constatons que l'instruction au lieu de __RedirectMatch__ c'est __RewriteRule__ .
4. L'expression régulière est équivalente je sauterai donc l'explication de cette dernière . Relire l'explication dans la section __RedirectMatch__.
5. Nous avons en plus des **flag** , ces derniers permettent de définir le comportement de la redirection , vous avec la liste des [drapeaux disponible sur la documentation](https://httpd.apache.org/docs/2.4/fr/mod/mod_rewrite.html#rewriterule) 

        [R,L]

    * **R** : L'utilisation du [drapeau \[R\]](https://httpd.apache.org/docs/2.4/fr/rewrite/flags.html#flag_r) provoque l'envoi d'une redirection au navigateur. Si une URL pleinement qualifiée (FQDN - fully qualified domain name) est spécifiée (c'est à dire incluant http://nom-du-serveur/), une redirection sera effectuée vers cette adresse. Dans le cas contraire, le protocole courant, le nom du serveur et le numéro de port seront utilisés pour générer l'URL envoyée avec la redirection. 
    * **L** : Lorsque le [drapeau \[L\]](https://httpd.apache.org/docs/2.4/fr/rewrite/flags.html#flag_l) est présent, mod\_rewrite arrête le traitement du jeu de règles. Cela signifie dans la plupart des situations que si la règle s'applique, aucune autre règle ne sera traitée. Ce drapeau correspond à la commande Perl last, ou à la commande break en C. Utilisez ce drapeau pour indiquer que la règle courante doit être appliquée immédiatement, sans tenir compte des règles ultérieures.


Si nous réalisons un changement au niveau des **flags** , supprimons l'option **R** pour ne pas avoir une redirection mais simplement une réécriture de règle. **ATTENTION** ceci ne fonctionne que si la redirection est réalisé **localement**, en d'autre mot vers une page ou une référence interne au serveur. Voici la nouvelles configuration :

        RewriteEngine  on
        Rewriterule "(.*)\.gif$" "$1.png"  [L]

Seule différence au niveau de la configuration nous avons supprimé le drapeau **R**, si vous accédez à l'URL : https://www.linux202-sitea.com/Free_Software_Foundation\_logo.gif , ça fonctionne toujours et vous voyez bien le fichier **png** car il y a la ligne noir présente. Soyez attentif maintenant à l'URL dans la bar, l'URL est toujours **GIF** et non **PNG**, donc l'écriture c'est réalisé mais n'est pas présenté à l'utilisateur :D.

Telle que mentionné ceci ne fonctionne que lorsque le serveur gère l'ensemble , soit la source et la destination , si vous définissez une URL externe par exemple l'URL du logo de google, le comportement sera une redirection :

        RewriteEngine  on
        Rewriterule "(.*)\.gif$" "https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png"

### <a name="mod_rewrite-RewriteCond" /> Mise en place de condition de réécriture 

Le vraie avantage de __mod\_rewrite__ est la mise en place de la gestion de condition multiple, choses impossible avec le système de redirection, avec le module **mod\_alias**.
[RewriteRule](https://httpd.apache.org/docs/2.4/fr/mod/mod_rewrite.html#rewriterule) permet de définir une condition dans l'exemple ci-dessus nous avons définie uniquement le fait que la requête soit pour les fichiers avec l'extension __gif__.
Avec l'instruction [RewriteCond](https://httpd.apache.org/docs/2.4/fr/mod/mod_rewrite.html#rewritecond) il est possible de définir plus de condition, pas uniquement sur l'URL fournit mais aussi sur le client réalisant la requête. 

#### <a name="mod_rewrite-RewriteCond_browser" /> Mise en place de condition de réécriture selon le fureteur

Petite démonstration pour bien comprendre la concept , nous allons réaliser une règle de redirection afin de fournir une page pour les fureteurs **Chrome**, car **Chrome** ce n'est pas un logiciel libre faut informer les gens :-). 

Nous allons donc mettre une règle afin d'intercepter les connexions des fureteurs de type **Chrome**, pour ce faire nous allons utiliser l'identifiant **USER-AGENT** .Quand un internaute visite une page Web, une chaîne de type texte est généralement envoyée au serveur pour identifier l'agent utilisateur. Elle est incluse dans la requête HTTP par l'en-tête « User-Agent » et elle donne des informations comme : le nom de l'application, la version, le système d'exploitation, la langue, etc.).

Je vais revenir dans quelques minutes avec une liste des variables de validation disponible une fois la démonstration réalisé.
Voici donc l'instruction :

        RewriteCond "%{HTTP_USER_AGENT}"  "(Chrome)"
        RewriteRule "(.*)"  "/chrome-info.php?link=$1"

Donc nous prenons l'information du fureteur , si ce dernier est **Chrome** alors nous réalisons une redirection vers le fichier __chrome-info.php__ en passant en argument à __PHP__ l'URL original. L'objectif est d'afficher un message à l'utilisateur et le rediriger vers la page original mais nous allons y allé par étape :P .

Réalisons le fichier __chrome-info.php__ : **/data/vhosts/siteA/docroot/chrome-info.php**

        <?php
        $url=$_GET['link'];
        ?>

        Votre Fureteur est pas libre ... Chrome est privatif, je vous suggere Chromium : https://www.chromium.org/ !! <br>
        <br>
        Ceci est uniquement pour vous informer ! <b>vous serez redirige vers la bonne page dans 5 secondes vers l'URL</b>
        <br>

        <?php
        print $url;
        print "<br> time : ";
        print time();

        ?>

Nous validons la configuration et redémarrons le service apache, puis nous accédons à l'URL , par exemple __info.php__ .

        $ sudo apachectl configtest && sudo /etc/init.d/apache2 restart

Donc si nous accédons à : https://www.linux202-sitea.com/info.php , vous aurez ceci à l'écran :

![mod_rewrite_chrome-loop.png](./imgs/mod_rewrite_chrome-loop.png)

Le message est claire , il y a une boucle dans la redirection ... Vous pouvez facilement le confirmer en consultant les logs , faites un **tail -f** sur le fichier d'accès vous pourrez le voir clairement. 

        $ tail -f /data/vhosts/siteA/logs/ssl_access.log
        172.17.42.1 - - [19/May/2016:08:35:35 -0400] "GET /info.php HTTP/1.1" 302 813 "-" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36"
        172.17.42.1 - - [19/May/2016:08:35:35 -0400] "GET /chrome-info.php?link=/info.php HTTP/1.1" 302 689 "-" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36"
        172.17.42.1 - - [19/May/2016:08:35:35 -0400] "GET /chrome-info.php?link=/chrome-info.php HTTP/1.1" 302 689 "-" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36"
        172.17.42.1 - - [19/May/2016:08:35:35 -0400] "GET /chrome-info.php?link=/chrome-info.php HTTP/1.1" 302 689 "-" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36"
        ....
        ....

Donc Si nous regardons les logs :

1. **"GET /info.php HTTP/1.1" 302 813 "-" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/** : Nous voyons la première requête à l'URL **info.php** et nous constatons que l'agent contient bien le mot **Chrome**.
2. **"GET /chrome-info.php?link=/info.php HTTP/1.1" 302 689 "-" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome** : Nous avons bien la redirection vers le fichier **chrome-info.php** avec l'argument en paramètre de la page original **?link=/info.php** . Jusqu'ici tous va bien , de plus nous avons toujours l'agent contenant **Chrome**
3. **"GET /chrome-info.php?link=/chrome-info.php HTTP/1.1" 302 689 "-" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome** : Oupss, ça commence à partir en vrille , en effet lorsque le client demande d'accéder à la page **chrome.php** la condition **RewriteCond** s'applique encore :P , il y a toujours l'agent **Chrome** il réalise donc la redirection en passant en argument l'URL d'origine **?link=/chrome-info.php** 
4. **"GET /chrome-info.php?link=/chrome-info.php HTTP/1.1" 302 689 "-" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome** : Nous sommes dans la boucle ...

Ceci est un cas **classique** lorsque vous travaillerez avec le système de redirection d'URL voilà pourquoi il est compliqué de travailler avec **mod\_rewrite** et que je suggère toujours d'avoir un environnement de test pour valider vos configurations.

Comment corriger ce problème ??

Nous allons rajouter une condition, nous allons indiquer que nous ne voulons pas que la redirection s'applique si le fureteur demande la page **chrome-info.php** . Voici donc la configuration avec le correctif pour ne pas tomber dans une boucle infinie :

                RewriteCond "%{HTTP_USER_AGENT}"  "(Chrome)"
                RewriteCond "%{REQUEST_URI}" !/chrome-info.php
                RewriteRule "(.*)"  "/chrome-info.php?link=$1" [R,L]

Nous avons ajouter la validation sur l'URL demandé  (**REQUEST_URI**), j'ai définie une condition négative , en effet j'ai spécifier que pour que la reécriture s'applique il ne fait PAS (!) que l'URL demandé soit **/chrome-info.php**. Avec l'utilisation du point d'exclamation (!) ceci nous permet de définir une condition négative.

Suite au changement redémarrer le service apache et regardons les logs lorsque nous demandons la page **info.php**: 

        172.17.42.1 - - [19/May/2016:08:49:45 -0400] "GET /info.php HTTP/1.1" 302 2343 "-" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36"
        172.17.42.1 - - [19/May/2016:08:49:45 -0400] "GET /chrome-info.php?link=/info.php HTTP/1.1" 200 575 "-" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36"
        172.17.42.1 - - [19/May/2016:08:49:45 -0400] "GET /favicon.ico HTTP/1.1" 302 681 "https://www.linux202-sitea.com/chrome-info.php?link=/info.php" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36"
        172.17.42.1 - - [19/May/2016:08:49:45 -0400] "GET /chrome-info.php?link=/favicon.ico HTTP/1.1" 200 575 "https://www.linux202-sitea.com/chrome-info.php?link=/info.php" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36"

1. **GET /info.php HTTP/1.1" 302 2343 "-" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome** : Bon pas de changement ici la première requête pour **info.php**  et toujours l'agent **Chrome**.
2. **GET /chrome-info.php?link=/info.php HTTP/1.1" 200 575 "-" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome** : Jusqu'ici tous va bien nous avons la redirection vers la page **chrome-info.php** avec l'URL d'origine en argument.
3. **GET /favicon.ico** et **GET /chrome-info.php?link=/favicon.ico** : Le fureteur essaye  d'avoir l'icône de la page , nous voyons que le système de redirection fonctionne même pour ça :P , il y aurait moyen d amélioré la règle mais restons en là pour le moment :D.
4. Voilà PAS d'autre requête , plus de boucle , car lors de l'appel de la page **chrome-info.php** les règles **RewriteCond** ne sont plus valide.

Donc vous devriez voir la page : 

![mod_rewrite_chrome-ok-sans-redirection.png](/imgs/mod_rewrite_chrome-ok-sans-redirection.png)

C'est bon il nous reste à réaliser la redirection :D et c'est fini ... Heu heu , en fait on va avoir une autre problème :). Mais bon un problème à la fois :) , mettons en place la redirection :D.

Pour ce faire je vais modifier le fichier __chrome-info.php__  voici la nouvelle version :

        <?php
        $url=$_GET['link'];
        header( "refresh:5;url=$url" );
        ?>

        Votre Fureteur est pas libre ... Chrome est privatif, je vous suggere Chromium : https://www.chromium.org/ !! <br>
        <br>
        Ceci est uniquement pour vous informer ! <b>vous serez redirige vers la bonne page dans 5 secondes vers l'URL</b>
        <br>

        <?php
        print $url;
        print "<br> time : ";
        print time();

        ?>

La seule chose en plus est la ligne **header** qui permet de définir la redirection de type **html**. Malheureusement si vous accéder à l'URL : https://www.linux202-sitea.com/info.php , il y a bien la redirection vers https://www.linux202-sitea.com/chrome-info.php?link=/info.php. 
Cependant lorsque le client est redirigé vers __info.php__, il se fait redirigé encore une fois vers __chrome-info.php__ et ceci de manière perpétuelle. Vous pouvez le constater, en regardant l'information **time : 1463746918**. Dans les logs nous le voyons clairement (pour information j'ai supprimé l'information du __favicon.ico__ afin de simplifier la visualisation ) :

        172.17.42.1 - - [20/May/2016:08:19:17 -0400] "GET /info.php HTTP/1.1" 302 675 "-" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36"
        172.17.42.1 - - [20/May/2016:08:19:17 -0400] "GET /chrome-info.php?link=/info.php HTTP/1.1" 200 600 "-" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36"
        172.17.42.1 - - [20/May/2016:08:19:22 -0400] "GET /info.php HTTP/1.1" 302 675 "https://www.linux202-sitea.com/chrome-info.php?link=/info.php" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36"
        172.17.42.1 - - [20/May/2016:08:19:22 -0400] "GET /chrome-info.php?link=/info.php HTTP/1.1" 200 600 "https://www.linux202-sitea.com/chrome-info.php?link=/info.php" "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36"


Nous nous retrouvons donc encore dans une boucle, mais une boucle applicative et non plus une boucle de configuration dans __mod\_rewrite__.

Comment solutionné ce problème, car nous voulons informer le client , mais pas le bloquer , bon peut-être s'il est sur internet explorer :P , mais pas Chrome :P. Il y a plusieurs solution, mais une simple est la mise en place d'un **cookie**, je choisie aussi cette solution pour démontrer l'utilisation d'un **cookie** avec __mod\_rewrite__. Je pense que ceci est très pertinent !
Donc nous allons modifier le fichier __php__ afin de définir le __cookie__ lorsque le client accède à la page :

        <?php
        print $url;
        print "<br> time : ";
        print time();

        $date_of_expiry = time() + 60 ; // 60 secondes
        setcookie( "bad_browser", "chrome", $date_of_expiry );
        ?>

Ici je définie un __cookie__ nommé **bad\_browser** et je lui définie une chaine de caractère avec le nom du fureteur __chrome__ de plus je définie une date d'expiration au __cookie__ de 60 secondes. L'expiration est trop courte pour une utilisation en production car le client sera redirigé à la page après 1 minutes de consultation du site , mais pour les testes c'est très pratique :P. Plus d'information disponible sur la page de documentation de __php__ : [setcookie](http://php.net/manual/en/function.setcookie.php). 

Maintenant que le __cookie__ est définie dans l'application je vais modifier la règles de __mod\_rewrite__ afin que la règle de redirection ne s'applique pas si le __cookie__ nommé **bad\_browser** est définie.

        RewriteCond "%{HTTP_USER_AGENT}"  "(Chrome)"
        RewriteCond "%{REQUEST_URI}" !/chrome-info.php
        RewriteCond "%{HTTP_COOKIE}"   !(bad_browser)
        RewriteRule "(.*)"  "/chrome-info.php?link=$1" [R,L]

#### <a name="mod_rewrite-RewriteCond_refferrer" /> Mise en place de condition de réécriture selon l'origine

Voyons un autre exemple à présent de manipulation de réécriture afin de voir une méthode , je ne prendrais pas le temps de traiter l'ensemble des variables disponibles car il y en a beaucoup :

![variable_mod_rewrite.png](./imgs/variable_mod_rewrite.png)

* https://httpd.apache.org/docs/2.4/fr/mod/mod\_rewrite.html#rewritecond


Nous allons donc voir la méthode pour "protéger" nos images sur le site web, quand je dis protégé je veux dire que nous allons bloqué l'inclusion de vos images sur un site web distant.

Nous allons modifier le contenu de la page **index.html** du site web du __siteA__ afin de joindre une images :

        $ cat /data/vhosts/siteA/docroot/index.html
        <html>
        <body>

        <h3> Le site A</h3>

        <img src=./Free_Software_Foundation_logo.png />
        </body>
        </html>

Si vous accédez à l'URL : https://www.linux202-sitea.com/ vous aurez l'images de la __Free software Fondation__: 

![index_html-siteA.png](./imgs/index_html-siteA.png)


Regardons les logs qui sont généré lors de l'accès au site :

        $ tail -f /data/vhosts/siteA/logs/ssl_access.log
        172.17.42.1 - - [25/May/2016:08:30:07 -0400] "GET / HTTP/1.1" 200 668 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"
        172.17.42.1 - - [25/May/2016:08:30:07 -0400] "GET /Free_Software_Foundation_logo.png HTTP/1.1" 200 38268 "https://www.linux202-sitea.com/" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"


Comme vous pouvez le constater l'inclusion de l'images à comme référence la provenance : __200 38268__ **"https://www.linux202-sitea.com/"** __"Mozilla/5.0__.

Maintenant nous allons modifier la configuration du **siteC** afin que la page d'index inclus l'image disponible sur le **siteA**

        $ cat /data/vhosts/siteC/docroot/index.html
        <html>
        <body>

        <h3> Le site C</h3>

        <img src=https://www.linux202-sitea.com/Free_Software_Foundation_logo.png />
        </body>
        </html>

Accédons au **siteC** afin de voir la page ainsi que les logs : http://sitec.com/

        $ tail -f /data/vhosts/siteA/logs/ssl_access.log
        172.17.42.1 - - [25/May/2016:08:36:23 -0400] "GET /Free_Software_Foundation_logo.png HTTP/1.1" 200 38406 "http://sitec.com/" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"

Comme nous pouvons le constater comme j'interroge les logs du **siteA** je ne vois pas l'accès à l'index du __siteC__ cependant je vois l'accès à l'image avec l'identifiant de la référence : __200 38406__ **"http://sitec.com/"** __"Mozilla/5.0__.

Maintenant que l'on voit le déroulement du processus d'inclusion d'une image par un autre site nous allons pouvoir commencer la manipulation avec **mod\_rewrite**. Nous allons faire en sorte que lors qu'une personne inclue une images de notre site ce dernier ne reçoit pas l'image original mais un autre fichier :D.

![access-denied.jpg](./imgs/access-denied.jpg)

J'ai mis le fichier dans le __DocumentRoot__ du __siteA__ .

Passons à la réécriture de l'URL , donc s'il y a accès aux fichiers de type __png__ depuis l'extérieur du site nous fournirons l'images des __Lego__.
Pour ce faire nous allons éditer la configuration d'apache pour **siteA** :

        $ cat /etc/apache2/sites-enabled/siteA-ssl.conf
        [ ... OUTPUT COUPÉ ... ]
                RewriteCond "%{HTTP_REFERER}" !https:\/\/www.linux202-sitea.com\/
                RewriteRule "(.*)\.png$"  "/access-denied.jpg" [R,L]
        [ ... OUTPUT COUPÉ ... ]

Nous suivons le même concept avec une condition négatif à l'aide du symbole **!** , rechargeons la configuration apache et regardons les logs :

        $ sudo apachectl configtest && sudo /etc/init.d/apache2 restart
        Syntax OK
         Restarting web server apache2
         *    ...done.
        $ tail -f /data/vhosts/siteA/logs/ssl_access.log  /data/vhosts/siteC/logs/access.log
        ==> /data/vhosts/siteA/logs/ssl_access.log <==
        172.17.42.1 - - [25/May/2016:08:57:58 -0400] "GET / HTTP/1.1" 200 2198 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"
        172.17.42.1 - - [25/May/2016:08:57:59 -0400] "GET /Free_Software_Foundation_logo.png HTTP/1.1" 200 38268 "https://www.linux202-sitea.com/" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"


        ==> /data/vhosts/siteC/logs/access.log <==
        172.17.42.1 - - [25/May/2016:08:58:41 -0400] "GET / HTTP/1.1" 200 470 "-" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"

        ==> /data/vhosts/siteA/logs/ssl_access.log <==
        172.17.42.1 - - [25/May/2016:08:58:41 -0400] "GET /Free_Software_Foundation_logo.png HTTP/1.1" 302 787 "http://sitec.com/" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"
        172.17.42.1 - - [25/May/2016:08:58:41 -0400] "GET /access-denied.jpg HTTP/1.1" 200 354733 "http://sitec.com/" "Mozilla/5.0 (X11; Linux i686; rv:42.0) Gecko/20100101 Firefox/42.0"


Nous le voyons clairement dans les logs la redirections car la source de l'accès n'est PAS le sitea.

#### <a name="mod_rewrite-RewriteCond_path" /> Mise en place de redirection sur le PATH de l'URL

Pour terminer, voyons la redirection d'un URL basé sur le chemin, si votre site web utilise un langage telle que __php__, __python__ , __ruby__ , ... Il est fort probable que vous avez une base de données en arrière pour le stockage du contenu. Nous nous retrouvons souvent avec des URL contenant des paramètres exemple : 

* https://www.linux202-sitea.com/articles.php?year=2016&title=le\_super\_article

Ceci n'est en soit pas critique cependant en dehors de l'aspect esthétique, ceci à un coût sur l'indexation dans __google__, en effet une URL à plus de valeur qu'un argument ... De plus l'utilisateur préfère avoir une URL "dur" ceci est plus simple à retenir et évite les erreurs d'argument avec les caractères : **&** , **?**, **=**,...

Une fois notre redirection mise en place voici l'URL que nous aurons :

* https://www.linux202-sitea.com/articles/2016/le\_super\_article

C'est tous de même plus jolie ... Pour les besoins de la démonstration je vais définir le fichier __articles.php__ afin que vous puissiez avoir un point de référence pour vos testes :

        $ cat /data/vhosts/siteA/docroot/articles.php 
        <?php
        $year=$_GET['year'];
        $titre=$_GET['title'];
        ?>

        <?php
        print " <h3> Article du $year </h3> ";
        print " <p> Le titre : $titre ";
        ?>

        <p>
        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed elementum, lacus sed egestas faucibus, justo magna placerat ante, quis feugiat diam dui eu metus. Nam sit amet turpis arcu. Curabitur vel lobortis dui, ac consectetur lacus. Donec felis lectus, malesuada nec convallis in, hendrerit ut nisi. Phasellus sagittis, est sit amet dignissim iaculis, eros ex viverra nunc, vel porta neque dolor et justo. Etiam dignissim lacinia sollicitudin. Sed eget erat quam. Maecenas non molestie dui, quis dictum felis. Phasellus vel facilisis sapien. Curabitur non mollis leo, vel auctor nisi. Fusce pretium arcu dui, et efficitur mauris vulputate eget.
        </p>

        <br> <br>
        <?php
        print " Debug info : select article_text from article where year=$year and title=$titre ";
        ?>


Avant de mettre en place la redirection validons que le fichier __php__ fonctionne comme attendu .
Accédons à l'URL : https://www.linux202-sitea.com/articles.php?year=2016&title=le\_super\_article

![article_php_with_args.png](./imgs/article_php_with_args.png)

Donc nous voyons bien l'information de l'année ainsi que le titre passé en paramètre, en bas (non présent sur la copie d'écran) nous voyons aussi la requête __SQL__ qui serait utilisée. 

Mettons en place la redirection d'URL à présent : __/etc/apache2/sites-enabled/siteA-ssl.conf__

        [ ... OUTPUT COUPÉ ... ] 
        RewriteEngine  on

        RewriteRule "^/articles/([^/]*)/([^/]*)" "/articles.php?year=$1&title=$2" [PT]

        Rewriterule "(.*)\.gif$" "$1.png"  [L]

        RewriteCond "%{HTTP_USER_AGENT}"  "(Chrome)"
        RewriteCond "%{REQUEST_URI}" !/chrome-info.php
        RewriteCond "%{HTTP_COOKIE}"   !(bad_browser)
        RewriteRule "(.*)"  "/chrome-info.php?link=$1" [R,L]
        [ ... OUTPUT COUPÉ ... ] 

Analysons la règles : **RewriteRule "^/articles/([^/]*)/([^/]*)" "/articles.php?year=$1&title=$2" [PT]**

* **^/articles/([^/]\*)/([^/]\*)** : L'URL sera traitée si ceci commence par /articles , par la suite je regroupes le premier "répertoire" dans la variable $1 ainsi que la deuxième "répertoire" dans la variable $2.
* **/articles.php?year=$1&title=$2** :  Je passe l'information extraite préalablement $1 et $2 avec le bon nom de variables
* **[PT]** : Nous avons principalement utilisé les **flag** : **R** et **L** . Par défaut, la cible (ou chaîne de substitution) d'une règle RewriteRule est sensée être un chemin de fichier. Avec le drapeau [PT], par contre, elle est traitée comme un URI. Autrement dit, avec le drapeau [PT], le résultat de la règle RewriteRule est passé à nouveau au système de mise en correspondance des URLs avec le système de fichiers, de façon à ce que les systèmes de mise en correspondance basés sur les chemins de fichiers, comme la directive Alias, Redirect, ou ScriptAlias, par exemple, puissent avoir une chance d'accomplir leur tâche. 

Ajoutons une autre donnée, j'essaye de répondre à quelques cas de figure **classique** que nous rencontrons , donc imaginons que vous avez déjà des articles présent , qui ne sont pas contenu dans le système de base de donnée. Par exemple si nous avons la structure suivante :

        $ cat /data/vhosts/siteA/docroot/articles/1999/le_vieux_articles.html 
        Un super Vieux Articles mais toujours super pertinents

Donc nous avons un articles de 1999 contenu dans le répertoire __articles__ le problème est qu'avec la règle de redirection en place vous n'avez plus accès à ce fichier. La règle de redirection intercepte la requête au fichier, nous allons donc rajouter une condition afin que si le fichier demandé existe **réellement** sur le système de fichier la redirection ne s'applique pas.

                RewriteEngine  on
                
                RewriteCond "%{DOCUMENT_ROOT}/%{REQUEST_FILENAME}" !-f
                RewriteRule "^/articles/([^/]*)/([^/]*)" "/articles.php?year=$1&title=$2" [PT]


* **%{DOCUMENT\_ROOT}** :  Définie la racine du site web , l'utilisation d'une variable permet d'avoir une solution applicable peut importe le site
* **%{REQUEST\_FILENAME}** : Définie le chemin d'accès dans l'URL qui est demandé
* **!-f** : Permet de définir la condition si ce n'est PAS (**!**) un fichier

#### <a name="mod_rewrite-avoid" /> Quand ne pas utiliser mod\_rewrite

Je vous invite à consulter la page : https://httpd.apache.org/docs/2.4/fr/rewrite/avoid.html , afin de comprendre quand il n'est pas conseillé d'utiliser mod\_rewrite.

Référence :

* https://httpd.apache.org/docs/2.4/fr/rewrite/
* https://httpd.apache.org/docs/2.4/fr/rewrite/remapping.html
* https://httpd.apache.org/docs/2.4/fr/rewrite/avoid.html
* https://httpd.apache.org/docs/current/fr/rewrite/flags.html
* http://www.useragentstring.com/pages/useragentstring.php


