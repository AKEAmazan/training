<meta http-equiv='Content-Type' content='text/html; charset=utf-8' /> 
<style>
pre{background:#F8F8FF; border:black dashed 1px; padding:6px}
</style>

TODO : Corriger les \_

# Index 


# <a name="redirect" /> Redirection d'URL

La manipulation des __URL__ est maintenant une pratique très courante dans l'industrie , les raisons sont multiple :

* Cacher la structure réelle des fichiers sur le système 
* Rediriger l'ensemble des requêtes vers un fichier principale (__.php__, ...)
* Rediriger les erreurs vers une page , plus jolie que l'erreur par défaut d'apache
* Migré un site web tout en conservant la structure original, afin de satisfaire les exigences client et les __référenceurs__ (__google__, __yahoo__, __altavista__ :P, ...)
* Rediriger les requêtes d'accès au site non chiffré (__http__) pour la version chiffré (**https**)
* Rediriger les requêtes des clients mobile vers un site plus adapté à l'équipement, voir bloquer les OS impures :P (c'est un blague)
* Traiter les arguments transmis dans l'URL pour un comportement particulier.
* ...

Nous allons voir quelques méthodes de mise en place de redirection , certaines configuration sont simple à mettre en place d'autre complexe. Nous verrons le système **mod_rewrite** qui permet de réaliser des configurations très complexe , je vous conseille d'avoir un environnement de teste avant d'essayer d'effectuer, les configurations directement en production. Une mauvaise configuration peut rendre votre site web inaccessible.

## <a name="simple_redirect" /> Redirection Simple

Avant de parler de [mod_rewrite](https://httpd.apache.org/docs/2.4/fr/mod/mod_rewrite.html) nous allons voir d'autre méthode de redirection. Bien que **mod_rewrite** peut répondre à l'ensemble des exemples couvert ci-dessous, il est plus simple d'utiliser des méthodes avec lesquelles nous sommes plus confortable, car plus simple. Libre à vous par la suite :P.


### <a name="html_redirect" /> Redirection avec un fichier html

Je sort un peu du cadre d'apache, cependant j'aime bien cette méthode, car elle est simple et n'oblige pas d'avoir un accès à la configuration apache. Il suffit de créer un fichier __index.html__ dans le répertoire désiré , par exemple la racine du site et de mettre le code de redirection .

Si nous prenons le __siteC__ que nous avons préalablement créé , si nous accédons au site site actuellement nous avons simplement le message : "Le site C ". Nous allons réaliser une redirection vers le site __google__ quand on accède au site.

Pour ce faire je vais modifier le fichier __index.html__ avec l'instruction suivant :

        <html>
          <head>
              <title>HTML redirect</title>
              <META http-equiv="refresh" content="5;URL=http://www.google.com">
          </head>
          <body bgcolor="#ffffff">
            <center>
                Vous allez etre redirigé dans 5 seconde vers google.com
            </center>
          </body>
        </html>


Ceci fonctionne très bien cependant ça ne fonctionne que si nous accédons à la racine du site web , en effet si on crée un fichier __info.html__ dans le __DocumentRoot__ et que l'on y accède directement nous ne serons pas redirigé . Démonstration !


        $ sudo vim info.html
        $ cat info.html
        un peu de texte pour fournir de l'information

Si vous accédez à http://www.sitec.com/info.html , telle que mentionné vous aurez le contenu du fichier sans aucune redirection. Il est possible que ceci soit ce que vous désirez, chaque problème à ça solution !

Référence :

* http://webmaster.iu.edu/tools-and-guides/maintenance/redirect-meta-refresh.phtml

### <a name="redirect_instruction" /> Redirection avec l'instruction redirect

Avant de voir le module **mod_rewrite** nous allons voir l'instruction [redirect](https://httpd.apache.org/docs/current/fr/mod/mod_alias.html#redirect) cette dernière fait partie du module **mod_alias**.

![redirect_screenshot-documentation.png](./imgs/redirect_screenshot-documentation.png)

Comme vous pouvez le voir dans la documentation l'instruction peut être utilisé dans plusieurs contexte de configuration :

* Configuration globale du serveur
* Un serveur virtuel (__Virtual host__)
* Un répertoire
* Un fichier __.htaccess__

Voici un exemple simple est très très classique de l'utilisation de l'instruction **redirect**, renvoyer l'ensemble des communications du site __http__ vers le mode __ssl__ __http__**S**.

Nous allons donc modifier la configuration du serveur virtuel __siteA__ afin que lors de la réception de requête sur le canal non chiffré l'ensemble soit redirigé vers le site en __SSL__.

Nous allons éditer le fichier **/etc/apache2/sites-available/siteA.conf** :

        $ sudo vim /etc/apache2/sites-available/siteA.conf
        $ cat siteA.conf

        <VirtualHost 172.17.0.1:80>
                ServerAdmin webmaster@localhost

                ServerName www.linux202-siteA.com
                ServerAlias linux202-siteA.com
                ServerAlias toto.linux202-siteA.com
                
                DocumentRoot /data/vhosts/siteA/docroot/
                
                Redirect / https://www.linux202-siteA.com/

               # Configuration des logs
               ErrorLog /data/vhosts/siteA/logs/error.log
               CustomLog /data/vhosts/siteA/logs/access.log combined
         </VirtualHost>

Si vous regardez le fichier original de configuration vous constaterez que j'ai supprimer l'ensemble des instructions en lien avec les permissions des répertoires. En effet j'ai enlever l'ensemble des instructions pour simplifier le fichier au maximum car de toute manière l'ensemble des instructions seront redirigé vers la configuration **SSL**.

Si vous réalisez quelques tests 

* http://www.linux202-sitea.com/ : Redirige effectivement vers le site en https://www.linux202-sitea.com/
* http://www.linux202-sitea.com/info.php : Redirige aussi vers le site en __https__ tous en conservant le fichier de référence.

Il est aussi possible de réaliser une redirection d'une section uniquement vers un site externe. Dans l'exemple suivant la section __/search__ redirigera vers le site **duckduckgo.com**.

        $ cat /etc/apache2/sites-available/siteA.conf
        [ ... OUTPUT COUPÉ ... ]
             DocumentRoot /data/vhosts/siteA/docroot/
              
             Redirect /search https://www.duckduckgo.com
             Redirect / https://www.linux202-siteA.com/
        [ ... OUTPUT COUPÉ ... ]


Ceci peut être très utile lorsque qu'il y a du mouvement dans l'organisation du site web. L'image corporative étant très importante de nos jours et le site web de service ou la compagnie est la vitrine de notre aptitude à gérer les changements. Un autre exemple d'expérience que j'ai eu est le changement de serveur pour fournir du contenu multimédia . Originalement l'ensemble du matériel était sur le serveur fournissant le service mais avec le temps l'espace ou la performance du serveur n'était plus au rendez-vous. Nous avons donc modifier le serveur afin que le répertoires __imgs__ soit redirigés vers http://img.corposite.com.

Autre exemple de situation la conversion de fichier __gif__ ou __bmp__ :P vers un format de fichier __png__ ou __jpg__. Nous avons l'instruction [RedirectMatch](https://httpd.apache.org/docs/current/fr/mod/mod_alias.html#redirectmatch), qui fonctionne comme l'instruction __Redirect__ mais nous permet d'utiliser des expressions régulière et des variables . Voici un exemple d'utilisation pour convertir les fichiers __gif__ vers __jpg__ .

        RedirectMatch "(.*)\.gif$" "http://autre.example.com$1.jpg"

ICI ICI 

Référence :

* https://httpd.apache.org/docs/current/fr/mod/mod_alias.html#redirect

## <a name="mod_rewrite" /> Mod_rewrite pour réécrire les URL



Référence :

* https://httpd.apache.org/docs/2.4/fr/rewrite/remapping.html

# <a name="mod_proxy" /> Mod_proxy pour rediriger les requêtes
# <a name="mod_webdav" /> Mod_webdav pour avoir un lieu de stockage de fichiers

# <a name="performance" /> Performance et analyse d'apache




# <a name="auth_local_access" /> Autorisation d'accès avec authentification local

Nous allons maintenant revoir notre configuration pour l'accès au répertoire admin , au lieu d'utiliser un système de limitation par adresse ip, nous allons mettre en place une authentification local. La limitation par adresse ip c'est bien, malheureusement quand nous sommes en mouvement nous n'avons pas toujours la même adresse ip. Nous allons utiliser le module apache [mod\_authn\_core](https://httpd.apache.org/docs/2.4/mod/mod_authn_core.html#authtype). 

Commençons par valider que ce dernier est bien chargé :

        $ ls -l /etc/apache2/mods-enabled/*auth*
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/auth_basic.load -> ../mods-available/auth_basic.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/authn_core.load -> ../mods-available/authn_core.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/authn_file.load -> ../mods-available/authn_file.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/authz_core.load -> ../mods-available/authz_core.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/authz_host.load -> ../mods-available/authz_host.load
        lrwxrwxrwx 1 root root 33 Nov 25 08:20 /etc/apache2/mods-enabled/authz_user.load -> ../mods-available/authz_user.load

Comme nous pouvons le constater plusieurs module d'authentification sont chargé par défaut incluant [mod_authn_core](https://httpd.apache.org/docs/2.4/mod/mod_authn_core.html#authtype) (ligne 2 :P )

Pour information voici le contenu :

        $ cat /etc/apache2/mods-enabled/authn_core.load 
        LoadModule authn_core_module /usr/lib/apache2/modules/mod_authn_core.so

Apache charge un fichier **.so** qui est l'équivalent d'un **DLL** qui permet d'avoir une suite d'instruction en plus, disponible pour le service. Le module fut compilé pour la version spécifique d'Apache il n'est pas possible de prendre un module écrit pour la version 2.2 et le faire fonctionner sur la version 2.4 . Nous verrons plus en détail plus tard les modules apaches cependant il est bien d'avoir une compréhension, sommaire du fonctionnement.


Procédons à la modification du fichier de configuration de notre site par défaut (**/etc/apache2/sites-available/000-default.conf**). Voici la configuration :

        <Directory /data/www/admin >
            Options FollowSymLinks
            AllowOverride None
    
            #  Section d'authentification
            AuthType Basic
            AuthName "Authentication Required"
            AuthUserFile "/data/private-www/.htpasswd-admin"
            Require valid-user
        </Directory>

Analysons les paramètres :

* [AuthType](https://httpd.apache.org/docs/2.4/fr/mod/mod_authn_core.html#authtype) : Définie le type de module d'authentification , nous avions vu que plusieurs module été disponible dans le cas présent nous utiliserons le mode __Basic__. Il est important de souligné que dans le mode de communication actuelle le transfert du mot de passe est transmis en claire . Afin d'augmenter le niveau de sécurité nous devrions activer le support __SSL__ nous y reviendrons. Voici les type disponibles :
    * [Basic](https://httpd.apache.org/docs/2.4/fr/mod/mod_auth_basic.html) 
    * [Digest](https://httpd.apache.org/docs/2.4/fr/mod/mod_auth_digest.html)
    * [form](https://httpd.apache.org/docs/2.4/fr/mod/mod_auth_form.html)
* [AuthName](https://httpd.apache.org/docs/2.4/fr/mod/mod_authn_core.html#authname) : message affiché à l'utilisateur afin qu'il entre les informations d'authentification requis .
* [AuthUserFile](https://httpd.apache.org/docs/2.4/fr/mod/mod_authn_file.html#authuserfile) : Ficher local sur le serveur web contenant la liste des utilisateurs et mot de passe permettant de valider l'authentification des utilisateurs.
* [Require](https://httpd.apache.org/docs/2.4/fr/mod/mod_authz_core.html#require) : Instruction spécifiant le critère d'autorisation, dans les démonstrations passé nous avions utilisé les adresses ip comme critère ici nous pourrons utiliser des noms d'utilisateur ou définir comme dans le cas présent n'importe quelle utilisateur s'authentifiant avec succès. 


Validons qu'il n'y pas d'erreur syntaxique et rechargeons le fichier de configuration :

        $ sudo apache2ctl configtest && sudo service apache2 restart
        Syntax OK
        * Restarting web server apache2
        *    ...done.

Donc si nous allons à l'URL nous avons bien le message demandant le nom d'utilisateur et mot de passe :

![imgs/auth_admin-request.png](imgs/auth_admin-request.png)

Par contre, comme nous n'avons jamais définie de nom d'usagé / mot de passe quand on rentre n'importe quoi nous avons une [erreur 500](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#5xx_Server_Error) indiquant un problème sur le serveur. Le message d'erreur sur le serveur est très claire :

        $ sudo tail /var/log/apache2/error.log
        [Tue Dec 01 08:40:05.516453 2015] [authn_file:error] [pid 457:tid 2869857088] (2)No such file or directory: [client 172.17.42.1:52744] AH01620: Could not open password file: /data/private-www/.htpasswd-admin


## <a name="htpasswd" /> Création du fichier de mot de passe ( __htpasswd__ )

Pour réaliser la création du fichier contenant le nom d'utilisateur et le mot de passe nous avons besoin de l'application **htpasswd** , cette application est disponible dans le pacquage : **apache2-utils**

        $ sudo apt-get install apache2-utils

Nous allons faire la création du fichier :

        $ sudo mkdir /data/private-www/
        $ sudo htpasswd -c /data/private-www/.htpasswd-admin admin
        New password:
        Re-type new password:
        Adding password for user admin
        $ sudo htpasswd  /data/private-www/.htpasswd-admin robert
        New password: 
        Re-type new password: 
        Adding password for user robert

**IMPORTANT** : entre le 2 commandes il y a une différence, pour réaliser la création du fichier j'ai utilisé l'option **-c** par la suite je ne l'utilise pas . En fait il faut surtout pas que je l'utilise sinon ça vide le fichier pour créer un nouveau fichier , nous perdons donc l'information :-/ . Ouin c'est dangereux, heureusement que vous savez ce que vous faites :D, sinon il y a les backups ...

Visualisons le contenu du fichier, dans les 2 cas j'ai mis le même mot de passe (toto) :

        $ cat /data/private-www/.htpasswd-admin
        admin:$apr1$6gHZyTty$lxisZ66JPD7yK6K8fcXlU.
        robert:$apr1$fUI6se3h$40k/ftJPUtVOrptHlMiYB0

Si nous retournons à l'URL nous devrions avoir une authentification avec succès avec l'un ou l'autre des utilisateurs. La page indiquant que nous sommes dans une "section prive" devrais s'afficher.


# <a name="Reference" /> Référence :

* [Documentation Apache 2.4](https://httpd.apache.org/docs/2.4/) : https://httpd.apache.org/docs/2.4/
* [Liste des code d'état du protocole http](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes): https://en.wikipedia.org/wiki/List_of_HTTP_status_codes


## <a name="compilation_module" /> Compilation d'un modules apache (a valider)

TODO : a analyser 

https://httpd.apache.org/docs/2.4/developer/modguide.html

ODO: demontration du symlink vers /etc/passwd == sudo ln -s /etc/ /var/www/html/sys
